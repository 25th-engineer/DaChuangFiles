## 44. 优化验证测试

假设你正在构建语言识别系统，你的系统通过输入音频片段 A 并为每一个输出的语句 S 计算可能性 $Score_A(S)$。例如，假设输入音频是 A，你可能会通过 $Score_A(S) = P(S|A)$ 来估计得分——即将音频 A 正确转录为句子 S 的概率。给定计算  $Score_A(S)$ 的方法，你需要找到使 $Score_A(S)$ 最大化的那个句子 S：

$$Output=arg\ \underset{S}{max}\ Score_A(S)$$

那么，该如何计算上式中的 “arg max”呢？如果我们的英文单词有 5 万个，那么一个长度为 $N$ 的句子中单词的组合的可能性则有 $(50000)^N$ 种，实在是太多了。所以，你可以应用一个近似的搜索算法来找到一个合理的 S 来优化（最大化）$Score_A(S)$。关于这种搜索算法，其中有一种叫做“集束搜索”(Beam Serach)，它在搜索过程中只保留前 K 个表现最好的作为候选值。（就本章而言，你无需了解关于“集束搜索”的细节）然而，这样的算法并不能保证找到一个 S 来最大化 $Score_A(S)$。

假设一个音频剪辑 A 记录了某人说“我喜欢机器学习”。但你的系统输出的不是正确的转录语句——音频被转录为了“我爱机器人”。出现这种错误有下列两种可能性：

1.  搜索算法的问题： 近似搜索算法（波束搜索）并没有找到能够最大化 $Score_A(S)$ 的 S 的值。
2. 目标（评分函数）问题：我们对$Score_A(S) = P(S|A)$ 的估计是不准确的。特别是，我们选择的 $Score_A(S)$ 并不能体现出“我喜欢机器学习”才是正确的转录语句。

取决于不同失败的原因，你应该用不同的方式来优先考虑你的工作重心。如果是问题 #1，那么你应该努力去改进你的搜索算法；如果是问题 #2，你应该是着重去研究能够准确估算 $Score_A(S)$ 的学习算法。

面对这种情况，一些研究者会随机地选择搜索算法；另一些人则会随机选择一种更好的方法来学习 $Score_A(S)$ 的值，但是，除非你知道这些错误的根本原因，否则大部分努力都是白费的。那么，如何更系统地决定要做什么呢?

我们用 $S_{out}$ 来指代系统转录的输出——“我爱机器人”。用 $S^{* }$ 来指代正确的转录内容——“我爱机器学习”。为了深刻了解我们的系统出现的问题到底是上述的 #1 还是 #2 ，你可以执行优化验证测试(Optimization Verification test)：首先计算 $Score_A(S^{* })$ 和 $Score_A(S_{out})$，然后检查是否有 $Score_A(S^{* }) > Score_A(S_{out})$。在这里存在两种情况：

情况 1： $Score_A(S^{* }) > Score_A(S_{out})$

在这种情况下，您的学习算法已经正确给出 $S^{* }$ 比 $S_{out}$ 更高的分数。 尽管如此，我们的近似搜索算法依然选择了 $S_{out}$ 而不是 $S^{* }$。 这就说明了你的近似搜索算法没有选择最大化 $Score_A(S)$ 的 S 的值。换句话说，优化验证测试告诉了你：你有一个搜索算法问题，应该专注于此。 例如，您可以尝试增加集束搜索的集束宽度。

情况 2： $Score_A(S^{* }) \leq  Score_A(S_{out})$

在这种情况下，你知道计算 $Score_A(.)$ 的方式存在问题，它无法对正确的输出 $S^{* }$ 给出严格高于 $S_{out}$ 的分数。优化验证测试告诉您有一个目标(评分)函数问题，因此，你应该专注于改进你的算法对不同的句子 S 学习或者近似 $Score_A(S)$ 的方式 。

我们上述的讨论都集中在一个例子上。然而要在实践中应用优化验证测试，您应该检查开发集中的错误。 对于开发集中的每个错误，你都要检查评分是否满足 $Score_A(S^{* }) > Score_A(S_{out})$。 满足这个不等式的所有的开发集错误样本的错误原因都将被归咎为优化算法的问题，而不满足不等式的所有的开发集错误样本的错误原因则都将被归咎为计算 $Score_A(.)$ 的方式存在问题。

例如，假设您发现在所有的开发集错误样本中有 95% 的错误是由于评分函数 $Score_A(.)$导致的，而只有 5% 是由于优化算法所导致的。通过这个你就能得知，无论您如何改进优化过程，实际上您只会消除大约 5% 的错误。因此，你应该将重点放在如何准确评估 $Score_A(.)$ 的问题上。