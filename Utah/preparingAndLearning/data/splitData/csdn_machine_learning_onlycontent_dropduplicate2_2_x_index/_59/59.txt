Andrew Ng coursera上的《机器学习》ex5
按照课程所给的ex5的文档要求，ex5要求完成以下几个计算过程的代码编写：
1.LinearRegCostFunction.m
该.m文件包含了求正则化线性回归模型代价函数，梯度下降算法两个算法。
function [J, grad] = linearRegCostFunction(X, y, theta, lambda) %LINEARREGCOSTFUNCTION Compute cost and gradient for regularized linear %regression with multiple variables % [J, grad] = LINEARREGCOSTFUNCTION(X, y, theta, lambda) computes the % cost of using theta as the parameter for linear regression to fit the % data points in X and y. Returns the cost in J and the gradient in grad % Initialize some useful values m = length(y); % number of training examples % You need to return the following variables correctly J = 0; grad = zeros(size(theta)); % ====================== YOUR CODE HERE ====================== % Instructions: Compute the cost and gradient of regularized linear % regression for a particular choice of theta. % % You should set J to the cost and grad to the gradient. % theta1= [0;theta(2:end)]; Theta = theta; for i=2:m Theta = [Theta,theta]; end h = sum(X .* Theta',2); J = sum(( h - y).^2,1) / m / 2 + sum(theta1 .^ 2,1) * lambda / 2 / m; % Theta(1,:) = Theta(1,:) * 0; [m1,n1] = size(X); tmp = h - y; for i=2:n1 tmp = [tmp,h - y]; end grad_tmp = tmp .* X; grad = sum(grad_tmp,1) /m + (lambda * theta1 /m)'; grad = grad'; % ========================================================================= grad = grad(:); end
2.learningCurve.m
通过学习曲线，我们可以判断针对high variance（过拟合）以及high bias（欠拟合）两种情况的时候分别使用什么解决办法。学习曲线主要是训练数据集，交叉验证集和lambda，数据集大小m，特征项数目之间的关系曲线。
function [error_train, error_val] = ... learningCurve(X, y, Xval, yval, lambda) %LEARNINGCURVE Generates the train and cross validation set errors needed %to plot a learning curve % [error_train, error_val] = ... % LEARNINGCURVE(X, y, Xval, yval, lambda) returns the train and % cross validation set errors for a learning curve. In particular, % it returns two vectors of the same length - error_train and % error_val. Then, error_train(i) contains the training error for % i examples (and similarly for error_val(i)). % % In this function, you will compute the train and test errors for % dataset sizes from 1 up to m. In practice, when working with larger % datasets, you might want to do this in larger intervals. % % Number of training examples m = size(X, 1); % You need to return these values correctly error_train = zeros(m, 1); error_val = zeros(m, 1); % ====================== YOUR CODE HERE ====================== % Instructions: Fill in this function to return training errors in % error_train and the cross validation errors in error_val. % i.e., error_train(i) and % error_val(i) should give you the errors % obtained after training on i examples. % % Note: You should evaluate the training error on the first i training % examples (i.e., X(1:i, :) and y(1:i)). % % For the cross-validation error, you should instead evaluate on % the _entire_ cross validation set (Xval and yval). % % Note: If you are using your cost function (linearRegCostFunction) % to compute the training and cross validation error, you should % call the function with the lambda argument set to 0. % Do note that you will still need to use lambda when running % the training to obtain the theta parameters. % % Hint: You can loop over the examples with the following: % % for i = 1:m % % Compute train/cross validation errors using training examples % % X(1:i, :) and y(1:i), storing the result in % % error_train(i) and error_val(i) % .... % % end % % ---------------------- Sample Solution ---------------------- for i=1:m %利用X(1:i,:),y(1:i),trainLinearReg(),来训练参数theta theta=trainLinearReg(X(1:i,:),y(1:i), lambda); %You should evaluate the training error on the first i training examples (i.e., X(1:i, :) and y(1:i)). %训练误差计算只用X(1:i,:), y(1:i) [error_train(i),grad]=linearRegCostFunction(X(1:i,:), y(1:i), theta, 0); %交叉验证用上所有的验证集，即Xval, yval %For the cross-validation error, you should instead evaluate on the _entire_ cross validation set (Xval and yval). [error_val(i), grad]=linearRegCostFunction(Xval, yval, theta, 0); end % ------------------------------------------------------------- % ========================================================================= end
3. polyFeature.m
为了解决欠拟合的问题，所以增加数据集的特征项。
function [X_poly] = polyFeatures(X, p) %POLYFEATURES Maps X (1D vector) into the p-th power % [X_poly] = POLYFEATURES(X, p) takes a data matrix X (size m x 1) and % maps each example into its polynomial features where % X_poly(i, :) = [X(i) X(i).^2 X(i).^3 ... X(i).^p]; % % You need to return the following variables correctly. X_poly = zeros(numel(X), p); % ====================== YOUR CODE HERE ====================== % Instructions: Given a vector X, return a matrix X_poly where the p-th % column of X contains the values of X to the p-th power. % % X_poly(:,1) = X; for i=2:p X_poly(:,i) = X .^ i; end % ========================================================================= end
上面的代码按照文档的要求，第一列是x^2,依次类推。
4.validationCurve.m
要求是选择合适的lambda。通过计算在不同的lambda下训练数据集、交叉验证集的误差可以得出合适的lambda。
function [lambda_vec, error_train, error_val] = ... validationCurve(X, y, Xval, yval) %VALIDATIONCURVE Generate the train and validation errors needed to %plot a validation curve that we can use to select lambda % [lambda_vec, error_train, error_val] = ... % VALIDATIONCURVE(X, y, Xval, yval) returns the train % and validation errors (in error_train, error_val) % for different values of lambda. You are given the training set (X, % y) and validation set (Xval, yval). % % Selected values of lambda (you should not change this) lambda_vec = [0 0.001 0.003 0.01 0.03 0.1 0.3 1 3 10]'; % You need to return these variables correctly. error_train = zeros(length(lambda_vec), 1); error_val = zeros(length(lambda_vec), 1); % ====================== YOUR CODE HERE ====================== % Instructions: Fill in this function to return training errors in % error_train and the validation errors in error_val. The % vector lambda_vec contains the different lambda parameters % to use for each calculation of the errors, i.e, % error_train(i), and error_val(i) should give % you the errors obtained after training with % lambda = lambda_vec(i) % % Note: You can loop over lambda_vec with the following: % % for i = 1:length(lambda_vec) % lambda = lambda_vec(i); % % Compute train / val errors when training linear % % regression with regularization parameter lambda % % You should store the result in error_train(i) % % and error_val(i) % .... % % end % % m = size(lambda_vec,1); for i = 1:m lambda = lambda_vec(i); [theta] = trainLinearReg(X, y, lambda); error_train(i)= linearRegCostFunction(X, y, theta, 0); error_val(i)= linearRegCostFunction(Xval, yval, theta, 0); end % ========================================================================= end