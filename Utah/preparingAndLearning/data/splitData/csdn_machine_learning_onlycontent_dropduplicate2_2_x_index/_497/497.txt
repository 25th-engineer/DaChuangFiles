这一篇博客将介绍机器学习中另一个重要的任务——分类（classification），即找一个函数判断输入数据所属的类别，可以是二类别问题（是/不是），也可以是多类别问题（在多个类别中判断输入数据具体属于哪一个类别）。与回归问题（regression）相比，分类问题的输出不再是连续值，而是离散值，用来指定其属于哪个类别。分类问题在现实中应用非常广泛，比如垃圾邮件识别，手写数字识别，人脸识别，语音识别等。
思考
首先思考一个问题，能不能用回归问题的解法去求解分类问题呢？
以二分类问题为例，对于类别1，我们假设其目标值为1，对于类别2，假设其目标值为-1。在回归问题中，我们需要找到一个函数，使得函数的预测值尽可能的接近目标值。如下图所示，为了方便可视化，假设每个样本只用两维特征表示。
上图中，蓝色的点目标值是1，代表类别1；红色的点目标值是-1，代表类别2。现在需要找到一个函数对这些点进行拟合，如图中绿线所代表的函数
b+w1x1+w2x2=0
b
+
w
1
x
1
+
w
2
x
2
=
0
b+w_1x_1+w_2x_2=0。对于一个样本点，如果其对应的函数值大于0，则认为其属于类别1，反之属于类别2。这么做看起来好像也是可以的，但现在我们考虑另外一种情况，如下图所示
此时，在类别1中加入了右下角这些点，如果仍然采用绿色那条线所代表的函数进行预测，这些新加入进来的点的误差将特别的大，为了缓解由此带来的误差，绿色的线将往右下角偏移，以此减少误差。但这么做明显是不符合常理的，误差虽然减少了，但也带来了更严重的分类类别错误问题。造成这个问题的本质是损失函数定义的不恰当，回归问题种将损失函数定位为误差函数是因为回归的目标是尽可能拟合样本点，但分类问题的目标是尽可能将样本点分类到正确的类别中，仍然使用误差函数作为损失函数显然是不合适的。会闹出这样的笑话：对于那些类别明显的点，回归问题求解的惩罚反而更加严重。另外对于多分类问题种，我们给每个类别指定一个对应的目标值，在机器看来这些目标值之间是有联系的，比如：类别1目标值指定为1，类别2目标值指定为2，类别3目标值指定为3……计算机在寻找样本之间的关系时，会默认类别2和类别3要比类别1和类别3更加有关联，因为3和2更加靠近。
分类问题
分类问题的求解过程同样可以分为三个步骤：
1、确定一个模型
f(x)
f
(
x
)
f(x)，输入样本数据
x
x
x，输出其类别；
2、定义损失函数
L(f)
L
(
f
)
L(f)，一个最简单的想法是计数分类错误的次数，
L(f)=∑nδ(f(xn)≠y^n)
L
(
f
)
=
∑
n
δ
(
f
(
x
n
)
≠
y
^
n
)
L(f)=\sum_\limits n \delta(f(x^n)\ne \hat{y}^n)；
3、找出使损失函数最小的那个最优函数。
上面的做法中，我们寻找到的最优函数直接计算出了
p(c|x)
p
(
c
|
x
)
p(c|x)，即给出了样本
x
x
x属于每个类别
c
c
c的概率，这是一种解法。我们将其称作判别式（discrimination）方法，因为我们直接对样本所属类别进行了判断，相应的模型称作判别式模型。这一篇博客我们换一个角度思考，从另一个方向解决分类问题。下面以最简单的二分类为例，样本可以根据其类别标签被自然分为两类，那为什么我们不分别对每一类进行研究呢？是否可以发现每一类样本的特性呢？结合我们的研究目标：建模
p(c|x)
p
(
c
|
x
)
p(c|x)，借助概率论条件概率的知识，我们对其进行下转换：
p(c|x)=p(c,x)p(x)(1)
(1)
p
(
c
|
x
)
=
p
(
c
,
x
)
p
(
x
)
p(c|x)=\frac{p(c,x)}{p(x)} \tag 1
此时还需要求解联合概率分布
p(c,x)
p
(
c
,
x
)
p(c,x)，基于贝叶斯定理，
p(c|x)
p
(
c
|
x
)
p(c|x)可写为
p(c|x)=p(x|c)p(c)p(x)(2)
(2)
p
(
c
|
x
)
=
p
(
x
|
c
)
p
(
c
)
p
(
x
)
p(c|x)=\frac{p(x|c)p(c)}{p(x)} \tag 2
对给定样本
x
x
x，
p(x)
p
(
x
)
p(x)与类别无关，因此我们需要考虑的只剩下
p(x|c)
p
(
x
|
c
)
p(x|c)和
p(c)
p
(
c
)
p(c)，惊讶的是，这两个分布不正是每一类样本的特性吗？因此下面就需要对这两个分布进行研究。
p(c)
p
(
c
)
p(c)是类先验（prior）概率，即在未知其他条件下对事件发生概率的表示，这个值是通过以往经验和分析（历史数据）得到的结果。根据大数定律，当训练样本中包含充足的独立同分布样本时，
p(c)
p
(
c
)
p(c)可通过各类样本的出现频率进行估计；与类先验概率相对应的是类后验（posterior）概率
p(c|x)
p
(
c
|
x
)
p(c|x)，即我们要建模的目标，表示在已知条件
x
x
x下事件发生的概率。
p(x|c)
p
(
x
|
c
)
p(x|c)是类条件（class-conditional）概率，即在某个特定类别下，样本
x
x
x的发生概率。它是涉及关于样本
x
x
x所有属性的联合概率，如果
x
x
x有
d
d
d个属性且取值均为二值，那么样本空间大小将是
2d
2
d
2^d，现实中训练样本的大小往往远小于这个值，因此通过频率估算
p(x|c)
p
(
x
|
c
)
p(x|c)显然是不可行的，因为“未被观测到”不等于“出现概率为0”。
高斯分布
通常我们假定类条件概率
p(x|c)
p
(
x
|
c
)
p(x|c)符合某种确定的概率分布，训练样本都是从这个分布中随机采样得到的，“未被采样到的点”也对应有一个发生概率。某种确定的概率分布通常被假设为高斯分布（Gaussian Distribution），现在我们需要做的就是根据训练样本确定高斯分布的参数。多元高斯分布的概率密度函数如下：
fμ,Σ(x)=1(2π)k/21|Σ|1/2exp{−12(x−μ)TΣ−1(x−μ)}
f
μ
,
Σ
(
x
)
=
1
(
2
π
)
k
/
2
1
|
Σ
|
1
/
2
e
x
p
{
−
1
2
(
x
−
μ
)
T
Σ
−
1
(
x
−
μ
)
}
f_{\mu,\Sigma}(x)=\frac{1}{(2\pi)^{k/2}}\frac{1}{|\Sigma|^{1/2}}exp\{-\frac{1}{2}(x-\mu)^T\Sigma^{-1}(x-\mu)\}
其中
k
k
k是
x
x
x的维数，
μ
μ
\mu是均值向量，
Σ
Σ
\Sigma是协方差矩阵，
μ
μ
\mu决定了分布的最高点，
Σ
Σ
\Sigma决定了分布的形状，二维高斯分布概率密度函数如下：
下面两幅图分别展示了
μ
μ
\mu不同，
Σ
Σ
\Sigma相同，和
μ
μ
\mu相同，
Σ
Σ
\Sigma不同的分布对比。
极大似然估计
任何一个高斯分布都能采样出我们的训练样本，但是不同的分布采样出训练样本的可能性（likelihood）是不一样的，对给定
μ
μ
\mu和
Σ
Σ
\Sigma采样出训练样本的likelihood可以写作：
L(μ,Σ)=∏x∈Dcpμ,Σ(x)
L
(
μ
,
Σ
)
=
∏
x
∈
D
c
p
μ
,
Σ
(
x
)
L(\mu,\Sigma)=\prod_{x\in D_c}p_{\mu,\Sigma}(x)
Dc
D
c
D_c表示训练样本中属于类别
c
c
c的样本数目。最大化上面的似然函数，找出的
μ
μ
\mu和
Σ
Σ
\Sigma就是最佳参数。
μ∗,Σ∗=argmaxμ,ΣL(μ,Σ)
μ
∗
,
Σ
∗
=
a
r
g
max
μ
,
Σ
L
(
μ
,
Σ
)
\mu^*,\Sigma^*=arg \max_{\mu,\Sigma}L(\mu,\Sigma)
该方法称为最大似然估计（Maximum Likelihood Estimation，MLE），参数
μ
μ
\mu和
Σ
Σ
\Sigma的最大似然估计为
μ∗=1|Dc|∑x∈DcxΣ∗=1|Dc|∑x∈Dc(x−μ∗)(x−μ∗)T
μ
∗
=
1
|
D
c
|
∑
x
∈
D
c
x
Σ
∗
=
1
|
D
c
|
∑
x
∈
D
c
(
x
−
μ
∗
)
(
x
−
μ
∗
)
T
\mu^*=\frac{1}{|D_c|}\sum_{x\in D_c}x \\ \Sigma^*=\frac{1}{|D_c|}\sum_{x\in D_c}(x-\mu^*)(x-\mu^*)^T
也就是说，最佳
μ∗
μ
∗
\mu^*是样本均值，协方差矩阵是
(x−μ∗)(x−μ∗)T
(
x
−
μ
∗
)
(
x
−
μ
∗
)
T
(x-\mu^*)(x-\mu^*)^T的均值，这显然是一个符合直觉的结果。现在我们已经计算出每个类别的
p(c)
p
(
c
)
p(c)和
p(x|c)
p
(
x
|
c
)
p(x|c)，就可以选择
p(c)p(x|c)
p
(
c
)
p
(
x
|
c
)
p(c)p(x|c)较大的那个类别作为
x
x
x的类别。
在实际应用中，对于不同的类别分别给予不同的
μ
μ
\mu和
Σ
Σ
\Sigma是比较少见的，尤其是
Σ
Σ
\Sigma的大小是特征的平方，分别给予不同的参数将使得模型参数太多，容易过拟合，所以通常给予不同分布相同的
Σ
Σ
\Sigma，此时似然函数如下：
L(μ1,μ2,Σ)=∏x∈Dc1pμ1,Σ(x)∏x∈Dc2pμ2,Σ(x)
L
(
μ
1
,
μ
2
,
Σ
)
=
∏
x
∈
D
c
1
p
μ
1
,
Σ
(
x
)
∏
x
∈
D
c
2
p
μ
2
,
Σ
(
x
)
L(\mu^1,\mu^2,\Sigma)=\prod_{x\in D_{c_1}}p_{\mu^1,\Sigma}(x)\prod_{x\in D_{c_2}}p_{\mu^2,\Sigma}(x)
μ1
μ
1
\mu^1和
μ2
μ
2
\mu^2的值不变，依旧是每一类样本的均值。
Σ
Σ
\Sigma的值稍有变化，等于每一类样本的
Σ
Σ
\Sigma的加权平均
Σ=Dc1DΣ1+Dc2DΣ2
Σ
=
D
c
1
D
Σ
1
+
D
c
2
D
Σ
2
\Sigma=\frac{D_{c_1}}{D}\Sigma^1+\frac{D_{c_2}}{D}\Sigma^2
朴素贝叶斯分类器
上面的计算中，我们将大部分的精力都放在了求解类条件概率
p(x|c)
p
(
x
|
c
)
p(x|c)上，因为
p(x|c)
p
(
x
|
c
)
p(x|c)是关于所有属性的联合概率，难以从样本中直接估计得到。一个大胆的假设是认为描述样本的所有属性是相互独立的，因此
p(x|c)
p
(
x
|
c
)
p(x|c)可以拆解成
p(x|c)=p(x1|c)p(x2|c)⋯p(xn|c)=∏i=1np(xi|c)
p
(
x
|
c
)
=
p
(
x
1
|
c
)
p
(
x
2
|
c
)
⋯
p
(
x
n
|
c
)
=
∏
i
=
1
n
p
(
x
i
|
c
)
p(x|c)=p(x_1|c)p(x_2|c)\cdots p(x_n|c)=\prod_{i=1}^np(x_i|c)
其中，
n
n
n是属性数目，
xi
x
i
x_i是第
i
i
i个属性。同样可以假设每一维属性上的概率分布仍然服从高斯分布，此时的高斯分布是一个一维高斯分布，
Σ
Σ
\Sigma对应一个实值，组成协方差矩阵也只在对角线位置有值，进一步减少了参数数目，得到了更简单的模型。这样的模型被称作朴素贝叶斯分类器（naive Bayes classifier，NB）。
最后，对于样本分布不一定要选择高斯分布，例如如果是二值分布，我们可以假设符合伯努利分布，具体应用中要根据样本特点具体而定，但显示生活中确实有很多分布符合高斯分布。
总结
这一篇博客中，我们从另一个角度介绍了求解分类问题的一类新模型，与判别式模型直接建模
p(c|x)
p
(
c
|
x
)
p(c|x)不同，这类模型首先对每一类别样本求解
p(c)
p
(
c
)
p(c)和
p(x|c)
p
(
x
|
c
)
p(x|c)，然后再计算
p(c|x)
p
(
c
|
x
)
p(c|x)，我们将这一类模型称作生成式模型（generative models）。因为求解出
p(c)
p
(
c
)
p(c)和
p(x|c)
p
(
x
|
c
)
p(x|c)后，我们也就求出了联合概率
p(x,c)
p
(
x
,
c
)
p(x,c)，也就求出了
p(x)=p(x,c1)+p(x,c2)+⋯
p
(
x
)
=
p
(
x
,
c
1
)
+
p
(
x
,
c
2
)
+
⋯
p(x)=p(x,c_1)+p(x,c_2)+\cdots，有了p(x)我们就能采样生成每一个样本
x
x
x，所以被称为生成式模型。
参考文献
李宏毅机器学习2017秋