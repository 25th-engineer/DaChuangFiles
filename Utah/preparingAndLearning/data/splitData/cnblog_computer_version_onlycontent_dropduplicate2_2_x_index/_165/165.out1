一 detect/w 和/c build/w 前面/f 多节/m 中/f 我们/r 花了/nr 大量/n 
笔墨/n 介绍/v build/w 方法/n 的/uj inference/w 分支/n 这 节 我们 
看看 它 是 如何 被 调用 的 在 dimo . 
ipynb 中 涉及 model 的 操作 我们 简单 进行 一下 
汇总 首先 创建 图 并 载入 预 训练 权重 然后 
规范 了 类别 序列 实际 开始 检测 的 代码 块 
如下 经由 model . detect 方法 调用 model . build 
方法 也 就是 我们 前面 多节 在 讲解 的 方法 
构建 图 实施 预测 二 detect 方法 首先 看看 detect 
方法 的 前 几行 和 build 一样 同 见 model 
. py def detect self images verbose = 0 Runs 
the detection pipeline . images List of images potentially of 
different sizes . Returns a list of dicts one dict 
per image . The dict contains rois N y1 x1 
y2 x2 detection bounding boxes class _ ids N int 
class IDs scores N float probability scores for the class 
IDs masks H W N instance binary masks assert self 
. mode = = inference Create model in inference mode 
. assert len images = = self . config . 
BATCH _ SIZE len images must be equal to BATCH 
_ SIZE # 日志 记录 if verbose log Processing { 
} images . format len images for image in images 
log image image 1 待 检测 图像 预处理 # Mold 
inputs to format expected by the neural network molded _ 
images image _ metas windows = self . mold _ 
inputs images # Validate image sizes # All images in 
a batch MUST be of the same size image _ 
shape = molded _ images 0 . shape for g 
in molded _ images 1 assert g . shape = 
= image _ shape \ After resizing all images must 
have the same size . Check IMAGE _ RESIZE _ 
MODE and image sizes . 简单 的 纠错 和 日志 
控制 之后 即 调用 mold _ input 函数 对 输入 
图片 进行 调整 并 记录 图片 信息 self . mold 
_ inputs 方法 如下 def mold _ inputs self images 
Takes a list of images and modifies them to the 
format expected as an input to the neural network . 
images List of image matrices height width depth . Images 
can have different sizes . Returns 3 Numpy matrices molded 
_ images N h w 3 . Images resized and 
normalized . image _ metas N length of meta data 
. Details about each image . windows N y1 x1 
y2 x2 . The portion of the image that has 
the original image padding excluded . molded _ images = 
image _ metas = windows = for image in images 
# Resize image # TODO move resizing to mold _ 
image molded _ image window scale padding crop = utils 
. resize _ image image min _ dim = self 
. config . IMAGE _ MIN _ DIM # 800 
min _ scale = self . config . IMAGE _ 
MIN _ SCALE # 0 max _ dim = self 
. config . IMAGE _ MAX _ DIM # 1024 
mode = self . config . IMAGE _ RESIZE _ 
MODE # square molded _ image = mold _ image 
molded _ image self . config # 减 平均 像素 
# Build image _ meta 形式 为 np 数组 image 
_ meta = compose _ image _ meta 0 image 
. shape molded _ image . shape window scale np 
. zeros self . config . NUM _ CLASSES dtype 
= np . int32 # Append molded _ images . 
append molded _ image windows . append window image _ 
metas . append image _ meta # Pack into arrays 
molded _ images = np . stack molded _ images 
image _ metas = np . stack image _ metas 
windows = np . stack windows return molded _ images 
image _ metas windowsutils . resize _ image 函数 用于 
缩放 原 图像 它 生成 一个 scale 返回 图像 大小 
等于 输入 图像 大小 * scale 并 保证 最短 边 
等于 输入 min _ dim 最 长边 不大于 max _ 
dim 如果 最 长边 超过 了 max _ dim 则 
保证 最 长边 等于 max _ dim 最短 边 不再 
限制 最后 将 图片 padding 到 max _ dim * 
max _ dim 大小 即 molded _ images 大小 其实 
是 固定 的 其 返回值 如下 image . astype image 
_ dtype window scale padding crop 表示 resize 后 图片 
原图 相对 resize 后 图片 的 位置 信息 详见 计算机 
视觉 Mask RCNN _ 推断 网络 其五 目标 检测 结果 
精炼 放缩 倍数 padding 信息 四个 整数 crop 信息 四个 
整数 或者 None mold _ image 函数 更为 简单 就是 
把 图片 像素 减去 了 个 平均值 MEAN _ PIXEL 
= 123.7 116.8 103.9 compose _ image _ meta 记录 
了 全部 的 原始 信息 可以 看到 crop 并未 收录 
在内 def compose _ image _ meta image _ id 
original _ image _ shape image _ shape window scale 
active _ class _ ids Takes attributes of an image 
and puts them in one 1D array . image _ 
id An int ID of the image . Useful for 
debugging . original _ image _ shape H W C 
before resizing or padding . image _ shape H W 
C after resizing and padding window y1 x1 y2 x2 
in pixels . The area of the image where the 
real image is excluding the padding scale The scaling factor 
applied to the original image float32 active _ class _ 
ids List of class _ ids available in the dataset 
from which the image came . Useful if training on 
images from multiple datasets where not all classes are present 
in all datasets . meta = np . array image 
_ id + # size = 1 list original _ 
image _ shape + # size = 3 list image 
_ shape + # size = 3 list window + 
# size = 4 y1 x1 y2 x2 in image 
cooredinates scale + # size = 1 list active _ 
class _ ids # size = num _ classes return 
meta 最后 拼接 返回 2 anchors 生成 首先 调用 方法 
get _ anchors 生成 锚 框 见 计算机 视觉 Mask 
RCNN _ 锚 框 生成 shape 为 anchor _ count 
y1 x1 y2 x2 # Anchors anchors = self . 
get _ anchors image _ shape # Duplicate across the 
batch dimension because Keras requires it # TODO can this 
be optimized to avoid duplicating the anchors # anchor _ 
count y1 x1 y2 x2 batch anchor _ count y1 
x1 y2 x2 anchors = np . broadcast _ to 
anchors self . config . BATCH _ SIZE + anchors 
. shape 然后 为之 添加 batch 维度 最终 batch anchor 
_ count y1 x1 y2 x2 3 inference 网络 预测 
调用 keras 的 predict 方法 前 向 传播 在 预测 
任务 中 我们 仅仅 关注 detections 和 mrcnn _ mask 
两个 输出 # Run object detection # 于__/nr init _ 
_ 中 定义 self . keras _ model = self 
. build mode = mode config = config # 返回 
list detections mrcnn _ class mrcnn _ bbox # mrcnn 
_ mask rpn _ rois rpn _ class rpn _ 
bbox # detections batch num _ detections y1 x1 y2 
x2 class _ id score # mrcnn _ mask batch 
num _ detections MASK _ POOL _ SIZE MASK _ 
POOL _ SIZE NUM _ CLASSES detections _ _ mrcnn 
_ mask _ _ _ = \ self . keras 
_ model . predict molded _ images image _ metas 
anchors verbose = 0 4 坐标 框 重 映射 我们 
对于 坐标 的 操作 都是/nr 基于 输入 图片 的 相对位置 
且 单位 长度 也是 其 宽 高 在 最后 我们 
需要 将之 修正 回 像素 空间坐标 令 输入 图片 list 
不 需要 输入 图片 具有 相同 的 尺寸 所以 我们 
在 恢复 时 必须 注意 单张 处理 之 # Process 
detections results = for i image in enumerate images # 
需要 单张 处理 因为 原始 图片 images 不 保证 每张 
尺寸 一致 final _ rois final _ class _ ids 
final _ scores final _ masks = \ self . 
unmold _ detections detections i mrcnn _ mask i image 
. shape molded _ images i . shape windows i 
目标 检测 框 重 映射 unmold _ detections 函数 def 
unmold _ detections self detections mrcnn _ mask original _ 
image _ shape image _ shape window Reformats the detections 
of one image from the format of the neural network 
output to a format suitable for use in the rest 
of the application . detections N y1 x1 y2 x2 
class _ id score in normalized coordinates mrcnn _ mask 
N height width num _ classes original _ image _ 
shape H W C Original image shape before resizing image 
_ shape H W C Shape of the image after 
resizing and padding window y1 x1 y2 x2 Pixel coordinates 
of box in the image where the real image is 
excluding the padding . Returns boxes N y1 x1 y2 
x2 Bounding boxes in pixels class _ ids N Integer 
class IDs for each bounding box scores N Float probability 
scores of the class _ id masks height width num 
_ instances Instance masks # How many detections do we 
have # Detections array is padded with zeros . Find 
the first class _ id = = 0 . zero 
_ ix = np . where detections 4 = = 
0 0 # DetectionLayer 末尾 对 结果 进行 了 全0/nr 
填充 N = zero _ ix 0 if zero _ 
ix . shape 0 0 else detections . shape 0 
# 有 意义 的 检测 结果 数 N # Extract 
boxes class _ ids scores and class specific masks boxes 
= detections N 4 # N y1 x1 y2 x2 
class _ ids = detections N 4 . astype np 
. int32 # N class _ id scores = detections 
N 5 # N score masks = mrcnn _ mask 
np . arange N class _ ids # N height 
width num _ classes # Translate normalized coordinates in the 
resized image to pixel # coordinates in the original image 
before resizing window = utils . norm _ boxes window 
image _ shape 2 # window 相对 输入 图片 规范化 
wy1 wx1 wy2 wx2 = window shift = np . 
array wy1 wx1 wy1 wx1 wh = wy2 wy1 # 
window height ww = wx2 wx1 # window width scale 
= np . array wh ww wh ww # Convert 
boxes to normalized coordinates on the window boxes = np 
. divide boxes shift scale # box 相对 window 坐标 
规范化 # Convert boxes to pixel coordinates on the original 
image boxes = utils . denorm _ boxes boxes original 
_ image _ shape 2 # box 相对 原 图解 
规范化 # Filter out detections with zero area . Happens 
in early training when # network weights are still random 
exclude _ ix = np . where boxes 2 boxes 
0 * boxes 3 boxes 1 = 0 0 if 
exclude _ ix . shape 0 0 boxes = np 
. delete boxes exclude _ ix axis = 0 class 
_ ids = np . delete class _ ids exclude 
_ ix axis = 0 scores = np . delete 
scores exclude _ ix axis = 0 masks = np 
. delete masks exclude _ ix axis = 0 N 
= class _ ids . shape 0 # Resize masks 
to original image size and set boundary threshold . full 
_ masks = for i in range N # 单个 
box 操作 # Convert neural network mask to full size 
mask full _ mask = utils . unmold _ mask 
masks i boxes i original _ image _ shape full 
_ masks . append full _ mask full _ masks 
= np . stack full _ masks axis = 1 
\ if full _ masks else np . empty original 
_ image _ shape 2 + 0 # n y1 
x1 y2 x2 # n class _ id # n 
class _ id # h w n return boxes class 
_ ids scores full _ masks 为了 将 输出 结果 
格式 还原 我们 需要 进行 如下 几步 剔除 为了 凑齐 
DETECTION _ MAX _ INSTANCES 填充 的 全0/nr 检测 结果 
将 box 放 缩回 原始 图片 对应 尺寸 剔除 面积 
为 0 的 boxmask 输出 尺寸 还原 在 网络 中 
操作 的 box 尺寸 为 基于 输入 图片 的 规范化 
坐标 window 为 像素 坐标 所以 我们 先将 window 相对 
输入 图片 规范化 使得 window 和 box 处于 同一 坐标系 
然后 这两者 坐标 就 可以 直接 交互 了 使 box 
相对 window 规范化 此时 box 坐标 尺寸 都是 window 的 
相对值 而/c window/w 和/c 原始/v 图片/n 是/v 直接/ad 有/v 映射/v 
关系/n 的/uj 所以 box 遵循 其 关系 映 射回 原始 
像素 大小 即可 完成 box 映射 后 我们 开始 对 
mask 进行 处理 Mask 信息 重 映射 utils . unmold 
_ mask 函数 utils . unmold _ mask 受 调 
用于 unmold _ detections 尾部 # Resize masks to original 
image size and set boundary threshold . full _ masks 
= for i in range N # 单个 box 操作 
# Convert neural network mask to full size mask full 
_ mask = utils . unmold _ mask masks i 
boxes i original _ image _ shape full _ masks 
. append full _ mask full _ masks = np 
. stack full _ masks axis = 1 \ if 
full _ masks else np . empty original _ image 
_ shape 2 + 0 首先 重申 我们 的 unmold 
_ detections 函数 是 对 单张 图片 进行 处理 的 
而 mask 处理 进一步 的 是 对 每一个 检测 框 
进行 处理 的 def unmold _ mask mask bbox image 
_ shape Converts a mask generated by the neural network 
to a format similar to its original shape . mask 
height width of type float . A small typically 28x28 
mask . bbox y1 x1 y2 x2 . The box 
to fit the mask in . Returns a binary mask 
with the same size as the original image . threshold 
= 0.5 y1 x1 y2 x2 = bbox mask = 
resize mask y2 y1 x2 x1 mask = np . 
where mask = threshold 1 0 . astype np . 
bool # Put the mask in the right location . 
full _ mask = np . zeros image _ shape 
2 dtype = np . bool full _ mask y1 
y2 x1 x2 = mask return full _ mask 我们 
在 inference 中 输出 的 mask 信息 仅仅 是 一般 
的 生成 网络 输出 所以 为了 得到 掩码 格式 我们 
需要 一个 阈值 明确 了 这个 概念 下 一步 就 
简单 了 我们 将 mask 输出 放缩 到 对应 的 
box 大小 即可 此时 的 box 已经 相对 原始 图片 
进行 了 放缩 是 像素 坐标 然后/c 将/d 放缩/v 后的/nr 
掩码/n 按照/p box/w 相对/d 原始/v 图片/n 的/uj 位置/v 贴/v 在/p 
一张/m 和/c 原始/v 图片/n 等/u 大/a 的/uj 空白/n 图片/n 上/f 
我们 对 每 一个 检测 目标 做 这个 操作 就 
可以 得到 等同于 检测 目标 数 的 原始 图片大小 的 
掩码 图片 每个 掩码 图片 上 有一个 掩码 对象 将之 
按照 axis = 1 拼接 最终 获取 h w n 
格式 输出 hw 为 原始 图片大小 n 为 最终 检测 
到 的 目标 数目 最终 将 计算结果 返回 退出 函数 
# n y1 x1 y2 x2 # n class _ 
id # n class _ id # h w n 
return boxes class _ ids scores full _ masks 实际 
调用 如下 一 detect/w 和/c build/w 前面/f 多节/m 中/f 我们/r 花了/nr 大量/n 
笔墨/n 介绍/v build/w 方法/n 的/uj inference/w 分支/n 这 节 我们 
看看 它 是 如何 被 调用 的 在 dimo . 
ipynb 中 涉及 model 的 操作 我们 简单 进行 一下 
汇总 首先 创建 图 并 载入 预 训练 权重 然后 
规范 了 类别 序列 实际 开始 检测 的 代码 块 
如下 经由 model . detect 方法 调用 model . build 
方法 也 就是 我们 前面 多节 在 讲解 的 方法 
构建 图 实施 预测 二 detect 方法 首先 看看 detect 
方法 的 前 几行 和 build 一样 同 见 model 
. py def detect self images verbose = 0 Runs 
the detection pipeline . images List of images potentially of 
different sizes . Returns a list of dicts one dict 
per image . The dict contains rois N y1 x1 
y2 x2 detection bounding boxes class _ ids N int 
class IDs scores N float probability scores for the class 
IDs masks H W N instance binary masks assert self 
. mode = = inference Create model in inference mode 
. assert len images = = self . config . 
BATCH _ SIZE len images must be equal to BATCH 
_ SIZE # 日志 记录 if verbose log Processing { 
} images . format len images for image in images 
log image image 1 待 检测 图像 预处理 # Mold 
inputs to format expected by the neural network molded _ 
images image _ metas windows = self . mold _ 
inputs images # Validate image sizes # All images in 
a batch MUST be of the same size image _ 
shape = molded _ images 0 . shape for g 
in molded _ images 1 assert g . shape = 
= image _ shape \ After resizing all images must 
have the same size . Check IMAGE _ RESIZE _ 
MODE and image sizes . 简单 的 纠错 和 日志 
控制 之后 即 调用 mold _ input 函数 对 输入 
图片 进行 调整 并 记录 图片 信息 self . mold 
_ inputs 方法 如下 def mold _ inputs self images 
Takes a list of images and modifies them to the 
format expected as an input to the neural network . 
images List of image matrices height width depth . Images 
can have different sizes . Returns 3 Numpy matrices molded 
_ images N h w 3 . Images resized and 
normalized . image _ metas N length of meta data 
. Details about each image . windows N y1 x1 
y2 x2 . The portion of the image that has 
the original image padding excluded . molded _ images = 
image _ metas = windows = for image in images 
# Resize image # TODO move resizing to mold _ 
image molded _ image window scale padding crop = utils 
. resize _ image image min _ dim = self 
. config . IMAGE _ MIN _ DIM # 800 
min _ scale = self . config . IMAGE _ 
MIN _ SCALE # 0 max _ dim = self 
. config . IMAGE _ MAX _ DIM # 1024 
mode = self . config . IMAGE _ RESIZE _ 
MODE # square molded _ image = mold _ image 
molded _ image self . config # 减 平均 像素 
# Build image _ meta 形式 为 np 数组 image 
_ meta = compose _ image _ meta 0 image 
. shape molded _ image . shape window scale np 
. zeros self . config . NUM _ CLASSES dtype 
= np . int32 # Append molded _ images . 
append molded _ image windows . append window image _ 
metas . append image _ meta # Pack into arrays 
molded _ images = np . stack molded _ images 
image _ metas = np . stack image _ metas 
windows = np . stack windows return molded _ images 
image _ metas windowsutils . resize _ image 函数 用于 
缩放 原 图像 它 生成 一个 scale 返回 图像 大小 
等于 输入 图像 大小 * scale 并 保证 最短 边 
等于 输入 min _ dim 最 长边 不大于 max _ 
dim 如果 最 长边 超过 了 max _ dim 则 
保证 最 长边 等于 max _ dim 最短 边 不再 
限制 最后 将 图片 padding 到 max _ dim * 
max _ dim 大小 即 molded _ images 大小 其实 
是 固定 的 其 返回值 如下 image . astype image 
_ dtype window scale padding crop 表示 resize 后 图片 
原图 相对 resize 后 图片 的 位置 信息 详见 计算机 
视觉 Mask RCNN _ 推断 网络 其五 目标 检测 结果 
精炼 放缩 倍数 padding 信息 四个 整数 crop 信息 四个 
整数 或者 None mold _ image 函数 更为 简单 就是 
把 图片 像素 减去 了 个 平均值 MEAN _ PIXEL 
= 123.7 116.8 103.9 compose _ image _ meta 记录 
了 全部 的 原始 信息 可以 看到 crop 并未 收录 
在内 def compose _ image _ meta image _ id 
original _ image _ shape image _ shape window scale 
active _ class _ ids Takes attributes of an image 
and puts them in one 1D array . image _ 
id An int ID of the image . Useful for 
debugging . original _ image _ shape H W C 
before resizing or padding . image _ shape H W 
C after resizing and padding window y1 x1 y2 x2 
in pixels . The area of the image where the 
real image is excluding the padding scale The scaling factor 
applied to the original image float32 active _ class _ 
ids List of class _ ids available in the dataset 
from which the image came . Useful if training on 
images from multiple datasets where not all classes are present 
in all datasets . meta = np . array image 
_ id + # size = 1 list original _ 
image _ shape + # size = 3 list image 
_ shape + # size = 3 list window + 
# size = 4 y1 x1 y2 x2 in image 
cooredinates scale + # size = 1 list active _ 
class _ ids # size = num _ classes return 
meta 最后 拼接 返回 2 anchors 生成 首先 调用 方法 
get _ anchors 生成 锚 框 见 计算机 视觉 Mask 
RCNN _ 锚 框 生成 shape 为 anchor _ count 
y1 x1 y2 x2 # Anchors anchors = self . 
get _ anchors image _ shape # Duplicate across the 
batch dimension because Keras requires it # TODO can this 
be optimized to avoid duplicating the anchors # anchor _ 
count y1 x1 y2 x2 batch anchor _ count y1 
x1 y2 x2 anchors = np . broadcast _ to 
anchors self . config . BATCH _ SIZE + anchors 
. shape 然后 为之 添加 batch 维度 最终 batch anchor 
_ count y1 x1 y2 x2 3 inference 网络 预测 
调用 keras 的 predict 方法 前 向 传播 在 预测 
任务 中 我们 仅仅 关注 detections 和 mrcnn _ mask 
两个 输出 # Run object detection # 于__/nr init _ 
_ 中 定义 self . keras _ model = self 
. build mode = mode config = config # 返回 
list detections mrcnn _ class mrcnn _ bbox # mrcnn 
_ mask rpn _ rois rpn _ class rpn _ 
bbox # detections batch num _ detections y1 x1 y2 
x2 class _ id score # mrcnn _ mask batch 
num _ detections MASK _ POOL _ SIZE MASK _ 
POOL _ SIZE NUM _ CLASSES detections _ _ mrcnn 
_ mask _ _ _ = \ self . keras 
_ model . predict molded _ images image _ metas 
anchors verbose = 0 4 坐标 框 重 映射 我们 
对于 坐标 的 操作 都是/nr 基于 输入 图片 的 相对位置 
且 单位 长度 也是 其 宽 高 在 最后 我们 
需要 将之 修正 回 像素 空间坐标 令 输入 图片 list 
不 需要 输入 图片 具有 相同 的 尺寸 所以 我们 
在 恢复 时 必须 注意 单张 处理 之 # Process 
detections results = for i image in enumerate images # 
需要 单张 处理 因为 原始 图片 images 不 保证 每张 
尺寸 一致 final _ rois final _ class _ ids 
final _ scores final _ masks = \ self . 
unmold _ detections detections i mrcnn _ mask i image 
. shape molded _ images i . shape windows i 
目标 检测 框 重 映射 unmold _ detections 函数 def 
unmold _ detections self detections mrcnn _ mask original _ 
image _ shape image _ shape window Reformats the detections 
of one image from the format of the neural network 
output to a format suitable for use in the rest 
of the application . detections N y1 x1 y2 x2 
class _ id score in normalized coordinates mrcnn _ mask 
N height width num _ classes original _ image _ 
shape H W C Original image shape before resizing image 
_ shape H W C Shape of the image after 
resizing and padding window y1 x1 y2 x2 Pixel coordinates 
of box in the image where the real image is 
excluding the padding . Returns boxes N y1 x1 y2 
x2 Bounding boxes in pixels class _ ids N Integer 
class IDs for each bounding box scores N Float probability 
scores of the class _ id masks height width num 
_ instances Instance masks # How many detections do we 
have # Detections array is padded with zeros . Find 
the first class _ id = = 0 . zero 
_ ix = np . where detections 4 = = 
0 0 # DetectionLayer 末尾 对 结果 进行 了 全0/nr 
填充 N = zero _ ix 0 if zero _ 
ix . shape 0 0 else detections . shape 0 
# 有 意义 的 检测 结果 数 N # Extract 
boxes class _ ids scores and class specific masks boxes 
= detections N 4 # N y1 x1 y2 x2 
class _ ids = detections N 4 . astype np 
. int32 # N class _ id scores = detections 
N 5 # N score masks = mrcnn _ mask 
np . arange N class _ ids # N height 
width num _ classes # Translate normalized coordinates in the 
resized image to pixel # coordinates in the original image 
before resizing window = utils . norm _ boxes window 
image _ shape 2 # window 相对 输入 图片 规范化 
wy1 wx1 wy2 wx2 = window shift = np . 
array wy1 wx1 wy1 wx1 wh = wy2 wy1 # 
window height ww = wx2 wx1 # window width scale 
= np . array wh ww wh ww # Convert 
boxes to normalized coordinates on the window boxes = np 
. divide boxes shift scale # box 相对 window 坐标 
规范化 # Convert boxes to pixel coordinates on the original 
image boxes = utils . denorm _ boxes boxes original 
_ image _ shape 2 # box 相对 原 图解 
规范化 # Filter out detections with zero area . Happens 
in early training when # network weights are still random 
exclude _ ix = np . where boxes 2 boxes 
0 * boxes 3 boxes 1 = 0 0 if 
exclude _ ix . shape 0 0 boxes = np 
. delete boxes exclude _ ix axis = 0 class 
_ ids = np . delete class _ ids exclude 
_ ix axis = 0 scores = np . delete 
scores exclude _ ix axis = 0 masks = np 
. delete masks exclude _ ix axis = 0 N 
= class _ ids . shape 0 # Resize masks 
to original image size and set boundary threshold . full 
_ masks = for i in range N # 单个 
box 操作 # Convert neural network mask to full size 
mask full _ mask = utils . unmold _ mask 
masks i boxes i original _ image _ shape full 
_ masks . append full _ mask full _ masks 
= np . stack full _ masks axis = 1 
\ if full _ masks else np . empty original 
_ image _ shape 2 + 0 # n y1 
x1 y2 x2 # n class _ id # n 
class _ id # h w n return boxes class 
_ ids scores full _ masks 为了 将 输出 结果 
格式 还原 我们 需要 进行 如下 几步 剔除 为了 凑齐 
DETECTION _ MAX _ INSTANCES 填充 的 全0/nr 检测 结果 
将 box 放 缩回 原始 图片 对应 尺寸 剔除 面积 
为 0 的 boxmask 输出 尺寸 还原 在 网络 中 
操作 的 box 尺寸 为 基于 输入 图片 的 规范化 
坐标 window 为 像素 坐标 所以 我们 先将 window 相对 
输入 图片 规范化 使得 window 和 box 处于 同一 坐标系 
然后 这两者 坐标 就 可以 直接 交互 了 使 box 
相对 window 规范化 此时 box 坐标 尺寸 都是 window 的 
相对值 而/c window/w 和/c 原始/v 图片/n 是/v 直接/ad 有/v 映射/v 
关系/n 的/uj 所以 box 遵循 其 关系 映 射回 原始 
像素 大小 即可 完成 box 映射 后 我们 开始 对 
mask 进行 处理 Mask 信息 重 映射 utils . unmold 
_ mask 函数 utils . unmold _ mask 受 调 
用于 unmold _ detections 尾部 # Resize masks to original 
image size and set boundary threshold . full _ masks 
= for i in range N # 单个 box 操作 
# Convert neural network mask to full size mask full 
_ mask = utils . unmold _ mask masks i 
boxes i original _ image _ shape full _ masks 
. append full _ mask full _ masks = np 
. stack full _ masks axis = 1 \ if 
full _ masks else np . empty original _ image 
_ shape 2 + 0 首先 重申 我们 的 unmold 
_ detections 函数 是 对 单张 图片 进行 处理 的 
而 mask 处理 进一步 的 是 对 每一个 检测 框 
进行 处理 的 def unmold _ mask mask bbox image 
_ shape Converts a mask generated by the neural network 
to a format similar to its original shape . mask 
height width of type float . A small typically 28x28 
mask . bbox y1 x1 y2 x2 . The box 
to fit the mask in . Returns a binary mask 
with the same size as the original image . threshold 
= 0.5 y1 x1 y2 x2 = bbox mask = 
resize mask y2 y1 x2 x1 mask = np . 
where mask = threshold 1 0 . astype np . 
bool # Put the mask in the right location . 
full _ mask = np . zeros image _ shape 
2 dtype = np . bool full _ mask y1 
y2 x1 x2 = mask return full _ mask 我们 
在 inference 中 输出 的 mask 信息 仅仅 是 一般 
的 生成 网络 输出 所以 为了 得到 掩码 格式 我们 
需要 一个 阈值 明确 了 这个 概念 下 一步 就 
简单 了 我们 将 mask 输出 放缩 到 对应 的 
box 大小 即可 此时 的 box 已经 相对 原始 图片 
进行 了 放缩 是 像素 坐标 然后/c 将/d 放缩/v 后的/nr 
掩码/n 按照/p box/w 相对/d 原始/v 图片/n 的/uj 位置/v 贴/v 在/p 
一张/m 和/c 原始/v 图片/n 等/u 大/a 的/uj 空白/n 图片/n 上/f 
我们 对 每 一个 检测 目标 做 这个 操作 就 
可以 得到 等同于 检测 目标 数 的 原始 图片大小 的 
掩码 图片 每个 掩码 图片 上 有一个 掩码 对象 将之 
按照 axis = 1 拼接 最终 获取 h w n 
格式 输出 hw 为 原始 图片大小 n 为 最终 检测 
到 的 目标 数目 最终 将 计算结果 返回 退出 函数 
# n y1 x1 y2 x2 # n class _ 
id # n class _ id # h w n 
return boxes class _ ids scores full _ masks 实际 
调用 如下 一 detect/w 和/c build/w 前面/f 多节/m 中/f 我们/r 花了/nr 大量/n 
笔墨/n 介绍/v build/w 方法/n 的/uj inference/w 分支/n 这 节 我们 
看看 它 是 如何 被 调用 的 在 dimo . 
ipynb 中 涉及 model 的 操作 我们 简单 进行 一下 
汇总 首先 创建 图 并 载入 预 训练 权重 然后 
规范 了 类别 序列 实际 开始 检测 的 代码 块 
如下 经由 model . detect 方法 调用 model . build 
方法 也 就是 我们 前面 多节 在 讲解 的 方法 
构建 图 实施 预测 二 detect 方法 首先 看看 detect 
方法 的 前 几行 和 build 一样 同 见 model 
. py def detect self images verbose = 0 Runs 
the detection pipeline . images List of images potentially of 
different sizes . Returns a list of dicts one dict 
per image . The dict contains rois N y1 x1 
y2 x2 detection bounding boxes class _ ids N int 
class IDs scores N float probability scores for the class 
IDs masks H W N instance binary masks assert self 
. mode = = inference Create model in inference mode 
. assert len images = = self . config . 
BATCH _ SIZE len images must be equal to BATCH 
_ SIZE # 日志 记录 if verbose log Processing { 
} images . format len images for image in images 
log image image 1 待 检测 图像 预处理 # Mold 
inputs to format expected by the neural network molded _ 
images image _ metas windows = self . mold _ 
inputs images # Validate image sizes # All images in 
a batch MUST be of the same size image _ 
shape = molded _ images 0 . shape for g 
in molded _ images 1 assert g . shape = 
= image _ shape \ After resizing all images must 
have the same size . Check IMAGE _ RESIZE _ 
MODE and image sizes . 简单 的 纠错 和 日志 
控制 之后 即 调用 mold _ input 函数 对 输入 
图片 进行 调整 并 记录 图片 信息 self . mold 
_ inputs 方法 如下 def mold _ inputs self images 
Takes a list of images and modifies them to the 
format expected as an input to the neural network . 
images List of image matrices height width depth . Images 
can have different sizes . Returns 3 Numpy matrices molded 
_ images N h w 3 . Images resized and 
normalized . image _ metas N length of meta data 
. Details about each image . windows N y1 x1 
y2 x2 . The portion of the image that has 
the original image padding excluded . molded _ images = 
image _ metas = windows = for image in images 
# Resize image # TODO move resizing to mold _ 
image molded _ image window scale padding crop = utils 
. resize _ image image min _ dim = self 
. config . IMAGE _ MIN _ DIM # 800 
min _ scale = self . config . IMAGE _ 
MIN _ SCALE # 0 max _ dim = self 
. config . IMAGE _ MAX _ DIM # 1024 
mode = self . config . IMAGE _ RESIZE _ 
MODE # square molded _ image = mold _ image 
molded _ image self . config # 减 平均 像素 
# Build image _ meta 形式 为 np 数组 image 
_ meta = compose _ image _ meta 0 image 
. shape molded _ image . shape window scale np 
. zeros self . config . NUM _ CLASSES dtype 
= np . int32 # Append molded _ images . 
append molded _ image windows . append window image _ 
metas . append image _ meta # Pack into arrays 
molded _ images = np . stack molded _ images 
image _ metas = np . stack image _ metas 
windows = np . stack windows return molded _ images 
image _ metas windowsutils . resize _ image 函数 用于 
缩放 原 图像 它 生成 一个 scale 返回 图像 大小 
等于 输入 图像 大小 * scale 并 保证 最短 边 
等于 输入 min _ dim 最 长边 不大于 max _ 
dim 如果 最 长边 超过 了 max _ dim 则 
保证 最 长边 等于 max _ dim 最短 边 不再 
限制 最后 将 图片 padding 到 max _ dim * 
max _ dim 大小 即 molded _ images 大小 其实 
是 固定 的 其 返回值 如下 image . astype image 
_ dtype window scale padding crop 表示 resize 后 图片 
原图 相对 resize 后 图片 的 位置 信息 详见 计算机 
视觉 Mask RCNN _ 推断 网络 其五 目标 检测 结果 
精炼 放缩 倍数 padding 信息 四个 整数 crop 信息 四个 
整数 或者 None mold _ image 函数 更为 简单 就是 
把 图片 像素 减去 了 个 平均值 MEAN _ PIXEL 
= 123.7 116.8 103.9 compose _ image _ meta 记录 
了 全部 的 原始 信息 可以 看到 crop 并未 收录 
在内 def compose _ image _ meta image _ id 
original _ image _ shape image _ shape window scale 
active _ class _ ids Takes attributes of an image 
and puts them in one 1D array . image _ 
id An int ID of the image . Useful for 
debugging . original _ image _ shape H W C 
before resizing or padding . image _ shape H W 
C after resizing and padding window y1 x1 y2 x2 
in pixels . The area of the image where the 
real image is excluding the padding scale The scaling factor 
applied to the original image float32 active _ class _ 
ids List of class _ ids available in the dataset 
from which the image came . Useful if training on 
images from multiple datasets where not all classes are present 
in all datasets . meta = np . array image 
_ id + # size = 1 list original _ 
image _ shape + # size = 3 list image 
_ shape + # size = 3 list window + 
# size = 4 y1 x1 y2 x2 in image 
cooredinates scale + # size = 1 list active _ 
class _ ids # size = num _ classes return 
meta 最后 拼接 返回 2 anchors 生成 首先 调用 方法 
get _ anchors 生成 锚 框 见 计算机 视觉 Mask 
RCNN _ 锚 框 生成 shape 为 anchor _ count 
y1 x1 y2 x2 # Anchors anchors = self . 
get _ anchors image _ shape # Duplicate across the 
batch dimension because Keras requires it # TODO can this 
be optimized to avoid duplicating the anchors # anchor _ 
count y1 x1 y2 x2 batch anchor _ count y1 
x1 y2 x2 anchors = np . broadcast _ to 
anchors self . config . BATCH _ SIZE + anchors 
. shape 然后 为之 添加 batch 维度 最终 batch anchor 
_ count y1 x1 y2 x2 3 inference 网络 预测 
调用 keras 的 predict 方法 前 向 传播 在 预测 
任务 中 我们 仅仅 关注 detections 和 mrcnn _ mask 
两个 输出 # Run object detection # 于__/nr init _ 
_ 中 定义 self . keras _ model = self 
. build mode = mode config = config # 返回 
list detections mrcnn _ class mrcnn _ bbox # mrcnn 
_ mask rpn _ rois rpn _ class rpn _ 
bbox # detections batch num _ detections y1 x1 y2 
x2 class _ id score # mrcnn _ mask batch 
num _ detections MASK _ POOL _ SIZE MASK _ 
POOL _ SIZE NUM _ CLASSES detections _ _ mrcnn 
_ mask _ _ _ = \ self . keras 
_ model . predict molded _ images image _ metas 
anchors verbose = 0 4 坐标 框 重 映射 我们 
对于 坐标 的 操作 都是/nr 基于 输入 图片 的 相对位置 
且 单位 长度 也是 其 宽 高 在 最后 我们 
需要 将之 修正 回 像素 空间坐标 令 输入 图片 list 
不 需要 输入 图片 具有 相同 的 尺寸 所以 我们 
在 恢复 时 必须 注意 单张 处理 之 # Process 
detections results = for i image in enumerate images # 
需要 单张 处理 因为 原始 图片 images 不 保证 每张 
尺寸 一致 final _ rois final _ class _ ids 
final _ scores final _ masks = \ self . 
unmold _ detections detections i mrcnn _ mask i image 
. shape molded _ images i . shape windows i 
目标 检测 框 重 映射 unmold _ detections 函数 def 
unmold _ detections self detections mrcnn _ mask original _ 
image _ shape image _ shape window Reformats the detections 
of one image from the format of the neural network 
output to a format suitable for use in the rest 
of the application . detections N y1 x1 y2 x2 
class _ id score in normalized coordinates mrcnn _ mask 
N height width num _ classes original _ image _ 
shape H W C Original image shape before resizing image 
_ shape H W C Shape of the image after 
resizing and padding window y1 x1 y2 x2 Pixel coordinates 
of box in the image where the real image is 
excluding the padding . Returns boxes N y1 x1 y2 
x2 Bounding boxes in pixels class _ ids N Integer 
class IDs for each bounding box scores N Float probability 
scores of the class _ id masks height width num 
_ instances Instance masks # How many detections do we 
have # Detections array is padded with zeros . Find 
the first class _ id = = 0 . zero 
_ ix = np . where detections 4 = = 
0 0 # DetectionLayer 末尾 对 结果 进行 了 全0/nr 
填充 N = zero _ ix 0 if zero _ 
ix . shape 0 0 else detections . shape 0 
# 有 意义 的 检测 结果 数 N # Extract 
boxes class _ ids scores and class specific masks boxes 
= detections N 4 # N y1 x1 y2 x2 
class _ ids = detections N 4 . astype np 
. int32 # N class _ id scores = detections 
N 5 # N score masks = mrcnn _ mask 
np . arange N class _ ids # N height 
width num _ classes # Translate normalized coordinates in the 
resized image to pixel # coordinates in the original image 
before resizing window = utils . norm _ boxes window 
image _ shape 2 # window 相对 输入 图片 规范化 
wy1 wx1 wy2 wx2 = window shift = np . 
array wy1 wx1 wy1 wx1 wh = wy2 wy1 # 
window height ww = wx2 wx1 # window width scale 
= np . array wh ww wh ww # Convert 
boxes to normalized coordinates on the window boxes = np 
. divide boxes shift scale # box 相对 window 坐标 
规范化 # Convert boxes to pixel coordinates on the original 
image boxes = utils . denorm _ boxes boxes original 
_ image _ shape 2 # box 相对 原 图解 
规范化 # Filter out detections with zero area . Happens 
in early training when # network weights are still random 
exclude _ ix = np . where boxes 2 boxes 
0 * boxes 3 boxes 1 = 0 0 if 
exclude _ ix . shape 0 0 boxes = np 
. delete boxes exclude _ ix axis = 0 class 
_ ids = np . delete class _ ids exclude 
_ ix axis = 0 scores = np . delete 
scores exclude _ ix axis = 0 masks = np 
. delete masks exclude _ ix axis = 0 N 
= class _ ids . shape 0 # Resize masks 
to original image size and set boundary threshold . full 
_ masks = for i in range N # 单个 
box 操作 # Convert neural network mask to full size 
mask full _ mask = utils . unmold _ mask 
masks i boxes i original _ image _ shape full 
_ masks . append full _ mask full _ masks 
= np . stack full _ masks axis = 1 
\ if full _ masks else np . empty original 
_ image _ shape 2 + 0 # n y1 
x1 y2 x2 # n class _ id # n 
class _ id # h w n return boxes class 
_ ids scores full _ masks 为了 将 输出 结果 
格式 还原 我们 需要 进行 如下 几步 剔除 为了 凑齐 
DETECTION _ MAX _ INSTANCES 填充 的 全0/nr 检测 结果 
将 box 放 缩回 原始 图片 对应 尺寸 剔除 面积 
为 0 的 boxmask 输出 尺寸 还原 在 网络 中 
操作 的 box 尺寸 为 基于 输入 图片 的 规范化 
坐标 window 为 像素 坐标 所以 我们 先将 window 相对 
输入 图片 规范化 使得 window 和 box 处于 同一 坐标系 
然后 这两者 坐标 就 可以 直接 交互 了 使 box 
相对 window 规范化 此时 box 坐标 尺寸 都是 window 的 
相对值 而/c window/w 和/c 原始/v 图片/n 是/v 直接/ad 有/v 映射/v 
关系/n 的/uj 所以 box 遵循 其 关系 映 射回 原始 
像素 大小 即可 完成 box 映射 后 我们 开始 对 
mask 进行 处理 Mask 信息 重 映射 utils . unmold 
_ mask 函数 utils . unmold _ mask 受 调 
用于 unmold _ detections 尾部 # Resize masks to original 
image size and set boundary threshold . full _ masks 
= for i in range N # 单个 box 操作 
# Convert neural network mask to full size mask full 
_ mask = utils . unmold _ mask masks i 
boxes i original _ image _ shape full _ masks 
. append full _ mask full _ masks = np 
. stack full _ masks axis = 1 \ if 
full _ masks else np . empty original _ image 
_ shape 2 + 0 首先 重申 我们 的 unmold 
_ detections 函数 是 对 单张 图片 进行 处理 的 
而 mask 处理 进一步 的 是 对 每一个 检测 框 
进行 处理 的 def unmold _ mask mask bbox image 
_ shape Converts a mask generated by the neural network 
to a format similar to its original shape . mask 
height width of type float . A small typically 28x28 
mask . bbox y1 x1 y2 x2 . The box 
to fit the mask in . Returns a binary mask 
with the same size as the original image . threshold 
= 0.5 y1 x1 y2 x2 = bbox mask = 
resize mask y2 y1 x2 x1 mask = np . 
where mask = threshold 1 0 . astype np . 
bool # Put the mask in the right location . 
full _ mask = np . zeros image _ shape 
2 dtype = np . bool full _ mask y1 
y2 x1 x2 = mask return full _ mask 我们 
在 inference 中 输出 的 mask 信息 仅仅 是 一般 
的 生成 网络 输出 所以 为了 得到 掩码 格式 我们 
需要 一个 阈值 明确 了 这个 概念 下 一步 就 
简单 了 我们 将 mask 输出 放缩 到 对应 的 
box 大小 即可 此时 的 box 已经 相对 原始 图片 
进行 了 放缩 是 像素 坐标 然后/c 将/d 放缩/v 后的/nr 
掩码/n 按照/p box/w 相对/d 原始/v 图片/n 的/uj 位置/v 贴/v 在/p 
一张/m 和/c 原始/v 图片/n 等/u 大/a 的/uj 空白/n 图片/n 上/f 
我们 对 每 一个 检测 目标 做 这个 操作 就 
可以 得到 等同于 检测 目标 数 的 原始 图片大小 的 
掩码 图片 每个 掩码 图片 上 有一个 掩码 对象 将之 
按照 axis = 1 拼接 最终 获取 h w n 
格式 输出 hw 为 原始 图片大小 n 为 最终 检测 
到 的 目标 数目 最终 将 计算结果 返回 退出 函数 
# n y1 x1 y2 x2 # n class _ 
id # n class _ id # h w n 
return boxes class _ ids scores full _ masks 实际 
调用 如下 