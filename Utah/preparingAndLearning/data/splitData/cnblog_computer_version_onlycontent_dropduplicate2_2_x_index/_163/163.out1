一 Mask 生成 概览 上 一节 的 末尾 我们 已经 
获取 了 待 检测 图片 的 分类 回归 信息 我们 
将 回归 信息 即 待 检测 目标 的 边框 信息 
单独 提取 出来 结合 金字塔 特征 mrcnn _ feature _ 
maps 进行 Mask 生成 工作 input _ image _ meta 
用于 提取 输入 图片 长宽 进行 金字塔 ROI 处理 即 
PyramidROIAlign # Detections # output is batch num _ detections 
y1 x1 y2 x2 class _ id score in # 
normalized coordinates detections = DetectionLayer config name = mrcnn _ 
detection rpn _ rois mrcnn _ class mrcnn _ bbox 
input _ image _ meta # Create masks for detections 
detection _ boxes = KL . Lambda lambda x x 
. . . 4 detections mrcnn _ mask = build 
_ fpn _ mask _ graph detection _ boxes mrcnn 
_ feature _ maps input _ image _ meta config 
. MASK _ POOL _ SIZE config . NUM _ 
CLASSES train _ bn = config . TRAIN _ BN 
二 Mask 生成 函数 我们 在 计算机 视觉 Mask RCNN 
_ 推断 网络 其四 FPN 和 ROIAlign 的 耦合 已经 
介绍 过了 PyramidROIAlign class 的 内容 def build _ fpn 
_ mask _ graph rois feature _ maps image _ 
meta pool _ size num _ classes train _ bn 
= True Builds the computation graph of the mask head 
of Feature Pyramid Network . rois batch num _ rois 
y1 x1 y2 x2 Proposal boxes in normalized coordinates . 
feature _ maps List of feature maps from different layers 
of the pyramid P2 P3 P4 P5 . Each has 
a different resolution . image _ meta batch meta data 
Image details . See compose _ image _ meta pool 
_ size The width of the square feature map generated 
from ROI Pooling . num _ classes number of classes 
which determines the depth of the results train _ bn 
Boolean . Train or freeze Batch Norm layers Returns Masks 
batch num _ rois MASK _ POOL _ SIZE MASK 
_ POOL _ SIZE NUM _ CLASSES # ROI Pooling 
# Shape batch num _ rois MASK _ POOL _ 
SIZE MASK _ POOL _ SIZE channels x = PyramidROIAlign 
pool _ size pool _ size name = roi _ 
align _ mask rois image _ meta + feature _ 
maps # Conv layers x = KL . TimeDistributed KL 
. Conv2D 256 3 3 padding = same name = 
mrcnn _ mask _ conv1 x x = KL . 
TimeDistributed BatchNorm name = mrcnn _ mask _ bn1 x 
training = train _ bn x = KL . Activation 
relu x x = KL . TimeDistributed KL . Conv2D 
256 3 3 padding = same name = mrcnn _ 
mask _ conv2 x x = KL . TimeDistributed BatchNorm 
name = mrcnn _ mask _ bn2 x training = 
train _ bn x = KL . Activation relu x 
x = KL . TimeDistributed KL . Conv2D 256 3 
3 padding = same name = mrcnn _ mask _ 
conv3 x x = KL . TimeDistributed BatchNorm name = 
mrcnn _ mask _ bn3 x training = train _ 
bn x = KL . Activation relu x x = 
KL . TimeDistributed KL . Conv2D 256 3 3 padding 
= same name = mrcnn _ mask _ conv4 x 
x = KL . TimeDistributed BatchNorm name = mrcnn _ 
mask _ bn4 x training = train _ bn x 
= KL . Activation relu x x = KL . 
TimeDistributed KL . Conv2DTranspose 256 2 2 strides = 2 
activation = relu name = mrcnn _ mask _ deconv 
x x = KL . TimeDistributed KL . Conv2D num 
_ classes 1 1 strides = 1 activation = sigmoid 
name = mrcnn _ mask x return xPyramidROIAlign 之后 这里会 
降 采样 一次 最 终生 成众 多宽 高 等同 输入 
ROI feat 但是 是 单通道 的 Mask 输出 最后 的 
激活 函数 很 疯狂 relu 接 sigmoid 保证 每个 像素 
位置 介于 01 之间 此时 的 Mask 掩码 输出 大小 
为 2 * MASK _ POOL _ SIZE 2 * 
MASK _ POOL _ SIZE 对 demo . pynb 而言 
是 28 * 28 源码 注释 给 的 数目 是 
没有 * 2 的 由于 最后 有 一个 stride 为 
2 的 转置 卷积 所以 应该 是 疏忽 毕竟 config 
的 另外 一个 参量 MASK _ SHAPE 值 为 28 
* 28 虽然在 推断 网络 没有 使用 到 至此 推断 
网络 的 最后 一个 输出 对象 级别 原始 Mask 计算 
了 出来 三 build 函数 返回 然后 我们 将 整个 
build 函数 构建 model 所 需要 的 输入 tensor 和 
输出 tensor 进行 打包 创建 keras 模型 model = KM 
. Model input _ image input _ image _ meta 
input _ anchors detections mrcnn _ class mrcnn _ bbox 
mrcnn _ mask rpn _ rois rpn _ class rpn 
_ bbox name = mask _ rcnn # Add multi 
GPU support . if config . GPU _ COUNT 1 
from mrcnn . parallel _ model import ParallelModel model = 
ParallelModel model config . GPU _ COUNT return model 整理 
一下 模型 输出 Tensor # num _ anchors 每张 图片 
上 生成 的 锚 框 数量 # num _ rois 
每张 图片 上 由 锚 框 筛选出 的 推荐 区 
数量 # # 由 POST _ NMS _ ROIS _ 
TRAINING 或 POST _ NMS _ ROIS _ INFERENCE 规定 
# num _ detections 每张 图片 上 最终 检测 输出 
框 # # 由 DETECTION _ MAX _ INSTANCES 规定 
# detections batch num _ detections y1 x1 y2 x2 
class _ id score # mrcnn _ class batch num 
_ rois NUM _ CLASSES classifier probabilities # mrcnn _ 
bbox batch num _ rois NUM _ CLASSES dy dx 
log dh log dw # mrcnn _ mask batch num 
_ detections MASK _ POOL _ SIZE MASK _ POOL 
_ SIZE NUM _ CLASSES # rpn _ rois batch 
num _ rois y1 x1 y2 x2 class _ id 
score # rpn _ class batch num _ anchors 2 
# rpn _ bbox batch num _ anchors 4 由于 
我们 的 GPU _ COUNT 为 1 不是 多 卡 
训练 所以 不 需要 GPU 支持 多 GPU 模型 后面 
应该会 单开 一节 讲 直接 将 model 返回 即可 附 
MaskRCNN class 网络 构建 方法 总览 再次 将 build 函数 
全貌 贴出 分支 选项 按照 mode = inference 选 即为 
本 系列 推断 网络 的 内容 # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # MaskRCNN Class # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # class 
MaskRCNN Encapsulates the Mask RCNN model functionality . The actual 
Keras model is in the keras _ model property . 
def _ _ init _ _ self mode config model 
_ dir mode Either training or inference config A Sub 
class of the Config class model _ dir Directory to 
save training logs and trained weights assert mode in training 
inference self . mode = mode self . config = 
config self . model _ dir = model _ dir 
self . set _ log _ dir self . keras 
_ model = self . build mode = mode config 
= config def build self mode config Build Mask R 
CNN architecture . input _ shape The shape of the 
input image . mode Either training or inference . The 
inputs and outputs of the model differ accordingly . assert 
mode in training inference # Image size must be dividable 
by 2 multiple times h w = config . IMAGE 
_ SHAPE 2 # 1024 1024 3 if h / 
2 * * 6 = int h / 2 * 
* 6 or w / 2 * * 6 = 
int w / 2 * * 6 # 这里 就 
限定 了 下 采样 不会 产生 坐标 误差 raise Exception 
Image size must be dividable by 2 at least 6 
times to avoid fractions when downscaling and upscaling . For 
example use 256 320 384 448 512 . . . 
etc . # Inputs input _ image = KL . 
Input shape = None None config . IMAGE _ SHAPE 
2 name = input _ image input _ image _ 
meta = KL . Input shape = config . IMAGE 
_ META _ SIZE name = input _ image _ 
meta if mode = = training # RPN GT input 
_ rpn _ match = KL . Input shape = 
None 1 name = input _ rpn _ match dtype 
= tf . int32 input _ rpn _ bbox = 
KL . Input shape = None 4 name = input 
_ rpn _ bbox dtype = tf . float32 # 
Detection GT class IDs bounding boxes and masks # 1 
. GT Class IDs zero padded input _ gt _ 
class _ ids = KL . Input shape = None 
name = input _ gt _ class _ ids dtype 
= tf . int32 # 2 . GT Boxes in 
pixels zero padded # batch MAX _ GT _ INSTANCES 
y1 x1 y2 x2 in image coordinates input _ gt 
_ boxes = KL . Input shape = None 4 
name = input _ gt _ boxes dtype = tf 
. float32 # Normalize coordinates gt _ boxes = KL 
. Lambda lambda x norm _ boxes _ graph x 
K . shape input _ image 1 3 input _ 
gt _ boxes # 3 . GT Masks zero padded 
# batch height width MAX _ GT _ INSTANCES if 
config . USE _ MINI _ MASK input _ gt 
_ masks = KL . Input shape = config . 
MINI _ MASK _ SHAPE 0 config . MINI _ 
MASK _ SHAPE 1 None name = input _ gt 
_ masks dtype = bool else input _ gt _ 
masks = KL . Input shape = config . IMAGE 
_ SHAPE 0 config . IMAGE _ SHAPE 1 None 
name = input _ gt _ masks dtype = bool 
elif mode = = inference # Anchors in normalized coordinates 
input _ anchors = KL . Input shape = None 
4 name = input _ anchors # Build the shared 
convolutional layers . # Bottom up Layers # Returns a 
list of the last layers of each stage 5 in 
total . # Don t create the thead stage 5 
so we pick the 4th item in the list . 
if callable config . BACKBONE _ C2 C3 C4 C5 
= config . BACKBONE input _ image stage5 = True 
train _ bn = config . TRAIN _ BN else 
_ C2 C3 C4 C5 = resnet _ graph input 
_ image config . BACKBONE stage5 = True train _ 
bn = config . TRAIN _ BN # Top down 
Layers # TODO add assert to varify feature map sizes 
match what s in config P5 = KL . Conv2D 
config . TOP _ DOWN _ PYRAMID _ SIZE 1 
1 name = fpn _ c5p5 C5 # 256 P4 
= KL . Add name = fpn _ p4add KL 
. UpSampling2D size = 2 2 name = fpn _ 
p5upsampled P5 KL . Conv2D config . TOP _ DOWN 
_ PYRAMID _ SIZE 1 1 name = fpn _ 
c4p4 C4 P3 = KL . Add name = fpn 
_ p3add KL . UpSampling2D size = 2 2 name 
= fpn _ p4upsampled P4 KL . Conv2D config . 
TOP _ DOWN _ PYRAMID _ SIZE 1 1 name 
= fpn _ c3p3 C3 P2 = KL . Add 
name = fpn _ p2add KL . UpSampling2D size = 
2 2 name = fpn _ p3upsampled P3 KL . 
Conv2D config . TOP _ DOWN _ PYRAMID _ SIZE 
1 1 name = fpn _ c2p2 C2 # Attach 
3x3 conv to all P layers to get the final 
feature maps . P2 = KL . Conv2D config . 
TOP _ DOWN _ PYRAMID _ SIZE 3 3 padding 
= SAME name = fpn _ p2 P2 P3 = 
KL . Conv2D config . TOP _ DOWN _ PYRAMID 
_ SIZE 3 3 padding = SAME name = fpn 
_ p3 P3 P4 = KL . Conv2D config . 
TOP _ DOWN _ PYRAMID _ SIZE 3 3 padding 
= SAME name = fpn _ p4 P4 P5 = 
KL . Conv2D config . TOP _ DOWN _ PYRAMID 
_ SIZE 3 3 padding = SAME name = fpn 
_ p5 P5 # P6 is used for the 5th 
anchor scale in RPN . Generated by # subsampling from 
P5 with stride of 2 . P6 = KL . 
MaxPooling2D pool _ size = 1 1 strides = 2 
name = fpn _ p6 P5 # Note that P6 
is used in RPN but not in the classifier heads 
. rpn _ feature _ maps = P2 P3 P4 
P5 P6 mrcnn _ feature _ maps = P2 P3 
P4 P5 # Anchors if mode = = training anchors 
= self . get _ anchors config . IMAGE _ 
SHAPE # Duplicate across the batch dimension because Keras requires 
it # TODO can this be optimized to avoid duplicating 
the anchors anchors = np . broadcast _ to anchors 
config . BATCH _ SIZE + anchors . shape # 
A hack to get around Keras s bad support for 
constants anchors = KL . Lambda lambda x tf . 
Variable anchors name = anchors input _ image else anchors 
= input _ anchors # RPN Model 返回 的 是 
keras 的 Module 对象 注意 keras 中的 Module 对象 是 
可 call 的 rpn = build _ rpn _ model 
config . RPN _ ANCHOR _ STRIDE # 1 3 
256 len config . RPN _ ANCHOR _ RATIOS config 
. TOP _ DOWN _ PYRAMID _ SIZE # Loop 
through pyramid layers layer _ outputs = # list of 
lists for p in rpn _ feature _ maps layer 
_ outputs . append rpn p # 保存 各 pyramid 
特征 经过 RPN 之后 的 结果 # Concatenate layer outputs 
# Convert from list of lists of level outputs to 
list of lists # of outputs across levels . # 
e . g . a1 b1 c1 a2 b2 c2 
= a1 a2 b1 b2 c1 c2 output _ names 
= rpn _ class _ logits rpn _ class rpn 
_ bbox outputs = list zip * layer _ outputs 
# logits2 6 class2 6 bbox2 6 outputs = KL 
. Concatenate axis = 1 name = n list o 
for o n in zip outputs output _ names # 
batch num _ anchors 2/4 # 其中 num _ anchors 
指 的 是 全部 特征 层 上 的 anchors 总数 
rpn _ class _ logits rpn _ class rpn _ 
bbox = outputs # Generate proposals # Proposals are batch 
N y1 x1 y2 x2 in normalized coordinates # and 
zero padded . # POST _ NMS _ ROIS _ 
INFERENCE = 1000 # POST _ NMS _ ROIS _ 
TRAINING = 2000 proposal _ count = config . POST 
_ NMS _ ROIS _ TRAINING if mode = = 
training \ else config . POST _ NMS _ ROIS 
_ INFERENCE # IMAGES _ PER _ GPU num _ 
rois y1 x1 y2 x2 # IMAGES _ PER _ 
GPU 取代 了 batch 之后 说 的 batch 都是 IMAGES 
_ PER _ GPU rpn _ rois = ProposalLayer proposal 
_ count = proposal _ count nms _ threshold = 
config . RPN _ NMS _ THRESHOLD # 0.7 name 
= ROI config = config rpn _ class rpn _ 
bbox anchors if mode = = training # Class ID 
mask to mark class IDs supported by the dataset the 
image # came from . active _ class _ ids 
= KL . Lambda lambda x parse _ image _ 
meta _ graph x active _ class _ ids input 
_ image _ meta if not config . USE _ 
RPN _ ROIS # Ignore predicted ROIs and use ROIs 
provided as an input . input _ rois = KL 
. Input shape = config . POST _ NMS _ 
ROIS _ TRAINING 4 name = input _ roi dtype 
= np . int32 # Normalize coordinates target _ rois 
= KL . Lambda lambda x norm _ boxes _ 
graph x K . shape input _ image 1 3 
input _ rois else target _ rois = rpn _ 
rois # Generate detection targets # Subsamples proposals and generates 
target outputs for training # Note that proposal class IDs 
gt _ boxes and gt _ masks are zero # 
padded . Equally returned rois and targets are zero padded 
. rois target _ class _ ids target _ bbox 
target _ mask = \ D e t e c 
t i o n T a r g e t 
L a y e r config name = proposal _ 
targets target _ rois input _ gt _ class _ 
ids gt _ boxes input _ gt _ masks # 
Network Heads # TODO verify that this handles zero padded 
ROIs mrcnn _ class _ logits mrcnn _ class mrcnn 
_ bbox = \ fpn _ classifier _ graph rois 
mrcnn _ feature _ maps input _ image _ meta 
config . POOL _ SIZE config . NUM _ CLASSES 
train _ bn = config . TRAIN _ BN fc 
_ layers _ size = config . FPN _ CLASSIF 
_ FC _ LAYERS _ SIZE mrcnn _ mask = 
build _ fpn _ mask _ graph rois mrcnn _ 
feature _ maps input _ image _ meta config . 
MASK _ POOL _ SIZE config . NUM _ CLASSES 
train _ bn = config . TRAIN _ BN # 
TODO clean up use tf . identify if necessary output 
_ rois = KL . Lambda lambda x x * 
1 name = output _ rois rois # Losses rpn 
_ class _ loss = KL . Lambda lambda x 
rpn _ class _ loss _ graph * x name 
= rpn _ class _ loss input _ rpn _ 
match rpn _ class _ logits rpn _ bbox _ 
loss = KL . Lambda lambda x rpn _ bbox 
_ loss _ graph config * x name = rpn 
_ bbox _ loss input _ rpn _ bbox input 
_ rpn _ match rpn _ bbox class _ loss 
= KL . Lambda lambda x mrcnn _ class _ 
loss _ graph * x name = mrcnn _ class 
_ loss target _ class _ ids mrcnn _ class 
_ logits active _ class _ ids bbox _ loss 
= KL . Lambda lambda x mrcnn _ bbox _ 
loss _ graph * x name = mrcnn _ bbox 
_ loss target _ bbox target _ class _ ids 
mrcnn _ bbox mask _ loss = KL . Lambda 
lambda x mrcnn _ mask _ loss _ graph * 
x name = mrcnn _ mask _ loss target _ 
mask target _ class _ ids mrcnn _ mask # 
Model inputs = input _ image input _ image _ 
meta input _ rpn _ match input _ rpn _ 
bbox input _ gt _ class _ ids input _ 
gt _ boxes input _ gt _ masks if not 
config . USE _ RPN _ ROIS inputs . append 
input _ rois outputs = rpn _ class _ logits 
rpn _ class rpn _ bbox mrcnn _ class _ 
logits mrcnn _ class mrcnn _ bbox mrcnn _ mask 
rpn _ rois output _ rois rpn _ class _ 
loss rpn _ bbox _ loss class _ loss bbox 
_ loss mask _ loss model = KM . Model 
inputs outputs name = mask _ rcnn else # Network 
Heads # Proposal classifier and BBox regressor heads # output 
shapes # mrcnn _ class _ logits batch num _ 
rois NUM _ CLASSES classifier logits before softmax # mrcnn 
_ class batch num _ rois NUM _ CLASSES classifier 
probabilities # mrcnn _ bbox deltas batch num _ rois 
NUM _ CLASSES dy dx log dh log dw mrcnn 
_ class _ logits mrcnn _ class mrcnn _ bbox 
= \ fpn _ classifier _ graph rpn _ rois 
mrcnn _ feature _ maps input _ image _ meta 
config . POOL _ SIZE # 7 config . NUM 
_ CLASSES train _ bn = config . TRAIN _ 
BN fc _ layers _ size = config . FPN 
_ CLASSIF _ FC _ LAYERS _ SIZE # Detections 
# output is batch num _ detections y1 x1 y2 
x2 class _ id score in # normalized coordinates detections 
= DetectionLayer config name = mrcnn _ detection rpn _ 
rois mrcnn _ class mrcnn _ bbox input _ image 
_ meta # Create masks for detections detection _ boxes 
= KL . Lambda lambda x x . . . 
4 detections mrcnn _ mask = build _ fpn _ 
mask _ graph detection _ boxes mrcnn _ feature _ 
maps input _ image _ meta config . MASK _ 
POOL _ SIZE # 14 config . NUM _ CLASSES 
train _ bn = config . TRAIN _ BN # 
num _ anchors 每张 图片 上 生成 的 锚 框 
数量 # num _ rois 每张 图片 上 由 锚 
框 筛选出 的 推荐 区 数量 # # 由 POST 
_ NMS _ ROIS _ TRAINING 或 POST _ NMS 
_ ROIS _ INFERENCE 规定 # num _ detections 每张 
图片 上 最终 检测 输出 框 # # 由 DETECTION 
_ MAX _ INSTANCES 规定 # detections batch num _ 
detections y1 x1 y2 x2 class _ id score # 
mrcnn _ class batch num _ rois NUM _ CLASSES 
classifier probabilities # mrcnn _ bbox batch num _ rois 
NUM _ CLASSES dy dx log dh log dw # 
mrcnn _ mask batch num _ detections MASK _ POOL 
_ SIZE MASK _ POOL _ SIZE NUM _ CLASSES 
# rpn _ rois batch num _ rois y1 x1 
y2 x2 class _ id score # rpn _ class 
batch num _ anchors 2 # rpn _ bbox batch 
num _ anchors 4 model = KM . Model input 
_ image input _ image _ meta input _ anchors 
detections mrcnn _ class mrcnn _ bbox mrcnn _ mask 
rpn _ rois rpn _ class rpn _ bbox name 
= mask _ rcnn # Add multi GPU support . 
if config . GPU _ COUNT 1 from mrcnn . 
parallel _ model import ParallelModel model = ParallelModel model config 
. GPU _ COUNT return model 一 Mask 生成 概览 上 一节 的 末尾 我们 已经 
获取 了 待 检测 图片 的 分类 回归 信息 我们 
将 回归 信息 即 待 检测 目标 的 边框 信息 
单独 提取 出来 结合 金字塔 特征 mrcnn _ feature _ 
maps 进行 Mask 生成 工作 input _ image _ meta 
用于 提取 输入 图片 长宽 进行 金字塔 ROI 处理 即 
PyramidROIAlign # Detections # output is batch num _ detections 
y1 x1 y2 x2 class _ id score in # 
normalized coordinates detections = DetectionLayer config name = mrcnn _ 
detection rpn _ rois mrcnn _ class mrcnn _ bbox 
input _ image _ meta # Create masks for detections 
detection _ boxes = KL . Lambda lambda x x 
. . . 4 detections mrcnn _ mask = build 
_ fpn _ mask _ graph detection _ boxes mrcnn 
_ feature _ maps input _ image _ meta config 
. MASK _ POOL _ SIZE config . NUM _ 
CLASSES train _ bn = config . TRAIN _ BN 
二 Mask 生成 函数 我们 在 计算机 视觉 Mask RCNN 
_ 推断 网络 其四 FPN 和 ROIAlign 的 耦合 已经 
介绍 过了 PyramidROIAlign class 的 内容 def build _ fpn 
_ mask _ graph rois feature _ maps image _ 
meta pool _ size num _ classes train _ bn 
= True Builds the computation graph of the mask head 
of Feature Pyramid Network . rois batch num _ rois 
y1 x1 y2 x2 Proposal boxes in normalized coordinates . 
feature _ maps List of feature maps from different layers 
of the pyramid P2 P3 P4 P5 . Each has 
a different resolution . image _ meta batch meta data 
Image details . See compose _ image _ meta pool 
_ size The width of the square feature map generated 
from ROI Pooling . num _ classes number of classes 
which determines the depth of the results train _ bn 
Boolean . Train or freeze Batch Norm layers Returns Masks 
batch num _ rois MASK _ POOL _ SIZE MASK 
_ POOL _ SIZE NUM _ CLASSES # ROI Pooling 
# Shape batch num _ rois MASK _ POOL _ 
SIZE MASK _ POOL _ SIZE channels x = PyramidROIAlign 
pool _ size pool _ size name = roi _ 
align _ mask rois image _ meta + feature _ 
maps # Conv layers x = KL . TimeDistributed KL 
. Conv2D 256 3 3 padding = same name = 
mrcnn _ mask _ conv1 x x = KL . 
TimeDistributed BatchNorm name = mrcnn _ mask _ bn1 x 
training = train _ bn x = KL . Activation 
relu x x = KL . TimeDistributed KL . Conv2D 
256 3 3 padding = same name = mrcnn _ 
mask _ conv2 x x = KL . TimeDistributed BatchNorm 
name = mrcnn _ mask _ bn2 x training = 
train _ bn x = KL . Activation relu x 
x = KL . TimeDistributed KL . Conv2D 256 3 
3 padding = same name = mrcnn _ mask _ 
conv3 x x = KL . TimeDistributed BatchNorm name = 
mrcnn _ mask _ bn3 x training = train _ 
bn x = KL . Activation relu x x = 
KL . TimeDistributed KL . Conv2D 256 3 3 padding 
= same name = mrcnn _ mask _ conv4 x 
x = KL . TimeDistributed BatchNorm name = mrcnn _ 
mask _ bn4 x training = train _ bn x 
= KL . Activation relu x x = KL . 
TimeDistributed KL . Conv2DTranspose 256 2 2 strides = 2 
activation = relu name = mrcnn _ mask _ deconv 
x x = KL . TimeDistributed KL . Conv2D num 
_ classes 1 1 strides = 1 activation = sigmoid 
name = mrcnn _ mask x return xPyramidROIAlign 之后 这里会 
降 采样 一次 最 终生 成众 多宽 高 等同 输入 
ROI feat 但是 是 单通道 的 Mask 输出 最后 的 
激活 函数 很 疯狂 relu 接 sigmoid 保证 每个 像素 
位置 介于 01 之间 此时 的 Mask 掩码 输出 大小 
为 2 * MASK _ POOL _ SIZE 2 * 
MASK _ POOL _ SIZE 对 demo . pynb 而言 
是 28 * 28 源码 注释 给 的 数目 是 
没有 * 2 的 由于 最后 有 一个 stride 为 
2 的 转置 卷积 所以 应该 是 疏忽 毕竟 config 
的 另外 一个 参量 MASK _ SHAPE 值 为 28 
* 28 虽然在 推断 网络 没有 使用 到 至此 推断 
网络 的 最后 一个 输出 对象 级别 原始 Mask 计算 
了 出来 三 build 函数 返回 然后 我们 将 整个 
build 函数 构建 model 所 需要 的 输入 tensor 和 
输出 tensor 进行 打包 创建 keras 模型 model = KM 
. Model input _ image input _ image _ meta 
input _ anchors detections mrcnn _ class mrcnn _ bbox 
mrcnn _ mask rpn _ rois rpn _ class rpn 
_ bbox name = mask _ rcnn # Add multi 
GPU support . if config . GPU _ COUNT 1 
from mrcnn . parallel _ model import ParallelModel model = 
ParallelModel model config . GPU _ COUNT return model 整理 
一下 模型 输出 Tensor # num _ anchors 每张 图片 
上 生成 的 锚 框 数量 # num _ rois 
每张 图片 上 由 锚 框 筛选出 的 推荐 区 
数量 # # 由 POST _ NMS _ ROIS _ 
TRAINING 或 POST _ NMS _ ROIS _ INFERENCE 规定 
# num _ detections 每张 图片 上 最终 检测 输出 
框 # # 由 DETECTION _ MAX _ INSTANCES 规定 
# detections batch num _ detections y1 x1 y2 x2 
class _ id score # mrcnn _ class batch num 
_ rois NUM _ CLASSES classifier probabilities # mrcnn _ 
bbox batch num _ rois NUM _ CLASSES dy dx 
log dh log dw # mrcnn _ mask batch num 
_ detections MASK _ POOL _ SIZE MASK _ POOL 
_ SIZE NUM _ CLASSES # rpn _ rois batch 
num _ rois y1 x1 y2 x2 class _ id 
score # rpn _ class batch num _ anchors 2 
# rpn _ bbox batch num _ anchors 4 由于 
我们 的 GPU _ COUNT 为 1 不是 多 卡 
训练 所以 不 需要 GPU 支持 多 GPU 模型 后面 
应该会 单开 一节 讲 直接 将 model 返回 即可 附 
MaskRCNN class 网络 构建 方法 总览 再次 将 build 函数 
全貌 贴出 分支 选项 按照 mode = inference 选 即为 
本 系列 推断 网络 的 内容 # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # MaskRCNN Class # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # class 
MaskRCNN Encapsulates the Mask RCNN model functionality . The actual 
Keras model is in the keras _ model property . 
def _ _ init _ _ self mode config model 
_ dir mode Either training or inference config A Sub 
class of the Config class model _ dir Directory to 
save training logs and trained weights assert mode in training 
inference self . mode = mode self . config = 
config self . model _ dir = model _ dir 
self . set _ log _ dir self . keras 
_ model = self . build mode = mode config 
= config def build self mode config Build Mask R 
CNN architecture . input _ shape The shape of the 
input image . mode Either training or inference . The 
inputs and outputs of the model differ accordingly . assert 
mode in training inference # Image size must be dividable 
by 2 multiple times h w = config . IMAGE 
_ SHAPE 2 # 1024 1024 3 if h / 
2 * * 6 = int h / 2 * 
* 6 or w / 2 * * 6 = 
int w / 2 * * 6 # 这里 就 
限定 了 下 采样 不会 产生 坐标 误差 raise Exception 
Image size must be dividable by 2 at least 6 
times to avoid fractions when downscaling and upscaling . For 
example use 256 320 384 448 512 . . . 
etc . # Inputs input _ image = KL . 
Input shape = None None config . IMAGE _ SHAPE 
2 name = input _ image input _ image _ 
meta = KL . Input shape = config . IMAGE 
_ META _ SIZE name = input _ image _ 
meta if mode = = training # RPN GT input 
_ rpn _ match = KL . Input shape = 
None 1 name = input _ rpn _ match dtype 
= tf . int32 input _ rpn _ bbox = 
KL . Input shape = None 4 name = input 
_ rpn _ bbox dtype = tf . float32 # 
Detection GT class IDs bounding boxes and masks # 1 
. GT Class IDs zero padded input _ gt _ 
class _ ids = KL . Input shape = None 
name = input _ gt _ class _ ids dtype 
= tf . int32 # 2 . GT Boxes in 
pixels zero padded # batch MAX _ GT _ INSTANCES 
y1 x1 y2 x2 in image coordinates input _ gt 
_ boxes = KL . Input shape = None 4 
name = input _ gt _ boxes dtype = tf 
. float32 # Normalize coordinates gt _ boxes = KL 
. Lambda lambda x norm _ boxes _ graph x 
K . shape input _ image 1 3 input _ 
gt _ boxes # 3 . GT Masks zero padded 
# batch height width MAX _ GT _ INSTANCES if 
config . USE _ MINI _ MASK input _ gt 
_ masks = KL . Input shape = config . 
MINI _ MASK _ SHAPE 0 config . MINI _ 
MASK _ SHAPE 1 None name = input _ gt 
_ masks dtype = bool else input _ gt _ 
masks = KL . Input shape = config . IMAGE 
_ SHAPE 0 config . IMAGE _ SHAPE 1 None 
name = input _ gt _ masks dtype = bool 
elif mode = = inference # Anchors in normalized coordinates 
input _ anchors = KL . Input shape = None 
4 name = input _ anchors # Build the shared 
convolutional layers . # Bottom up Layers # Returns a 
list of the last layers of each stage 5 in 
total . # Don t create the thead stage 5 
so we pick the 4th item in the list . 
if callable config . BACKBONE _ C2 C3 C4 C5 
= config . BACKBONE input _ image stage5 = True 
train _ bn = config . TRAIN _ BN else 
_ C2 C3 C4 C5 = resnet _ graph input 
_ image config . BACKBONE stage5 = True train _ 
bn = config . TRAIN _ BN # Top down 
Layers # TODO add assert to varify feature map sizes 
match what s in config P5 = KL . Conv2D 
config . TOP _ DOWN _ PYRAMID _ SIZE 1 
1 name = fpn _ c5p5 C5 # 256 P4 
= KL . Add name = fpn _ p4add KL 
. UpSampling2D size = 2 2 name = fpn _ 
p5upsampled P5 KL . Conv2D config . TOP _ DOWN 
_ PYRAMID _ SIZE 1 1 name = fpn _ 
c4p4 C4 P3 = KL . Add name = fpn 
_ p3add KL . UpSampling2D size = 2 2 name 
= fpn _ p4upsampled P4 KL . Conv2D config . 
TOP _ DOWN _ PYRAMID _ SIZE 1 1 name 
= fpn _ c3p3 C3 P2 = KL . Add 
name = fpn _ p2add KL . UpSampling2D size = 
2 2 name = fpn _ p3upsampled P3 KL . 
Conv2D config . TOP _ DOWN _ PYRAMID _ SIZE 
1 1 name = fpn _ c2p2 C2 # Attach 
3x3 conv to all P layers to get the final 
feature maps . P2 = KL . Conv2D config . 
TOP _ DOWN _ PYRAMID _ SIZE 3 3 padding 
= SAME name = fpn _ p2 P2 P3 = 
KL . Conv2D config . TOP _ DOWN _ PYRAMID 
_ SIZE 3 3 padding = SAME name = fpn 
_ p3 P3 P4 = KL . Conv2D config . 
TOP _ DOWN _ PYRAMID _ SIZE 3 3 padding 
= SAME name = fpn _ p4 P4 P5 = 
KL . Conv2D config . TOP _ DOWN _ PYRAMID 
_ SIZE 3 3 padding = SAME name = fpn 
_ p5 P5 # P6 is used for the 5th 
anchor scale in RPN . Generated by # subsampling from 
P5 with stride of 2 . P6 = KL . 
MaxPooling2D pool _ size = 1 1 strides = 2 
name = fpn _ p6 P5 # Note that P6 
is used in RPN but not in the classifier heads 
. rpn _ feature _ maps = P2 P3 P4 
P5 P6 mrcnn _ feature _ maps = P2 P3 
P4 P5 # Anchors if mode = = training anchors 
= self . get _ anchors config . IMAGE _ 
SHAPE # Duplicate across the batch dimension because Keras requires 
it # TODO can this be optimized to avoid duplicating 
the anchors anchors = np . broadcast _ to anchors 
config . BATCH _ SIZE + anchors . shape # 
A hack to get around Keras s bad support for 
constants anchors = KL . Lambda lambda x tf . 
Variable anchors name = anchors input _ image else anchors 
= input _ anchors # RPN Model 返回 的 是 
keras 的 Module 对象 注意 keras 中的 Module 对象 是 
可 call 的 rpn = build _ rpn _ model 
config . RPN _ ANCHOR _ STRIDE # 1 3 
256 len config . RPN _ ANCHOR _ RATIOS config 
. TOP _ DOWN _ PYRAMID _ SIZE # Loop 
through pyramid layers layer _ outputs = # list of 
lists for p in rpn _ feature _ maps layer 
_ outputs . append rpn p # 保存 各 pyramid 
特征 经过 RPN 之后 的 结果 # Concatenate layer outputs 
# Convert from list of lists of level outputs to 
list of lists # of outputs across levels . # 
e . g . a1 b1 c1 a2 b2 c2 
= a1 a2 b1 b2 c1 c2 output _ names 
= rpn _ class _ logits rpn _ class rpn 
_ bbox outputs = list zip * layer _ outputs 
# logits2 6 class2 6 bbox2 6 outputs = KL 
. Concatenate axis = 1 name = n list o 
for o n in zip outputs output _ names # 
batch num _ anchors 2/4 # 其中 num _ anchors 
指 的 是 全部 特征 层 上 的 anchors 总数 
rpn _ class _ logits rpn _ class rpn _ 
bbox = outputs # Generate proposals # Proposals are batch 
N y1 x1 y2 x2 in normalized coordinates # and 
zero padded . # POST _ NMS _ ROIS _ 
INFERENCE = 1000 # POST _ NMS _ ROIS _ 
TRAINING = 2000 proposal _ count = config . POST 
_ NMS _ ROIS _ TRAINING if mode = = 
training \ else config . POST _ NMS _ ROIS 
_ INFERENCE # IMAGES _ PER _ GPU num _ 
rois y1 x1 y2 x2 # IMAGES _ PER _ 
GPU 取代 了 batch 之后 说 的 batch 都是 IMAGES 
_ PER _ GPU rpn _ rois = ProposalLayer proposal 
_ count = proposal _ count nms _ threshold = 
config . RPN _ NMS _ THRESHOLD # 0.7 name 
= ROI config = config rpn _ class rpn _ 
bbox anchors if mode = = training # Class ID 
mask to mark class IDs supported by the dataset the 
image # came from . active _ class _ ids 
= KL . Lambda lambda x parse _ image _ 
meta _ graph x active _ class _ ids input 
_ image _ meta if not config . USE _ 
RPN _ ROIS # Ignore predicted ROIs and use ROIs 
provided as an input . input _ rois = KL 
. Input shape = config . POST _ NMS _ 
ROIS _ TRAINING 4 name = input _ roi dtype 
= np . int32 # Normalize coordinates target _ rois 
= KL . Lambda lambda x norm _ boxes _ 
graph x K . shape input _ image 1 3 
input _ rois else target _ rois = rpn _ 
rois # Generate detection targets # Subsamples proposals and generates 
target outputs for training # Note that proposal class IDs 
gt _ boxes and gt _ masks are zero # 
padded . Equally returned rois and targets are zero padded 
. rois target _ class _ ids target _ bbox 
target _ mask = \ D e t e c 
t i o n T a r g e t 
L a y e r config name = proposal _ 
targets target _ rois input _ gt _ class _ 
ids gt _ boxes input _ gt _ masks # 
Network Heads # TODO verify that this handles zero padded 
ROIs mrcnn _ class _ logits mrcnn _ class mrcnn 
_ bbox = \ fpn _ classifier _ graph rois 
mrcnn _ feature _ maps input _ image _ meta 
config . POOL _ SIZE config . NUM _ CLASSES 
train _ bn = config . TRAIN _ BN fc 
_ layers _ size = config . FPN _ CLASSIF 
_ FC _ LAYERS _ SIZE mrcnn _ mask = 
build _ fpn _ mask _ graph rois mrcnn _ 
feature _ maps input _ image _ meta config . 
MASK _ POOL _ SIZE config . NUM _ CLASSES 
train _ bn = config . TRAIN _ BN # 
TODO clean up use tf . identify if necessary output 
_ rois = KL . Lambda lambda x x * 
1 name = output _ rois rois # Losses rpn 
_ class _ loss = KL . Lambda lambda x 
rpn _ class _ loss _ graph * x name 
= rpn _ class _ loss input _ rpn _ 
match rpn _ class _ logits rpn _ bbox _ 
loss = KL . Lambda lambda x rpn _ bbox 
_ loss _ graph config * x name = rpn 
_ bbox _ loss input _ rpn _ bbox input 
_ rpn _ match rpn _ bbox class _ loss 
= KL . Lambda lambda x mrcnn _ class _ 
loss _ graph * x name = mrcnn _ class 
_ loss target _ class _ ids mrcnn _ class 
_ logits active _ class _ ids bbox _ loss 
= KL . Lambda lambda x mrcnn _ bbox _ 
loss _ graph * x name = mrcnn _ bbox 
_ loss target _ bbox target _ class _ ids 
mrcnn _ bbox mask _ loss = KL . Lambda 
lambda x mrcnn _ mask _ loss _ graph * 
x name = mrcnn _ mask _ loss target _ 
mask target _ class _ ids mrcnn _ mask # 
Model inputs = input _ image input _ image _ 
meta input _ rpn _ match input _ rpn _ 
bbox input _ gt _ class _ ids input _ 
gt _ boxes input _ gt _ masks if not 
config . USE _ RPN _ ROIS inputs . append 
input _ rois outputs = rpn _ class _ logits 
rpn _ class rpn _ bbox mrcnn _ class _ 
logits mrcnn _ class mrcnn _ bbox mrcnn _ mask 
rpn _ rois output _ rois rpn _ class _ 
loss rpn _ bbox _ loss class _ loss bbox 
_ loss mask _ loss model = KM . Model 
inputs outputs name = mask _ rcnn else # Network 
Heads # Proposal classifier and BBox regressor heads # output 
shapes # mrcnn _ class _ logits batch num _ 
rois NUM _ CLASSES classifier logits before softmax # mrcnn 
_ class batch num _ rois NUM _ CLASSES classifier 
probabilities # mrcnn _ bbox deltas batch num _ rois 
NUM _ CLASSES dy dx log dh log dw mrcnn 
_ class _ logits mrcnn _ class mrcnn _ bbox 
= \ fpn _ classifier _ graph rpn _ rois 
mrcnn _ feature _ maps input _ image _ meta 
config . POOL _ SIZE # 7 config . NUM 
_ CLASSES train _ bn = config . TRAIN _ 
BN fc _ layers _ size = config . FPN 
_ CLASSIF _ FC _ LAYERS _ SIZE # Detections 
# output is batch num _ detections y1 x1 y2 
x2 class _ id score in # normalized coordinates detections 
= DetectionLayer config name = mrcnn _ detection rpn _ 
rois mrcnn _ class mrcnn _ bbox input _ image 
_ meta # Create masks for detections detection _ boxes 
= KL . Lambda lambda x x . . . 
4 detections mrcnn _ mask = build _ fpn _ 
mask _ graph detection _ boxes mrcnn _ feature _ 
maps input _ image _ meta config . MASK _ 
POOL _ SIZE # 14 config . NUM _ CLASSES 
train _ bn = config . TRAIN _ BN # 
num _ anchors 每张 图片 上 生成 的 锚 框 
数量 # num _ rois 每张 图片 上 由 锚 
框 筛选出 的 推荐 区 数量 # # 由 POST 
_ NMS _ ROIS _ TRAINING 或 POST _ NMS 
_ ROIS _ INFERENCE 规定 # num _ detections 每张 
图片 上 最终 检测 输出 框 # # 由 DETECTION 
_ MAX _ INSTANCES 规定 # detections batch num _ 
detections y1 x1 y2 x2 class _ id score # 
mrcnn _ class batch num _ rois NUM _ CLASSES 
classifier probabilities # mrcnn _ bbox batch num _ rois 
NUM _ CLASSES dy dx log dh log dw # 
mrcnn _ mask batch num _ detections MASK _ POOL 
_ SIZE MASK _ POOL _ SIZE NUM _ CLASSES 
# rpn _ rois batch num _ rois y1 x1 
y2 x2 class _ id score # rpn _ class 
batch num _ anchors 2 # rpn _ bbox batch 
num _ anchors 4 model = KM . Model input 
_ image input _ image _ meta input _ anchors 
detections mrcnn _ class mrcnn _ bbox mrcnn _ mask 
rpn _ rois rpn _ class rpn _ bbox name 
= mask _ rcnn # Add multi GPU support . 
if config . GPU _ COUNT 1 from mrcnn . 
parallel _ model import ParallelModel model = ParallelModel model config 
. GPU _ COUNT return model 一 Mask 生成 概览 上 一节 的 末尾 我们 已经 
获取 了 待 检测 图片 的 分类 回归 信息 我们 
将 回归 信息 即 待 检测 目标 的 边框 信息 
单独 提取 出来 结合 金字塔 特征 mrcnn _ feature _ 
maps 进行 Mask 生成 工作 input _ image _ meta 
用于 提取 输入 图片 长宽 进行 金字塔 ROI 处理 即 
PyramidROIAlign # Detections # output is batch num _ detections 
y1 x1 y2 x2 class _ id score in # 
normalized coordinates detections = DetectionLayer config name = mrcnn _ 
detection rpn _ rois mrcnn _ class mrcnn _ bbox 
input _ image _ meta # Create masks for detections 
detection _ boxes = KL . Lambda lambda x x 
. . . 4 detections mrcnn _ mask = build 
_ fpn _ mask _ graph detection _ boxes mrcnn 
_ feature _ maps input _ image _ meta config 
. MASK _ POOL _ SIZE config . NUM _ 
CLASSES train _ bn = config . TRAIN _ BN 
二 Mask 生成 函数 我们 在 计算机 视觉 Mask RCNN 
_ 推断 网络 其四 FPN 和 ROIAlign 的 耦合 已经 
介绍 过了 PyramidROIAlign class 的 内容 def build _ fpn 
_ mask _ graph rois feature _ maps image _ 
meta pool _ size num _ classes train _ bn 
= True Builds the computation graph of the mask head 
of Feature Pyramid Network . rois batch num _ rois 
y1 x1 y2 x2 Proposal boxes in normalized coordinates . 
feature _ maps List of feature maps from different layers 
of the pyramid P2 P3 P4 P5 . Each has 
a different resolution . image _ meta batch meta data 
Image details . See compose _ image _ meta pool 
_ size The width of the square feature map generated 
from ROI Pooling . num _ classes number of classes 
which determines the depth of the results train _ bn 
Boolean . Train or freeze Batch Norm layers Returns Masks 
batch num _ rois MASK _ POOL _ SIZE MASK 
_ POOL _ SIZE NUM _ CLASSES # ROI Pooling 
# Shape batch num _ rois MASK _ POOL _ 
SIZE MASK _ POOL _ SIZE channels x = PyramidROIAlign 
pool _ size pool _ size name = roi _ 
align _ mask rois image _ meta + feature _ 
maps # Conv layers x = KL . TimeDistributed KL 
. Conv2D 256 3 3 padding = same name = 
mrcnn _ mask _ conv1 x x = KL . 
TimeDistributed BatchNorm name = mrcnn _ mask _ bn1 x 
training = train _ bn x = KL . Activation 
relu x x = KL . TimeDistributed KL . Conv2D 
256 3 3 padding = same name = mrcnn _ 
mask _ conv2 x x = KL . TimeDistributed BatchNorm 
name = mrcnn _ mask _ bn2 x training = 
train _ bn x = KL . Activation relu x 
x = KL . TimeDistributed KL . Conv2D 256 3 
3 padding = same name = mrcnn _ mask _ 
conv3 x x = KL . TimeDistributed BatchNorm name = 
mrcnn _ mask _ bn3 x training = train _ 
bn x = KL . Activation relu x x = 
KL . TimeDistributed KL . Conv2D 256 3 3 padding 
= same name = mrcnn _ mask _ conv4 x 
x = KL . TimeDistributed BatchNorm name = mrcnn _ 
mask _ bn4 x training = train _ bn x 
= KL . Activation relu x x = KL . 
TimeDistributed KL . Conv2DTranspose 256 2 2 strides = 2 
activation = relu name = mrcnn _ mask _ deconv 
x x = KL . TimeDistributed KL . Conv2D num 
_ classes 1 1 strides = 1 activation = sigmoid 
name = mrcnn _ mask x return xPyramidROIAlign 之后 这里会 
降 采样 一次 最 终生 成众 多宽 高 等同 输入 
ROI feat 但是 是 单通道 的 Mask 输出 最后 的 
激活 函数 很 疯狂 relu 接 sigmoid 保证 每个 像素 
位置 介于 01 之间 此时 的 Mask 掩码 输出 大小 
为 2 * MASK _ POOL _ SIZE 2 * 
MASK _ POOL _ SIZE 对 demo . pynb 而言 
是 28 * 28 源码 注释 给 的 数目 是 
没有 * 2 的 由于 最后 有 一个 stride 为 
2 的 转置 卷积 所以 应该 是 疏忽 毕竟 config 
的 另外 一个 参量 MASK _ SHAPE 值 为 28 
* 28 虽然在 推断 网络 没有 使用 到 至此 推断 
网络 的 最后 一个 输出 对象 级别 原始 Mask 计算 
了 出来 三 build 函数 返回 然后 我们 将 整个 
build 函数 构建 model 所 需要 的 输入 tensor 和 
输出 tensor 进行 打包 创建 keras 模型 model = KM 
. Model input _ image input _ image _ meta 
input _ anchors detections mrcnn _ class mrcnn _ bbox 
mrcnn _ mask rpn _ rois rpn _ class rpn 
_ bbox name = mask _ rcnn # Add multi 
GPU support . if config . GPU _ COUNT 1 
from mrcnn . parallel _ model import ParallelModel model = 
ParallelModel model config . GPU _ COUNT return model 整理 
一下 模型 输出 Tensor # num _ anchors 每张 图片 
上 生成 的 锚 框 数量 # num _ rois 
每张 图片 上 由 锚 框 筛选出 的 推荐 区 
数量 # # 由 POST _ NMS _ ROIS _ 
TRAINING 或 POST _ NMS _ ROIS _ INFERENCE 规定 
# num _ detections 每张 图片 上 最终 检测 输出 
框 # # 由 DETECTION _ MAX _ INSTANCES 规定 
# detections batch num _ detections y1 x1 y2 x2 
class _ id score # mrcnn _ class batch num 
_ rois NUM _ CLASSES classifier probabilities # mrcnn _ 
bbox batch num _ rois NUM _ CLASSES dy dx 
log dh log dw # mrcnn _ mask batch num 
_ detections MASK _ POOL _ SIZE MASK _ POOL 
_ SIZE NUM _ CLASSES # rpn _ rois batch 
num _ rois y1 x1 y2 x2 class _ id 
score # rpn _ class batch num _ anchors 2 
# rpn _ bbox batch num _ anchors 4 由于 
我们 的 GPU _ COUNT 为 1 不是 多 卡 
训练 所以 不 需要 GPU 支持 多 GPU 模型 后面 
应该会 单开 一节 讲 直接 将 model 返回 即可 附 
MaskRCNN class 网络 构建 方法 总览 再次 将 build 函数 
全貌 贴出 分支 选项 按照 mode = inference 选 即为 
本 系列 推断 网络 的 内容 # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # MaskRCNN Class # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # class 
MaskRCNN Encapsulates the Mask RCNN model functionality . The actual 
Keras model is in the keras _ model property . 
def _ _ init _ _ self mode config model 
_ dir mode Either training or inference config A Sub 
class of the Config class model _ dir Directory to 
save training logs and trained weights assert mode in training 
inference self . mode = mode self . config = 
config self . model _ dir = model _ dir 
self . set _ log _ dir self . keras 
_ model = self . build mode = mode config 
= config def build self mode config Build Mask R 
CNN architecture . input _ shape The shape of the 
input image . mode Either training or inference . The 
inputs and outputs of the model differ accordingly . assert 
mode in training inference # Image size must be dividable 
by 2 multiple times h w = config . IMAGE 
_ SHAPE 2 # 1024 1024 3 if h / 
2 * * 6 = int h / 2 * 
* 6 or w / 2 * * 6 = 
int w / 2 * * 6 # 这里 就 
限定 了 下 采样 不会 产生 坐标 误差 raise Exception 
Image size must be dividable by 2 at least 6 
times to avoid fractions when downscaling and upscaling . For 
example use 256 320 384 448 512 . . . 
etc . # Inputs input _ image = KL . 
Input shape = None None config . IMAGE _ SHAPE 
2 name = input _ image input _ image _ 
meta = KL . Input shape = config . IMAGE 
_ META _ SIZE name = input _ image _ 
meta if mode = = training # RPN GT input 
_ rpn _ match = KL . Input shape = 
None 1 name = input _ rpn _ match dtype 
= tf . int32 input _ rpn _ bbox = 
KL . Input shape = None 4 name = input 
_ rpn _ bbox dtype = tf . float32 # 
Detection GT class IDs bounding boxes and masks # 1 
. GT Class IDs zero padded input _ gt _ 
class _ ids = KL . Input shape = None 
name = input _ gt _ class _ ids dtype 
= tf . int32 # 2 . GT Boxes in 
pixels zero padded # batch MAX _ GT _ INSTANCES 
y1 x1 y2 x2 in image coordinates input _ gt 
_ boxes = KL . Input shape = None 4 
name = input _ gt _ boxes dtype = tf 
. float32 # Normalize coordinates gt _ boxes = KL 
. Lambda lambda x norm _ boxes _ graph x 
K . shape input _ image 1 3 input _ 
gt _ boxes # 3 . GT Masks zero padded 
# batch height width MAX _ GT _ INSTANCES if 
config . USE _ MINI _ MASK input _ gt 
_ masks = KL . Input shape = config . 
MINI _ MASK _ SHAPE 0 config . MINI _ 
MASK _ SHAPE 1 None name = input _ gt 
_ masks dtype = bool else input _ gt _ 
masks = KL . Input shape = config . IMAGE 
_ SHAPE 0 config . IMAGE _ SHAPE 1 None 
name = input _ gt _ masks dtype = bool 
elif mode = = inference # Anchors in normalized coordinates 
input _ anchors = KL . Input shape = None 
4 name = input _ anchors # Build the shared 
convolutional layers . # Bottom up Layers # Returns a 
list of the last layers of each stage 5 in 
total . # Don t create the thead stage 5 
so we pick the 4th item in the list . 
if callable config . BACKBONE _ C2 C3 C4 C5 
= config . BACKBONE input _ image stage5 = True 
train _ bn = config . TRAIN _ BN else 
_ C2 C3 C4 C5 = resnet _ graph input 
_ image config . BACKBONE stage5 = True train _ 
bn = config . TRAIN _ BN # Top down 
Layers # TODO add assert to varify feature map sizes 
match what s in config P5 = KL . Conv2D 
config . TOP _ DOWN _ PYRAMID _ SIZE 1 
1 name = fpn _ c5p5 C5 # 256 P4 
= KL . Add name = fpn _ p4add KL 
. UpSampling2D size = 2 2 name = fpn _ 
p5upsampled P5 KL . Conv2D config . TOP _ DOWN 
_ PYRAMID _ SIZE 1 1 name = fpn _ 
c4p4 C4 P3 = KL . Add name = fpn 
_ p3add KL . UpSampling2D size = 2 2 name 
= fpn _ p4upsampled P4 KL . Conv2D config . 
TOP _ DOWN _ PYRAMID _ SIZE 1 1 name 
= fpn _ c3p3 C3 P2 = KL . Add 
name = fpn _ p2add KL . UpSampling2D size = 
2 2 name = fpn _ p3upsampled P3 KL . 
Conv2D config . TOP _ DOWN _ PYRAMID _ SIZE 
1 1 name = fpn _ c2p2 C2 # Attach 
3x3 conv to all P layers to get the final 
feature maps . P2 = KL . Conv2D config . 
TOP _ DOWN _ PYRAMID _ SIZE 3 3 padding 
= SAME name = fpn _ p2 P2 P3 = 
KL . Conv2D config . TOP _ DOWN _ PYRAMID 
_ SIZE 3 3 padding = SAME name = fpn 
_ p3 P3 P4 = KL . Conv2D config . 
TOP _ DOWN _ PYRAMID _ SIZE 3 3 padding 
= SAME name = fpn _ p4 P4 P5 = 
KL . Conv2D config . TOP _ DOWN _ PYRAMID 
_ SIZE 3 3 padding = SAME name = fpn 
_ p5 P5 # P6 is used for the 5th 
anchor scale in RPN . Generated by # subsampling from 
P5 with stride of 2 . P6 = KL . 
MaxPooling2D pool _ size = 1 1 strides = 2 
name = fpn _ p6 P5 # Note that P6 
is used in RPN but not in the classifier heads 
. rpn _ feature _ maps = P2 P3 P4 
P5 P6 mrcnn _ feature _ maps = P2 P3 
P4 P5 # Anchors if mode = = training anchors 
= self . get _ anchors config . IMAGE _ 
SHAPE # Duplicate across the batch dimension because Keras requires 
it # TODO can this be optimized to avoid duplicating 
the anchors anchors = np . broadcast _ to anchors 
config . BATCH _ SIZE + anchors . shape # 
A hack to get around Keras s bad support for 
constants anchors = KL . Lambda lambda x tf . 
Variable anchors name = anchors input _ image else anchors 
= input _ anchors # RPN Model 返回 的 是 
keras 的 Module 对象 注意 keras 中的 Module 对象 是 
可 call 的 rpn = build _ rpn _ model 
config . RPN _ ANCHOR _ STRIDE # 1 3 
256 len config . RPN _ ANCHOR _ RATIOS config 
. TOP _ DOWN _ PYRAMID _ SIZE # Loop 
through pyramid layers layer _ outputs = # list of 
lists for p in rpn _ feature _ maps layer 
_ outputs . append rpn p # 保存 各 pyramid 
特征 经过 RPN 之后 的 结果 # Concatenate layer outputs 
# Convert from list of lists of level outputs to 
list of lists # of outputs across levels . # 
e . g . a1 b1 c1 a2 b2 c2 
= a1 a2 b1 b2 c1 c2 output _ names 
= rpn _ class _ logits rpn _ class rpn 
_ bbox outputs = list zip * layer _ outputs 
# logits2 6 class2 6 bbox2 6 outputs = KL 
. Concatenate axis = 1 name = n list o 
for o n in zip outputs output _ names # 
batch num _ anchors 2/4 # 其中 num _ anchors 
指 的 是 全部 特征 层 上 的 anchors 总数 
rpn _ class _ logits rpn _ class rpn _ 
bbox = outputs # Generate proposals # Proposals are batch 
N y1 x1 y2 x2 in normalized coordinates # and 
zero padded . # POST _ NMS _ ROIS _ 
INFERENCE = 1000 # POST _ NMS _ ROIS _ 
TRAINING = 2000 proposal _ count = config . POST 
_ NMS _ ROIS _ TRAINING if mode = = 
training \ else config . POST _ NMS _ ROIS 
_ INFERENCE # IMAGES _ PER _ GPU num _ 
rois y1 x1 y2 x2 # IMAGES _ PER _ 
GPU 取代 了 batch 之后 说 的 batch 都是 IMAGES 
_ PER _ GPU rpn _ rois = ProposalLayer proposal 
_ count = proposal _ count nms _ threshold = 
config . RPN _ NMS _ THRESHOLD # 0.7 name 
= ROI config = config rpn _ class rpn _ 
bbox anchors if mode = = training # Class ID 
mask to mark class IDs supported by the dataset the 
image # came from . active _ class _ ids 
= KL . Lambda lambda x parse _ image _ 
meta _ graph x active _ class _ ids input 
_ image _ meta if not config . USE _ 
RPN _ ROIS # Ignore predicted ROIs and use ROIs 
provided as an input . input _ rois = KL 
. Input shape = config . POST _ NMS _ 
ROIS _ TRAINING 4 name = input _ roi dtype 
= np . int32 # Normalize coordinates target _ rois 
= KL . Lambda lambda x norm _ boxes _ 
graph x K . shape input _ image 1 3 
input _ rois else target _ rois = rpn _ 
rois # Generate detection targets # Subsamples proposals and generates 
target outputs for training # Note that proposal class IDs 
gt _ boxes and gt _ masks are zero # 
padded . Equally returned rois and targets are zero padded 
. rois target _ class _ ids target _ bbox 
target _ mask = \ D e t e c 
t i o n T a r g e t 
L a y e r config name = proposal _ 
targets target _ rois input _ gt _ class _ 
ids gt _ boxes input _ gt _ masks # 
Network Heads # TODO verify that this handles zero padded 
ROIs mrcnn _ class _ logits mrcnn _ class mrcnn 
_ bbox = \ fpn _ classifier _ graph rois 
mrcnn _ feature _ maps input _ image _ meta 
config . POOL _ SIZE config . NUM _ CLASSES 
train _ bn = config . TRAIN _ BN fc 
_ layers _ size = config . FPN _ CLASSIF 
_ FC _ LAYERS _ SIZE mrcnn _ mask = 
build _ fpn _ mask _ graph rois mrcnn _ 
feature _ maps input _ image _ meta config . 
MASK _ POOL _ SIZE config . NUM _ CLASSES 
train _ bn = config . TRAIN _ BN # 
TODO clean up use tf . identify if necessary output 
_ rois = KL . Lambda lambda x x * 
1 name = output _ rois rois # Losses rpn 
_ class _ loss = KL . Lambda lambda x 
rpn _ class _ loss _ graph * x name 
= rpn _ class _ loss input _ rpn _ 
match rpn _ class _ logits rpn _ bbox _ 
loss = KL . Lambda lambda x rpn _ bbox 
_ loss _ graph config * x name = rpn 
_ bbox _ loss input _ rpn _ bbox input 
_ rpn _ match rpn _ bbox class _ loss 
= KL . Lambda lambda x mrcnn _ class _ 
loss _ graph * x name = mrcnn _ class 
_ loss target _ class _ ids mrcnn _ class 
_ logits active _ class _ ids bbox _ loss 
= KL . Lambda lambda x mrcnn _ bbox _ 
loss _ graph * x name = mrcnn _ bbox 
_ loss target _ bbox target _ class _ ids 
mrcnn _ bbox mask _ loss = KL . Lambda 
lambda x mrcnn _ mask _ loss _ graph * 
x name = mrcnn _ mask _ loss target _ 
mask target _ class _ ids mrcnn _ mask # 
Model inputs = input _ image input _ image _ 
meta input _ rpn _ match input _ rpn _ 
bbox input _ gt _ class _ ids input _ 
gt _ boxes input _ gt _ masks if not 
config . USE _ RPN _ ROIS inputs . append 
input _ rois outputs = rpn _ class _ logits 
rpn _ class rpn _ bbox mrcnn _ class _ 
logits mrcnn _ class mrcnn _ bbox mrcnn _ mask 
rpn _ rois output _ rois rpn _ class _ 
loss rpn _ bbox _ loss class _ loss bbox 
_ loss mask _ loss model = KM . Model 
inputs outputs name = mask _ rcnn else # Network 
Heads # Proposal classifier and BBox regressor heads # output 
shapes # mrcnn _ class _ logits batch num _ 
rois NUM _ CLASSES classifier logits before softmax # mrcnn 
_ class batch num _ rois NUM _ CLASSES classifier 
probabilities # mrcnn _ bbox deltas batch num _ rois 
NUM _ CLASSES dy dx log dh log dw mrcnn 
_ class _ logits mrcnn _ class mrcnn _ bbox 
= \ fpn _ classifier _ graph rpn _ rois 
mrcnn _ feature _ maps input _ image _ meta 
config . POOL _ SIZE # 7 config . NUM 
_ CLASSES train _ bn = config . TRAIN _ 
BN fc _ layers _ size = config . FPN 
_ CLASSIF _ FC _ LAYERS _ SIZE # Detections 
# output is batch num _ detections y1 x1 y2 
x2 class _ id score in # normalized coordinates detections 
= DetectionLayer config name = mrcnn _ detection rpn _ 
rois mrcnn _ class mrcnn _ bbox input _ image 
_ meta # Create masks for detections detection _ boxes 
= KL . Lambda lambda x x . . . 
4 detections mrcnn _ mask = build _ fpn _ 
mask _ graph detection _ boxes mrcnn _ feature _ 
maps input _ image _ meta config . MASK _ 
POOL _ SIZE # 14 config . NUM _ CLASSES 
train _ bn = config . TRAIN _ BN # 
num _ anchors 每张 图片 上 生成 的 锚 框 
数量 # num _ rois 每张 图片 上 由 锚 
框 筛选出 的 推荐 区 数量 # # 由 POST 
_ NMS _ ROIS _ TRAINING 或 POST _ NMS 
_ ROIS _ INFERENCE 规定 # num _ detections 每张 
图片 上 最终 检测 输出 框 # # 由 DETECTION 
_ MAX _ INSTANCES 规定 # detections batch num _ 
detections y1 x1 y2 x2 class _ id score # 
mrcnn _ class batch num _ rois NUM _ CLASSES 
classifier probabilities # mrcnn _ bbox batch num _ rois 
NUM _ CLASSES dy dx log dh log dw # 
mrcnn _ mask batch num _ detections MASK _ POOL 
_ SIZE MASK _ POOL _ SIZE NUM _ CLASSES 
# rpn _ rois batch num _ rois y1 x1 
y2 x2 class _ id score # rpn _ class 
batch num _ anchors 2 # rpn _ bbox batch 
num _ anchors 4 model = KM . Model input 
_ image input _ image _ meta input _ anchors 
detections mrcnn _ class mrcnn _ bbox mrcnn _ mask 
rpn _ rois rpn _ class rpn _ bbox name 
= mask _ rcnn # Add multi GPU support . 
if config . GPU _ COUNT 1 from mrcnn . 
parallel _ model import ParallelModel model = ParallelModel model config 
. GPU _ COUNT return model 