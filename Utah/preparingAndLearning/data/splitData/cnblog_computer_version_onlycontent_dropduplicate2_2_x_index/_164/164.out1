一 RPN 锚 框 信息 生成 上文 的 最后 我们 
生成 了 用于 计算 锚 框 信息 的 特征 源代码 
在 inference 模式 中 不 进行 锚 框 生成 而是 
外部 生成 好 feed 进 网络 training 模式 下 在 
向前 传播 时 直接 生成 锚 框 不过 实际上 没什么 
区别 锚 框 生成 的 讲解 见 计算机 视觉 Mask 
RCNN _ 锚 框 生成 rpn _ feature _ maps 
= P2 P3 P4 P5 P6 接下来 我们 基于 上述 
特征 首先 生成 锚 框 的 信息 包含 每个 锚 
框 的 前景 / 背景 得分 信息 及 每个 锚 
框 的 坐标 修正 信息 接 前文 主 函数 我们 
初始化 rpn model class 的 对象 并 应用于 各层 特征 
# Anchors if mode = = training else anchors = 
input _ anchors # RPN Model 返回 的 是 keras 
的 Module 对象 注意 keras 中的 Module 对象 是 可 
call 的 rpn = build _ rpn _ model config 
. RPN _ ANCHOR _ STRIDE # 1 3 256 
len config . RPN _ ANCHOR _ RATIOS config . 
TOP _ DOWN _ PYRAMID _ SIZE # Loop through 
pyramid layers layer _ outputs = # list of lists 
for p in rpn _ feature _ maps layer _ 
outputs . append rpn p # 保存 各 pyramid 特征 
经过 RPN 之后 的 结果 具体 的 RPN 模块 调用函数 
栈 如下 # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # Region Proposal Network RPN # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # def rpn _ 
graph feature _ map anchors _ per _ location anchor 
_ stride Builds the computation graph of Region Proposal Network 
. feature _ map backbone features batch height width depth 
anchors _ per _ location number of anchors per pixel 
in the feature map anchor _ stride Controls the density 
of anchors . Typically 1 anchors for every pixel in 
the feature map or 2 every other pixel . Returns 
rpn _ class _ logits batch H * W * 
anchors _ per _ location 2 Anchor classifier logits before 
softmax rpn _ probs batch H * W * anchors 
_ per _ location 2 Anchor classifier probabilities . rpn 
_ bbox batch H * W * anchors _ per 
_ location dy dx log dh log dw Deltas to 
be applied to anchors . # TODO check if stride 
of 2 causes alignment 校准 对齐 issues if the feature 
map # is not even . # Shared convolutional base 
of the RPN shared = KL . Conv2D 512 3 
3 padding = same activation = relu strides = anchor 
_ stride name = rpn _ conv _ shared feature 
_ map # Anchor Score . batch height width anchors 
per location * 2 . x = KL . Conv2D 
2 * anchors _ per _ location 1 1 padding 
= valid activation = linear name = rpn _ class 
_ raw shared # Reshape to batch anchors 2 rpn 
_ class _ logits = KL . Lambda lambda t 
tf . reshape t tf . shape t 0 1 
2 x # Output tensors to a Model must be 
Keras tensors 所以 下面 不行 # rpn _ class _ 
logits = tf . reshape x tf . shape x 
0 1 2 # Softmax on last dimension of BG 
/ FG . rpn _ probs = KL . Activation 
softmax name = rpn _ class _ xxx rpn _ 
class _ logits # Bounding box refinement . batch H 
W anchors per location * depth # where depth is 
x y log w log h x = KL . 
Conv2D anchors _ per _ location * 4 1 1 
padding = valid activation = linear name = rpn _ 
bbox _ pred shared # Reshape to batch anchors 4 
rpn _ bbox = KL . Lambda lambda t tf 
. reshape t tf . shape t 0 1 4 
x return rpn _ class _ logits rpn _ probs 
rpn _ bbox def build _ rpn _ model anchor 
_ stride anchors _ per _ location depth Builds a 
Keras model of the Region Proposal Network . It wraps 
the RPN graph so it can be used multiple times 
with shared weights . anchors _ per _ location number 
of anchors per pixel in the feature map anchor _ 
stride Controls the density of anchors . Typically 1 anchors 
for every pixel in the feature map or 2 every 
other pixel . depth Depth of the backbone feature map 
. Returns a Keras Model object . The model outputs 
when called are rpn _ class _ logits batch H 
* W * anchors _ per _ location 2 Anchor 
classifier logits before softmax rpn _ probs batch H * 
W * anchors _ per _ location 2 Anchor classifier 
probabilities . rpn _ bbox batch H * W * 
anchors _ per _ location dy dx log dh log 
dw Deltas to be applied to anchors . input _ 
feature _ map = KL . Input shape = None 
None depth name = input _ rpn _ feature _ 
map # rpn _ class _ logits rpn _ probs 
rpn _ bbox input _ feature _ map 3 1 
outputs = rpn _ graph input _ feature _ map 
anchors _ per _ location anchor _ stride return KM 
. Model input _ feature _ map outputs name = 
rpn _ model 接 前文 主 函数 我们 将 获取 
的 list 形式 的 各层 锚 框 信息 进行 拼接 
重组 # Loop through pyramid layers layer _ outputs = 
# list of lists for p in rpn _ feature 
_ maps layer _ outputs . append rpn p # 
保存 各 pyramid 特征 经过 RPN 之后 的 结果 # 
Concatenate layer outputs # Convert from list of lists of 
level outputs to list of lists # of outputs across 
levels . # e . g . a1 b1 c1 
a2 b2 c2 = a1 a2 b1 b2 c1 c2 
output _ names = rpn _ class _ logits rpn 
_ class rpn _ bbox outputs = list zip * 
layer _ outputs # logits2 6 class2 6 bbox2 6 
outputs = KL . Concatenate axis = 1 name = 
n list o for o n in zip outputs output 
_ names # batch num _ anchors 2/4 # 其中 
num _ anchors 指 的 是 全部 特征 层 上 
的 anchors 总数 rpn _ class _ logits rpn _ 
class rpn _ bbox = outputs 目的 很 简单 原来 
的 返回值 为 logits2 class2 bbox2 logits3 class3 bbox3 首先 
将之 转换 为 logits2 6 class2 6 bbox2 6 然后 
将 每个 小 list 中的 tensor 按照 第一 维度 即 
anchors 维度 拼接 得到 三个 tensor 每个 tensor 表明 batch 
中 图片 对应 5个 特征 层 的 全部 anchors 的 
分类 回归 信息 即 batch anchors 2 分类 结果 or 
dy dx log dh log dw 二 Proposal 建议 区 
生成 上 一步 我们 获取 了 全部 锚 框 的 
信息 这里 我们 的 目的 是 从中 挑选 指定 个数 
的 更 可能 包含 obj 的 锚 框 作为 建议 
区域 即 我们 希望 获取 在上 一步 的 二分 类 
中 前景 得分 更高 的 框 同时 由于 锚 框 
生成 算法 的 设计 其 数量 巨大 且 重叠 严重 
我们 在 得分 高低 的 基础 上 进一步 的 希望 
能够 去 重 非 极大值 抑制 这 就是 proposal 生成 
的 目的 接 前文 主 函数 我们 用 下面 的 
代码 进入 候 选区 生成 过程 # Generate proposals # 
Proposals are batch N y1 x1 y2 x2 in normalized 
coordinates # and zero padded . # POST _ NMS 
_ ROIS _ INFERENCE = 1000 # POST _ NMS 
_ ROIS _ TRAINING = 2000 proposal _ count = 
config . POST _ NMS _ ROIS _ TRAINING if 
mode = = training \ else config . POST _ 
NMS _ ROIS _ INFERENCE # IMAGES _ PER _ 
GPU num _ rois y1 x1 y2 x2 # IMAGES 
_ PER _ GPU 取代 了 batch 之后 说 的 
batch 都是 IMAGES _ PER _ GPU rpn _ rois 
= ProposalLayer proposal _ count = proposal _ count nms 
_ threshold = config . RPN _ NMS _ THRESHOLD 
# 0.7 name = ROI config = config rpn _ 
class rpn _ bbox anchors proposal _ count 是 一个 
整数 用于 指定 生成 proposal 数目 不足 时会/nr 生成 坐标 
为 0 0 0 0 的 空值 进行 补全 1 
初始化 ProposalLayer class 下面 我们 来 看看 ProposalLayer 的 过程 
在 初始 部分 我们 获取 rpn _ class rpn _ 
bbox anchors 三个 张量 作为 参数 class ProposalLayer KE . 
Layer Receives anchor scores and selects a subset to pass 
as proposals to the second stage . Filtering is done 
based on anchor scores and non max suppression to remove 
overlaps . It also applies bounding box refinement deltas to 
anchors . Inputs rpn _ probs batch num _ anchors 
bg prob fg prob rpn _ bbox batch num _ 
anchors dy dx log dh log dw anchors batch num 
_ anchors y1 x1 y2 x2 anchors in normalized coordinates 
Returns Proposals in normalized coordinates batch rois y1 x1 y2 
x2 def _ _ init _ _ self proposal _ 
count nms _ threshold config = None * * kwargs 
super ProposalLayer self . _ _ init _ _ * 
* kwargs self . config = config self . proposal 
_ count = proposal _ count self . nms _ 
threshold = nms _ threshold def call self inputs # 
rpn _ class rpn _ bbox anchors # Box Scores 
. Use the foreground class confidence . batch num _ 
rois 2 batch num _ rois scores = inputs 0 
1 # Box deltas . 记录 坐标 修正 信息 dy 
dx log dh log dw . batch num _ rois 
4 deltas = inputs 1 deltas = deltas * np 
. reshape self . config . RPN _ BBOX _ 
STD _ DEV 1 1 4 # 0.1 0.1 0.2 
0.2 # Anchors . 记录 坐标 信息 y1 x1 y2 
x2 . batch num _ rois 4 anchors = inputs 
2 这里 的 变量 scores = inputs 0 1 即 
我们 只 需要 全部 候选框 的 前景 得分 2 top 
k 锚 框 筛选 然后 我们 获取 前景 得分 最大 
的 n 个 候选框 # Improve performance by trimming to 
top anchors by score # and doing the rest on 
the smaller subset . pre _ nms _ limit = 
tf . minimum self . config . PRE _ NMS 
_ LIMIT tf . shape anchors 1 # 输入 矩阵 
时 输出 每 一行 的 top k . batch top 
_ k ix = tf . nn . top _ 
k scores pre _ nms _ limit sorted = True 
name = top _ anchors . indices 提取 top k 
锚 框 我们 同时 对 三个 输入 进行 了 提取 
# batch _ slice 函数 # # 将 batch 特征 
拆 分为 单张 # # 然后 提取 指定 的 张数 
# # 使用 单张 特征 处理函数 处理 并 合并 此时 
返回 的 第一 维 不是 输 入时 的 batch 而是 
上步 指定 的 张数 scores = utils . batch _ 
slice scores ix lambda x y tf . gather x 
y self . config . IMAGES _ PER _ GPU 
deltas = utils . batch _ slice deltas ix lambda 
x y tf . gather x y self . config 
. IMAGES _ PER _ GPU pre _ nms _ 
anchors = utils . batch _ slice anchors ix lambda 
a x tf . gather a x self . config 
. IMAGES _ PER _ GPU names = pre _ 
nms _ anchors 附录 . 辅助 函数 batch _ slice 
其中 使用 了 一个 后面 也 会 大量 使用 的 
函数 batch _ slice 我 尝试 使用 tf 的 while 
_ loop 进行 了 改写 这个 函数 将 只 支持 
batch 为 1 的 函数 进行 了 扩展 实际 就是 
不能 有 batch 维度 的 函数 tf . gather 函数 
只能 进行 一维 数组 的 切片 而 scares 为 2 
维 batch num _ rois 相对 的 ix 也是 二维 
batch top _ k 所以 我们 需要 将 两者 切片 
应用 函数 后将/nr 结果 拼接 注 本 函数 位于 util 
. py 而非 model . py # # # Batch 
Slicing # Some custom layers support a batch size of 
1 only and require a lot of work # to 
support batches greater than 1 . This function slices an 
input tensor # across the batch dimension and feeds batches 
of size 1 . Effectively # an easy way to 
support batches 1 quickly with little code modification . # 
In the long run it s more efficient to modify 
the code to support large # batches and getting rid 
of this function . Consider this a temporary solution def 
batch _ slice inputs graph _ fn batch _ size 
names = None Splits inputs into slices and feeds each 
slice to a copy of the given computation graph and 
then combines the results . It allows you to run 
a graph on a batch of inputs even if the 
graph is written to support one instance only . inputs 
list of tensors . All must have the same first 
dimension length graph _ fn A function that returns a 
TF tensor that s part of a graph . batch 
_ size number of slices to divide the data into 
. names If provided assigns names to the resulting tensors 
. if not isinstance inputs list inputs = inputs outputs 
= for i in range batch _ size inputs _ 
slice = x i for x in inputs output _ 
slice = graph _ fn * inputs _ slice if 
not isinstance output _ slice tuple list output _ slice 
= output _ slice outputs . append output _ slice 
# 使用 tf . while _ loop 实现 循环体 代码 
如下 # import tensorflow as tf # i = 0 
# outputs = # # def cond index # return 
index batch _ size # 返回 bool 值 # # 
def body index # index + = 1 # inputs 
_ slice = x i for x in inputs # 
output _ slice = graph _ fn * inputs _ 
slice # if not isinstance output _ slice tuple list 
# output _ slice = output _ slice # outputs 
. append output _ slice # return index # 返回 
cond 需要 的 判断 参数 进行 下一次 判断 # # 
tf . while _ loop cond body i # Change 
outputs from a list of slices where each is # 
a list of outputs to a list of outputs and 
each has # a list of slices # 下面 示 
意中 假设 每次 graph _ fn 返回 两个 tensor # 
tensor11 tensor12 tensor21 tensor22 # tensor11 tensor21 tensor12 tensor22 zip 
返回 的 是 多个 tuple outputs = list zip * 
outputs if names is None names = None * len 
outputs # 一般来讲 就是 batch 维度 合 并回去 上面 的 
for 循环 实际 是 将 batch 拆 分了 result = 
tf . stack o axis = 0 name = n 
for o n in zip outputs names if len result 
= = 1 result = result 0 return result3 锚 
框 坐标 初 调 我们 在 RPN 中 获取 了 
全部 锚 框 的 坐标 回归 结果 rpn _ bbox 
batch anchors dy dx log dh log dw 2 小节 
中 我们 将 top k 锚 框 的 坐标 信息 
以及 top k 的 回归 信息 提取 了 出来 现在 
我们 将 之 合并 使用 RPN 回归 的 结果 取 
修正 top k 锚 框 的 坐标 # Apply deltas 
to anchors to get refined anchors . # IMAGES _ 
PER _ GPU top _ k y1 x1 y2 x2 
boxes = utils . batch _ slice pre _ nms 
_ anchors deltas lambda x y apply _ box _ 
deltas _ graph x y self . config . IMAGES 
_ PER _ GPU names = refined _ anchors 函数 
如下 def apply _ box _ deltas _ graph boxes 
deltas Applies the given deltas to the given boxes . 
boxes N y1 x1 y2 x2 boxes to update deltas 
N dy dx log dh log dw refinements to apply 
# dy = y _ n y _ o / 
h _ o # dx = x _ n x 
_ o / w _ o # dh = h 
_ n / h _ o # dw = w 
_ n / w _ o # Convert to y 
x h w height = boxes 2 boxes 0 width 
= boxes 3 boxes 1 center _ y = boxes 
0 + 0.5 * height center _ x = boxes 
1 + 0.5 * width # Apply deltas center _ 
y + = deltas 0 * height center _ x 
+ = deltas 1 * width height * = tf 
. exp deltas 2 width * = tf . exp 
deltas 3 # Convert back to y1 x1 y2 x2 
y1 = center _ y 0.5 * height x1 = 
center _ x 0.5 * width y2 = y1 + 
height x2 = x1 + width result = tf . 
stack y1 x1 y2 x2 axis = 1 name = 
apply _ box _ deltas _ out return result 自此 
我们 在 代码 层面 认识到 了 回归 结果 4个 坐标值 
的 真正 含义 dy = y _ n y _ 
o / h _ odx = x _ n x 
_ o / w _ odh = h _ n 
/ h _ o # dw = w _ n 
/ w _ o 注意 我们 的 锚 框 坐标 
实际上 是 位于 一个 归一 化了 的 图上 SSD 也是 
如此 且 有过 介绍 见 TensorFlow SSD 源码 学习 _ 
其三 锚 框 生成 即 所有 锚 框 位于 一个 
长宽 为 1 的 虚拟 画布 上 上 一步 的 
修正 进行 之后 不再 能够 保证 这 一点 所以 我们 
需要 切除 锚 框 越界 的 的 部分 即 只 
保留 锚 框 和 0 0 1 1 画布 的 
交集 # Clip to image boundaries . Since we re 
in normalized coordinates # clip to 0 . . 1 
range . IMAGES _ PER _ GPU top _ k 
y1 x1 y2 x2 window = np . array 0 
0 1 1 dtype = np . float32 boxes = 
utils . batch _ slice boxes # boxes 来 源自 
anchors 修正 deltas 的 影响 lambda x clip _ boxes 
_ graph x window self . config . IMAGES _ 
PER _ GPU names = refined _ anchors _ clipped 
保留 交集 函数 如下 def clip _ boxes _ graph 
boxes window boxes N y1 x1 y2 x2 window 4 
in the form y1 x1 y2 x2 # Split wy1 
wx1 wy2 wx2 = tf . split window 4 y1 
x1 y2 x2 = tf . split boxes 4 axis 
= 1 # Clip y1 = tf . maximum tf 
. minimum y1 wy2 wy1 x1 = tf . maximum 
tf . minimum x1 wx2 wx1 y2 = tf . 
maximum tf . minimum y2 wy2 wy1 x2 = tf 
. maximum tf . minimum x2 wx2 wx1 clipped = 
tf . concat y1 x1 y2 x2 axis = 1 
name = clipped _ boxes clipped . set _ shape 
clipped . shape 0 4 return clipped4 非 极大值 抑制 
最后 进行 非 极大值 抑制 确保 不会 出现 过于 重复 
的 推荐 区域 # Filter out small boxes # According 
to Xinlei Chen s paper this reduces detection accuracy # 
for small objects so we re skipping it . # 
Non max suppression def nms boxes scores 非 极大值 抑制 
子函数 param boxes top _ k y1 x1 y2 x2 
param scores top _ k return indices = tf . 
image . non _ max _ suppression boxes scores self 
. proposal _ count # 参数 三 为 最大 返回 
数目 self . nms _ threshold name = rpn _ 
non _ max _ suppression proposals = tf . gather 
boxes indices # Pad if needed 一旦 返回 数目 不足 
填充 0 0 0 0 直到 数目 达标 padding = 
tf . maximum self . proposal _ count tf . 
shape proposals 0 0 # 在后面 添加 全 0行 proposals 
= tf . pad proposals 0 padding 0 0 return 
proposals proposals = utils . batch _ slice boxes scores 
nms self . config . IMAGES _ PER _ GPU 
return proposals # IMAGES _ PER _ GPU proposal _ 
count y1 x1 y2 x2 没错 TensorFlow 以 经 封装 
好了 tf . image . non _ max _ suppression 
至此 我们 获取 了 全部 的 推荐 区域 一 RPN 锚 框 信息 生成 上文 的 最后 我们 
生成 了 用于 计算 锚 框 信息 的 特征 源代码 
在 inference 模式 中 不 进行 锚 框 生成 而是 
外部 生成 好 feed 进 网络 training 模式 下 在 
向前 传播 时 直接 生成 锚 框 不过 实际上 没什么 
区别 锚 框 生成 的 讲解 见 计算机 视觉 Mask 
RCNN _ 锚 框 生成 rpn _ feature _ maps 
= P2 P3 P4 P5 P6 接下来 我们 基于 上述 
特征 首先 生成 锚 框 的 信息 包含 每个 锚 
框 的 前景 / 背景 得分 信息 及 每个 锚 
框 的 坐标 修正 信息 接 前文 主 函数 我们 
初始化 rpn model class 的 对象 并 应用于 各层 特征 
# Anchors if mode = = training else anchors = 
input _ anchors # RPN Model 返回 的 是 keras 
的 Module 对象 注意 keras 中的 Module 对象 是 可 
call 的 rpn = build _ rpn _ model config 
. RPN _ ANCHOR _ STRIDE # 1 3 256 
len config . RPN _ ANCHOR _ RATIOS config . 
TOP _ DOWN _ PYRAMID _ SIZE # Loop through 
pyramid layers layer _ outputs = # list of lists 
for p in rpn _ feature _ maps layer _ 
outputs . append rpn p # 保存 各 pyramid 特征 
经过 RPN 之后 的 结果 具体 的 RPN 模块 调用函数 
栈 如下 # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # Region Proposal Network RPN # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # def rpn _ 
graph feature _ map anchors _ per _ location anchor 
_ stride Builds the computation graph of Region Proposal Network 
. feature _ map backbone features batch height width depth 
anchors _ per _ location number of anchors per pixel 
in the feature map anchor _ stride Controls the density 
of anchors . Typically 1 anchors for every pixel in 
the feature map or 2 every other pixel . Returns 
rpn _ class _ logits batch H * W * 
anchors _ per _ location 2 Anchor classifier logits before 
softmax rpn _ probs batch H * W * anchors 
_ per _ location 2 Anchor classifier probabilities . rpn 
_ bbox batch H * W * anchors _ per 
_ location dy dx log dh log dw Deltas to 
be applied to anchors . # TODO check if stride 
of 2 causes alignment 校准 对齐 issues if the feature 
map # is not even . # Shared convolutional base 
of the RPN shared = KL . Conv2D 512 3 
3 padding = same activation = relu strides = anchor 
_ stride name = rpn _ conv _ shared feature 
_ map # Anchor Score . batch height width anchors 
per location * 2 . x = KL . Conv2D 
2 * anchors _ per _ location 1 1 padding 
= valid activation = linear name = rpn _ class 
_ raw shared # Reshape to batch anchors 2 rpn 
_ class _ logits = KL . Lambda lambda t 
tf . reshape t tf . shape t 0 1 
2 x # Output tensors to a Model must be 
Keras tensors 所以 下面 不行 # rpn _ class _ 
logits = tf . reshape x tf . shape x 
0 1 2 # Softmax on last dimension of BG 
/ FG . rpn _ probs = KL . Activation 
softmax name = rpn _ class _ xxx rpn _ 
class _ logits # Bounding box refinement . batch H 
W anchors per location * depth # where depth is 
x y log w log h x = KL . 
Conv2D anchors _ per _ location * 4 1 1 
padding = valid activation = linear name = rpn _ 
bbox _ pred shared # Reshape to batch anchors 4 
rpn _ bbox = KL . Lambda lambda t tf 
. reshape t tf . shape t 0 1 4 
x return rpn _ class _ logits rpn _ probs 
rpn _ bbox def build _ rpn _ model anchor 
_ stride anchors _ per _ location depth Builds a 
Keras model of the Region Proposal Network . It wraps 
the RPN graph so it can be used multiple times 
with shared weights . anchors _ per _ location number 
of anchors per pixel in the feature map anchor _ 
stride Controls the density of anchors . Typically 1 anchors 
for every pixel in the feature map or 2 every 
other pixel . depth Depth of the backbone feature map 
. Returns a Keras Model object . The model outputs 
when called are rpn _ class _ logits batch H 
* W * anchors _ per _ location 2 Anchor 
classifier logits before softmax rpn _ probs batch H * 
W * anchors _ per _ location 2 Anchor classifier 
probabilities . rpn _ bbox batch H * W * 
anchors _ per _ location dy dx log dh log 
dw Deltas to be applied to anchors . input _ 
feature _ map = KL . Input shape = None 
None depth name = input _ rpn _ feature _ 
map # rpn _ class _ logits rpn _ probs 
rpn _ bbox input _ feature _ map 3 1 
outputs = rpn _ graph input _ feature _ map 
anchors _ per _ location anchor _ stride return KM 
. Model input _ feature _ map outputs name = 
rpn _ model 接 前文 主 函数 我们 将 获取 
的 list 形式 的 各层 锚 框 信息 进行 拼接 
重组 # Loop through pyramid layers layer _ outputs = 
# list of lists for p in rpn _ feature 
_ maps layer _ outputs . append rpn p # 
保存 各 pyramid 特征 经过 RPN 之后 的 结果 # 
Concatenate layer outputs # Convert from list of lists of 
level outputs to list of lists # of outputs across 
levels . # e . g . a1 b1 c1 
a2 b2 c2 = a1 a2 b1 b2 c1 c2 
output _ names = rpn _ class _ logits rpn 
_ class rpn _ bbox outputs = list zip * 
layer _ outputs # logits2 6 class2 6 bbox2 6 
outputs = KL . Concatenate axis = 1 name = 
n list o for o n in zip outputs output 
_ names # batch num _ anchors 2/4 # 其中 
num _ anchors 指 的 是 全部 特征 层 上 
的 anchors 总数 rpn _ class _ logits rpn _ 
class rpn _ bbox = outputs 目的 很 简单 原来 
的 返回值 为 logits2 class2 bbox2 logits3 class3 bbox3 首先 
将之 转换 为 logits2 6 class2 6 bbox2 6 然后 
将 每个 小 list 中的 tensor 按照 第一 维度 即 
anchors 维度 拼接 得到 三个 tensor 每个 tensor 表明 batch 
中 图片 对应 5个 特征 层 的 全部 anchors 的 
分类 回归 信息 即 batch anchors 2 分类 结果 or 
dy dx log dh log dw 二 Proposal 建议 区 
生成 上 一步 我们 获取 了 全部 锚 框 的 
信息 这里 我们 的 目的 是 从中 挑选 指定 个数 
的 更 可能 包含 obj 的 锚 框 作为 建议 
区域 即 我们 希望 获取 在上 一步 的 二分 类 
中 前景 得分 更高 的 框 同时 由于 锚 框 
生成 算法 的 设计 其 数量 巨大 且 重叠 严重 
我们 在 得分 高低 的 基础 上 进一步 的 希望 
能够 去 重 非 极大值 抑制 这 就是 proposal 生成 
的 目的 接 前文 主 函数 我们 用 下面 的 
代码 进入 候 选区 生成 过程 # Generate proposals # 
Proposals are batch N y1 x1 y2 x2 in normalized 
coordinates # and zero padded . # POST _ NMS 
_ ROIS _ INFERENCE = 1000 # POST _ NMS 
_ ROIS _ TRAINING = 2000 proposal _ count = 
config . POST _ NMS _ ROIS _ TRAINING if 
mode = = training \ else config . POST _ 
NMS _ ROIS _ INFERENCE # IMAGES _ PER _ 
GPU num _ rois y1 x1 y2 x2 # IMAGES 
_ PER _ GPU 取代 了 batch 之后 说 的 
batch 都是 IMAGES _ PER _ GPU rpn _ rois 
= ProposalLayer proposal _ count = proposal _ count nms 
_ threshold = config . RPN _ NMS _ THRESHOLD 
# 0.7 name = ROI config = config rpn _ 
class rpn _ bbox anchors proposal _ count 是 一个 
整数 用于 指定 生成 proposal 数目 不足 时会/nr 生成 坐标 
为 0 0 0 0 的 空值 进行 补全 1 
初始化 ProposalLayer class 下面 我们 来 看看 ProposalLayer 的 过程 
在 初始 部分 我们 获取 rpn _ class rpn _ 
bbox anchors 三个 张量 作为 参数 class ProposalLayer KE . 
Layer Receives anchor scores and selects a subset to pass 
as proposals to the second stage . Filtering is done 
based on anchor scores and non max suppression to remove 
overlaps . It also applies bounding box refinement deltas to 
anchors . Inputs rpn _ probs batch num _ anchors 
bg prob fg prob rpn _ bbox batch num _ 
anchors dy dx log dh log dw anchors batch num 
_ anchors y1 x1 y2 x2 anchors in normalized coordinates 
Returns Proposals in normalized coordinates batch rois y1 x1 y2 
x2 def _ _ init _ _ self proposal _ 
count nms _ threshold config = None * * kwargs 
super ProposalLayer self . _ _ init _ _ * 
* kwargs self . config = config self . proposal 
_ count = proposal _ count self . nms _ 
threshold = nms _ threshold def call self inputs # 
rpn _ class rpn _ bbox anchors # Box Scores 
. Use the foreground class confidence . batch num _ 
rois 2 batch num _ rois scores = inputs 0 
1 # Box deltas . 记录 坐标 修正 信息 dy 
dx log dh log dw . batch num _ rois 
4 deltas = inputs 1 deltas = deltas * np 
. reshape self . config . RPN _ BBOX _ 
STD _ DEV 1 1 4 # 0.1 0.1 0.2 
0.2 # Anchors . 记录 坐标 信息 y1 x1 y2 
x2 . batch num _ rois 4 anchors = inputs 
2 这里 的 变量 scores = inputs 0 1 即 
我们 只 需要 全部 候选框 的 前景 得分 2 top 
k 锚 框 筛选 然后 我们 获取 前景 得分 最大 
的 n 个 候选框 # Improve performance by trimming to 
top anchors by score # and doing the rest on 
the smaller subset . pre _ nms _ limit = 
tf . minimum self . config . PRE _ NMS 
_ LIMIT tf . shape anchors 1 # 输入 矩阵 
时 输出 每 一行 的 top k . batch top 
_ k ix = tf . nn . top _ 
k scores pre _ nms _ limit sorted = True 
name = top _ anchors . indices 提取 top k 
锚 框 我们 同时 对 三个 输入 进行 了 提取 
# batch _ slice 函数 # # 将 batch 特征 
拆 分为 单张 # # 然后 提取 指定 的 张数 
# # 使用 单张 特征 处理函数 处理 并 合并 此时 
返回 的 第一 维 不是 输 入时 的 batch 而是 
上步 指定 的 张数 scores = utils . batch _ 
slice scores ix lambda x y tf . gather x 
y self . config . IMAGES _ PER _ GPU 
deltas = utils . batch _ slice deltas ix lambda 
x y tf . gather x y self . config 
. IMAGES _ PER _ GPU pre _ nms _ 
anchors = utils . batch _ slice anchors ix lambda 
a x tf . gather a x self . config 
. IMAGES _ PER _ GPU names = pre _ 
nms _ anchors 附录 . 辅助 函数 batch _ slice 
其中 使用 了 一个 后面 也 会 大量 使用 的 
函数 batch _ slice 我 尝试 使用 tf 的 while 
_ loop 进行 了 改写 这个 函数 将 只 支持 
batch 为 1 的 函数 进行 了 扩展 实际 就是 
不能 有 batch 维度 的 函数 tf . gather 函数 
只能 进行 一维 数组 的 切片 而 scares 为 2 
维 batch num _ rois 相对 的 ix 也是 二维 
batch top _ k 所以 我们 需要 将 两者 切片 
应用 函数 后将/nr 结果 拼接 注 本 函数 位于 util 
. py 而非 model . py # # # Batch 
Slicing # Some custom layers support a batch size of 
1 only and require a lot of work # to 
support batches greater than 1 . This function slices an 
input tensor # across the batch dimension and feeds batches 
of size 1 . Effectively # an easy way to 
support batches 1 quickly with little code modification . # 
In the long run it s more efficient to modify 
the code to support large # batches and getting rid 
of this function . Consider this a temporary solution def 
batch _ slice inputs graph _ fn batch _ size 
names = None Splits inputs into slices and feeds each 
slice to a copy of the given computation graph and 
then combines the results . It allows you to run 
a graph on a batch of inputs even if the 
graph is written to support one instance only . inputs 
list of tensors . All must have the same first 
dimension length graph _ fn A function that returns a 
TF tensor that s part of a graph . batch 
_ size number of slices to divide the data into 
. names If provided assigns names to the resulting tensors 
. if not isinstance inputs list inputs = inputs outputs 
= for i in range batch _ size inputs _ 
slice = x i for x in inputs output _ 
slice = graph _ fn * inputs _ slice if 
not isinstance output _ slice tuple list output _ slice 
= output _ slice outputs . append output _ slice 
# 使用 tf . while _ loop 实现 循环体 代码 
如下 # import tensorflow as tf # i = 0 
# outputs = # # def cond index # return 
index batch _ size # 返回 bool 值 # # 
def body index # index + = 1 # inputs 
_ slice = x i for x in inputs # 
output _ slice = graph _ fn * inputs _ 
slice # if not isinstance output _ slice tuple list 
# output _ slice = output _ slice # outputs 
. append output _ slice # return index # 返回 
cond 需要 的 判断 参数 进行 下一次 判断 # # 
tf . while _ loop cond body i # Change 
outputs from a list of slices where each is # 
a list of outputs to a list of outputs and 
each has # a list of slices # 下面 示 
意中 假设 每次 graph _ fn 返回 两个 tensor # 
tensor11 tensor12 tensor21 tensor22 # tensor11 tensor21 tensor12 tensor22 zip 
返回 的 是 多个 tuple outputs = list zip * 
outputs if names is None names = None * len 
outputs # 一般来讲 就是 batch 维度 合 并回去 上面 的 
for 循环 实际 是 将 batch 拆 分了 result = 
tf . stack o axis = 0 name = n 
for o n in zip outputs names if len result 
= = 1 result = result 0 return result3 锚 
框 坐标 初 调 我们 在 RPN 中 获取 了 
全部 锚 框 的 坐标 回归 结果 rpn _ bbox 
batch anchors dy dx log dh log dw 2 小节 
中 我们 将 top k 锚 框 的 坐标 信息 
以及 top k 的 回归 信息 提取 了 出来 现在 
我们 将 之 合并 使用 RPN 回归 的 结果 取 
修正 top k 锚 框 的 坐标 # Apply deltas 
to anchors to get refined anchors . # IMAGES _ 
PER _ GPU top _ k y1 x1 y2 x2 
boxes = utils . batch _ slice pre _ nms 
_ anchors deltas lambda x y apply _ box _ 
deltas _ graph x y self . config . IMAGES 
_ PER _ GPU names = refined _ anchors 函数 
如下 def apply _ box _ deltas _ graph boxes 
deltas Applies the given deltas to the given boxes . 
boxes N y1 x1 y2 x2 boxes to update deltas 
N dy dx log dh log dw refinements to apply 
# dy = y _ n y _ o / 
h _ o # dx = x _ n x 
_ o / w _ o # dh = h 
_ n / h _ o # dw = w 
_ n / w _ o # Convert to y 
x h w height = boxes 2 boxes 0 width 
= boxes 3 boxes 1 center _ y = boxes 
0 + 0.5 * height center _ x = boxes 
1 + 0.5 * width # Apply deltas center _ 
y + = deltas 0 * height center _ x 
+ = deltas 1 * width height * = tf 
. exp deltas 2 width * = tf . exp 
deltas 3 # Convert back to y1 x1 y2 x2 
y1 = center _ y 0.5 * height x1 = 
center _ x 0.5 * width y2 = y1 + 
height x2 = x1 + width result = tf . 
stack y1 x1 y2 x2 axis = 1 name = 
apply _ box _ deltas _ out return result 自此 
我们 在 代码 层面 认识到 了 回归 结果 4个 坐标值 
的 真正 含义 dy = y _ n y _ 
o / h _ odx = x _ n x 
_ o / w _ odh = h _ n 
/ h _ o # dw = w _ n 
/ w _ o 注意 我们 的 锚 框 坐标 
实际上 是 位于 一个 归一 化了 的 图上 SSD 也是 
如此 且 有过 介绍 见 TensorFlow SSD 源码 学习 _ 
其三 锚 框 生成 即 所有 锚 框 位于 一个 
长宽 为 1 的 虚拟 画布 上 上 一步 的 
修正 进行 之后 不再 能够 保证 这 一点 所以 我们 
需要 切除 锚 框 越界 的 的 部分 即 只 
保留 锚 框 和 0 0 1 1 画布 的 
交集 # Clip to image boundaries . Since we re 
in normalized coordinates # clip to 0 . . 1 
range . IMAGES _ PER _ GPU top _ k 
y1 x1 y2 x2 window = np . array 0 
0 1 1 dtype = np . float32 boxes = 
utils . batch _ slice boxes # boxes 来 源自 
anchors 修正 deltas 的 影响 lambda x clip _ boxes 
_ graph x window self . config . IMAGES _ 
PER _ GPU names = refined _ anchors _ clipped 
保留 交集 函数 如下 def clip _ boxes _ graph 
boxes window boxes N y1 x1 y2 x2 window 4 
in the form y1 x1 y2 x2 # Split wy1 
wx1 wy2 wx2 = tf . split window 4 y1 
x1 y2 x2 = tf . split boxes 4 axis 
= 1 # Clip y1 = tf . maximum tf 
. minimum y1 wy2 wy1 x1 = tf . maximum 
tf . minimum x1 wx2 wx1 y2 = tf . 
maximum tf . minimum y2 wy2 wy1 x2 = tf 
. maximum tf . minimum x2 wx2 wx1 clipped = 
tf . concat y1 x1 y2 x2 axis = 1 
name = clipped _ boxes clipped . set _ shape 
clipped . shape 0 4 return clipped4 非 极大值 抑制 
最后 进行 非 极大值 抑制 确保 不会 出现 过于 重复 
的 推荐 区域 # Filter out small boxes # According 
to Xinlei Chen s paper this reduces detection accuracy # 
for small objects so we re skipping it . # 
Non max suppression def nms boxes scores 非 极大值 抑制 
子函数 param boxes top _ k y1 x1 y2 x2 
param scores top _ k return indices = tf . 
image . non _ max _ suppression boxes scores self 
. proposal _ count # 参数 三 为 最大 返回 
数目 self . nms _ threshold name = rpn _ 
non _ max _ suppression proposals = tf . gather 
boxes indices # Pad if needed 一旦 返回 数目 不足 
填充 0 0 0 0 直到 数目 达标 padding = 
tf . maximum self . proposal _ count tf . 
shape proposals 0 0 # 在后面 添加 全 0行 proposals 
= tf . pad proposals 0 padding 0 0 return 
proposals proposals = utils . batch _ slice boxes scores 
nms self . config . IMAGES _ PER _ GPU 
return proposals # IMAGES _ PER _ GPU proposal _ 
count y1 x1 y2 x2 没错 TensorFlow 以 经 封装 
好了 tf . image . non _ max _ suppression 
至此 我们 获取 了 全部 的 推荐 区域 一 RPN 锚 框 信息 生成 上文 的 最后 我们 
生成 了 用于 计算 锚 框 信息 的 特征 源代码 
在 inference 模式 中 不 进行 锚 框 生成 而是 
外部 生成 好 feed 进 网络 training 模式 下 在 
向前 传播 时 直接 生成 锚 框 不过 实际上 没什么 
区别 锚 框 生成 的 讲解 见 计算机 视觉 Mask 
RCNN _ 锚 框 生成 rpn _ feature _ maps 
= P2 P3 P4 P5 P6 接下来 我们 基于 上述 
特征 首先 生成 锚 框 的 信息 包含 每个 锚 
框 的 前景 / 背景 得分 信息 及 每个 锚 
框 的 坐标 修正 信息 接 前文 主 函数 我们 
初始化 rpn model class 的 对象 并 应用于 各层 特征 
# Anchors if mode = = training else anchors = 
input _ anchors # RPN Model 返回 的 是 keras 
的 Module 对象 注意 keras 中的 Module 对象 是 可 
call 的 rpn = build _ rpn _ model config 
. RPN _ ANCHOR _ STRIDE # 1 3 256 
len config . RPN _ ANCHOR _ RATIOS config . 
TOP _ DOWN _ PYRAMID _ SIZE # Loop through 
pyramid layers layer _ outputs = # list of lists 
for p in rpn _ feature _ maps layer _ 
outputs . append rpn p # 保存 各 pyramid 特征 
经过 RPN 之后 的 结果 具体 的 RPN 模块 调用函数 
栈 如下 # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # Region Proposal Network RPN # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # # # # 
# # # # # # # def rpn _ 
graph feature _ map anchors _ per _ location anchor 
_ stride Builds the computation graph of Region Proposal Network 
. feature _ map backbone features batch height width depth 
anchors _ per _ location number of anchors per pixel 
in the feature map anchor _ stride Controls the density 
of anchors . Typically 1 anchors for every pixel in 
the feature map or 2 every other pixel . Returns 
rpn _ class _ logits batch H * W * 
anchors _ per _ location 2 Anchor classifier logits before 
softmax rpn _ probs batch H * W * anchors 
_ per _ location 2 Anchor classifier probabilities . rpn 
_ bbox batch H * W * anchors _ per 
_ location dy dx log dh log dw Deltas to 
be applied to anchors . # TODO check if stride 
of 2 causes alignment 校准 对齐 issues if the feature 
map # is not even . # Shared convolutional base 
of the RPN shared = KL . Conv2D 512 3 
3 padding = same activation = relu strides = anchor 
_ stride name = rpn _ conv _ shared feature 
_ map # Anchor Score . batch height width anchors 
per location * 2 . x = KL . Conv2D 
2 * anchors _ per _ location 1 1 padding 
= valid activation = linear name = rpn _ class 
_ raw shared # Reshape to batch anchors 2 rpn 
_ class _ logits = KL . Lambda lambda t 
tf . reshape t tf . shape t 0 1 
2 x # Output tensors to a Model must be 
Keras tensors 所以 下面 不行 # rpn _ class _ 
logits = tf . reshape x tf . shape x 
0 1 2 # Softmax on last dimension of BG 
/ FG . rpn _ probs = KL . Activation 
softmax name = rpn _ class _ xxx rpn _ 
class _ logits # Bounding box refinement . batch H 
W anchors per location * depth # where depth is 
x y log w log h x = KL . 
Conv2D anchors _ per _ location * 4 1 1 
padding = valid activation = linear name = rpn _ 
bbox _ pred shared # Reshape to batch anchors 4 
rpn _ bbox = KL . Lambda lambda t tf 
. reshape t tf . shape t 0 1 4 
x return rpn _ class _ logits rpn _ probs 
rpn _ bbox def build _ rpn _ model anchor 
_ stride anchors _ per _ location depth Builds a 
Keras model of the Region Proposal Network . It wraps 
the RPN graph so it can be used multiple times 
with shared weights . anchors _ per _ location number 
of anchors per pixel in the feature map anchor _ 
stride Controls the density of anchors . Typically 1 anchors 
for every pixel in the feature map or 2 every 
other pixel . depth Depth of the backbone feature map 
. Returns a Keras Model object . The model outputs 
when called are rpn _ class _ logits batch H 
* W * anchors _ per _ location 2 Anchor 
classifier logits before softmax rpn _ probs batch H * 
W * anchors _ per _ location 2 Anchor classifier 
probabilities . rpn _ bbox batch H * W * 
anchors _ per _ location dy dx log dh log 
dw Deltas to be applied to anchors . input _ 
feature _ map = KL . Input shape = None 
None depth name = input _ rpn _ feature _ 
map # rpn _ class _ logits rpn _ probs 
rpn _ bbox input _ feature _ map 3 1 
outputs = rpn _ graph input _ feature _ map 
anchors _ per _ location anchor _ stride return KM 
. Model input _ feature _ map outputs name = 
rpn _ model 接 前文 主 函数 我们 将 获取 
的 list 形式 的 各层 锚 框 信息 进行 拼接 
重组 # Loop through pyramid layers layer _ outputs = 
# list of lists for p in rpn _ feature 
_ maps layer _ outputs . append rpn p # 
保存 各 pyramid 特征 经过 RPN 之后 的 结果 # 
Concatenate layer outputs # Convert from list of lists of 
level outputs to list of lists # of outputs across 
levels . # e . g . a1 b1 c1 
a2 b2 c2 = a1 a2 b1 b2 c1 c2 
output _ names = rpn _ class _ logits rpn 
_ class rpn _ bbox outputs = list zip * 
layer _ outputs # logits2 6 class2 6 bbox2 6 
outputs = KL . Concatenate axis = 1 name = 
n list o for o n in zip outputs output 
_ names # batch num _ anchors 2/4 # 其中 
num _ anchors 指 的 是 全部 特征 层 上 
的 anchors 总数 rpn _ class _ logits rpn _ 
class rpn _ bbox = outputs 目的 很 简单 原来 
的 返回值 为 logits2 class2 bbox2 logits3 class3 bbox3 首先 
将之 转换 为 logits2 6 class2 6 bbox2 6 然后 
将 每个 小 list 中的 tensor 按照 第一 维度 即 
anchors 维度 拼接 得到 三个 tensor 每个 tensor 表明 batch 
中 图片 对应 5个 特征 层 的 全部 anchors 的 
分类 回归 信息 即 batch anchors 2 分类 结果 or 
dy dx log dh log dw 二 Proposal 建议 区 
生成 上 一步 我们 获取 了 全部 锚 框 的 
信息 这里 我们 的 目的 是 从中 挑选 指定 个数 
的 更 可能 包含 obj 的 锚 框 作为 建议 
区域 即 我们 希望 获取 在上 一步 的 二分 类 
中 前景 得分 更高 的 框 同时 由于 锚 框 
生成 算法 的 设计 其 数量 巨大 且 重叠 严重 
我们 在 得分 高低 的 基础 上 进一步 的 希望 
能够 去 重 非 极大值 抑制 这 就是 proposal 生成 
的 目的 接 前文 主 函数 我们 用 下面 的 
代码 进入 候 选区 生成 过程 # Generate proposals # 
Proposals are batch N y1 x1 y2 x2 in normalized 
coordinates # and zero padded . # POST _ NMS 
_ ROIS _ INFERENCE = 1000 # POST _ NMS 
_ ROIS _ TRAINING = 2000 proposal _ count = 
config . POST _ NMS _ ROIS _ TRAINING if 
mode = = training \ else config . POST _ 
NMS _ ROIS _ INFERENCE # IMAGES _ PER _ 
GPU num _ rois y1 x1 y2 x2 # IMAGES 
_ PER _ GPU 取代 了 batch 之后 说 的 
batch 都是 IMAGES _ PER _ GPU rpn _ rois 
= ProposalLayer proposal _ count = proposal _ count nms 
_ threshold = config . RPN _ NMS _ THRESHOLD 
# 0.7 name = ROI config = config rpn _ 
class rpn _ bbox anchors proposal _ count 是 一个 
整数 用于 指定 生成 proposal 数目 不足 时会/nr 生成 坐标 
为 0 0 0 0 的 空值 进行 补全 1 
初始化 ProposalLayer class 下面 我们 来 看看 ProposalLayer 的 过程 
在 初始 部分 我们 获取 rpn _ class rpn _ 
bbox anchors 三个 张量 作为 参数 class ProposalLayer KE . 
Layer Receives anchor scores and selects a subset to pass 
as proposals to the second stage . Filtering is done 
based on anchor scores and non max suppression to remove 
overlaps . It also applies bounding box refinement deltas to 
anchors . Inputs rpn _ probs batch num _ anchors 
bg prob fg prob rpn _ bbox batch num _ 
anchors dy dx log dh log dw anchors batch num 
_ anchors y1 x1 y2 x2 anchors in normalized coordinates 
Returns Proposals in normalized coordinates batch rois y1 x1 y2 
x2 def _ _ init _ _ self proposal _ 
count nms _ threshold config = None * * kwargs 
super ProposalLayer self . _ _ init _ _ * 
* kwargs self . config = config self . proposal 
_ count = proposal _ count self . nms _ 
threshold = nms _ threshold def call self inputs # 
rpn _ class rpn _ bbox anchors # Box Scores 
. Use the foreground class confidence . batch num _ 
rois 2 batch num _ rois scores = inputs 0 
1 # Box deltas . 记录 坐标 修正 信息 dy 
dx log dh log dw . batch num _ rois 
4 deltas = inputs 1 deltas = deltas * np 
. reshape self . config . RPN _ BBOX _ 
STD _ DEV 1 1 4 # 0.1 0.1 0.2 
0.2 # Anchors . 记录 坐标 信息 y1 x1 y2 
x2 . batch num _ rois 4 anchors = inputs 
2 这里 的 变量 scores = inputs 0 1 即 
我们 只 需要 全部 候选框 的 前景 得分 2 top 
k 锚 框 筛选 然后 我们 获取 前景 得分 最大 
的 n 个 候选框 # Improve performance by trimming to 
top anchors by score # and doing the rest on 
the smaller subset . pre _ nms _ limit = 
tf . minimum self . config . PRE _ NMS 
_ LIMIT tf . shape anchors 1 # 输入 矩阵 
时 输出 每 一行 的 top k . batch top 
_ k ix = tf . nn . top _ 
k scores pre _ nms _ limit sorted = True 
name = top _ anchors . indices 提取 top k 
锚 框 我们 同时 对 三个 输入 进行 了 提取 
# batch _ slice 函数 # # 将 batch 特征 
拆 分为 单张 # # 然后 提取 指定 的 张数 
# # 使用 单张 特征 处理函数 处理 并 合并 此时 
返回 的 第一 维 不是 输 入时 的 batch 而是 
上步 指定 的 张数 scores = utils . batch _ 
slice scores ix lambda x y tf . gather x 
y self . config . IMAGES _ PER _ GPU 
deltas = utils . batch _ slice deltas ix lambda 
x y tf . gather x y self . config 
. IMAGES _ PER _ GPU pre _ nms _ 
anchors = utils . batch _ slice anchors ix lambda 
a x tf . gather a x self . config 
. IMAGES _ PER _ GPU names = pre _ 
nms _ anchors 附录 . 辅助 函数 batch _ slice 
其中 使用 了 一个 后面 也 会 大量 使用 的 
函数 batch _ slice 我 尝试 使用 tf 的 while 
_ loop 进行 了 改写 这个 函数 将 只 支持 
batch 为 1 的 函数 进行 了 扩展 实际 就是 
不能 有 batch 维度 的 函数 tf . gather 函数 
只能 进行 一维 数组 的 切片 而 scares 为 2 
维 batch num _ rois 相对 的 ix 也是 二维 
batch top _ k 所以 我们 需要 将 两者 切片 
应用 函数 后将/nr 结果 拼接 注 本 函数 位于 util 
. py 而非 model . py # # # Batch 
Slicing # Some custom layers support a batch size of 
1 only and require a lot of work # to 
support batches greater than 1 . This function slices an 
input tensor # across the batch dimension and feeds batches 
of size 1 . Effectively # an easy way to 
support batches 1 quickly with little code modification . # 
In the long run it s more efficient to modify 
the code to support large # batches and getting rid 
of this function . Consider this a temporary solution def 
batch _ slice inputs graph _ fn batch _ size 
names = None Splits inputs into slices and feeds each 
slice to a copy of the given computation graph and 
then combines the results . It allows you to run 
a graph on a batch of inputs even if the 
graph is written to support one instance only . inputs 
list of tensors . All must have the same first 
dimension length graph _ fn A function that returns a 
TF tensor that s part of a graph . batch 
_ size number of slices to divide the data into 
. names If provided assigns names to the resulting tensors 
. if not isinstance inputs list inputs = inputs outputs 
= for i in range batch _ size inputs _ 
slice = x i for x in inputs output _ 
slice = graph _ fn * inputs _ slice if 
not isinstance output _ slice tuple list output _ slice 
= output _ slice outputs . append output _ slice 
# 使用 tf . while _ loop 实现 循环体 代码 
如下 # import tensorflow as tf # i = 0 
# outputs = # # def cond index # return 
index batch _ size # 返回 bool 值 # # 
def body index # index + = 1 # inputs 
_ slice = x i for x in inputs # 
output _ slice = graph _ fn * inputs _ 
slice # if not isinstance output _ slice tuple list 
# output _ slice = output _ slice # outputs 
. append output _ slice # return index # 返回 
cond 需要 的 判断 参数 进行 下一次 判断 # # 
tf . while _ loop cond body i # Change 
outputs from a list of slices where each is # 
a list of outputs to a list of outputs and 
each has # a list of slices # 下面 示 
意中 假设 每次 graph _ fn 返回 两个 tensor # 
tensor11 tensor12 tensor21 tensor22 # tensor11 tensor21 tensor12 tensor22 zip 
返回 的 是 多个 tuple outputs = list zip * 
outputs if names is None names = None * len 
outputs # 一般来讲 就是 batch 维度 合 并回去 上面 的 
for 循环 实际 是 将 batch 拆 分了 result = 
tf . stack o axis = 0 name = n 
for o n in zip outputs names if len result 
= = 1 result = result 0 return result3 锚 
框 坐标 初 调 我们 在 RPN 中 获取 了 
全部 锚 框 的 坐标 回归 结果 rpn _ bbox 
batch anchors dy dx log dh log dw 2 小节 
中 我们 将 top k 锚 框 的 坐标 信息 
以及 top k 的 回归 信息 提取 了 出来 现在 
我们 将 之 合并 使用 RPN 回归 的 结果 取 
修正 top k 锚 框 的 坐标 # Apply deltas 
to anchors to get refined anchors . # IMAGES _ 
PER _ GPU top _ k y1 x1 y2 x2 
boxes = utils . batch _ slice pre _ nms 
_ anchors deltas lambda x y apply _ box _ 
deltas _ graph x y self . config . IMAGES 
_ PER _ GPU names = refined _ anchors 函数 
如下 def apply _ box _ deltas _ graph boxes 
deltas Applies the given deltas to the given boxes . 
boxes N y1 x1 y2 x2 boxes to update deltas 
N dy dx log dh log dw refinements to apply 
# dy = y _ n y _ o / 
h _ o # dx = x _ n x 
_ o / w _ o # dh = h 
_ n / h _ o # dw = w 
_ n / w _ o # Convert to y 
x h w height = boxes 2 boxes 0 width 
= boxes 3 boxes 1 center _ y = boxes 
0 + 0.5 * height center _ x = boxes 
1 + 0.5 * width # Apply deltas center _ 
y + = deltas 0 * height center _ x 
+ = deltas 1 * width height * = tf 
. exp deltas 2 width * = tf . exp 
deltas 3 # Convert back to y1 x1 y2 x2 
y1 = center _ y 0.5 * height x1 = 
center _ x 0.5 * width y2 = y1 + 
height x2 = x1 + width result = tf . 
stack y1 x1 y2 x2 axis = 1 name = 
apply _ box _ deltas _ out return result 自此 
我们 在 代码 层面 认识到 了 回归 结果 4个 坐标值 
的 真正 含义 dy = y _ n y _ 
o / h _ odx = x _ n x 
_ o / w _ odh = h _ n 
/ h _ o # dw = w _ n 
/ w _ o 注意 我们 的 锚 框 坐标 
实际上 是 位于 一个 归一 化了 的 图上 SSD 也是 
如此 且 有过 介绍 见 TensorFlow SSD 源码 学习 _ 
其三 锚 框 生成 即 所有 锚 框 位于 一个 
长宽 为 1 的 虚拟 画布 上 上 一步 的 
修正 进行 之后 不再 能够 保证 这 一点 所以 我们 
需要 切除 锚 框 越界 的 的 部分 即 只 
保留 锚 框 和 0 0 1 1 画布 的 
交集 # Clip to image boundaries . Since we re 
in normalized coordinates # clip to 0 . . 1 
range . IMAGES _ PER _ GPU top _ k 
y1 x1 y2 x2 window = np . array 0 
0 1 1 dtype = np . float32 boxes = 
utils . batch _ slice boxes # boxes 来 源自 
anchors 修正 deltas 的 影响 lambda x clip _ boxes 
_ graph x window self . config . IMAGES _ 
PER _ GPU names = refined _ anchors _ clipped 
保留 交集 函数 如下 def clip _ boxes _ graph 
boxes window boxes N y1 x1 y2 x2 window 4 
in the form y1 x1 y2 x2 # Split wy1 
wx1 wy2 wx2 = tf . split window 4 y1 
x1 y2 x2 = tf . split boxes 4 axis 
= 1 # Clip y1 = tf . maximum tf 
. minimum y1 wy2 wy1 x1 = tf . maximum 
tf . minimum x1 wx2 wx1 y2 = tf . 
maximum tf . minimum y2 wy2 wy1 x2 = tf 
. maximum tf . minimum x2 wx2 wx1 clipped = 
tf . concat y1 x1 y2 x2 axis = 1 
name = clipped _ boxes clipped . set _ shape 
clipped . shape 0 4 return clipped4 非 极大值 抑制 
最后 进行 非 极大值 抑制 确保 不会 出现 过于 重复 
的 推荐 区域 # Filter out small boxes # According 
to Xinlei Chen s paper this reduces detection accuracy # 
for small objects so we re skipping it . # 
Non max suppression def nms boxes scores 非 极大值 抑制 
子函数 param boxes top _ k y1 x1 y2 x2 
param scores top _ k return indices = tf . 
image . non _ max _ suppression boxes scores self 
. proposal _ count # 参数 三 为 最大 返回 
数目 self . nms _ threshold name = rpn _ 
non _ max _ suppression proposals = tf . gather 
boxes indices # Pad if needed 一旦 返回 数目 不足 
填充 0 0 0 0 直到 数目 达标 padding = 
tf . maximum self . proposal _ count tf . 
shape proposals 0 0 # 在后面 添加 全 0行 proposals 
= tf . pad proposals 0 padding 0 0 return 
proposals proposals = utils . batch _ slice boxes scores 
nms self . config . IMAGES _ PER _ GPU 
return proposals # IMAGES _ PER _ GPU proposal _ 
count y1 x1 y2 x2 没错 TensorFlow 以 经 封装 
好了 tf . image . non _ max _ suppression 
至此 我们 获取 了 全部 的 推荐 区域 