计算机 视觉 中的 边缘 检测 边缘 检测 是 计算机 视觉 
中 最重要 的 概念 之一 这 是 一个 很 直观 
的 概念 在 一个 图像 上 运行 图像 检测 应该 
只 输出 边缘 与 素描 比较 相似 我 的 目标 
不仅 是 清晰 地 解释 边缘 检测 是 怎样 工作 
的 同时 也 提供 一个 新 而又 容易 的 方法 
只 需要 最小 工作 来 明显 地 提高 边缘 检测 
通过 获得 这些 边缘 许多 计算机 算法 才 得以 有可能 
实现 因为 在 一个 场景 中 边缘 包含着 绝大部分 至少 
很多 的 信息 举个 例子 我们 都 记得 Windows XP 
的 那个 绿色 小 山坡 和 蓝色 天空 的 背景 
当 我们 的 大脑 试图 去 理解 这个 场景 时 
我们 知道 这 是 草地 看起来 很 统一 然后 我们 
看到 了 飘着 些许 白云 的 天空 这些 对象 的 
每一个 都是/nr 分离 的 而且 它们 之间 有 一个 边缘 
这 就是 场景 中 为什么 绝大部分 的 信息 存在 与 
边缘 中 这也 是 为什么 边缘 检测 是 计算机 视觉 
中 的 重要 概念 通过 把 图像 减少 到 只剩下 
边缘 使得 对于 许多 算法 更容易 识别 学习 或者 处理 
场景 边缘 检测 滤波 边缘 检测 的 大多数 是 基于 
滤波 的 通常 来说 滤波 是 一个 消除 的 动作 
比如 过滤 水 是 消除 寄生虫 相 似地 当 我们 
尝试 找到 图像 边缘 时 我 是 在 尝试 消除 
掉 除 图像 边缘 之外 的 东西 消除 那些 不是 
有用 的 边缘 的 图像 部分 而 留下 合适 的 
边缘 也是 困难 所在 我 怎么 知道 这 是不是 有用 
的 边缘 比如 我 对 Windows XP 背景 运行 Canny 
edge dectector 程序 效果 如下 你 能 看到 那些 小草 
的 细小 刀刃 似的 边缘 这 很让 人 讨厌 而且 
没有 真正 提供 有用 的 信息 甚至 那些 云朵 也 
不是 非常 清晰 现在 你 能在 大多数 的 Canny edge 
dectector 上 设置 一些 边界 这些 边界 设置 了 阈值 
或者 非 极大值 抑制 所有 的 边缘 必须 满足 这个 
阈值 才能 划分为 重要 的 边缘 与其 在 Canny edge 
的 阈值 上 区分 不如 我们 更 广泛 地 来 
谈谈 并且 搭建 几个 滤波器 边缘 检测 高斯 滤波器 高斯 
滤波器 是 边缘 检测 最 基础 的 滤波器 之一 虽然 
还有 其他 的 但是 高斯 滤波器 会 贯穿 这篇文章 高斯 
滤波器 正如 其名 是 一个 基于 高斯分布 的 滤波器 它 
看起来 像 一个 抛物线 除了 在 二维 的 情况 通过 
矩阵 乘法 高斯 滤波器 能被 应用 到 每一个 像素 上 
它 实现 的 是 混合 效果 让 最 中心 的 
像素 尽 量小 基于 它 相邻 的 像素 举个 例子 
如对 我 的 猫 的 图像 运行 一个 均匀分布 的 
高斯 滤波器 我 能够 得到 下面 的 图像 5 . 
jpg 你 可以 看到 图像 变得 模糊 了 高斯滤波 器 
就是 获取 所有 像素 让 像素 值 的 成分 是 
与 相邻 像素 有关 为了 让 高斯 滤波器 在 边缘 
检测 中 有效 我们 可以 使用 从 x 和 y 
方面 求导 出来 的 高斯 滤波器 这 也许 听 起来 
有点 反 直觉 或者 不知所谓 但是 如果 我们 看到 这种 
导数 高斯 滤波器 的 图像 这种 想法 就 很 清晰 
了 当 你 把 一个 高斯 的 x 和 y 
分量 求导 后 一个 大 的 波峰 和 波谷 就 
出现 了 如果 你 明白 导数 思考 下 这种 情况 
你 应该 能 很快 想到 由于 高斯 函 数峰 上 
数值 上 的 巨大 变化 从而 导致 了 高斯 导数 
波峰 和 波谷 的 出现 如果 我们 把 上面 的 
写成 代码 那 相当 直接 至少 对于 Matlab 和 Python 
来说 % Takes the derivative of a 5x5 gaussian with 
a sigma hx hy = gradient fspecial gaussian 5 5 
sigma 这 就是 了 一行 代码 就能 得到 我们 所 
想要 的 高斯 然后 对 x 和 y 分量 求导 
边缘 检测 应用 滤波器 我们 已经 有了/nr 两个 高斯 滤波器 
我们 把 他们 应用到 图像 中 我们 同样 使用 非 
极大值 限制 即 如果 不是 极大值 的话 就把 像素 值 
设置 为 0 换 种 说法 就是 消除 噪声 应用 
滤波器 的 代码 如下 % Convert an image to double 
for increased precision img = double img % Find two 
derived gaussians with respect to x and y hx hy 
= gradient fspecial gaussian 5 5 sigma % Run the 
filters over the image generating a filtered image % Leaves 
x edges gx = double imfilter img hx replicate conv 
% Leaves y edges gy = double imfilter img hy 
replicate conv % Take the absolute value and combine the 
x and y edges mag = sqrt gx . * 
gx + gy . * gy % Use non maxima 
suppression mag = max mag 3 如果 我们 将 它 
应用 我 的 猫 的 一张 图片 我 我们 就 
得到 一下 的 图片 有 趣地 是 我们 同样 也能 
这种 方法 应用 到 RGB 图像 上去 同样 也 会 
得到 彩色 的 边缘 普通/nz 的/uj 边缘/n 滤波器/nz 应用到/i 猫/n 
的/uj RGB/w 图像/n 这/r 两张/m 图片/n 应该/v 都能/nr 代表/n 像素/n 
和它/nr 相邻/v 之间/f 像素/n 的/uj 颜色/n 的/uj 差异/n 只不过 彩色图像 
有 3层 而 黑白 图像 只有 1层 层 翻译 不是 
很好 边缘 检测 方向 滤波器 为什么 要 限制 我们 自己 
仅 仅 使用 绝对 的 x 和 y 方向 的 
滤波器 呢 让 我们 也 来 构建 一些 方向 滤波器 
这个 方法 或多或少 来源于 Freeman 和 Adelson 的 The design 
and use of steerable filters 论文 这个 想法 使 我们 
能够 把 我们 的 高斯 滤波器 放置 在 不同 的 
方向 根本 上 我们 把 我们 的 高斯 滤波器 放置 
到 不同 的 方向 上去 以 基于 与 高斯 相关 
的 边缘 的 角度 来 创建 不同 数值 比如 如果 
我们 把 高斯 函数 放置 到 45度 应用到 45 度角 
的 图像 上 应该 可以 比 在 0度 的 高斯 
函数 得到 更高 的 数量级 在 这种 情况 下 我 
生成 了 几种 不同 的 方向 滤波器 上行 x 分量 
下行 y 分量 各种各样 的 高斯 函数 产生 了 相对 
于x/nr 和 y 分量 上 的 90 45 45 和 
22.5 度 的 滤波器 这也 就 产生 了 不同 的 
边缘 大小 尽管 这些 滤波器 应该 检测 出 相近 的 
边缘 我 使用 的 代码 与 单个 滤波器 使用 的 
代码 几乎 相同 但是 我 不同 以往 地 把 他们 
混合 在 一起 它 看起来 有点 杂乱 但是 我 通过 
让 我 运行 每个 滤波器 表达 更 明白 来 尽可 
能使 它 看起来 更 清晰 % Create four filters hx 
hy = gradient fspecial gaussian 5 5 sigma hx1 hy1 
= altOrientFilter1 hx hy hx2 hy2 = altOrientFilter2 hx hy 
hx3 hy3 = altOrientFilter3 hx hy % Run first gaussian 
filter on image gx = double imfilter img hx replicate 
conv gy = double imfilter img hy replicate conv % 
Run second gaussian filter on image gx1 = double imfilter 
img hx1 replicate conv gy1 = double imfilter img hy1 
replicate conv % Run third gaussian filter on image gx2 
= double imfilter img hx2 replicate conv gy2 = double 
imfilter img hy2 replicate conv % Run fourth gaussian filter 
on image gx3 = double imfilter img hx3 replicate conv 
gy3 = double imfilter img hy3 replicate conv % Merge 
all filters squareGD = gx . * gx + gy 
. * gy squareGD = squareGD + gx1 . * 
gx1 + gy1 . * gy1 squareGD = squareGD + 
gx2 . * gx2 + gy2 . * gy2 squareGD 
= squareGD + gx3 . * gx3 + gy3 . 
* gy3 % Run non maxima supression mag = max 
sqrt squareGD 3 如果 你 靠近 点 看 的话 你 
能 看到 数量 大小 的 不同 特别 是 那些 皱纹 
如果 我们 混合 了 所有 图像 我们 就 能 得到 
一张 轻微 较好 的 边缘 检测 方向 滤波器 和非/nr 方向 
滤波器 之间 并 没有 很大 的 不同 但是 我们 也 
应该 看到 多种 方向 的 结果 有 些许 的 提高 
边缘 检测 提高 彩 色域 过去 两年 我 在 不同 
的 彩色 域 上 做 了 大量 的 测试 和 
实验 特别地 是 Lab 彩 色域 是 另一种 描述 图像 
的 方式 比如 我们 知道 的 RGB 和 灰度 图像 
或者 你 甚至 可能 知道 YUV 空间 Lab 彩 色域 
与之 非常 相似 我 对 Lab 彩色 感兴趣 的 原因 
是 它 对 产生 场景 的 边缘 有着 优异 的 
能力 Lab 彩色 空间 的 每个 字母 表示 L Luminance 
亮度 a alpha 红到 绿 b beta 黄到蓝/nr 事实上/l 这些 
颜色通道 非常适合 发现 颜色 变化 梯度 正 自然而然 地 黄色 
很少 出现 另 一个 黄色 周围 红色 和 绿色 也是 
如此 尽管 我 已经 彻底 证明了 Lab 彩色 空间 与 
我们 人类 怎样 察觉 颜色 中的 亮度 有 很强 的 
相关性 与 RGB 相反 的 是 在 Lab 彩色 空间 
中 亮度 有它/nr 自己 的 分离 通道 这 使得 它 
能 更好 地 处理 颜色 的 差异 这些 差异 也是 
亮度 与 颜色 相关 之处 为了 最小化 额外 的 代码 
我们 所 要做 的 就是 把 输入 的 图像 转化 
为 Lab 彩色 空间 的 图像 你 可以 做 一些 
最 优化 不过 你 仅仅 做了 这 额外 的 一步 
也能 明显提高 适宜 的 边缘 检测 % Convert an image 
to the Lab color space colorTransform = makecform srgb2lab img 
= applycform rgbImg colorTransform % Make it double to improve 
representation img = double img % Find x and y 
derivative of a 9x9 gaussian hx hy = gradient fspecial 
gaussian 9 9 sigma % Apply filters gx = double 
imfilter img hx replicate gy = double imfilter img hy 
replicate % Find absolute value gSquared = sqrt gx . 
* gx + gy . * gy % Apply non 
maxima suppression find best points for edges mag = max 
gSquared 3 如果 我们 将 Windows XP 小 山坡 的 
背景 图像 转换 为 Lab 我们 将 得到 下面 的 
图像 Windows XP 背景 的 Lab 空间 图像 然后 如果 
我们 施加 滤波器 非 极大值 抑制 将 得到 下面 的 
图像 清晰 的 包含 着 草地 云 草地 和 天空 
的 分界线 的 图象 在 Lab 空间 上边缘 检测 最终 
如果 我们 运行 非 极大值 抑制 那么 我们 将 得到 
比 本文 开头 提到 的 Canny 边缘 检测器 要 好得多 
的 边缘 效果 Lab 彩色 空间 边缘 检测 平均 来说 
这种 方法 会 比 普通 方法 提高 10% 左右 的 
边缘 检测 精度 这是 对 The Berkeley Segmentation Dataset and 
Benchmark 运行 F measure 测试 得到 的 结果 边缘 检测 
结语 有 无数 的 方法 去做 边缘 检测 这里 讲述 
的 方法 绝 不是 最好 最 容易 实现 最 容易 
解释 的 我 使用 这些 方法 解释 它 是因为 我 
对 它们 很 有兴趣 加上 这是 UIUC 的 CS543 课程 
计算机 视觉 布置 的 作业 所以 你 也 在上 这门 
课 请 不要 抄袭 我 的 代码 我 已经 把 
我们 所有 的 实现 都 放到 了 github 上了 包括 
用 C + + 的 OpenCV 实现 然而 如果 你 
想 跟 我 的 猫 照相 这 没什么 问题 建议 
阅读 PCA Principal Component AnalysisEveryday Algorithms Pancake SortUsing Computer Vision 
to Improve EEG i g n a l s I 
n t r o d u c t i o 
n to Markov ProcessesThe Cache and Multithreading 参考文献 1 Canny 
John . A computational approach to edge detection . Pattern 
Analysis and Machine Intelligence IEEE Transactions on 6 1986 679 
698 . 2 Freeman William T . and Edward H 
. Adelson . The design and use of steerable filters 
. IEEE Transactions on Pattern analysis and machine intelligence 13.9 
1991 891 906 . 转 自 计算机 视觉 中的 边缘 
检测 yewei11 的 专栏 CSDN 博客 http / / blog 
. csdn . net / yewei11 / article / details 
/ 50748012 原文 链接 请 点击 原文 链接 Edge Detection 
in Computer Vision http / / austingwalters . com / 
edge detection in computer vision / 计算机 视觉 中的 边缘 检测 边缘 检测 是 计算机 视觉 
中 最重要 的 概念 之一 这 是 一个 很 直观 
的 概念 在 一个 图像 上 运行 图像 检测 应该 
只 输出 边缘 与 素描 比较 相似 我 的 目标 
不仅 是 清晰 地 解释 边缘 检测 是 怎样 工作 
的 同时 也 提供 一个 新 而又 容易 的 方法 
只 需要 最小 工作 来 明显 地 提高 边缘 检测 
通过 获得 这些 边缘 许多 计算机 算法 才 得以 有可能 
实现 因为 在 一个 场景 中 边缘 包含着 绝大部分 至少 
很多 的 信息 举个 例子 我们 都 记得 Windows XP 
的 那个 绿色 小 山坡 和 蓝色 天空 的 背景 
当 我们 的 大脑 试图 去 理解 这个 场景 时 
我们 知道 这 是 草地 看起来 很 统一 然后 我们 
看到 了 飘着 些许 白云 的 天空 这些 对象 的 
每一个 都是/nr 分离 的 而且 它们 之间 有 一个 边缘 
这 就是 场景 中 为什么 绝大部分 的 信息 存在 与 
边缘 中 这也 是 为什么 边缘 检测 是 计算机 视觉 
中 的 重要 概念 通过 把 图像 减少 到 只剩下 
边缘 使得 对于 许多 算法 更容易 识别 学习 或者 处理 
场景 边缘 检测 滤波 边缘 检测 的 大多数 是 基于 
滤波 的 通常 来说 滤波 是 一个 消除 的 动作 
比如 过滤 水 是 消除 寄生虫 相 似地 当 我们 
尝试 找到 图像 边缘 时 我 是 在 尝试 消除 
掉 除 图像 边缘 之外 的 东西 消除 那些 不是 
有用 的 边缘 的 图像 部分 而 留下 合适 的 
边缘 也是 困难 所在 我 怎么 知道 这 是不是 有用 
的 边缘 比如 我 对 Windows XP 背景 运行 Canny 
edge dectector 程序 效果 如下 你 能 看到 那些 小草 
的 细小 刀刃 似的 边缘 这 很让 人 讨厌 而且 
没有 真正 提供 有用 的 信息 甚至 那些 云朵 也 
不是 非常 清晰 现在 你 能在 大多数 的 Canny edge 
dectector 上 设置 一些 边界 这些 边界 设置 了 阈值 
或者 非 极大值 抑制 所有 的 边缘 必须 满足 这个 
阈值 才能 划分为 重要 的 边缘 与其 在 Canny edge 
的 阈值 上 区分 不如 我们 更 广泛 地 来 
谈谈 并且 搭建 几个 滤波器 边缘 检测 高斯 滤波器 高斯 
滤波器 是 边缘 检测 最 基础 的 滤波器 之一 虽然 
还有 其他 的 但是 高斯 滤波器 会 贯穿 这篇文章 高斯 
滤波器 正如 其名 是 一个 基于 高斯分布 的 滤波器 它 
看起来 像 一个 抛物线 除了 在 二维 的 情况 通过 
矩阵 乘法 高斯 滤波器 能被 应用 到 每一个 像素 上 
它 实现 的 是 混合 效果 让 最 中心 的 
像素 尽 量小 基于 它 相邻 的 像素 举个 例子 
如对 我 的 猫 的 图像 运行 一个 均匀分布 的 
高斯 滤波器 我 能够 得到 下面 的 图像 5 . 
jpg 你 可以 看到 图像 变得 模糊 了 高斯滤波 器 
就是 获取 所有 像素 让 像素 值 的 成分 是 
与 相邻 像素 有关 为了 让 高斯 滤波器 在 边缘 
检测 中 有效 我们 可以 使用 从 x 和 y 
方面 求导 出来 的 高斯 滤波器 这 也许 听 起来 
有点 反 直觉 或者 不知所谓 但是 如果 我们 看到 这种 
导数 高斯 滤波器 的 图像 这种 想法 就 很 清晰 
了 当 你 把 一个 高斯 的 x 和 y 
分量 求导 后 一个 大 的 波峰 和 波谷 就 
出现 了 如果 你 明白 导数 思考 下 这种 情况 
你 应该 能 很快 想到 由于 高斯 函 数峰 上 
数值 上 的 巨大 变化 从而 导致 了 高斯 导数 
波峰 和 波谷 的 出现 如果 我们 把 上面 的 
写成 代码 那 相当 直接 至少 对于 Matlab 和 Python 
来说 % Takes the derivative of a 5x5 gaussian with 
a sigma hx hy = gradient fspecial gaussian 5 5 
sigma 这 就是 了 一行 代码 就能 得到 我们 所 
想要 的 高斯 然后 对 x 和 y 分量 求导 
边缘 检测 应用 滤波器 我们 已经 有了/nr 两个 高斯 滤波器 
我们 把 他们 应用到 图像 中 我们 同样 使用 非 
极大值 限制 即 如果 不是 极大值 的话 就把 像素 值 
设置 为 0 换 种 说法 就是 消除 噪声 应用 
滤波器 的 代码 如下 % Convert an image to double 
for increased precision img = double img % Find two 
derived gaussians with respect to x and y hx hy 
= gradient fspecial gaussian 5 5 sigma % Run the 
filters over the image generating a filtered image % Leaves 
x edges gx = double imfilter img hx replicate conv 
% Leaves y edges gy = double imfilter img hy 
replicate conv % Take the absolute value and combine the 
x and y edges mag = sqrt gx . * 
gx + gy . * gy % Use non maxima 
suppression mag = max mag 3 如果 我们 将 它 
应用 我 的 猫 的 一张 图片 我 我们 就 
得到 一下 的 图片 有 趣地 是 我们 同样 也能 
这种 方法 应用 到 RGB 图像 上去 同样 也 会 
得到 彩色 的 边缘 普通/nz 的/uj 边缘/n 滤波器/nz 应用到/i 猫/n 
的/uj RGB/w 图像/n 这/r 两张/m 图片/n 应该/v 都能/nr 代表/n 像素/n 
和它/nr 相邻/v 之间/f 像素/n 的/uj 颜色/n 的/uj 差异/n 只不过 彩色图像 
有 3层 而 黑白 图像 只有 1层 层 翻译 不是 
很好 边缘 检测 方向 滤波器 为什么 要 限制 我们 自己 
仅 仅 使用 绝对 的 x 和 y 方向 的 
滤波器 呢 让 我们 也 来 构建 一些 方向 滤波器 
这个 方法 或多或少 来源于 Freeman 和 Adelson 的 The design 
and use of steerable filters 论文 这个 想法 使 我们 
能够 把 我们 的 高斯 滤波器 放置 在 不同 的 
方向 根本 上 我们 把 我们 的 高斯 滤波器 放置 
到 不同 的 方向 上去 以 基于 与 高斯 相关 
的 边缘 的 角度 来 创建 不同 数值 比如 如果 
我们 把 高斯 函数 放置 到 45度 应用到 45 度角 
的 图像 上 应该 可以 比 在 0度 的 高斯 
函数 得到 更高 的 数量级 在 这种 情况 下 我 
生成 了 几种 不同 的 方向 滤波器 上行 x 分量 
下行 y 分量 各种各样 的 高斯 函数 产生 了 相对 
于x/nr 和 y 分量 上 的 90 45 45 和 
22.5 度 的 滤波器 这也 就 产生 了 不同 的 
边缘 大小 尽管 这些 滤波器 应该 检测 出 相近 的 
边缘 我 使用 的 代码 与 单个 滤波器 使用 的 
代码 几乎 相同 但是 我 不同 以往 地 把 他们 
混合 在 一起 它 看起来 有点 杂乱 但是 我 通过 
让 我 运行 每个 滤波器 表达 更 明白 来 尽可 
能使 它 看起来 更 清晰 % Create four filters hx 
hy = gradient fspecial gaussian 5 5 sigma hx1 hy1 
= altOrientFilter1 hx hy hx2 hy2 = altOrientFilter2 hx hy 
hx3 hy3 = altOrientFilter3 hx hy % Run first gaussian 
filter on image gx = double imfilter img hx replicate 
conv gy = double imfilter img hy replicate conv % 
Run second gaussian filter on image gx1 = double imfilter 
img hx1 replicate conv gy1 = double imfilter img hy1 
replicate conv % Run third gaussian filter on image gx2 
= double imfilter img hx2 replicate conv gy2 = double 
imfilter img hy2 replicate conv % Run fourth gaussian filter 
on image gx3 = double imfilter img hx3 replicate conv 
gy3 = double imfilter img hy3 replicate conv % Merge 
all filters squareGD = gx . * gx + gy 
. * gy squareGD = squareGD + gx1 . * 
gx1 + gy1 . * gy1 squareGD = squareGD + 
gx2 . * gx2 + gy2 . * gy2 squareGD 
= squareGD + gx3 . * gx3 + gy3 . 
* gy3 % Run non maxima supression mag = max 
sqrt squareGD 3 如果 你 靠近 点 看 的话 你 
能 看到 数量 大小 的 不同 特别 是 那些 皱纹 
如果 我们 混合 了 所有 图像 我们 就 能 得到 
一张 轻微 较好 的 边缘 检测 方向 滤波器 和非/nr 方向 
滤波器 之间 并 没有 很大 的 不同 但是 我们 也 
应该 看到 多种 方向 的 结果 有 些许 的 提高 
边缘 检测 提高 彩 色域 过去 两年 我 在 不同 
的 彩色 域 上 做 了 大量 的 测试 和 
实验 特别地 是 Lab 彩 色域 是 另一种 描述 图像 
的 方式 比如 我们 知道 的 RGB 和 灰度 图像 
或者 你 甚至 可能 知道 YUV 空间 Lab 彩 色域 
与之 非常 相似 我 对 Lab 彩色 感兴趣 的 原因 
是 它 对 产生 场景 的 边缘 有着 优异 的 
能力 Lab 彩色 空间 的 每个 字母 表示 L Luminance 
亮度 a alpha 红到 绿 b beta 黄到蓝/nr 事实上/l 这些 
颜色通道 非常适合 发现 颜色 变化 梯度 正 自然而然 地 黄色 
很少 出现 另 一个 黄色 周围 红色 和 绿色 也是 
如此 尽管 我 已经 彻底 证明了 Lab 彩色 空间 与 
我们 人类 怎样 察觉 颜色 中的 亮度 有 很强 的 
相关性 与 RGB 相反 的 是 在 Lab 彩色 空间 
中 亮度 有它/nr 自己 的 分离 通道 这 使得 它 
能 更好 地 处理 颜色 的 差异 这些 差异 也是 
亮度 与 颜色 相关 之处 为了 最小化 额外 的 代码 
我们 所 要做 的 就是 把 输入 的 图像 转化 
为 Lab 彩色 空间 的 图像 你 可以 做 一些 
最 优化 不过 你 仅仅 做了 这 额外 的 一步 
也能 明显提高 适宜 的 边缘 检测 % Convert an image 
to the Lab color space colorTransform = makecform srgb2lab img 
= applycform rgbImg colorTransform % Make it double to improve 
representation img = double img % Find x and y 
derivative of a 9x9 gaussian hx hy = gradient fspecial 
gaussian 9 9 sigma % Apply filters gx = double 
imfilter img hx replicate gy = double imfilter img hy 
replicate % Find absolute value gSquared = sqrt gx . 
* gx + gy . * gy % Apply non 
maxima suppression find best points for edges mag = max 
gSquared 3 如果 我们 将 Windows XP 小 山坡 的 
背景 图像 转换 为 Lab 我们 将 得到 下面 的 
图像 Windows XP 背景 的 Lab 空间 图像 然后 如果 
我们 施加 滤波器 非 极大值 抑制 将 得到 下面 的 
图像 清晰 的 包含 着 草地 云 草地 和 天空 
的 分界线 的 图象 在 Lab 空间 上边缘 检测 最终 
如果 我们 运行 非 极大值 抑制 那么 我们 将 得到 
比 本文 开头 提到 的 Canny 边缘 检测器 要 好得多 
的 边缘 效果 Lab 彩色 空间 边缘 检测 平均 来说 
这种 方法 会 比 普通 方法 提高 10% 左右 的 
边缘 检测 精度 这是 对 The Berkeley Segmentation Dataset and 
Benchmark 运行 F measure 测试 得到 的 结果 边缘 检测 
结语 有 无数 的 方法 去做 边缘 检测 这里 讲述 
的 方法 绝 不是 最好 最 容易 实现 最 容易 
解释 的 我 使用 这些 方法 解释 它 是因为 我 
对 它们 很 有兴趣 加上 这是 UIUC 的 CS543 课程 
计算机 视觉 布置 的 作业 所以 你 也 在上 这门 
课 请 不要 抄袭 我 的 代码 我 已经 把 
我们 所有 的 实现 都 放到 了 github 上了 包括 
用 C + + 的 OpenCV 实现 然而 如果 你 
想 跟 我 的 猫 照相 这 没什么 问题 建议 
阅读 PCA Principal Component AnalysisEveryday Algorithms Pancake SortUsing Computer Vision 
to Improve EEG i g n a l s I 
n t r o d u c t i o 
n to Markov ProcessesThe Cache and Multithreading 参考文献 1 Canny 
John . A computational approach to edge detection . Pattern 
Analysis and Machine Intelligence IEEE Transactions on 6 1986 679 
698 . 2 Freeman William T . and Edward H 
. Adelson . The design and use of steerable filters 
. IEEE Transactions on Pattern analysis and machine intelligence 13.9 
1991 891 906 . 转 自 计算机 视觉 中的 边缘 
检测 yewei11 的 专栏 CSDN 博客 http / / blog 
. csdn . net / yewei11 / article / details 
/ 50748012 原文 链接 请 点击 原文 链接 Edge Detection 
in Computer Vision http / / austingwalters . com / 
edge detection in computer vision / 计算机 视觉 中的 边缘 检测 边缘 检测 是 计算机 视觉 
中 最重要 的 概念 之一 这 是 一个 很 直观 
的 概念 在 一个 图像 上 运行 图像 检测 应该 
只 输出 边缘 与 素描 比较 相似 我 的 目标 
不仅 是 清晰 地 解释 边缘 检测 是 怎样 工作 
的 同时 也 提供 一个 新 而又 容易 的 方法 
只 需要 最小 工作 来 明显 地 提高 边缘 检测 
通过 获得 这些 边缘 许多 计算机 算法 才 得以 有可能 
实现 因为 在 一个 场景 中 边缘 包含着 绝大部分 至少 
很多 的 信息 举个 例子 我们 都 记得 Windows XP 
的 那个 绿色 小 山坡 和 蓝色 天空 的 背景 
当 我们 的 大脑 试图 去 理解 这个 场景 时 
我们 知道 这 是 草地 看起来 很 统一 然后 我们 
看到 了 飘着 些许 白云 的 天空 这些 对象 的 
每一个 都是/nr 分离 的 而且 它们 之间 有 一个 边缘 
这 就是 场景 中 为什么 绝大部分 的 信息 存在 与 
边缘 中 这也 是 为什么 边缘 检测 是 计算机 视觉 
中 的 重要 概念 通过 把 图像 减少 到 只剩下 
边缘 使得 对于 许多 算法 更容易 识别 学习 或者 处理 
场景 边缘 检测 滤波 边缘 检测 的 大多数 是 基于 
滤波 的 通常 来说 滤波 是 一个 消除 的 动作 
比如 过滤 水 是 消除 寄生虫 相 似地 当 我们 
尝试 找到 图像 边缘 时 我 是 在 尝试 消除 
掉 除 图像 边缘 之外 的 东西 消除 那些 不是 
有用 的 边缘 的 图像 部分 而 留下 合适 的 
边缘 也是 困难 所在 我 怎么 知道 这 是不是 有用 
的 边缘 比如 我 对 Windows XP 背景 运行 Canny 
edge dectector 程序 效果 如下 你 能 看到 那些 小草 
的 细小 刀刃 似的 边缘 这 很让 人 讨厌 而且 
没有 真正 提供 有用 的 信息 甚至 那些 云朵 也 
不是 非常 清晰 现在 你 能在 大多数 的 Canny edge 
dectector 上 设置 一些 边界 这些 边界 设置 了 阈值 
或者 非 极大值 抑制 所有 的 边缘 必须 满足 这个 
阈值 才能 划分为 重要 的 边缘 与其 在 Canny edge 
的 阈值 上 区分 不如 我们 更 广泛 地 来 
谈谈 并且 搭建 几个 滤波器 边缘 检测 高斯 滤波器 高斯 
滤波器 是 边缘 检测 最 基础 的 滤波器 之一 虽然 
还有 其他 的 但是 高斯 滤波器 会 贯穿 这篇文章 高斯 
滤波器 正如 其名 是 一个 基于 高斯分布 的 滤波器 它 
看起来 像 一个 抛物线 除了 在 二维 的 情况 通过 
矩阵 乘法 高斯 滤波器 能被 应用 到 每一个 像素 上 
它 实现 的 是 混合 效果 让 最 中心 的 
像素 尽 量小 基于 它 相邻 的 像素 举个 例子 
如对 我 的 猫 的 图像 运行 一个 均匀分布 的 
高斯 滤波器 我 能够 得到 下面 的 图像 5 . 
jpg 你 可以 看到 图像 变得 模糊 了 高斯滤波 器 
就是 获取 所有 像素 让 像素 值 的 成分 是 
与 相邻 像素 有关 为了 让 高斯 滤波器 在 边缘 
检测 中 有效 我们 可以 使用 从 x 和 y 
方面 求导 出来 的 高斯 滤波器 这 也许 听 起来 
有点 反 直觉 或者 不知所谓 但是 如果 我们 看到 这种 
导数 高斯 滤波器 的 图像 这种 想法 就 很 清晰 
了 当 你 把 一个 高斯 的 x 和 y 
分量 求导 后 一个 大 的 波峰 和 波谷 就 
出现 了 如果 你 明白 导数 思考 下 这种 情况 
你 应该 能 很快 想到 由于 高斯 函 数峰 上 
数值 上 的 巨大 变化 从而 导致 了 高斯 导数 
波峰 和 波谷 的 出现 如果 我们 把 上面 的 
写成 代码 那 相当 直接 至少 对于 Matlab 和 Python 
来说 % Takes the derivative of a 5x5 gaussian with 
a sigma hx hy = gradient fspecial gaussian 5 5 
sigma 这 就是 了 一行 代码 就能 得到 我们 所 
想要 的 高斯 然后 对 x 和 y 分量 求导 
边缘 检测 应用 滤波器 我们 已经 有了/nr 两个 高斯 滤波器 
我们 把 他们 应用到 图像 中 我们 同样 使用 非 
极大值 限制 即 如果 不是 极大值 的话 就把 像素 值 
设置 为 0 换 种 说法 就是 消除 噪声 应用 
滤波器 的 代码 如下 % Convert an image to double 
for increased precision img = double img % Find two 
derived gaussians with respect to x and y hx hy 
= gradient fspecial gaussian 5 5 sigma % Run the 
filters over the image generating a filtered image % Leaves 
x edges gx = double imfilter img hx replicate conv 
% Leaves y edges gy = double imfilter img hy 
replicate conv % Take the absolute value and combine the 
x and y edges mag = sqrt gx . * 
gx + gy . * gy % Use non maxima 
suppression mag = max mag 3 如果 我们 将 它 
应用 我 的 猫 的 一张 图片 我 我们 就 
得到 一下 的 图片 有 趣地 是 我们 同样 也能 
这种 方法 应用 到 RGB 图像 上去 同样 也 会 
得到 彩色 的 边缘 普通/nz 的/uj 边缘/n 滤波器/nz 应用到/i 猫/n 
的/uj RGB/w 图像/n 这/r 两张/m 图片/n 应该/v 都能/nr 代表/n 像素/n 
和它/nr 相邻/v 之间/f 像素/n 的/uj 颜色/n 的/uj 差异/n 只不过 彩色图像 
有 3层 而 黑白 图像 只有 1层 层 翻译 不是 
很好 边缘 检测 方向 滤波器 为什么 要 限制 我们 自己 
仅 仅 使用 绝对 的 x 和 y 方向 的 
滤波器 呢 让 我们 也 来 构建 一些 方向 滤波器 
这个 方法 或多或少 来源于 Freeman 和 Adelson 的 The design 
and use of steerable filters 论文 这个 想法 使 我们 
能够 把 我们 的 高斯 滤波器 放置 在 不同 的 
方向 根本 上 我们 把 我们 的 高斯 滤波器 放置 
到 不同 的 方向 上去 以 基于 与 高斯 相关 
的 边缘 的 角度 来 创建 不同 数值 比如 如果 
我们 把 高斯 函数 放置 到 45度 应用到 45 度角 
的 图像 上 应该 可以 比 在 0度 的 高斯 
函数 得到 更高 的 数量级 在 这种 情况 下 我 
生成 了 几种 不同 的 方向 滤波器 上行 x 分量 
下行 y 分量 各种各样 的 高斯 函数 产生 了 相对 
于x/nr 和 y 分量 上 的 90 45 45 和 
22.5 度 的 滤波器 这也 就 产生 了 不同 的 
边缘 大小 尽管 这些 滤波器 应该 检测 出 相近 的 
边缘 我 使用 的 代码 与 单个 滤波器 使用 的 
代码 几乎 相同 但是 我 不同 以往 地 把 他们 
混合 在 一起 它 看起来 有点 杂乱 但是 我 通过 
让 我 运行 每个 滤波器 表达 更 明白 来 尽可 
能使 它 看起来 更 清晰 % Create four filters hx 
hy = gradient fspecial gaussian 5 5 sigma hx1 hy1 
= altOrientFilter1 hx hy hx2 hy2 = altOrientFilter2 hx hy 
hx3 hy3 = altOrientFilter3 hx hy % Run first gaussian 
filter on image gx = double imfilter img hx replicate 
conv gy = double imfilter img hy replicate conv % 
Run second gaussian filter on image gx1 = double imfilter 
img hx1 replicate conv gy1 = double imfilter img hy1 
replicate conv % Run third gaussian filter on image gx2 
= double imfilter img hx2 replicate conv gy2 = double 
imfilter img hy2 replicate conv % Run fourth gaussian filter 
on image gx3 = double imfilter img hx3 replicate conv 
gy3 = double imfilter img hy3 replicate conv % Merge 
all filters squareGD = gx . * gx + gy 
. * gy squareGD = squareGD + gx1 . * 
gx1 + gy1 . * gy1 squareGD = squareGD + 
gx2 . * gx2 + gy2 . * gy2 squareGD 
= squareGD + gx3 . * gx3 + gy3 . 
* gy3 % Run non maxima supression mag = max 
sqrt squareGD 3 如果 你 靠近 点 看 的话 你 
能 看到 数量 大小 的 不同 特别 是 那些 皱纹 
如果 我们 混合 了 所有 图像 我们 就 能 得到 
一张 轻微 较好 的 边缘 检测 方向 滤波器 和非/nr 方向 
滤波器 之间 并 没有 很大 的 不同 但是 我们 也 
应该 看到 多种 方向 的 结果 有 些许 的 提高 
边缘 检测 提高 彩 色域 过去 两年 我 在 不同 
的 彩色 域 上 做 了 大量 的 测试 和 
实验 特别地 是 Lab 彩 色域 是 另一种 描述 图像 
的 方式 比如 我们 知道 的 RGB 和 灰度 图像 
或者 你 甚至 可能 知道 YUV 空间 Lab 彩 色域 
与之 非常 相似 我 对 Lab 彩色 感兴趣 的 原因 
是 它 对 产生 场景 的 边缘 有着 优异 的 
能力 Lab 彩色 空间 的 每个 字母 表示 L Luminance 
亮度 a alpha 红到 绿 b beta 黄到蓝/nr 事实上/l 这些 
颜色通道 非常适合 发现 颜色 变化 梯度 正 自然而然 地 黄色 
很少 出现 另 一个 黄色 周围 红色 和 绿色 也是 
如此 尽管 我 已经 彻底 证明了 Lab 彩色 空间 与 
我们 人类 怎样 察觉 颜色 中的 亮度 有 很强 的 
相关性 与 RGB 相反 的 是 在 Lab 彩色 空间 
中 亮度 有它/nr 自己 的 分离 通道 这 使得 它 
能 更好 地 处理 颜色 的 差异 这些 差异 也是 
亮度 与 颜色 相关 之处 为了 最小化 额外 的 代码 
我们 所 要做 的 就是 把 输入 的 图像 转化 
为 Lab 彩色 空间 的 图像 你 可以 做 一些 
最 优化 不过 你 仅仅 做了 这 额外 的 一步 
也能 明显提高 适宜 的 边缘 检测 % Convert an image 
to the Lab color space colorTransform = makecform srgb2lab img 
= applycform rgbImg colorTransform % Make it double to improve 
representation img = double img % Find x and y 
derivative of a 9x9 gaussian hx hy = gradient fspecial 
gaussian 9 9 sigma % Apply filters gx = double 
imfilter img hx replicate gy = double imfilter img hy 
replicate % Find absolute value gSquared = sqrt gx . 
* gx + gy . * gy % Apply non 
maxima suppression find best points for edges mag = max 
gSquared 3 如果 我们 将 Windows XP 小 山坡 的 
背景 图像 转换 为 Lab 我们 将 得到 下面 的 
图像 Windows XP 背景 的 Lab 空间 图像 然后 如果 
我们 施加 滤波器 非 极大值 抑制 将 得到 下面 的 
图像 清晰 的 包含 着 草地 云 草地 和 天空 
的 分界线 的 图象 在 Lab 空间 上边缘 检测 最终 
如果 我们 运行 非 极大值 抑制 那么 我们 将 得到 
比 本文 开头 提到 的 Canny 边缘 检测器 要 好得多 
的 边缘 效果 Lab 彩色 空间 边缘 检测 平均 来说 
这种 方法 会 比 普通 方法 提高 10% 左右 的 
边缘 检测 精度 这是 对 The Berkeley Segmentation Dataset and 
Benchmark 运行 F measure 测试 得到 的 结果 边缘 检测 
结语 有 无数 的 方法 去做 边缘 检测 这里 讲述 
的 方法 绝 不是 最好 最 容易 实现 最 容易 
解释 的 我 使用 这些 方法 解释 它 是因为 我 
对 它们 很 有兴趣 加上 这是 UIUC 的 CS543 课程 
计算机 视觉 布置 的 作业 所以 你 也 在上 这门 
课 请 不要 抄袭 我 的 代码 我 已经 把 
我们 所有 的 实现 都 放到 了 github 上了 包括 
用 C + + 的 OpenCV 实现 然而 如果 你 
想 跟 我 的 猫 照相 这 没什么 问题 建议 
阅读 PCA Principal Component AnalysisEveryday Algorithms Pancake SortUsing Computer Vision 
to Improve EEG i g n a l s I 
n t r o d u c t i o 
n to Markov ProcessesThe Cache and Multithreading 参考文献 1 Canny 
John . A computational approach to edge detection . Pattern 
Analysis and Machine Intelligence IEEE Transactions on 6 1986 679 
698 . 2 Freeman William T . and Edward H 
. Adelson . The design and use of steerable filters 
. IEEE Transactions on Pattern analysis and machine intelligence 13.9 
1991 891 906 . 转 自 计算机 视觉 中的 边缘 
检测 yewei11 的 专栏 CSDN 博客 http / / blog 
. csdn . net / yewei11 / article / details 
/ 50748012 原文 链接 请 点击 原文 链接 Edge Detection 
in Computer Vision http / / austingwalters . com / 
edge detection in computer vision / 