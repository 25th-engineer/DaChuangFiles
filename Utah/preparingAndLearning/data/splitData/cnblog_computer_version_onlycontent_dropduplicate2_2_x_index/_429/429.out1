在 我们 学习 的 这个 项目 中 模型 主要 分为 
两种 状态 即 进行 推断 用 的 inference 模式 和 
进行 训练 用 的 training 模式 所谓 推断 模式 就是 
已经 训 练好 的 的 模型 我们 传入 一张 图片 
网络 将 其 分析 结果 计算 出来 的 模式 本节 
我们 从 demo . ipynb 入手 一 窥 已 经训 
练好 的 Mask RCNN 模型 如何 根据 一张 输入 图片 
进行 推断 得到 相关 信息 即 inference 模式 的 工作 
原理 一 调用 推断 网络 网络 配置 首先 进行 配置 
设定 设 定项 都被 集成 进 class config 中了 自建 
新的 设定 只要 基础 改 class 并 更新 属性 即可 
在 demo 中 我们 直接 使用 COCO 的 预 训练 
模型 所以 使用 其 设置 即可 但 由于 我们 想 
检测 单张 图片 所以 需要 更新 几个 相关 数目 设定 
# 父 类 继承 了 Config 类 目的 就是 记录 
配置 并在 其 基础 上 添加 了 几个 新的 属性 
class InferenceConfig coco . CocoConfig # Set batch size to 
1 since we ll be running inference on # one 
image at a time . Batch size = GPU _ 
COUNT * IMAGES _ PER _ GPU GPU _ COUNT 
= 1 IMAGES _ PER _ GPU = 1 config 
= InferenceConfig config . display 打印 出 配置 如下 Configurations 
BACKBONE resnet101 BACKBONE _ STRIDES 4 8 16 32 64 
BATCH _ SIZE 1 BBOX _ STD _ DEV 0.1 
0.1 0.2 0.2 COMPUTE _ BACKBONE _ SHAPE None DETECTION 
_ MAX _ INSTANCES 100 DETECTION _ MIN _ CONFIDENCE 
0.7 DETECTION _ NMS _ THRESHOLD 0.3 FPN _ CLASSIF 
_ FC _ LAYERS _ SIZE 1024 GPU _ COUNT 
1 GRADIENT _ CLIP _ NORM 5.0 IMAGES _ PER 
_ GPU 1 IMAGE _ CHANNEL _ COUNT 3 IMAGE 
_ MAX _ DIM 1024 IMAGE _ META _ SIZE 
93 IMAGE _ MIN _ DIM 800 IMAGE _ MIN 
_ SCALE 0 IMAGE _ RESIZE _ MODE square IMAGE 
_ SHAPE 1024 1024 3 LEARNING _ MOMENTUM 0.9 LEARNING 
_ RATE 0.001 LOSS _ WEIGHTS { rpn _ class 
_ loss 1.0 rpn _ bbox _ loss 1.0 mrcnn 
_ class _ loss 1.0 mrcnn _ bbox _ loss 
1.0 mrcnn _ mask _ loss 1.0 } MASK _ 
POOL _ SIZE 14 MASK _ SHAPE 28 28 MAX 
_ GT _ INSTANCES 100 MEAN _ PIXEL 123.7 116.8 
103.9 MINI _ MASK _ SHAPE 56 56 NAME coco 
NUM _ CLASSES 81 POOL _ SIZE 7 POST _ 
NMS _ ROIS _ INFERENCE 1000 POST _ NMS _ 
ROIS _ TRAINING 2000 PRE _ NMS _ LIMIT 6000 
ROI _ POSITIVE _ RATIO 0.33 RPN _ ANCHOR _ 
RATIOS 0.5 1 2 RPN _ ANCHOR _ SCALES 32 
64 128 256 512 RPN _ ANCHOR _ STRIDE 1 
RPN _ BBOX _ STD _ DEV 0.1 0.1 0.2 
0.2 RPN _ NMS _ THRESHOLD 0.7 RPN _ TRAIN 
_ ANCHORS _ PER _ IMAGE 256 STEPS _ PER 
_ EPOCH 1000 TOP _ DOWN _ PYRAMID _ SIZE 
256 TRAIN _ BN False TRAIN _ ROIS _ PER 
_ IMAGE 200 USE _ MINI _ MASK True USE 
_ RPN _ ROIS True VALIDATION _ STEPS 50 WEIGHT 
_ DECAY 0.0001 模型 初始化 首先 初始化 模型 然后 载入 
预 训练 参数 文件 在 末尾 我 可视 化了 模型 
不过 真的 太 长了 所以 注释 掉了 在/p 第一/m 步/n 
初始/v 化时/n 就会/i 根据/p mode/w 参数/n 的/uj 具体/a 值/n 建立/v 
计/n 算图/i 本节 介绍 的 推断 网络 就是 在 mode 
参数 设定 为 inference 时 建立 的 计算网络 # Create 
model object in inference mode . model = modellib . 
MaskRCNN mode = inference model _ dir = MODEL _ 
DIR config = config # Load weights trained on MS 
COCO model . load _ weights COCO _ MODEL _ 
PATH by _ name = True # model . keras 
_ model . summary 检测 图片 # Load a random 
image from the images folder file _ names = next 
os . walk IMAGE _ DIR 2 # 只要 是 
迭代 器 调用 next 方法 获 取值 学习 了 image 
= skimage . io . imread os . path . 
join IMAGE _ DIR random . choice file _ names 
print image . shape # Run detection results = model 
. detect image verbose = 1 # Visualize results r 
= results 0 visualize . display _ instances image r 
rois r masks r class _ ids class _ names 
r scores 读取 一张 图片 调用 model 的 detect 方法 
即 可输出 结果 最后 使用 辅助 方法 可视化 结果 二 
推断 逻辑 概览 inference 的 前 向 逻辑 如下 图 
所示 我们 简单 的 看 一下 其 计算 流程 是 
怎样 的 左上 模块 为 以 ResNet101 为基础 的 FPN 
特征 金字塔 网络 的 特征提取 逻辑 可以 看到 作者 并 
没有 直接 将 up down 特征 使用 而是 又 做了 
一次 3 * 3 卷积 进行 了 进一步 的 特征 
融合 出来 的 各层 FPN 特征 首先 各自 独立 地 
进入 了 RPN 处理 层 根据 锚 框 数目 信息 
确定 候选 区域 的 分类 前景 背景 2 分类 和 
回归 结果 rpn _ class batch num _ rois 2 
rpn _ bbox batch num _ rois dy dx log 
dh log dw 有了/nr 众多 的 候选 区域 我们 将 
之 送入 Proposal 筛选 部分 首先 根据 前景 得分 排序 
进行 初筛 配置 会 指定 这一步 保留 多少 候选框 然后 
为非 极大值 抑制 做准备 用 RPN 的 回归 结果 修正 
anchors 值得 注意 的 是 anchors 都是 归一化 的 这 
意味着 修 值 之后 还 需要 做 检查 以防 越界 
最后 非 极大值 一致 删减 的 太多 了 的话 就 
补上 0 0 0 0 达到 配置文件 要求 的 数目 
非 极大值 部分 会 造成 同一个 batch 中 不同 图片 
的 候选框 数目 不 一致 但是 tensor 的 维数 不能 
参差不齐 所以 要 补零 使得 各 张 图片 候选 区域 
数目 一致 rpn _ rois IMAGES _ PER _ GPU 
num _ rois y1 x1 y2 x2 根据 候 选区 
的 实际 大小 归一化 候 选区 需要 映射 回原 图 
大小 为 候选 区 选择 合适 的 RPN 特征 层 
ROI Align 处理 实际上 就是 抠 出来 进行 双 线性插值 
到 指定 大小 得到 我们 需要 的 众多 等 大 
子图 对 这些 子图 各自 独立 的 进行 分类 / 
回归 mrcnn _ class _ logits batch num _ rois 
NUM _ CLASSES classifier logits before softmax mrcnn _ class 
batch num _ rois NUM _ CLASSES classifier p r 
o b a b i l i t i e 
s m r c n n _ bbox deltas batch 
num _ rois NUM _ CLASSES dy dx log dh 
log dw 在 分类 回归 之后 使用 回归 结果 对 
候选框 进行 修正 然后 重新 进行 FPN 特征 层 选择 
和 ROI Align 特征提取 最后 送入 Mask 网络 进行 Mask 
生成 最后 我们 希望 网络 输出 下面 的 张量 # 
num _ anchors 每张 图片 上 生成 的 锚 框 
数量 # num _ rois 每张 图片 上 由 锚 
框 筛选出 的 推荐 区 数量 # # 由 POST 
_ NMS _ ROIS _ TRAINING 或 POST _ NMS 
_ ROIS _ INFERENCE 规定 # num _ detections 每张 
图片 上 最终 检测 输出 框 # # 由 DETECTION 
_ MAX _ INSTANCES 规定 # detections batch num _ 
detections y1 x1 y2 x2 class _ id score # 
mrcnn _ class batch num _ rois NUM _ CLASSES 
classifier probabilities # mrcnn _ bbox batch num _ rois 
NUM _ CLASSES dy dx log dh log dw # 
mrcnn _ mask batch num _ detections MASK _ POOL 
_ SIZE MASK _ POOL _ SIZE NUM _ CLASSES 
# rpn _ rois batch num _ rois y1 x1 
y2 x2 class _ id score # rpn _ class 
batch num _ anchors 2 # rpn _ bbox batch 
num _ anchors 4 具体 每种 张量 的 意义 我们 
会在 源码 分析 中 一一 介绍 在 我们 学习 的 这个 项目 中 模型 主要 分为 
两种 状态 即 进行 推断 用 的 inference 模式 和 
进行 训练 用 的 training 模式 所谓 推断 模式 就是 
已经 训 练好 的 的 模型 我们 传入 一张 图片 
网络 将 其 分析 结果 计算 出来 的 模式 本节 
我们 从 demo . ipynb 入手 一 窥 已 经训 
练好 的 Mask RCNN 模型 如何 根据 一张 输入 图片 
进行 推断 得到 相关 信息 即 inference 模式 的 工作 
原理 一 调用 推断 网络 网络 配置 首先 进行 配置 
设定 设 定项 都被 集成 进 class config 中了 自建 
新的 设定 只要 基础 改 class 并 更新 属性 即可 
在 demo 中 我们 直接 使用 COCO 的 预 训练 
模型 所以 使用 其 设置 即可 但 由于 我们 想 
检测 单张 图片 所以 需要 更新 几个 相关 数目 设定 
# 父 类 继承 了 Config 类 目的 就是 记录 
配置 并在 其 基础 上 添加 了 几个 新的 属性 
class InferenceConfig coco . CocoConfig # Set batch size to 
1 since we ll be running inference on # one 
image at a time . Batch size = GPU _ 
COUNT * IMAGES _ PER _ GPU GPU _ COUNT 
= 1 IMAGES _ PER _ GPU = 1 config 
= InferenceConfig config . display 打印 出 配置 如下 Configurations 
BACKBONE resnet101 BACKBONE _ STRIDES 4 8 16 32 64 
BATCH _ SIZE 1 BBOX _ STD _ DEV 0.1 
0.1 0.2 0.2 COMPUTE _ BACKBONE _ SHAPE None DETECTION 
_ MAX _ INSTANCES 100 DETECTION _ MIN _ CONFIDENCE 
0.7 DETECTION _ NMS _ THRESHOLD 0.3 FPN _ CLASSIF 
_ FC _ LAYERS _ SIZE 1024 GPU _ COUNT 
1 GRADIENT _ CLIP _ NORM 5.0 IMAGES _ PER 
_ GPU 1 IMAGE _ CHANNEL _ COUNT 3 IMAGE 
_ MAX _ DIM 1024 IMAGE _ META _ SIZE 
93 IMAGE _ MIN _ DIM 800 IMAGE _ MIN 
_ SCALE 0 IMAGE _ RESIZE _ MODE square IMAGE 
_ SHAPE 1024 1024 3 LEARNING _ MOMENTUM 0.9 LEARNING 
_ RATE 0.001 LOSS _ WEIGHTS { rpn _ class 
_ loss 1.0 rpn _ bbox _ loss 1.0 mrcnn 
_ class _ loss 1.0 mrcnn _ bbox _ loss 
1.0 mrcnn _ mask _ loss 1.0 } MASK _ 
POOL _ SIZE 14 MASK _ SHAPE 28 28 MAX 
_ GT _ INSTANCES 100 MEAN _ PIXEL 123.7 116.8 
103.9 MINI _ MASK _ SHAPE 56 56 NAME coco 
NUM _ CLASSES 81 POOL _ SIZE 7 POST _ 
NMS _ ROIS _ INFERENCE 1000 POST _ NMS _ 
ROIS _ TRAINING 2000 PRE _ NMS _ LIMIT 6000 
ROI _ POSITIVE _ RATIO 0.33 RPN _ ANCHOR _ 
RATIOS 0.5 1 2 RPN _ ANCHOR _ SCALES 32 
64 128 256 512 RPN _ ANCHOR _ STRIDE 1 
RPN _ BBOX _ STD _ DEV 0.1 0.1 0.2 
0.2 RPN _ NMS _ THRESHOLD 0.7 RPN _ TRAIN 
_ ANCHORS _ PER _ IMAGE 256 STEPS _ PER 
_ EPOCH 1000 TOP _ DOWN _ PYRAMID _ SIZE 
256 TRAIN _ BN False TRAIN _ ROIS _ PER 
_ IMAGE 200 USE _ MINI _ MASK True USE 
_ RPN _ ROIS True VALIDATION _ STEPS 50 WEIGHT 
_ DECAY 0.0001 模型 初始化 首先 初始化 模型 然后 载入 
预 训练 参数 文件 在 末尾 我 可视 化了 模型 
不过 真的 太 长了 所以 注释 掉了 在/p 第一/m 步/n 
初始/v 化时/n 就会/i 根据/p mode/w 参数/n 的/uj 具体/a 值/n 建立/v 
计/n 算图/i 本节 介绍 的 推断 网络 就是 在 mode 
参数 设定 为 inference 时 建立 的 计算网络 # Create 
model object in inference mode . model = modellib . 
MaskRCNN mode = inference model _ dir = MODEL _ 
DIR config = config # Load weights trained on MS 
COCO model . load _ weights COCO _ MODEL _ 
PATH by _ name = True # model . keras 
_ model . summary 检测 图片 # Load a random 
image from the images folder file _ names = next 
os . walk IMAGE _ DIR 2 # 只要 是 
迭代 器 调用 next 方法 获 取值 学习 了 image 
= skimage . io . imread os . path . 
join IMAGE _ DIR random . choice file _ names 
print image . shape # Run detection results = model 
. detect image verbose = 1 # Visualize results r 
= results 0 visualize . display _ instances image r 
rois r masks r class _ ids class _ names 
r scores 读取 一张 图片 调用 model 的 detect 方法 
即 可输出 结果 最后 使用 辅助 方法 可视化 结果 二 
推断 逻辑 概览 inference 的 前 向 逻辑 如下 图 
所示 我们 简单 的 看 一下 其 计算 流程 是 
怎样 的 左上 模块 为 以 ResNet101 为基础 的 FPN 
特征 金字塔 网络 的 特征提取 逻辑 可以 看到 作者 并 
没有 直接 将 up down 特征 使用 而是 又 做了 
一次 3 * 3 卷积 进行 了 进一步 的 特征 
融合 出来 的 各层 FPN 特征 首先 各自 独立 地 
进入 了 RPN 处理 层 根据 锚 框 数目 信息 
确定 候选 区域 的 分类 前景 背景 2 分类 和 
回归 结果 rpn _ class batch num _ rois 2 
rpn _ bbox batch num _ rois dy dx log 
dh log dw 有了/nr 众多 的 候选 区域 我们 将 
之 送入 Proposal 筛选 部分 首先 根据 前景 得分 排序 
进行 初筛 配置 会 指定 这一步 保留 多少 候选框 然后 
为非 极大值 抑制 做准备 用 RPN 的 回归 结果 修正 
anchors 值得 注意 的 是 anchors 都是 归一化 的 这 
意味着 修 值 之后 还 需要 做 检查 以防 越界 
最后 非 极大值 一致 删减 的 太多 了 的话 就 
补上 0 0 0 0 达到 配置文件 要求 的 数目 
非 极大值 部分 会 造成 同一个 batch 中 不同 图片 
的 候选框 数目 不 一致 但是 tensor 的 维数 不能 
参差不齐 所以 要 补零 使得 各 张 图片 候选 区域 
数目 一致 rpn _ rois IMAGES _ PER _ GPU 
num _ rois y1 x1 y2 x2 根据 候 选区 
的 实际 大小 归一化 候 选区 需要 映射 回原 图 
大小 为 候选 区 选择 合适 的 RPN 特征 层 
ROI Align 处理 实际上 就是 抠 出来 进行 双 线性插值 
到 指定 大小 得到 我们 需要 的 众多 等 大 
子图 对 这些 子图 各自 独立 的 进行 分类 / 
回归 mrcnn _ class _ logits batch num _ rois 
NUM _ CLASSES classifier logits before softmax mrcnn _ class 
batch num _ rois NUM _ CLASSES classifier p r 
o b a b i l i t i e 
s m r c n n _ bbox deltas batch 
num _ rois NUM _ CLASSES dy dx log dh 
log dw 在 分类 回归 之后 使用 回归 结果 对 
候选框 进行 修正 然后 重新 进行 FPN 特征 层 选择 
和 ROI Align 特征提取 最后 送入 Mask 网络 进行 Mask 
生成 最后 我们 希望 网络 输出 下面 的 张量 # 
num _ anchors 每张 图片 上 生成 的 锚 框 
数量 # num _ rois 每张 图片 上 由 锚 
框 筛选出 的 推荐 区 数量 # # 由 POST 
_ NMS _ ROIS _ TRAINING 或 POST _ NMS 
_ ROIS _ INFERENCE 规定 # num _ detections 每张 
图片 上 最终 检测 输出 框 # # 由 DETECTION 
_ MAX _ INSTANCES 规定 # detections batch num _ 
detections y1 x1 y2 x2 class _ id score # 
mrcnn _ class batch num _ rois NUM _ CLASSES 
classifier probabilities # mrcnn _ bbox batch num _ rois 
NUM _ CLASSES dy dx log dh log dw # 
mrcnn _ mask batch num _ detections MASK _ POOL 
_ SIZE MASK _ POOL _ SIZE NUM _ CLASSES 
# rpn _ rois batch num _ rois y1 x1 
y2 x2 class _ id score # rpn _ class 
batch num _ anchors 2 # rpn _ bbox batch 
num _ anchors 4 具体 每种 张量 的 意义 我们 
会在 源码 分析 中 一一 介绍 在 我们 学习 的 这个 项目 中 模型 主要 分为 
两种 状态 即 进行 推断 用 的 inference 模式 和 
进行 训练 用 的 training 模式 所谓 推断 模式 就是 
已经 训 练好 的 的 模型 我们 传入 一张 图片 
网络 将 其 分析 结果 计算 出来 的 模式 本节 
我们 从 demo . ipynb 入手 一 窥 已 经训 
练好 的 Mask RCNN 模型 如何 根据 一张 输入 图片 
进行 推断 得到 相关 信息 即 inference 模式 的 工作 
原理 一 调用 推断 网络 网络 配置 首先 进行 配置 
设定 设 定项 都被 集成 进 class config 中了 自建 
新的 设定 只要 基础 改 class 并 更新 属性 即可 
在 demo 中 我们 直接 使用 COCO 的 预 训练 
模型 所以 使用 其 设置 即可 但 由于 我们 想 
检测 单张 图片 所以 需要 更新 几个 相关 数目 设定 
# 父 类 继承 了 Config 类 目的 就是 记录 
配置 并在 其 基础 上 添加 了 几个 新的 属性 
class InferenceConfig coco . CocoConfig # Set batch size to 
1 since we ll be running inference on # one 
image at a time . Batch size = GPU _ 
COUNT * IMAGES _ PER _ GPU GPU _ COUNT 
= 1 IMAGES _ PER _ GPU = 1 config 
= InferenceConfig config . display 打印 出 配置 如下 Configurations 
BACKBONE resnet101 BACKBONE _ STRIDES 4 8 16 32 64 
BATCH _ SIZE 1 BBOX _ STD _ DEV 0.1 
0.1 0.2 0.2 COMPUTE _ BACKBONE _ SHAPE None DETECTION 
_ MAX _ INSTANCES 100 DETECTION _ MIN _ CONFIDENCE 
0.7 DETECTION _ NMS _ THRESHOLD 0.3 FPN _ CLASSIF 
_ FC _ LAYERS _ SIZE 1024 GPU _ COUNT 
1 GRADIENT _ CLIP _ NORM 5.0 IMAGES _ PER 
_ GPU 1 IMAGE _ CHANNEL _ COUNT 3 IMAGE 
_ MAX _ DIM 1024 IMAGE _ META _ SIZE 
93 IMAGE _ MIN _ DIM 800 IMAGE _ MIN 
_ SCALE 0 IMAGE _ RESIZE _ MODE square IMAGE 
_ SHAPE 1024 1024 3 LEARNING _ MOMENTUM 0.9 LEARNING 
_ RATE 0.001 LOSS _ WEIGHTS { rpn _ class 
_ loss 1.0 rpn _ bbox _ loss 1.0 mrcnn 
_ class _ loss 1.0 mrcnn _ bbox _ loss 
1.0 mrcnn _ mask _ loss 1.0 } MASK _ 
POOL _ SIZE 14 MASK _ SHAPE 28 28 MAX 
_ GT _ INSTANCES 100 MEAN _ PIXEL 123.7 116.8 
103.9 MINI _ MASK _ SHAPE 56 56 NAME coco 
NUM _ CLASSES 81 POOL _ SIZE 7 POST _ 
NMS _ ROIS _ INFERENCE 1000 POST _ NMS _ 
ROIS _ TRAINING 2000 PRE _ NMS _ LIMIT 6000 
ROI _ POSITIVE _ RATIO 0.33 RPN _ ANCHOR _ 
RATIOS 0.5 1 2 RPN _ ANCHOR _ SCALES 32 
64 128 256 512 RPN _ ANCHOR _ STRIDE 1 
RPN _ BBOX _ STD _ DEV 0.1 0.1 0.2 
0.2 RPN _ NMS _ THRESHOLD 0.7 RPN _ TRAIN 
_ ANCHORS _ PER _ IMAGE 256 STEPS _ PER 
_ EPOCH 1000 TOP _ DOWN _ PYRAMID _ SIZE 
256 TRAIN _ BN False TRAIN _ ROIS _ PER 
_ IMAGE 200 USE _ MINI _ MASK True USE 
_ RPN _ ROIS True VALIDATION _ STEPS 50 WEIGHT 
_ DECAY 0.0001 模型 初始化 首先 初始化 模型 然后 载入 
预 训练 参数 文件 在 末尾 我 可视 化了 模型 
不过 真的 太 长了 所以 注释 掉了 在/p 第一/m 步/n 
初始/v 化时/n 就会/i 根据/p mode/w 参数/n 的/uj 具体/a 值/n 建立/v 
计/n 算图/i 本节 介绍 的 推断 网络 就是 在 mode 
参数 设定 为 inference 时 建立 的 计算网络 # Create 
model object in inference mode . model = modellib . 
MaskRCNN mode = inference model _ dir = MODEL _ 
DIR config = config # Load weights trained on MS 
COCO model . load _ weights COCO _ MODEL _ 
PATH by _ name = True # model . keras 
_ model . summary 检测 图片 # Load a random 
image from the images folder file _ names = next 
os . walk IMAGE _ DIR 2 # 只要 是 
迭代 器 调用 next 方法 获 取值 学习 了 image 
= skimage . io . imread os . path . 
join IMAGE _ DIR random . choice file _ names 
print image . shape # Run detection results = model 
. detect image verbose = 1 # Visualize results r 
= results 0 visualize . display _ instances image r 
rois r masks r class _ ids class _ names 
r scores 读取 一张 图片 调用 model 的 detect 方法 
即 可输出 结果 最后 使用 辅助 方法 可视化 结果 二 
推断 逻辑 概览 inference 的 前 向 逻辑 如下 图 
所示 我们 简单 的 看 一下 其 计算 流程 是 
怎样 的 左上 模块 为 以 ResNet101 为基础 的 FPN 
特征 金字塔 网络 的 特征提取 逻辑 可以 看到 作者 并 
没有 直接 将 up down 特征 使用 而是 又 做了 
一次 3 * 3 卷积 进行 了 进一步 的 特征 
融合 出来 的 各层 FPN 特征 首先 各自 独立 地 
进入 了 RPN 处理 层 根据 锚 框 数目 信息 
确定 候选 区域 的 分类 前景 背景 2 分类 和 
回归 结果 rpn _ class batch num _ rois 2 
rpn _ bbox batch num _ rois dy dx log 
dh log dw 有了/nr 众多 的 候选 区域 我们 将 
之 送入 Proposal 筛选 部分 首先 根据 前景 得分 排序 
进行 初筛 配置 会 指定 这一步 保留 多少 候选框 然后 
为非 极大值 抑制 做准备 用 RPN 的 回归 结果 修正 
anchors 值得 注意 的 是 anchors 都是 归一化 的 这 
意味着 修 值 之后 还 需要 做 检查 以防 越界 
最后 非 极大值 一致 删减 的 太多 了 的话 就 
补上 0 0 0 0 达到 配置文件 要求 的 数目 
非 极大值 部分 会 造成 同一个 batch 中 不同 图片 
的 候选框 数目 不 一致 但是 tensor 的 维数 不能 
参差不齐 所以 要 补零 使得 各 张 图片 候选 区域 
数目 一致 rpn _ rois IMAGES _ PER _ GPU 
num _ rois y1 x1 y2 x2 根据 候 选区 
的 实际 大小 归一化 候 选区 需要 映射 回原 图 
大小 为 候选 区 选择 合适 的 RPN 特征 层 
ROI Align 处理 实际上 就是 抠 出来 进行 双 线性插值 
到 指定 大小 得到 我们 需要 的 众多 等 大 
子图 对 这些 子图 各自 独立 的 进行 分类 / 
回归 mrcnn _ class _ logits batch num _ rois 
NUM _ CLASSES classifier logits before softmax mrcnn _ class 
batch num _ rois NUM _ CLASSES classifier p r 
o b a b i l i t i e 
s m r c n n _ bbox deltas batch 
num _ rois NUM _ CLASSES dy dx log dh 
log dw 在 分类 回归 之后 使用 回归 结果 对 
候选框 进行 修正 然后 重新 进行 FPN 特征 层 选择 
和 ROI Align 特征提取 最后 送入 Mask 网络 进行 Mask 
生成 最后 我们 希望 网络 输出 下面 的 张量 # 
num _ anchors 每张 图片 上 生成 的 锚 框 
数量 # num _ rois 每张 图片 上 由 锚 
框 筛选出 的 推荐 区 数量 # # 由 POST 
_ NMS _ ROIS _ TRAINING 或 POST _ NMS 
_ ROIS _ INFERENCE 规定 # num _ detections 每张 
图片 上 最终 检测 输出 框 # # 由 DETECTION 
_ MAX _ INSTANCES 规定 # detections batch num _ 
detections y1 x1 y2 x2 class _ id score # 
mrcnn _ class batch num _ rois NUM _ CLASSES 
classifier probabilities # mrcnn _ bbox batch num _ rois 
NUM _ CLASSES dy dx log dh log dw # 
mrcnn _ mask batch num _ detections MASK _ POOL 
_ SIZE MASK _ POOL _ SIZE NUM _ CLASSES 
# rpn _ rois batch num _ rois y1 x1 
y2 x2 class _ id score # rpn _ class 
batch num _ anchors 2 # rpn _ bbox batch 
num _ anchors 4 具体 每种 张量 的 意义 我们 
会在 源码 分析 中 一一 介绍 