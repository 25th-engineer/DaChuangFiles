1 加载 显示 保存 图像 import argparse import cv2 ap 
= argparse . ArgumentParser ap . add _ argument i 
image required = True help = Path to the image 
# 读取 指定 指令 获取 图片 参数 1 输入 指令 
的 头 字母 参数 2 需要 输入 的 指令 args 
= vars ap . parse _ args image = cv2 
. imread args image # 读取 指定 参数 的 读取 
照片 print width % d pixels % image . shape 
1 # 获取 图像 的 宽度 横向 尺寸 图像 坐标系 
中 第二个 参数 print height % d pixels % image 
. shape 0 # 获取 图像 的 高度 竖向 尺寸 
图像 坐标系 中 第一 个 参数 注意 读取 图像 x 
y 互换 print channels % d % image . shape 
2 cv2 . imshow Image image # 显示 图片 cv2 
. imwrite newimage . jpg image # 将 图片 写入 
指定 路径 cv2 . waitKey 0 # 等待 程序 结束 
2 图像 基础 h w = image . shape 2 
# x y 像素 中的 显示 获取 图片 的 高度 
x 获取 图片 的 宽度 y b g r = 
image 0 0 # 获取 指定 位置 的 像素 存储 
方式 为 bgr cX cY = w / 2 h 
/ 2 # cX 图片 的 宽度 cY 图片 高度 
tl = image 0 cY 0 cX # 获取 图片 
的 左上角 部分 起始 点 x 坐标 终点 x 坐标 
起点 的 y 坐标 终点 y 坐标 得出 的 值 
分别 指 高度 和 宽度 # 运用 像素 指定 位置 
赋值 方法 向 Background 图片 上 插入 图片 resized _ 
left for left _ x in xrange 0 500 1 
for left _ y in xrange 0 500 1 Background 
400 + left _ x 20 + left _ y 
= resized _ left left _ x left _ y 
3 绘图 canvas = np . zeros 300 300 3 
dtype = uint8 # 设置 画布 尺寸 green = 0 
255 0 # 设置 线条 颜色 cv2 . line canvas 
0 0 300 300 green # 参数 1 指定 画布 
参数 2 线条 的 开始 位置 参数 3 线条 终点 
位置 参数 4 线条 颜色 cv2 . line canvas 300 
0 0 300 red 3 # 参数 5 线条 像素 
厚度 cv2 . rectangle canvas 10 10 60 60 green 
# 参数 1 指定 画布 参数 2 矩形 起点 位置 
参数 3 矩形 对角线 点 的 位置 线条 颜色 cv2 
. rectangle canvas 50 200 200 225 red 5 # 
参数 5 线条 宽度 负数 表示 填充 矩形 centerX centerY 
= canvas . shape 1 / 2 canvas . shape 
0 / 2 # 设置 圆 心坐标 white = 255 
255 255 # 设置 圆 的 线条 颜色 cv2 . 
circle canvas centerX centerY r white # 参数 1 画布 
参数 2 圆心点 参数 3 设置 圆 的 半径 设置 
画圆 的 线条 颜色 cv2 . circle canvas tuple pt 
radius color 1 # 参数 4 设置 画圆 的 线条 
粗细 如果 为 负数 表示 填充 圆 4 图像处理 4.1 
翻译 M = np . float32 1 0 50 0 
1 90 # 定义 翻译 矩阵 参数 1 1 0 
x x 表示 像素 向左 或者 向右 移动 个数 x 
为 负值 图像 左移 正值 为 右移 定 参数 2 
0 1 y y 表示 像素 上下 移动 y 为 
负值 向上 移动 正值 向下 移动 记忆 口诀 前 左负右/nr 
正 后上 负 下 正 shifted = cv2 . warpAffine 
image M image . shape 1 image . shape 0 
# 对 矩阵 进行 翻译 参数 1 翻译 的 目标 
图像 参数 2 翻译 的 矩阵 参数 3 翻译 后 
图像 大小 # imutils 模块 的 翻译 函数 shifted = 
imutils . translate image 0 100 # 参数 1 移动 
的 目标 图像 参数 2 左右 移动 的 值 参数 
3 上下 移动 的 值 注 不会 改变 图像 大小 
4.2 旋 转注 运用 翻译 将 图片 移到 中心 位置 
四周 留出 黑色 边框 在 运用 旋转 旋转 角度 为 
0 可将 图片 放大 h w = image . shape 
2 #/i 获取/v 图像/n 的/uj 高和宽/nr cX cY = w 
/ 2 h / 2 # 获取 图像 的 中心点 
M = cv2 . g e t R o t 
a t i o n M a t r i 
x 2 D cX cY 45 1.0 # 设置 旋转 
矩阵 参数 1 旋转 点 参数 2 旋转 角度 正值 
逆时针 旋转 负值 顺时针 选装 参数 3 旋转 后 图像 
与 原始 图像 的 比例 图像 原始 大小 不会 发生 
变化 类似 相机 焦距 变化 rotated = cv2 . warpAffine 
image M w h # 参数 1 目标 图像 参数 
2 旋转 矩阵 参数 3 # 旋转 后的/nr 图像 尺寸 
# imutils 模块 的 旋转 函数 rotated = imutils . 
rotate image 180 # 参数 1 旋转 目标 图片 参数 
2 旋转 角度 center = x y 可以 设置 旋转 
点 4.3 图像 大小 调整 注 改变 原始 图片 的 
实际 大小 r = 150.0 / image . shape 1 
# 新 图像 与 旧 图像 的 宽 比例 注 
方便 图片 按 原 比例 缩放 dim = 150 int 
image . shape 0 * r # 设置 新 图像 
的 像素 尺寸 resized = cv2 . resize image dim 
interpolation = cv2 . INTER _ AREA # 调整 图像 
大小 返回 一个 新 图像 # 运用 imutils 中的 resize 
函数 resized = imutils . resize image width = 100 
# 参数 1 目标 图像 参数 2 设置 新 图像 
的 宽度 可以为 height 运用 高度 # 运用 插值 方法 
缩 放大 图片 通过 不同 的 像素 填充 方法 放大 
图片 resized = imutils . resize image width = image 
. shape 1 * 3 inter = method # 参数 
1 目标 图片 参数 2 处理 后 图片 像素 宽 
整形 参数 3 像素 处理 方法 method cv2 . INTER 
_ NEAREST 最 近邻 内 插值 cv2 . INTER _ 
LINEAR 双 线性插值 cv2 . INTER _ AREA 区域 插值 
cv2 . INTER _ CUBIC 双 三次 插值 cv2 . 
INTER _ LANCZOS4 双 三次 插值 4.4 图像 翻转 flipped 
= cv2 . flip image 1 # 水平 翻转 flipped 
= cv2 . flip image 0 # 上下 翻转 flipped 
= cv2 . flip image 1 # 水平 翻转 后 
上下 翻转 4.5 图像 裁剪 face = image 85 250 
85 220 # 参数 1 裁切 高度 x 开始 位置 
x 结束 位置 参数 2 裁切 宽度 y 开始 位置 
y 结束 位置 返回 新 图片 4.6 图像 像素 像素 
值 操作 注 修改 图片 的 亮度 M = np 
. ones image . shape dtype = uint8 * 100 
# 设置 与 图片 大 下 相同 的 矩阵 矩阵 
填 充值 为 100 added = cv2 . add image 
M # 将 原始 图片 与 新 矩阵 相加 像素 
亮 度提高 100 M = np . ones image . 
shape dtype = uint8 * 50 # 设置 与 图片 
大 下 相同 的 矩阵 矩阵 填 充值 为 50 
subtracted = cv2 . subtract image M # 将 原始 
图片 与 新 矩阵 相减 像素 亮度 降低 504.7 按 
位操作 注 主要 是 黑白 图像处理 bitwiseAnd = cv2 . 
bitwise _ and rectangle circle # 当且仅当 俩个 相同 位置 
的 像素 大于 0 才 返回 真 bitwiseOr = cv2 
. bitwise _ or rectangle circle # 俩个 相同 位置 
的 像素 有一个 大于 0 返回 真 bitwiseXor = cv2 
. bitwise _ xor rectangle circle # 当且仅当 俩个 相同 
位置 的 像素 只有 一个 大于 0 才 返回 真 
bitwiseNot = cv2 . bitwise _ not circle # 像素 
值 取反 4.8 掩蔽 注 提取 图像 中 感兴趣 的 
部分 遮掩 的 必须 用 关键字 maskmask = np . 
zeros image . shape 2 dtype = uint8 # 设置 
掩蔽 画布 的 大小 cv2 . rectangle mask 0 90 
290 450 255 1 # 设置 不 掩蔽 的 地方 
masked = cv2 . bitwise _ and image image mask 
= mask # 图片 显示 的 区域 4.9 像素 分割 
与 合并 B G R = cv2 . split image 
# 像素 分离 图像 B G R 图像 的 值 
为 整数 非 BGR 像素 矩阵 组成 其 值 是 
如何 转变 的 merged = cv2 . merge B G 
R # 三个 色彩 合并 还原 为 彩色图像 像素 由 
BGR 像素 矩阵 组成 zeros = np . zeros image 
. shape 2 dtype = uint8 # 建立 一个 二 
值 画布 与 各个 色彩 通道 合并 像是 各个 色彩 
通道 的 影响 cv2 . imshow Red cv2 . merge 
zeros zeros R # 只有 红色 的 图片 cv2 . 
imshow Green cv2 . merge zeros G zeros # 只有 
绿色 的 图片 cv2 . imshow Blue cv2 . merge 
B zeros zeros # 只有 蓝色 的 图片 问 如何 
从 BGR 转换成 整 数值 5 内核 略 6 形态 
操作 image = cv2 . imread args image # 打开 
一张 图片 gray = cv2 . cvtColor image cv2 . 
COLOR _ BGR2GRAY # 将 图片 转为 二 值 划 
# 侵蚀 将 前景 物体 变小 理解 成将/nr 图像 断开 
裂缝 变大 在 图片 上 画上 黑色 印记 印记 越来越 
大 for i in xrange 0 3 eroded = cv2 
. erode gray . copy None iterations = i + 
1 # 参数 1 需要 侵蚀 的 图像 参数 2 
结构 元素 参数 3 迭代 次数 值 越大 侵蚀 越 
严重 cv2 . imshow Eroded { } times . format 
i + 1 eroded cv2 . waitKey 0 # 扩张 
将 前景 物体 变大 理解 成将/nr 图像 断开 裂缝 变小 
在 图片 上 画上 黑色 印记 印记 越来越 小 for 
i in xrange 0 3 dilated = cv2 . dilate 
gray . copy None iterations = i + 1 # 
参数 1 需要 侵蚀 的 图像 参数 2 结构 元素 
参数 3 迭代 次数 值 越大 扩张 越大 cv2 . 
imshow Dilated { } times . format i + 1 
dilated cv2 . waitKey 0 # 开盘 应用 侵蚀 以 
去除 小斑点 然后 应用 扩张 以 重新 生成 原始 对象 
的 大小 用于 消除 杂质 kernelSizes = 3 3 5 
5 7 7 # 定义 结构化 元素 的 宽度 和 
高度 for kernelSize in kernelSizes kernel = cv2 . g 
e t t r u c t u r i 
n g E l e m e n t cv2 
. MORPH _ RECT kernelSize # 参数 1 结构化 元素 
的 类型 参数 2 构造 元素 的 大小 opening = 
cv2 . morphologyEx gray cv2 . MORPH _ OPEN kernel 
# 参数 1 形态学 运算 的 图像 参数 2 形态 
操作 的 实际 类型 参数 3 内核 / 结构 化元素 
cv2 . imshow Opening { } { } . format 
kernelSize 0 kernelSize 1 opening cv2 . waitKey 0 形态 
操作 实际 类型 cv2 . MORPH _ CLOSE 闭幕 用于 
封闭 对象 内 的 孔 或将 组件 连接 在 一起 
cv2 . MORPH _ GRADIENT 形态 梯度 用于 确定 图像 
的 特定 对象 的 轮廓 # 顶帽 / 黑帽 显示 
黑色 背景 上 的 图像 的 明亮 区域 适合于 灰度 
图像 rectKernel = cv2 . g e t t r 
u c t u r i n g E l 
e m e n t cv2 . MORPH _ RECT 
13 5 # 定义 宽度 为 13 像素 和 高度 
为 5 像素 的 矩形 结构 元素 blackhat = cv2 
. morphologyEx gray cv2 . MORPH _ BLACKHAT rectKernel # 
参数 1 形态学 运算 的 图像 参数 2 形态 操作 
的 实际 类型 参数 3 内核 / 结构 化元素 tophat 
= cv2 . morphologyEx gray cv2 . MORPH _ TOPHAT 
rectKernel # 参数 1 形态学 运算 的 图像 参数 2 
形态 操作 的 实际 类型 参数 3 内核 / 结构 
化元素 7 平滑 和 模糊 kernelSizes = 3 3 9 
9 15 15 # 定义 内核 大小 参数 列表 内核 
越大 模糊 越 明显 # loop over the kernel sizes 
and apply an average blur to the image for kX 
kY in kernelSizes blurred = cv2 . blur image kX 
kY # 使用 平均 模糊 方法 参数 1 模糊 对象 
参数 2 矩阵 大小 cv2 . imshow Average { } 
{ } . format kX kY blurred cv2 . waitKey 
0 模糊 方法 平均 模糊 过度 模糊 图像 并 忽略 
重要 的 边缘 blurred = cv2 . blur image kX 
kY 高斯 保留 更多 的 图像 边缘 blurred = cv2 
. GaussianBlur image kX kY 0 参数 1 模糊 对象 
参数 2 矩阵 大小 参数 3 标准 方差 中位数 模糊 
图像 中 去除 盐 和 胡椒 图像 中 的 杂质 
点 blurred = cv2 . medianBlur image k 参数 1 
模糊 对象 参数 2 中位数 值 为 整型数据 数据 越大 
图像 越 模糊 双边 模糊 减少 噪音 同时 仍然 保持 
边缘 我们 可以 使用 双边 模糊 双边 模糊 通过 引入 
两个 高斯分布 来 实现 blurred = cv2 . bilateralFilter image 
diameter sigmaColor sigmaSpace 参数 1 想要 模糊 的 图像 参数 
2 像素 邻域 的 直径 这个 直径 越大 模糊 计算 
中 包含 的 像素 越多 参数 3 颜色 标准差 模糊 
时将/nr 考虑 邻域 中的 更多 颜色 相似 颜色 的 像素 
才能 显着 地 影响 模糊 参数 4 空间 标准偏差 更大 
的 值 意味着 像素 越 远离 中心 像素 直径 将 
影响 模糊 计算 后面 3个 参数 都为 整型 参数 8 
照明 和 色彩 空间 # RGB 红 黄 蓝 组成 
的 颜色 矩阵 每个 色度 值 范围 0 255 image 
= cv2 . imread args image for name chan in 
zip B G R cv2 . split image cv2 . 
imshow name chan # HSV 色调 H 们 正在 研究 
哪种 纯 的 颜色 饱和度 S 颜色 如何 白 例如 
纯红 随着 零 饱和度 的 颜色 是 纯白色 价值 V 
该 值 允许 我们 控制 我们 的 颜色 的 亮度 
零值 表示 纯 黑色 hsv = cv2 . cvtColor image 
cv2 . COLOR _ BGR2HSV for name chan in zip 
H S V cv2 . split hsv cv2 . imshow 
name chan # L * a * b * 表 
L 通道 像素 的 亮度 a 通道 源于 L 通道 
的 中心 在 频谱 的 一端 定义 纯 绿色 另一端 
定义 纯 红色 b 通道 也 来自 于L/nr 通道 的 
中心 但是 垂直于 a 通道 lab = cv2 . cvtColor 
image cv2 . COLOR _ BGR2LAB for name chan in 
zip L * a * b * cv2 . split 
lab cv2 . imshow name chan # 灰度 转换成 灰度级 
时 每个 RGB 通道 不是 均匀 加权 gray = cv2 
. cvtColor image cv2 . COLOR _ BGR2GRAY 9 阀值 
阀值 图像 的 二 值 化 image = cv2 . 
imread args image gray = cv2 . cvtColor image cv2 
. COLOR _ BGR2GRAY # 将 图像 二 值 化 
blurred = cv2 . GaussianBlur gray 7 7 0 T 
threshInv = cv2 . threshold blurred 200 255 cv2 . 
THRESH _ BINARY _ INV # 参数 1 希望 阈值 
的 灰度 图像 参数 2 手动 提供 我们 的 T 
阈值 参数 3 设置 输出 值 参数 4 阈值 方法 
白色 背景 黑色 图 将 像素 值 小于 参数 2 
的 值 换成 参数 3 输出 大于 参数 2 的 
值 输出 值 为 0 cv2 . imshow Threshold Binary 
Inverse threshInv T thresh = cv2 . threshold blurred 200 
255 cv2 . THRESH _ BINARY # 参数 1 希望 
阈值 的 灰度 图像 参数 2 手动 提供 我们 的 
T 阈值 参数 3 设置 输出 值 参数 4 阈值 
方法 黑 背景 白色 图 将 像素 值 大于 参数 
2 的 值 换成 参数 3 输出 小于 参数 2 
的 值 输出 值 为 0 cv2 . imshow Threshold 
Binary thresh cv2 . imshow Output cv2 . bitwise _ 
and image image mask = threshInv # 大津 方法 参数 
1 希望 阈值 的 灰度 图像 参数 2 大津 的 
方法 将 自动 计算 出 我们 的 T 的 最优 
值 参数 3 阈值 的 输出 值 只要 给定 像素 
通过 阈值 测试 参数 4 对应 于 Otsu 的 阈值 
法 T threshInv = cv2 . threshold blurred 0 255 
cv2 . THRESH _ BINARY _ INV | cv2 . 
THRESH _ OTSU # 自适应 阀值 法 参数 1 希望 
阈值 的 灰度 图像 参数 2 参数 是 输出 阈值 
参数 3 自适应 阈值 法 参数 4 阈值 方法 参数 
5 是 我们 的 像素 邻域 大小 参数 6 微调 
我们 的 阈值 thresh = cv2 . a d a 
p t i v e T h r e s 
h o l d blurred 255 cv2 . ADAPTIVE _ 
THRESH _ MEAN _ C cv2 . THRESH _ BINARY 
_ INV 25 15 thresh = threshold _ adaptive blurred 
29 offset = 5 . astype uint8 * 255 thresh 
= cv2 . bitwise _ not thresh # 阈值 适配 
函数 执行 自适应 阈值 10.1 图像 渐变 图像 渐变 图像 
梯度 主要 应用 与 边缘 检测 # Sobel 内核 gray 
= cv2 . cvtColor image cv2 . COLOR _ BGR2GRAY 
gX = cv2 . Sobel gray ddepth = cv2 . 
CV _ 64F dx = 1 dy = 0 # 
计算 x 方向 的 梯度 gY = cv2 . Sobel 
gray ddepth = cv2 . CV _ 64F dx = 
0 dy = 1 # 计算 y 方向 的 梯度 
gX = cv2 . convertScaleAbs gX # 转 换回 8位 
无符号 整型 gY = cv2 . convertScaleAbs gY # 转 
换回 8位 无符号 整型 sobelCombined = cv2 . addWeighted gX 
0.5 gY 0.5 0 # 将 俩个 图像 组合成 单个 
图像 gX = cv2 . Sobel gray cv2 . CV 
_ 64F 1 0 # 计算 x 梯度方向 gY = 
cv2 . Sobel gray cv2 . CV _ 64F 0 
1 # 计算 y 梯度方向 mag = np . sqrt 
gX * * 2 + gY * * 2 # 
梯度 幅度 计算 平方 梯度 的 平方根 X 和 ÿ 
相加 orientation = np . arctan2 gY gX * 180 
/ np . pi % 180 # 梯度方向 计算 两个 
梯度 的 反 正切 idxs = np . where orientation 
= args lower _ angle orientation 1 # 手柄 选择 
参数 1 函数 是 我们 要 测试 的 条件 寻找 
大于 最小 提供 角度 的 索引 参数 2 要 检查 
的 阵列 在哪里 参数 3 特 定值 设置 为 1 
idxs = np . where orientation = args upper _ 
angle idxs 1 mask = np . zeros gray . 
shape dtype = uint8 # 构造 一个 掩码 所有 具有 
相应 idxs 值 1 的 坐标 都 设置 为 255 
即 前景 否则 它们 保留 为 0 即 背景 mask 
idxs 1 = 25510.2 边缘 检测 边缘 类型 步边/nr 阶跃 
边缘 形式 当 存在 来自 不连续 到 另一 的 一侧 
的 像素 强度 的 突然 变化 斜坡 边缘 斜坡 边缘 
就像 一个 阶跃 边缘 仅在 像素 强度 的 变化 不是 
瞬时 的 相反 像素 值 的 变化 发生 短 而 
有限 的 距离 岭 边 脊 边缘 是 相似 于 
两个 结合     斜坡 边缘 一个 右 对 另一 
碰撞 屋顶 边 顶部 有 一个 短 而 有限 的 
高原 的 边缘 不同 边缘 检测法 对 图像 应用 高斯 
平滑 来 帮助 减少 噪点 使用 Sobel 内核 计算 和 
图像 渐变 应用 非 最大值 抑制 来 仅 保持 指向 
梯度方向 的 梯度 幅度 像素 的 局部 最大值 定义/n 和/c 
应用/v 和/c 阈值/n 滞后/v 阈值/n gray/w = cv2 . cvtColor 
image cv2 . COLOR _ BGR2GRAY blurred = cv2 . 
GaussianBlur gray 5 5 0 wide = cv2 . Canny 
blurred 10 200 # 参数 1 想要 检测 边缘 的 
图像 参数 2 和3/nr 分别 提供 阈值 下限 和 阈值 
上限 # 自动 调整 边缘 检测 参数 # 自动 调整 
边缘 检测 参数 函数 def auto _ canny image sigma 
= 0.33 v = np . median image lower = 
int max 0 1.0 sigma * v upper = int 
min 255 1.0 + sigma * v edged = cv2 
. Canny image lower upper return edged # 自动 调整 
边缘 检测 参数 函数 运用 blurred = cv2 . GaussianBlur 
gray 3 3 0 auto = imutils . auto _ 
canny blurred 11.1 查找 和 绘制 轮廓 gray = cv2 
. cvtColor image cv2 . COLOR _ BGR2GRAY cnts _ 
= cv2 . findContours gray . copy cv2 . RETR 
_ LIST cv2 . CHAIN _ APPROX _ SIMPLE # 
参数 1 需要 绘制 轮廓 的 图像 参数 2 返回 
的 轮廓 数量 的 标志 参数 3 轮廓 压缩 类型 
返回值 第一 个 值 是 轮廓 本上 第二个 值 是 
要 检查 的 轮廓 层次结构 clone = image . copy 
cv2 . drawContours clone cnts 1 0 255 0 2 
# 参数 1 要 绘制 轮廓 的 图像 参数 2 
使用 的 轮廓 列表 参数 3 cnts 列表 中 的 
轮廓 索引 1 表示 绘制 所有 轮廓 0 是 仅 
画 第一个 1 表示 绘制 第二个 轮廓 参数 3 绘制 
轮廓 的 颜色 参数 4 绘制 轮廓线 的 像素 # 
轮廓 单个 绘制 for i c in enumerate cnts print 
Drawing contour # { } . format i + 1 
cv2 . drawContours clone c 1 0 255 0 2 
cv2 . imshow Single Contour clone cv2 . waitKey 0 
# 返回 所有 轮廓 外观 cnts _ = cv2 . 
findContours gray . copy cv2 . RETR _ EXTERNAL cv2 
. CHAIN _ APPROX _ SIMPLE # 轮廓 外观 与 
掩码 的 一起 使用 for c in cnts # construct 
a mask by drawing only the current contour mask = 
np . zeros gray . shape dtype = uint8 cv2 
. drawContours mask c 1 255 1 # show the 
images cv2 . imshow Image image cv2 . imshow Mask 
mask cv2 . imshow Image + Mask cv2 . bitwise 
_ and image image mask = mask # 补充 运用 
霍夫 找 圆心 gray = cv2 . cvtColor img cv2 
. COLOR _ BGR2GRAY # 输出 图像 大小 方便 根据 
图像 大小 调节 minRadius 和 maxRadius print img . shape 
# 霍夫 变换 圆 检测 circles = cv2 . HoughCircles 
gray cv2 . HOUGH _ GRADIENT 1 100 param1 = 
100 param2 = 30 minRadius = 5 maxRadius = 300 
# 输出 返回值 方便 查看 类型 print circles # 输出 
检测 到 圆 的 个数 print len circles 0 # 
根据 检测 到 圆 的 信息 画出 每 一个 圆 
for circle in circles 0 # 圆 的 基本 信息 
print circle 2 # 坐标 行列 x = int circle 
0 y = int circle 1 # 半径 r = 
int circle 2 # 在 原图 用 指定 颜 色标 
记出 圆 的 位置 img = cv2 . circle img 
x y r 0 0 255 1 # 显示 新 
图像 cv2 . imshow res img 11.2 简单 的 轮廓 
属性 质心 质心 或 质心   是 图像 中 物体 
的 中心     x y 坐标 # 绘制 轮廓 
质心 cnts _ = cv2 . findContours gray . copy 
cv2 . RETR _ EXTERNAL cv2 . CHAIN _ APPROX 
_ SIMPLE clone = image . copy for c in 
cnts # compute the moments of the contour which can 
be used to compute the # centroid or center of 
mass of the region M = cv2 . moments c 
cX = int M m10 / M m00 cY = 
int M m01 / M m00 # draw the center 
of the contour on the image cv2 . circle clone 
cX cY 10 0 255 0 1 面积 和 周长 
轮廓 的 面积 是 轮廓 轮廓 内部 的 像素数 类 
似地     周长     有时 称为     
弧长 是 轮廓 的 长度 # 获取 轮廓 的 面积 
与 周长 for i c in enumerate cnts area = 
cv2 . contourArea c perimeter = cv2 . arcLength c 
True print Contour # % d area % . 2f 
perimeter % . 2f % i + 1 area perimeter 
cv2 . drawContours clone c 1 0 255 0 2 
# 计算 图像 的 质心 并在 图像 上 显示 轮廓 
数 以便 我们 可以 将 形状 与 终端 输出 相关联 
M = cv2 . moments c cX = int M 
m10 / M m00 # cY = int M m01 
/ M m00 # cv2 . putText clone # % 
d % i + 1 cX 20 cY cv2 . 
FONT _ HERSHEY _ SIMPLEX 1.25 255 255 255 4 
边框 边界 和 包含 整个 图像 的 轮廓 区域 for 
c in cnts # fit a bounding box to the 
contour x y w h = cv2 . boundingRect c 
cv2 . rectangle clone x y x + w y 
+ h 0 255 0 2 旋转 边框 # 绘制 
轮廓 的 旋转 边框 for c in cnts # fit 
a rotated bounding box to the contour and draw a 
rotated bounding box box = cv2 . minAreaRect c # 
参数 我们 的 轮廓 并 返回 一个 包含 3个 值 
的 元组 元组 的 第一 个 值 是 旋转 的 
边界 框 的 起始 x y 坐标 第二个 值 是 
边界 框 的 宽度 和 高度 而 最终 的 值 
就是 我们 形状 或 旋转 的 角度 box = np 
. int0 cv2 . cv . BoxPoints box # 宽度 
和 高度 以及 旋转角 转换 为 一组 坐标 点 cv2 
. drawContours clone box 1 0 255 0 2 最小 
封闭 圆 for c in cnts x y radius = 
cv2 . m i n E n c l o 
s i n g C i r c l e 
c # 返回 圆 的 中心 的 x y 坐标 
以及 圆 的 半径 cv2 . circle clone int x 
int y int radius 0 255 0 2 装配 椭圆 
将 椭圆 拟 合到 轮廓 上 很像 将 轮廓 的 
矩形 装 配到 轮廓 上 for c in cnts if 
len c = 5 ellipse = cv2 . fitEllipse c 
cv2 . ellipse clone ellipse 0 255 0 2 11.3 
高级 轮廓 长 宽比 宽高比 = 图像 宽度 / 图像 
宽度 程度 边界 框 区域 = 边界 框 宽度 X 
边框 高度 凸 海鸥 欧氏 空间 中 的 一组   
  X 点 凸包 是 包含 这些 X 点 的 
最小 可能 凸 集 密实度 坚固 度 = 轮廓 面积 
/ 凸包 面积 # 识别 X 与 O cnts _ 
= cv2 . findContours gray . copy cv2 . RETR 
_ EXTERNAL cv2 . CHAIN _ APPROX _ SIMPLE # 
获取 轮廓 列表 for i c in enumerate cnts area 
= cv2 . contourArea c # 获取 轮廓 面积 x 
y w h = cv2 . boundingRect c # 获取 
轮廓 的 起始 坐标 边界 的 宽度 和 高度 hull 
= cv2 . convexHull c # 获取 形状 的 实际 
凸包 hullArea = cv2 . contourArea hull # 计算 凸包 
面积 solidity = area / float hullArea # 获取 坚固 
度 char = # 依据 坚固 度 判断 图像 的 
形状 if solidity 0.9 char = O elif solidity 0.5 
char = X # 绘制 轮廓 if char = cv2 
. drawContours image c 1 0 255 0 3 cv2 
. putText image char x y 10 cv2 . FONT 
_ HERSHEY _ SIMPLEX 1.25 0 255 0 4 print 
% s Contour # % d solidity = % . 
2f % char i + 1 solidity cv2 . imshow 
Output image cv2 . waitKey 0 # 识别 俄罗斯 方块 
cnts _ = cv2 . findContours thresh . copy cv2 
. RETR _ EXTERNAL cv2 . CHAIN _ APPROX _ 
SIMPLE # 获取 图 片中 的 轮廓 列表 hullImage = 
np . zeros gray . shape 2 dtype = uint8 
for i c in enumerate cnts area = cv2 . 
contourArea c # 获取 轮廓 面积 x y w h 
= cv2 . boundingRect c # 获取 轮廓 边界 aspectRatio 
= w / float h # 获取 宽高比 extent = 
area / float w * h # 获取 当前 轮廓 
的 范围 hull = cv2 . convexHull c hullArea = 
cv2 . contourArea hull # solidity = area / float 
hullArea # 获取 坚固 度 依据 坚固 度 判断 物体 
形状 cv2 . drawContours hullImage hull 1 255 1 cv2 
. drawContours image c 1 240 0 159 3 shape 
= 11.4 轮廓 近似 轮廓 逼近 一种 用 减少 的 
点集合 减少 曲线 中的 点数 的 算法 简单 的 称为 
分裂 合并 算法 # 检测 图像 中 的 正方形 import 
cv2 image = cv2 . imread images / circles _ 
and _ squares . png gray = cv2 . cvtColor 
image cv2 . COLOR _ BGR2GRAY # 获得 图像 轮廓 
列表 cnts _ = cv2 . findContours gray . copy 
cv2 . RETR _ EXTERNAL cv2 . CHAIN _ APPROX 
_ SIMPLE # 循环 每个 轮廓 for c in cnts 
# 获取 轮廓 的 周长 peri = cv2 . arcLength 
c True approx = cv2 . approxPolyDP c 0.01 * 
peri True if len approx = = 4 #/i 判断/v 
处理/v 后的/nr 轮廓/n 是否/v 有/v 4个/mq 顶点/n # draw the 
outline of the contour and draw the text on the 
image cv2 . drawContours image c 1 0 255 255 
2 x y w h = cv2 . boundingRect approx 
cv2 . putText image Rectangle x y 10 cv2 . 
FONT _ HERSHEY _ SIMPLEX 0.5 0 255 255 2 
cv2 . imshow Image image cv2 . waitKey 0 物体 
轮廓 检测 import cv2 image = cv2 . imread images 
/ receipt . png gray = cv2 . cvtColor image 
cv2 . COLOR _ BGR2GRAY edged = cv2 . Canny 
gray 75 200 cv2 . imshow Original image cv2 . 
imshow Edge Map edged cnts _ = cv2 . findContours 
edged . copy cv2 . RETR _ EXTERNAL cv2 . 
CHAIN _ APPROX _ SIMPLE cnts = sorted cnts key 
= cv2 . contourArea reverse = True 7 # loop 
over the contours for c in cnts peri = cv2 
. arcLength c True approx = cv2 . approxPolyDP c 
0.01 * peri True print original { } approx { 
} . format len c len approx if len approx 
= = 4 cv2 . drawContours image approx 1 0 
255 0 2 cv2 . imshow Output image cv2 . 
waitKey 0 11.5 排列 轮廓 import numpy as np import 
argparse import cv2 # 参数 1 轮廓 列表 参数 2 
排列 方法 def sort _ contours cnts method = left 
to right reverse = False i = 0 if method 
= = right to left or method = = bottom 
to top reverse = True if method = = top 
to bottom or method = = bottom to top i 
= 1 boundingBoxes = cv2 . boundingRect c for c 
in cnts cnts boundingBoxes = zip * sorted zip cnts 
boundingBoxes key = lambda b b 1 i reverse = 
reverse return cnts boundingBoxes def draw _ contour image c 
i M = cv2 . moments c cX = int 
M m10 / M m00 cY = int M m01 
/ M m00 cv2 . putText image # { } 
. format i + 1 cX 20 cY cv2 . 
FONT _ HERSHEY _ SIMPLEX 1.0 255 255 255 2 
return image ap = argparse . ArgumentParser ap . add 
_ argument i image required = True help = Path 
to the input image ap . add _ argument m 
method required = True help = Sorting method args = 
vars ap . parse _ args image = cv2 . 
imread args image accumEdged = np . zeros image . 
shape 2 dtype = uint8 for chan in cv2 . 
split image chan = cv2 . medianBlur chan 11 edged 
= cv2 . Canny chan 50 200 accumEdged = cv2 
. bitwise _ or accumEdged edged cv2 . imshow Edge 
Map accumEdged cnts _ = cv2 . findContours accumEdged . 
copy cv2 . RETR _ EXTERNAL cv2 . CHAIN _ 
APPROX _ SIMPLE cnts = sorted cnts key = cv2 
. contourArea reverse = True 5 orig = image . 
copy for i c in enumerate cnts orig = draw 
_ contour orig c i cv2 . imshow Unsorted orig 
cnts boundingBoxes = sort _ contours cnts method = args 
method for i c in enumerate cnts draw _ contour 
image c i cv2 . imshow Sorted image cv2 . 
waitKey 0 12 直方图 直方图 表示 图像 中 的 像素 
强度 运用 cv2 . calcHist 函数 构建 直方图 cv2 . 
calcHist 图像 通道 掩码 histSize 范围 参数 详解 图像 我们 
要 计算 的 直方图 的 图像 通道 索引 列表 其中 
指定 要 计算 直方图 的 通道 的 索引 掩码 提供 
一个 掩码 那么 只对 被 掩盖 的 像素 计算 一个 
直方图 histSize 计算 直方图 时要/nr 使用 的 分组 数 范围 
可能 的 像素 值 的 范围 # 灰度 直方图 from 
matplotlib import pyplot as plt import argparse import cv2 ap 
= argparse . ArgumentParser ap . add _ argument i 
image required = True help = Path to the image 
args = vars ap . parse _ args image = 
cv2 . imread args image image = cv2 . cvtColor 
image cv2 . COLOR _ BGR2GRAY cv2 . imshow Original 
image hist = cv2 . calcHist image 0 None 256 
0 256 plt . figure plt . title Grayscale Histogram 
plt . xlabel Bins plt . ylabel # of Pixels 
plt . plot hist plt . xlim 0 256 hist 
/ = hist . sum plt . figure plt . 
title Grayscale Histogram Normalized plt . xlabel Bins plt . 
ylabel % of Pixels plt . plot hist plt . 
xlim 0 256 plt . show # 颜色 直方图 from 
matplotlib import pyplot as plt import argparse import cv2 ap 
= argparse . ArgumentParser ap . add _ argument i 
image required = True help = Path to the image 
args = vars ap . parse _ args image = 
cv2 . imread args image cv2 . imshow Original image 
chans = cv2 . split image colors = b g 
r plt . figure plt . title Flattened Color Histogram 
plt . xlabel Bins plt . ylabel # of Pixels 
for chan color in zip chans colors hist = cv2 
. calcHist chan 0 None 256 0 256 plt . 
plot hist color = color plt . xlim 0 256 
fig = plt . figure ax = fig . add 
_ subplot 131 hist = cv2 . calcHist chans 1 
chans 0 0 1 None 32 32 0 256 0 
256 p = ax . imshow hist interpolation = nearest 
ax . set _ title 2D Color Histogram for G 
and B plt . colorbar p ax = fig . 
add _ subplot 132 hist = cv2 . calcHist chans 
1 chans 2 0 1 None 32 32 0 256 
0 256 p = ax . imshow hist interpolation = 
nearest ax . set _ title 2D Color Histogram for 
G and R plt . colorbar p ax = fig 
. add _ subplot 133 hist = cv2 . calcHist 
chans 0 chans 2 0 1 None 32 32 0 
256 0 256 p = ax . imshow hist interpolation 
= nearest ax . set _ title 2D Color Histogram 
for B and R plt . colorbar p print 2D 
histogram shape % s with % d values % hist 
. shape hist . flatten . shape 0 hist = 
cv2 . calcHist image 0 1 2 None 8 8 
8 0 256 0 256 0 256 print 3D histogram 
shape % s with % d values % hist . 
shape hist . flatten . shape 0 plt . show 
# 直方图 均衡 import argparse import cv2 # construct the 
argument parser and parse the arguments ap = argparse . 
ArgumentParser ap . add _ argument i image required = 
True help = Path to the image args = vars 
ap . parse _ args # load the image and 
convert it to grayscale image = cv2 . imread args 
image image = cv2 . cvtColor image cv2 . COLOR 
_ BGR2GRAY # apply histogram equalization to stretch the constrast 
of our image eq = cv2 . equalizeHist image # 
show our images notice how the constrast of the second 
image has # been stretched cv2 . imshow Original image 
cv2 . imshow Histogram Equalization eq cv2 . waitKey 0 
# 直方图 和 面具 from matplotlib import pyplot as plt 
import numpy as np import cv2 def plot _ histogram 
image title mask = None chans = cv2 . split 
image colors = b g r plt . figure plt 
. title title plt . xlabel Bins plt . ylabel 
# of Pixels for chan color in zip chans colors 
hist = cv2 . calcHist chan 0 mask 256 0 
256 plt . plot hist color = color plt . 
xlim 0 256 image = cv2 . imread beach . 
png cv2 . imshow Original image plot _ histogram image 
Histogram for Original Image mask = np . zeros image 
. shape 2 dtype = uint8 cv2 . rectangle mask 
60 290 210 390 255 1 cv2 . imshow Mask 
mask masked = cv2 . bitwise _ and image image 
mask = mask cv2 . imshow Applying the Mask masked 
plot _ histogram image Histogram for Masked Image mask = 
mask plt . show 13 连接 分量 标签 略 1 加载 显示 保存 图像 import argparse import cv2 ap 
= argparse . ArgumentParser ap . add _ argument i 
image required = True help = Path to the image 
# 读取 指定 指令 获取 图片 参数 1 输入 指令 
的 头 字母 参数 2 需要 输入 的 指令 args 
= vars ap . parse _ args image = cv2 
. imread args image # 读取 指定 参数 的 读取 
照片 print width % d pixels % image . shape 
1 # 获取 图像 的 宽度 横向 尺寸 图像 坐标系 
中 第二个 参数 print height % d pixels % image 
. shape 0 # 获取 图像 的 高度 竖向 尺寸 
图像 坐标系 中 第一 个 参数 注意 读取 图像 x 
y 互换 print channels % d % image . shape 
2 cv2 . imshow Image image # 显示 图片 cv2 
. imwrite newimage . jpg image # 将 图片 写入 
指定 路径 cv2 . waitKey 0 # 等待 程序 结束 
2 图像 基础 h w = image . shape 2 
# x y 像素 中的 显示 获取 图片 的 高度 
x 获取 图片 的 宽度 y b g r = 
image 0 0 # 获取 指定 位置 的 像素 存储 
方式 为 bgr cX cY = w / 2 h 
/ 2 # cX 图片 的 宽度 cY 图片 高度 
tl = image 0 cY 0 cX # 获取 图片 
的 左上角 部分 起始 点 x 坐标 终点 x 坐标 
起点 的 y 坐标 终点 y 坐标 得出 的 值 
分别 指 高度 和 宽度 # 运用 像素 指定 位置 
赋值 方法 向 Background 图片 上 插入 图片 resized _ 
left for left _ x in xrange 0 500 1 
for left _ y in xrange 0 500 1 Background 
400 + left _ x 20 + left _ y 
= resized _ left left _ x left _ y 
3 绘图 canvas = np . zeros 300 300 3 
dtype = uint8 # 设置 画布 尺寸 green = 0 
255 0 # 设置 线条 颜色 cv2 . line canvas 
0 0 300 300 green # 参数 1 指定 画布 
参数 2 线条 的 开始 位置 参数 3 线条 终点 
位置 参数 4 线条 颜色 cv2 . line canvas 300 
0 0 300 red 3 # 参数 5 线条 像素 
厚度 cv2 . rectangle canvas 10 10 60 60 green 
# 参数 1 指定 画布 参数 2 矩形 起点 位置 
参数 3 矩形 对角线 点 的 位置 线条 颜色 cv2 
. rectangle canvas 50 200 200 225 red 5 # 
参数 5 线条 宽度 负数 表示 填充 矩形 centerX centerY 
= canvas . shape 1 / 2 canvas . shape 
0 / 2 # 设置 圆 心坐标 white = 255 
255 255 # 设置 圆 的 线条 颜色 cv2 . 
circle canvas centerX centerY r white # 参数 1 画布 
参数 2 圆心点 参数 3 设置 圆 的 半径 设置 
画圆 的 线条 颜色 cv2 . circle canvas tuple pt 
radius color 1 # 参数 4 设置 画圆 的 线条 
粗细 如果 为 负数 表示 填充 圆 4 图像处理 4.1 
翻译 M = np . float32 1 0 50 0 
1 90 # 定义 翻译 矩阵 参数 1 1 0 
x x 表示 像素 向左 或者 向右 移动 个数 x 
为 负值 图像 左移 正值 为 右移 定 参数 2 
0 1 y y 表示 像素 上下 移动 y 为 
负值 向上 移动 正值 向下 移动 记忆 口诀 前 左负右/nr 
正 后上 负 下 正 shifted = cv2 . warpAffine 
image M image . shape 1 image . shape 0 
# 对 矩阵 进行 翻译 参数 1 翻译 的 目标 
图像 参数 2 翻译 的 矩阵 参数 3 翻译 后 
图像 大小 # imutils 模块 的 翻译 函数 shifted = 
imutils . translate image 0 100 # 参数 1 移动 
的 目标 图像 参数 2 左右 移动 的 值 参数 
3 上下 移动 的 值 注 不会 改变 图像 大小 
4.2 旋 转注 运用 翻译 将 图片 移到 中心 位置 
四周 留出 黑色 边框 在 运用 旋转 旋转 角度 为 
0 可将 图片 放大 h w = image . shape 
2 #/i 获取/v 图像/n 的/uj 高和宽/nr cX cY = w 
/ 2 h / 2 # 获取 图像 的 中心点 
M = cv2 . g e t R o t 
a t i o n M a t r i 
x 2 D cX cY 45 1.0 # 设置 旋转 
矩阵 参数 1 旋转 点 参数 2 旋转 角度 正值 
逆时针 旋转 负值 顺时针 选装 参数 3 旋转 后 图像 
与 原始 图像 的 比例 图像 原始 大小 不会 发生 
变化 类似 相机 焦距 变化 rotated = cv2 . warpAffine 
image M w h # 参数 1 目标 图像 参数 
2 旋转 矩阵 参数 3 # 旋转 后的/nr 图像 尺寸 
# imutils 模块 的 旋转 函数 rotated = imutils . 
rotate image 180 # 参数 1 旋转 目标 图片 参数 
2 旋转 角度 center = x y 可以 设置 旋转 
点 4.3 图像 大小 调整 注 改变 原始 图片 的 
实际 大小 r = 150.0 / image . shape 1 
# 新 图像 与 旧 图像 的 宽 比例 注 
方便 图片 按 原 比例 缩放 dim = 150 int 
image . shape 0 * r # 设置 新 图像 
的 像素 尺寸 resized = cv2 . resize image dim 
interpolation = cv2 . INTER _ AREA # 调整 图像 
大小 返回 一个 新 图像 # 运用 imutils 中的 resize 
函数 resized = imutils . resize image width = 100 
# 参数 1 目标 图像 参数 2 设置 新 图像 
的 宽度 可以为 height 运用 高度 # 运用 插值 方法 
缩 放大 图片 通过 不同 的 像素 填充 方法 放大 
图片 resized = imutils . resize image width = image 
. shape 1 * 3 inter = method # 参数 
1 目标 图片 参数 2 处理 后 图片 像素 宽 
整形 参数 3 像素 处理 方法 method cv2 . INTER 
_ NEAREST 最 近邻 内 插值 cv2 . INTER _ 
LINEAR 双 线性插值 cv2 . INTER _ AREA 区域 插值 
cv2 . INTER _ CUBIC 双 三次 插值 cv2 . 
INTER _ LANCZOS4 双 三次 插值 4.4 图像 翻转 flipped 
= cv2 . flip image 1 # 水平 翻转 flipped 
= cv2 . flip image 0 # 上下 翻转 flipped 
= cv2 . flip image 1 # 水平 翻转 后 
上下 翻转 4.5 图像 裁剪 face = image 85 250 
85 220 # 参数 1 裁切 高度 x 开始 位置 
x 结束 位置 参数 2 裁切 宽度 y 开始 位置 
y 结束 位置 返回 新 图片 4.6 图像 像素 像素 
值 操作 注 修改 图片 的 亮度 M = np 
. ones image . shape dtype = uint8 * 100 
# 设置 与 图片 大 下 相同 的 矩阵 矩阵 
填 充值 为 100 added = cv2 . add image 
M # 将 原始 图片 与 新 矩阵 相加 像素 
亮 度提高 100 M = np . ones image . 
shape dtype = uint8 * 50 # 设置 与 图片 
大 下 相同 的 矩阵 矩阵 填 充值 为 50 
subtracted = cv2 . subtract image M # 将 原始 
图片 与 新 矩阵 相减 像素 亮度 降低 504.7 按 
位操作 注 主要 是 黑白 图像处理 bitwiseAnd = cv2 . 
bitwise _ and rectangle circle # 当且仅当 俩个 相同 位置 
的 像素 大于 0 才 返回 真 bitwiseOr = cv2 
. bitwise _ or rectangle circle # 俩个 相同 位置 
的 像素 有一个 大于 0 返回 真 bitwiseXor = cv2 
. bitwise _ xor rectangle circle # 当且仅当 俩个 相同 
位置 的 像素 只有 一个 大于 0 才 返回 真 
bitwiseNot = cv2 . bitwise _ not circle # 像素 
值 取反 4.8 掩蔽 注 提取 图像 中 感兴趣 的 
部分 遮掩 的 必须 用 关键字 maskmask = np . 
zeros image . shape 2 dtype = uint8 # 设置 
掩蔽 画布 的 大小 cv2 . rectangle mask 0 90 
290 450 255 1 # 设置 不 掩蔽 的 地方 
masked = cv2 . bitwise _ and image image mask 
= mask # 图片 显示 的 区域 4.9 像素 分割 
与 合并 B G R = cv2 . split image 
# 像素 分离 图像 B G R 图像 的 值 
为 整数 非 BGR 像素 矩阵 组成 其 值 是 
如何 转变 的 merged = cv2 . merge B G 
R # 三个 色彩 合并 还原 为 彩色图像 像素 由 
BGR 像素 矩阵 组成 zeros = np . zeros image 
. shape 2 dtype = uint8 # 建立 一个 二 
值 画布 与 各个 色彩 通道 合并 像是 各个 色彩 
通道 的 影响 cv2 . imshow Red cv2 . merge 
zeros zeros R # 只有 红色 的 图片 cv2 . 
imshow Green cv2 . merge zeros G zeros # 只有 
绿色 的 图片 cv2 . imshow Blue cv2 . merge 
B zeros zeros # 只有 蓝色 的 图片 问 如何 
从 BGR 转换成 整 数值 5 内核 略 6 形态 
操作 image = cv2 . imread args image # 打开 
一张 图片 gray = cv2 . cvtColor image cv2 . 
COLOR _ BGR2GRAY # 将 图片 转为 二 值 划 
# 侵蚀 将 前景 物体 变小 理解 成将/nr 图像 断开 
裂缝 变大 在 图片 上 画上 黑色 印记 印记 越来越 
大 for i in xrange 0 3 eroded = cv2 
. erode gray . copy None iterations = i + 
1 # 参数 1 需要 侵蚀 的 图像 参数 2 
结构 元素 参数 3 迭代 次数 值 越大 侵蚀 越 
严重 cv2 . imshow Eroded { } times . format 
i + 1 eroded cv2 . waitKey 0 # 扩张 
将 前景 物体 变大 理解 成将/nr 图像 断开 裂缝 变小 
在 图片 上 画上 黑色 印记 印记 越来越 小 for 
i in xrange 0 3 dilated = cv2 . dilate 
gray . copy None iterations = i + 1 # 
参数 1 需要 侵蚀 的 图像 参数 2 结构 元素 
参数 3 迭代 次数 值 越大 扩张 越大 cv2 . 
imshow Dilated { } times . format i + 1 
dilated cv2 . waitKey 0 # 开盘 应用 侵蚀 以 
去除 小斑点 然后 应用 扩张 以 重新 生成 原始 对象 
的 大小 用于 消除 杂质 kernelSizes = 3 3 5 
5 7 7 # 定义 结构化 元素 的 宽度 和 
高度 for kernelSize in kernelSizes kernel = cv2 . g 
e t t r u c t u r i 
n g E l e m e n t cv2 
. MORPH _ RECT kernelSize # 参数 1 结构化 元素 
的 类型 参数 2 构造 元素 的 大小 opening = 
cv2 . morphologyEx gray cv2 . MORPH _ OPEN kernel 
# 参数 1 形态学 运算 的 图像 参数 2 形态 
操作 的 实际 类型 参数 3 内核 / 结构 化元素 
cv2 . imshow Opening { } { } . format 
kernelSize 0 kernelSize 1 opening cv2 . waitKey 0 形态 
操作 实际 类型 cv2 . MORPH _ CLOSE 闭幕 用于 
封闭 对象 内 的 孔 或将 组件 连接 在 一起 
cv2 . MORPH _ GRADIENT 形态 梯度 用于 确定 图像 
的 特定 对象 的 轮廓 # 顶帽 / 黑帽 显示 
黑色 背景 上 的 图像 的 明亮 区域 适合于 灰度 
图像 rectKernel = cv2 . g e t t r 
u c t u r i n g E l 
e m e n t cv2 . MORPH _ RECT 
13 5 # 定义 宽度 为 13 像素 和 高度 
为 5 像素 的 矩形 结构 元素 blackhat = cv2 
. morphologyEx gray cv2 . MORPH _ BLACKHAT rectKernel # 
参数 1 形态学 运算 的 图像 参数 2 形态 操作 
的 实际 类型 参数 3 内核 / 结构 化元素 tophat 
= cv2 . morphologyEx gray cv2 . MORPH _ TOPHAT 
rectKernel # 参数 1 形态学 运算 的 图像 参数 2 
形态 操作 的 实际 类型 参数 3 内核 / 结构 
化元素 7 平滑 和 模糊 kernelSizes = 3 3 9 
9 15 15 # 定义 内核 大小 参数 列表 内核 
越大 模糊 越 明显 # loop over the kernel sizes 
and apply an average blur to the image for kX 
kY in kernelSizes blurred = cv2 . blur image kX 
kY # 使用 平均 模糊 方法 参数 1 模糊 对象 
参数 2 矩阵 大小 cv2 . imshow Average { } 
{ } . format kX kY blurred cv2 . waitKey 
0 模糊 方法 平均 模糊 过度 模糊 图像 并 忽略 
重要 的 边缘 blurred = cv2 . blur image kX 
kY 高斯 保留 更多 的 图像 边缘 blurred = cv2 
. GaussianBlur image kX kY 0 参数 1 模糊 对象 
参数 2 矩阵 大小 参数 3 标准 方差 中位数 模糊 
图像 中 去除 盐 和 胡椒 图像 中 的 杂质 
点 blurred = cv2 . medianBlur image k 参数 1 
模糊 对象 参数 2 中位数 值 为 整型数据 数据 越大 
图像 越 模糊 双边 模糊 减少 噪音 同时 仍然 保持 
边缘 我们 可以 使用 双边 模糊 双边 模糊 通过 引入 
两个 高斯分布 来 实现 blurred = cv2 . bilateralFilter image 
diameter sigmaColor sigmaSpace 参数 1 想要 模糊 的 图像 参数 
2 像素 邻域 的 直径 这个 直径 越大 模糊 计算 
中 包含 的 像素 越多 参数 3 颜色 标准差 模糊 
时将/nr 考虑 邻域 中的 更多 颜色 相似 颜色 的 像素 
才能 显着 地 影响 模糊 参数 4 空间 标准偏差 更大 
的 值 意味着 像素 越 远离 中心 像素 直径 将 
影响 模糊 计算 后面 3个 参数 都为 整型 参数 8 
照明 和 色彩 空间 # RGB 红 黄 蓝 组成 
的 颜色 矩阵 每个 色度 值 范围 0 255 image 
= cv2 . imread args image for name chan in 
zip B G R cv2 . split image cv2 . 
imshow name chan # HSV 色调 H 们 正在 研究 
哪种 纯 的 颜色 饱和度 S 颜色 如何 白 例如 
纯红 随着 零 饱和度 的 颜色 是 纯白色 价值 V 
该 值 允许 我们 控制 我们 的 颜色 的 亮度 
零值 表示 纯 黑色 hsv = cv2 . cvtColor image 
cv2 . COLOR _ BGR2HSV for name chan in zip 
H S V cv2 . split hsv cv2 . imshow 
name chan # L * a * b * 表 
L 通道 像素 的 亮度 a 通道 源于 L 通道 
的 中心 在 频谱 的 一端 定义 纯 绿色 另一端 
定义 纯 红色 b 通道 也 来自 于L/nr 通道 的 
中心 但是 垂直于 a 通道 lab = cv2 . cvtColor 
image cv2 . COLOR _ BGR2LAB for name chan in 
zip L * a * b * cv2 . split 
lab cv2 . imshow name chan # 灰度 转换成 灰度级 
时 每个 RGB 通道 不是 均匀 加权 gray = cv2 
. cvtColor image cv2 . COLOR _ BGR2GRAY 9 阀值 
阀值 图像 的 二 值 化 image = cv2 . 
imread args image gray = cv2 . cvtColor image cv2 
. COLOR _ BGR2GRAY # 将 图像 二 值 化 
blurred = cv2 . GaussianBlur gray 7 7 0 T 
threshInv = cv2 . threshold blurred 200 255 cv2 . 
THRESH _ BINARY _ INV # 参数 1 希望 阈值 
的 灰度 图像 参数 2 手动 提供 我们 的 T 
阈值 参数 3 设置 输出 值 参数 4 阈值 方法 
白色 背景 黑色 图 将 像素 值 小于 参数 2 
的 值 换成 参数 3 输出 大于 参数 2 的 
值 输出 值 为 0 cv2 . imshow Threshold Binary 
Inverse threshInv T thresh = cv2 . threshold blurred 200 
255 cv2 . THRESH _ BINARY # 参数 1 希望 
阈值 的 灰度 图像 参数 2 手动 提供 我们 的 
T 阈值 参数 3 设置 输出 值 参数 4 阈值 
方法 黑 背景 白色 图 将 像素 值 大于 参数 
2 的 值 换成 参数 3 输出 小于 参数 2 
的 值 输出 值 为 0 cv2 . imshow Threshold 
Binary thresh cv2 . imshow Output cv2 . bitwise _ 
and image image mask = threshInv # 大津 方法 参数 
1 希望 阈值 的 灰度 图像 参数 2 大津 的 
方法 将 自动 计算 出 我们 的 T 的 最优 
值 参数 3 阈值 的 输出 值 只要 给定 像素 
通过 阈值 测试 参数 4 对应 于 Otsu 的 阈值 
法 T threshInv = cv2 . threshold blurred 0 255 
cv2 . THRESH _ BINARY _ INV | cv2 . 
THRESH _ OTSU # 自适应 阀值 法 参数 1 希望 
阈值 的 灰度 图像 参数 2 参数 是 输出 阈值 
参数 3 自适应 阈值 法 参数 4 阈值 方法 参数 
5 是 我们 的 像素 邻域 大小 参数 6 微调 
我们 的 阈值 thresh = cv2 . a d a 
p t i v e T h r e s 
h o l d blurred 255 cv2 . ADAPTIVE _ 
THRESH _ MEAN _ C cv2 . THRESH _ BINARY 
_ INV 25 15 thresh = threshold _ adaptive blurred 
29 offset = 5 . astype uint8 * 255 thresh 
= cv2 . bitwise _ not thresh # 阈值 适配 
函数 执行 自适应 阈值 10.1 图像 渐变 图像 渐变 图像 
梯度 主要 应用 与 边缘 检测 # Sobel 内核 gray 
= cv2 . cvtColor image cv2 . COLOR _ BGR2GRAY 
gX = cv2 . Sobel gray ddepth = cv2 . 
CV _ 64F dx = 1 dy = 0 # 
计算 x 方向 的 梯度 gY = cv2 . Sobel 
gray ddepth = cv2 . CV _ 64F dx = 
0 dy = 1 # 计算 y 方向 的 梯度 
gX = cv2 . convertScaleAbs gX # 转 换回 8位 
无符号 整型 gY = cv2 . convertScaleAbs gY # 转 
换回 8位 无符号 整型 sobelCombined = cv2 . addWeighted gX 
0.5 gY 0.5 0 # 将 俩个 图像 组合成 单个 
图像 gX = cv2 . Sobel gray cv2 . CV 
_ 64F 1 0 # 计算 x 梯度方向 gY = 
cv2 . Sobel gray cv2 . CV _ 64F 0 
1 # 计算 y 梯度方向 mag = np . sqrt 
gX * * 2 + gY * * 2 # 
梯度 幅度 计算 平方 梯度 的 平方根 X 和 ÿ 
相加 orientation = np . arctan2 gY gX * 180 
/ np . pi % 180 # 梯度方向 计算 两个 
梯度 的 反 正切 idxs = np . where orientation 
= args lower _ angle orientation 1 # 手柄 选择 
参数 1 函数 是 我们 要 测试 的 条件 寻找 
大于 最小 提供 角度 的 索引 参数 2 要 检查 
的 阵列 在哪里 参数 3 特 定值 设置 为 1 
idxs = np . where orientation = args upper _ 
angle idxs 1 mask = np . zeros gray . 
shape dtype = uint8 # 构造 一个 掩码 所有 具有 
相应 idxs 值 1 的 坐标 都 设置 为 255 
即 前景 否则 它们 保留 为 0 即 背景 mask 
idxs 1 = 25510.2 边缘 检测 边缘 类型 步边/nr 阶跃 
边缘 形式 当 存在 来自 不连续 到 另一 的 一侧 
的 像素 强度 的 突然 变化 斜坡 边缘 斜坡 边缘 
就像 一个 阶跃 边缘 仅在 像素 强度 的 变化 不是 
瞬时 的 相反 像素 值 的 变化 发生 短 而 
有限 的 距离 岭 边 脊 边缘 是 相似 于 
两个 结合     斜坡 边缘 一个 右 对 另一 
碰撞 屋顶 边 顶部 有 一个 短 而 有限 的 
高原 的 边缘 不同 边缘 检测法 对 图像 应用 高斯 
平滑 来 帮助 减少 噪点 使用 Sobel 内核 计算 和 
图像 渐变 应用 非 最大值 抑制 来 仅 保持 指向 
梯度方向 的 梯度 幅度 像素 的 局部 最大值 定义/n 和/c 
应用/v 和/c 阈值/n 滞后/v 阈值/n gray/w = cv2 . cvtColor 
image cv2 . COLOR _ BGR2GRAY blurred = cv2 . 
GaussianBlur gray 5 5 0 wide = cv2 . Canny 
blurred 10 200 # 参数 1 想要 检测 边缘 的 
图像 参数 2 和3/nr 分别 提供 阈值 下限 和 阈值 
上限 # 自动 调整 边缘 检测 参数 # 自动 调整 
边缘 检测 参数 函数 def auto _ canny image sigma 
= 0.33 v = np . median image lower = 
int max 0 1.0 sigma * v upper = int 
min 255 1.0 + sigma * v edged = cv2 
. Canny image lower upper return edged # 自动 调整 
边缘 检测 参数 函数 运用 blurred = cv2 . GaussianBlur 
gray 3 3 0 auto = imutils . auto _ 
canny blurred 11.1 查找 和 绘制 轮廓 gray = cv2 
. cvtColor image cv2 . COLOR _ BGR2GRAY cnts _ 
= cv2 . findContours gray . copy cv2 . RETR 
_ LIST cv2 . CHAIN _ APPROX _ SIMPLE # 
参数 1 需要 绘制 轮廓 的 图像 参数 2 返回 
的 轮廓 数量 的 标志 参数 3 轮廓 压缩 类型 
返回值 第一 个 值 是 轮廓 本上 第二个 值 是 
要 检查 的 轮廓 层次结构 clone = image . copy 
cv2 . drawContours clone cnts 1 0 255 0 2 
# 参数 1 要 绘制 轮廓 的 图像 参数 2 
使用 的 轮廓 列表 参数 3 cnts 列表 中 的 
轮廓 索引 1 表示 绘制 所有 轮廓 0 是 仅 
画 第一个 1 表示 绘制 第二个 轮廓 参数 3 绘制 
轮廓 的 颜色 参数 4 绘制 轮廓线 的 像素 # 
轮廓 单个 绘制 for i c in enumerate cnts print 
Drawing contour # { } . format i + 1 
cv2 . drawContours clone c 1 0 255 0 2 
cv2 . imshow Single Contour clone cv2 . waitKey 0 
# 返回 所有 轮廓 外观 cnts _ = cv2 . 
findContours gray . copy cv2 . RETR _ EXTERNAL cv2 
. CHAIN _ APPROX _ SIMPLE # 轮廓 外观 与 
掩码 的 一起 使用 for c in cnts # construct 
a mask by drawing only the current contour mask = 
np . zeros gray . shape dtype = uint8 cv2 
. drawContours mask c 1 255 1 # show the 
images cv2 . imshow Image image cv2 . imshow Mask 
mask cv2 . imshow Image + Mask cv2 . bitwise 
_ and image image mask = mask # 补充 运用 
霍夫 找 圆心 gray = cv2 . cvtColor img cv2 
. COLOR _ BGR2GRAY # 输出 图像 大小 方便 根据 
图像 大小 调节 minRadius 和 maxRadius print img . shape 
# 霍夫 变换 圆 检测 circles = cv2 . HoughCircles 
gray cv2 . HOUGH _ GRADIENT 1 100 param1 = 
100 param2 = 30 minRadius = 5 maxRadius = 300 
# 输出 返回值 方便 查看 类型 print circles # 输出 
检测 到 圆 的 个数 print len circles 0 # 
根据 检测 到 圆 的 信息 画出 每 一个 圆 
for circle in circles 0 # 圆 的 基本 信息 
print circle 2 # 坐标 行列 x = int circle 
0 y = int circle 1 # 半径 r = 
int circle 2 # 在 原图 用 指定 颜 色标 
记出 圆 的 位置 img = cv2 . circle img 
x y r 0 0 255 1 # 显示 新 
图像 cv2 . imshow res img 11.2 简单 的 轮廓 
属性 质心 质心 或 质心   是 图像 中 物体 
的 中心     x y 坐标 # 绘制 轮廓 
质心 cnts _ = cv2 . findContours gray . copy 
cv2 . RETR _ EXTERNAL cv2 . CHAIN _ APPROX 
_ SIMPLE clone = image . copy for c in 
cnts # compute the moments of the contour which can 
be used to compute the # centroid or center of 
mass of the region M = cv2 . moments c 
cX = int M m10 / M m00 cY = 
int M m01 / M m00 # draw the center 
of the contour on the image cv2 . circle clone 
cX cY 10 0 255 0 1 面积 和 周长 
轮廓 的 面积 是 轮廓 轮廓 内部 的 像素数 类 
似地     周长     有时 称为     
弧长 是 轮廓 的 长度 # 获取 轮廓 的 面积 
与 周长 for i c in enumerate cnts area = 
cv2 . contourArea c perimeter = cv2 . arcLength c 
True print Contour # % d area % . 2f 
perimeter % . 2f % i + 1 area perimeter 
cv2 . drawContours clone c 1 0 255 0 2 
# 计算 图像 的 质心 并在 图像 上 显示 轮廓 
数 以便 我们 可以 将 形状 与 终端 输出 相关联 
M = cv2 . moments c cX = int M 
m10 / M m00 # cY = int M m01 
/ M m00 # cv2 . putText clone # % 
d % i + 1 cX 20 cY cv2 . 
FONT _ HERSHEY _ SIMPLEX 1.25 255 255 255 4 
边框 边界 和 包含 整个 图像 的 轮廓 区域 for 
c in cnts # fit a bounding box to the 
contour x y w h = cv2 . boundingRect c 
cv2 . rectangle clone x y x + w y 
+ h 0 255 0 2 旋转 边框 # 绘制 
轮廓 的 旋转 边框 for c in cnts # fit 
a rotated bounding box to the contour and draw a 
rotated bounding box box = cv2 . minAreaRect c # 
参数 我们 的 轮廓 并 返回 一个 包含 3个 值 
的 元组 元组 的 第一 个 值 是 旋转 的 
边界 框 的 起始 x y 坐标 第二个 值 是 
边界 框 的 宽度 和 高度 而 最终 的 值 
就是 我们 形状 或 旋转 的 角度 box = np 
. int0 cv2 . cv . BoxPoints box # 宽度 
和 高度 以及 旋转角 转换 为 一组 坐标 点 cv2 
. drawContours clone box 1 0 255 0 2 最小 
封闭 圆 for c in cnts x y radius = 
cv2 . m i n E n c l o 
s i n g C i r c l e 
c # 返回 圆 的 中心 的 x y 坐标 
以及 圆 的 半径 cv2 . circle clone int x 
int y int radius 0 255 0 2 装配 椭圆 
将 椭圆 拟 合到 轮廓 上 很像 将 轮廓 的 
矩形 装 配到 轮廓 上 for c in cnts if 
len c = 5 ellipse = cv2 . fitEllipse c 
cv2 . ellipse clone ellipse 0 255 0 2 11.3 
高级 轮廓 长 宽比 宽高比 = 图像 宽度 / 图像 
宽度 程度 边界 框 区域 = 边界 框 宽度 X 
边框 高度 凸 海鸥 欧氏 空间 中 的 一组   
  X 点 凸包 是 包含 这些 X 点 的 
最小 可能 凸 集 密实度 坚固 度 = 轮廓 面积 
/ 凸包 面积 # 识别 X 与 O cnts _ 
= cv2 . findContours gray . copy cv2 . RETR 
_ EXTERNAL cv2 . CHAIN _ APPROX _ SIMPLE # 
获取 轮廓 列表 for i c in enumerate cnts area 
= cv2 . contourArea c # 获取 轮廓 面积 x 
y w h = cv2 . boundingRect c # 获取 
轮廓 的 起始 坐标 边界 的 宽度 和 高度 hull 
= cv2 . convexHull c # 获取 形状 的 实际 
凸包 hullArea = cv2 . contourArea hull # 计算 凸包 
面积 solidity = area / float hullArea # 获取 坚固 
度 char = # 依据 坚固 度 判断 图像 的 
形状 if solidity 0.9 char = O elif solidity 0.5 
char = X # 绘制 轮廓 if char = cv2 
. drawContours image c 1 0 255 0 3 cv2 
. putText image char x y 10 cv2 . FONT 
_ HERSHEY _ SIMPLEX 1.25 0 255 0 4 print 
% s Contour # % d solidity = % . 
2f % char i + 1 solidity cv2 . imshow 
Output image cv2 . waitKey 0 # 识别 俄罗斯 方块 
cnts _ = cv2 . findContours thresh . copy cv2 
. RETR _ EXTERNAL cv2 . CHAIN _ APPROX _ 
SIMPLE # 获取 图 片中 的 轮廓 列表 hullImage = 
np . zeros gray . shape 2 dtype = uint8 
for i c in enumerate cnts area = cv2 . 
contourArea c # 获取 轮廓 面积 x y w h 
= cv2 . boundingRect c # 获取 轮廓 边界 aspectRatio 
= w / float h # 获取 宽高比 extent = 
area / float w * h # 获取 当前 轮廓 
的 范围 hull = cv2 . convexHull c hullArea = 
cv2 . contourArea hull # solidity = area / float 
hullArea # 获取 坚固 度 依据 坚固 度 判断 物体 
形状 cv2 . drawContours hullImage hull 1 255 1 cv2 
. drawContours image c 1 240 0 159 3 shape 
= 11.4 轮廓 近似 轮廓 逼近 一种 用 减少 的 
点集合 减少 曲线 中的 点数 的 算法 简单 的 称为 
分裂 合并 算法 # 检测 图像 中 的 正方形 import 
cv2 image = cv2 . imread images / circles _ 
and _ squares . png gray = cv2 . cvtColor 
image cv2 . COLOR _ BGR2GRAY # 获得 图像 轮廓 
列表 cnts _ = cv2 . findContours gray . copy 
cv2 . RETR _ EXTERNAL cv2 . CHAIN _ APPROX 
_ SIMPLE # 循环 每个 轮廓 for c in cnts 
# 获取 轮廓 的 周长 peri = cv2 . arcLength 
c True approx = cv2 . approxPolyDP c 0.01 * 
peri True if len approx = = 4 #/i 判断/v 
处理/v 后的/nr 轮廓/n 是否/v 有/v 4个/mq 顶点/n # draw the 
outline of the contour and draw the text on the 
image cv2 . drawContours image c 1 0 255 255 
2 x y w h = cv2 . boundingRect approx 
cv2 . putText image Rectangle x y 10 cv2 . 
FONT _ HERSHEY _ SIMPLEX 0.5 0 255 255 2 
cv2 . imshow Image image cv2 . waitKey 0 物体 
轮廓 检测 import cv2 image = cv2 . imread images 
/ receipt . png gray = cv2 . cvtColor image 
cv2 . COLOR _ BGR2GRAY edged = cv2 . Canny 
gray 75 200 cv2 . imshow Original image cv2 . 
imshow Edge Map edged cnts _ = cv2 . findContours 
edged . copy cv2 . RETR _ EXTERNAL cv2 . 
CHAIN _ APPROX _ SIMPLE cnts = sorted cnts key 
= cv2 . contourArea reverse = True 7 # loop 
over the contours for c in cnts peri = cv2 
. arcLength c True approx = cv2 . approxPolyDP c 
0.01 * peri True print original { } approx { 
} . format len c len approx if len approx 
= = 4 cv2 . drawContours image approx 1 0 
255 0 2 cv2 . imshow Output image cv2 . 
waitKey 0 11.5 排列 轮廓 import numpy as np import 
argparse import cv2 # 参数 1 轮廓 列表 参数 2 
排列 方法 def sort _ contours cnts method = left 
to right reverse = False i = 0 if method 
= = right to left or method = = bottom 
to top reverse = True if method = = top 
to bottom or method = = bottom to top i 
= 1 boundingBoxes = cv2 . boundingRect c for c 
in cnts cnts boundingBoxes = zip * sorted zip cnts 
boundingBoxes key = lambda b b 1 i reverse = 
reverse return cnts boundingBoxes def draw _ contour image c 
i M = cv2 . moments c cX = int 
M m10 / M m00 cY = int M m01 
/ M m00 cv2 . putText image # { } 
. format i + 1 cX 20 cY cv2 . 
FONT _ HERSHEY _ SIMPLEX 1.0 255 255 255 2 
return image ap = argparse . ArgumentParser ap . add 
_ argument i image required = True help = Path 
to the input image ap . add _ argument m 
method required = True help = Sorting method args = 
vars ap . parse _ args image = cv2 . 
imread args image accumEdged = np . zeros image . 
shape 2 dtype = uint8 for chan in cv2 . 
split image chan = cv2 . medianBlur chan 11 edged 
= cv2 . Canny chan 50 200 accumEdged = cv2 
. bitwise _ or accumEdged edged cv2 . imshow Edge 
Map accumEdged cnts _ = cv2 . findContours accumEdged . 
copy cv2 . RETR _ EXTERNAL cv2 . CHAIN _ 
APPROX _ SIMPLE cnts = sorted cnts key = cv2 
. contourArea reverse = True 5 orig = image . 
copy for i c in enumerate cnts orig = draw 
_ contour orig c i cv2 . imshow Unsorted orig 
cnts boundingBoxes = sort _ contours cnts method = args 
method for i c in enumerate cnts draw _ contour 
image c i cv2 . imshow Sorted image cv2 . 
waitKey 0 12 直方图 直方图 表示 图像 中 的 像素 
强度 运用 cv2 . calcHist 函数 构建 直方图 cv2 . 
calcHist 图像 通道 掩码 histSize 范围 参数 详解 图像 我们 
要 计算 的 直方图 的 图像 通道 索引 列表 其中 
指定 要 计算 直方图 的 通道 的 索引 掩码 提供 
一个 掩码 那么 只对 被 掩盖 的 像素 计算 一个 
直方图 histSize 计算 直方图 时要/nr 使用 的 分组 数 范围 
可能 的 像素 值 的 范围 # 灰度 直方图 from 
matplotlib import pyplot as plt import argparse import cv2 ap 
= argparse . ArgumentParser ap . add _ argument i 
image required = True help = Path to the image 
args = vars ap . parse _ args image = 
cv2 . imread args image image = cv2 . cvtColor 
image cv2 . COLOR _ BGR2GRAY cv2 . imshow Original 
image hist = cv2 . calcHist image 0 None 256 
0 256 plt . figure plt . title Grayscale Histogram 
plt . xlabel Bins plt . ylabel # of Pixels 
plt . plot hist plt . xlim 0 256 hist 
/ = hist . sum plt . figure plt . 
title Grayscale Histogram Normalized plt . xlabel Bins plt . 
ylabel % of Pixels plt . plot hist plt . 
xlim 0 256 plt . show # 颜色 直方图 from 
matplotlib import pyplot as plt import argparse import cv2 ap 
= argparse . ArgumentParser ap . add _ argument i 
image required = True help = Path to the image 
args = vars ap . parse _ args image = 
cv2 . imread args image cv2 . imshow Original image 
chans = cv2 . split image colors = b g 
r plt . figure plt . title Flattened Color Histogram 
plt . xlabel Bins plt . ylabel # of Pixels 
for chan color in zip chans colors hist = cv2 
. calcHist chan 0 None 256 0 256 plt . 
plot hist color = color plt . xlim 0 256 
fig = plt . figure ax = fig . add 
_ subplot 131 hist = cv2 . calcHist chans 1 
chans 0 0 1 None 32 32 0 256 0 
256 p = ax . imshow hist interpolation = nearest 
ax . set _ title 2D Color Histogram for G 
and B plt . colorbar p ax = fig . 
add _ subplot 132 hist = cv2 . calcHist chans 
1 chans 2 0 1 None 32 32 0 256 
0 256 p = ax . imshow hist interpolation = 
nearest ax . set _ title 2D Color Histogram for 
G and R plt . colorbar p ax = fig 
. add _ subplot 133 hist = cv2 . calcHist 
chans 0 chans 2 0 1 None 32 32 0 
256 0 256 p = ax . imshow hist interpolation 
= nearest ax . set _ title 2D Color Histogram 
for B and R plt . colorbar p print 2D 
histogram shape % s with % d values % hist 
. shape hist . flatten . shape 0 hist = 
cv2 . calcHist image 0 1 2 None 8 8 
8 0 256 0 256 0 256 print 3D histogram 
shape % s with % d values % hist . 
shape hist . flatten . shape 0 plt . show 
# 直方图 均衡 import argparse import cv2 # construct the 
argument parser and parse the arguments ap = argparse . 
ArgumentParser ap . add _ argument i image required = 
True help = Path to the image args = vars 
ap . parse _ args # load the image and 
convert it to grayscale image = cv2 . imread args 
image image = cv2 . cvtColor image cv2 . COLOR 
_ BGR2GRAY # apply histogram equalization to stretch the constrast 
of our image eq = cv2 . equalizeHist image # 
show our images notice how the constrast of the second 
image has # been stretched cv2 . imshow Original image 
cv2 . imshow Histogram Equalization eq cv2 . waitKey 0 
# 直方图 和 面具 from matplotlib import pyplot as plt 
import numpy as np import cv2 def plot _ histogram 
image title mask = None chans = cv2 . split 
image colors = b g r plt . figure plt 
. title title plt . xlabel Bins plt . ylabel 
# of Pixels for chan color in zip chans colors 
hist = cv2 . calcHist chan 0 mask 256 0 
256 plt . plot hist color = color plt . 
xlim 0 256 image = cv2 . imread beach . 
png cv2 . imshow Original image plot _ histogram image 
Histogram for Original Image mask = np . zeros image 
. shape 2 dtype = uint8 cv2 . rectangle mask 
60 290 210 390 255 1 cv2 . imshow Mask 
mask masked = cv2 . bitwise _ and image image 
mask = mask cv2 . imshow Applying the Mask masked 
plot _ histogram image Histogram for Masked Image mask = 
mask plt . show 13 连接 分量 标签 略 1 加载 显示 保存 图像 import argparse import cv2 ap 
= argparse . ArgumentParser ap . add _ argument i 
image required = True help = Path to the image 
# 读取 指定 指令 获取 图片 参数 1 输入 指令 
的 头 字母 参数 2 需要 输入 的 指令 args 
= vars ap . parse _ args image = cv2 
. imread args image # 读取 指定 参数 的 读取 
照片 print width % d pixels % image . shape 
1 # 获取 图像 的 宽度 横向 尺寸 图像 坐标系 
中 第二个 参数 print height % d pixels % image 
. shape 0 # 获取 图像 的 高度 竖向 尺寸 
图像 坐标系 中 第一 个 参数 注意 读取 图像 x 
y 互换 print channels % d % image . shape 
2 cv2 . imshow Image image # 显示 图片 cv2 
. imwrite newimage . jpg image # 将 图片 写入 
指定 路径 cv2 . waitKey 0 # 等待 程序 结束 
2 图像 基础 h w = image . shape 2 
# x y 像素 中的 显示 获取 图片 的 高度 
x 获取 图片 的 宽度 y b g r = 
image 0 0 # 获取 指定 位置 的 像素 存储 
方式 为 bgr cX cY = w / 2 h 
/ 2 # cX 图片 的 宽度 cY 图片 高度 
tl = image 0 cY 0 cX # 获取 图片 
的 左上角 部分 起始 点 x 坐标 终点 x 坐标 
起点 的 y 坐标 终点 y 坐标 得出 的 值 
分别 指 高度 和 宽度 # 运用 像素 指定 位置 
赋值 方法 向 Background 图片 上 插入 图片 resized _ 
left for left _ x in xrange 0 500 1 
for left _ y in xrange 0 500 1 Background 
400 + left _ x 20 + left _ y 
= resized _ left left _ x left _ y 
3 绘图 canvas = np . zeros 300 300 3 
dtype = uint8 # 设置 画布 尺寸 green = 0 
255 0 # 设置 线条 颜色 cv2 . line canvas 
0 0 300 300 green # 参数 1 指定 画布 
参数 2 线条 的 开始 位置 参数 3 线条 终点 
位置 参数 4 线条 颜色 cv2 . line canvas 300 
0 0 300 red 3 # 参数 5 线条 像素 
厚度 cv2 . rectangle canvas 10 10 60 60 green 
# 参数 1 指定 画布 参数 2 矩形 起点 位置 
参数 3 矩形 对角线 点 的 位置 线条 颜色 cv2 
. rectangle canvas 50 200 200 225 red 5 # 
参数 5 线条 宽度 负数 表示 填充 矩形 centerX centerY 
= canvas . shape 1 / 2 canvas . shape 
0 / 2 # 设置 圆 心坐标 white = 255 
255 255 # 设置 圆 的 线条 颜色 cv2 . 
circle canvas centerX centerY r white # 参数 1 画布 
参数 2 圆心点 参数 3 设置 圆 的 半径 设置 
画圆 的 线条 颜色 cv2 . circle canvas tuple pt 
radius color 1 # 参数 4 设置 画圆 的 线条 
粗细 如果 为 负数 表示 填充 圆 4 图像处理 4.1 
翻译 M = np . float32 1 0 50 0 
1 90 # 定义 翻译 矩阵 参数 1 1 0 
x x 表示 像素 向左 或者 向右 移动 个数 x 
为 负值 图像 左移 正值 为 右移 定 参数 2 
0 1 y y 表示 像素 上下 移动 y 为 
负值 向上 移动 正值 向下 移动 记忆 口诀 前 左负右/nr 
正 后上 负 下 正 shifted = cv2 . warpAffine 
image M image . shape 1 image . shape 0 
# 对 矩阵 进行 翻译 参数 1 翻译 的 目标 
图像 参数 2 翻译 的 矩阵 参数 3 翻译 后 
图像 大小 # imutils 模块 的 翻译 函数 shifted = 
imutils . translate image 0 100 # 参数 1 移动 
的 目标 图像 参数 2 左右 移动 的 值 参数 
3 上下 移动 的 值 注 不会 改变 图像 大小 
4.2 旋 转注 运用 翻译 将 图片 移到 中心 位置 
四周 留出 黑色 边框 在 运用 旋转 旋转 角度 为 
0 可将 图片 放大 h w = image . shape 
2 #/i 获取/v 图像/n 的/uj 高和宽/nr cX cY = w 
/ 2 h / 2 # 获取 图像 的 中心点 
M = cv2 . g e t R o t 
a t i o n M a t r i 
x 2 D cX cY 45 1.0 # 设置 旋转 
矩阵 参数 1 旋转 点 参数 2 旋转 角度 正值 
逆时针 旋转 负值 顺时针 选装 参数 3 旋转 后 图像 
与 原始 图像 的 比例 图像 原始 大小 不会 发生 
变化 类似 相机 焦距 变化 rotated = cv2 . warpAffine 
image M w h # 参数 1 目标 图像 参数 
2 旋转 矩阵 参数 3 # 旋转 后的/nr 图像 尺寸 
# imutils 模块 的 旋转 函数 rotated = imutils . 
rotate image 180 # 参数 1 旋转 目标 图片 参数 
2 旋转 角度 center = x y 可以 设置 旋转 
点 4.3 图像 大小 调整 注 改变 原始 图片 的 
实际 大小 r = 150.0 / image . shape 1 
# 新 图像 与 旧 图像 的 宽 比例 注 
方便 图片 按 原 比例 缩放 dim = 150 int 
image . shape 0 * r # 设置 新 图像 
的 像素 尺寸 resized = cv2 . resize image dim 
interpolation = cv2 . INTER _ AREA # 调整 图像 
大小 返回 一个 新 图像 # 运用 imutils 中的 resize 
函数 resized = imutils . resize image width = 100 
# 参数 1 目标 图像 参数 2 设置 新 图像 
的 宽度 可以为 height 运用 高度 # 运用 插值 方法 
缩 放大 图片 通过 不同 的 像素 填充 方法 放大 
图片 resized = imutils . resize image width = image 
. shape 1 * 3 inter = method # 参数 
1 目标 图片 参数 2 处理 后 图片 像素 宽 
整形 参数 3 像素 处理 方法 method cv2 . INTER 
_ NEAREST 最 近邻 内 插值 cv2 . INTER _ 
LINEAR 双 线性插值 cv2 . INTER _ AREA 区域 插值 
cv2 . INTER _ CUBIC 双 三次 插值 cv2 . 
INTER _ LANCZOS4 双 三次 插值 4.4 图像 翻转 flipped 
= cv2 . flip image 1 # 水平 翻转 flipped 
= cv2 . flip image 0 # 上下 翻转 flipped 
= cv2 . flip image 1 # 水平 翻转 后 
上下 翻转 4.5 图像 裁剪 face = image 85 250 
85 220 # 参数 1 裁切 高度 x 开始 位置 
x 结束 位置 参数 2 裁切 宽度 y 开始 位置 
y 结束 位置 返回 新 图片 4.6 图像 像素 像素 
值 操作 注 修改 图片 的 亮度 M = np 
. ones image . shape dtype = uint8 * 100 
# 设置 与 图片 大 下 相同 的 矩阵 矩阵 
填 充值 为 100 added = cv2 . add image 
M # 将 原始 图片 与 新 矩阵 相加 像素 
亮 度提高 100 M = np . ones image . 
shape dtype = uint8 * 50 # 设置 与 图片 
大 下 相同 的 矩阵 矩阵 填 充值 为 50 
subtracted = cv2 . subtract image M # 将 原始 
图片 与 新 矩阵 相减 像素 亮度 降低 504.7 按 
位操作 注 主要 是 黑白 图像处理 bitwiseAnd = cv2 . 
bitwise _ and rectangle circle # 当且仅当 俩个 相同 位置 
的 像素 大于 0 才 返回 真 bitwiseOr = cv2 
. bitwise _ or rectangle circle # 俩个 相同 位置 
的 像素 有一个 大于 0 返回 真 bitwiseXor = cv2 
. bitwise _ xor rectangle circle # 当且仅当 俩个 相同 
位置 的 像素 只有 一个 大于 0 才 返回 真 
bitwiseNot = cv2 . bitwise _ not circle # 像素 
值 取反 4.8 掩蔽 注 提取 图像 中 感兴趣 的 
部分 遮掩 的 必须 用 关键字 maskmask = np . 
zeros image . shape 2 dtype = uint8 # 设置 
掩蔽 画布 的 大小 cv2 . rectangle mask 0 90 
290 450 255 1 # 设置 不 掩蔽 的 地方 
masked = cv2 . bitwise _ and image image mask 
= mask # 图片 显示 的 区域 4.9 像素 分割 
与 合并 B G R = cv2 . split image 
# 像素 分离 图像 B G R 图像 的 值 
为 整数 非 BGR 像素 矩阵 组成 其 值 是 
如何 转变 的 merged = cv2 . merge B G 
R # 三个 色彩 合并 还原 为 彩色图像 像素 由 
BGR 像素 矩阵 组成 zeros = np . zeros image 
. shape 2 dtype = uint8 # 建立 一个 二 
值 画布 与 各个 色彩 通道 合并 像是 各个 色彩 
通道 的 影响 cv2 . imshow Red cv2 . merge 
zeros zeros R # 只有 红色 的 图片 cv2 . 
imshow Green cv2 . merge zeros G zeros # 只有 
绿色 的 图片 cv2 . imshow Blue cv2 . merge 
B zeros zeros # 只有 蓝色 的 图片 问 如何 
从 BGR 转换成 整 数值 5 内核 略 6 形态 
操作 image = cv2 . imread args image # 打开 
一张 图片 gray = cv2 . cvtColor image cv2 . 
COLOR _ BGR2GRAY # 将 图片 转为 二 值 划 
# 侵蚀 将 前景 物体 变小 理解 成将/nr 图像 断开 
裂缝 变大 在 图片 上 画上 黑色 印记 印记 越来越 
大 for i in xrange 0 3 eroded = cv2 
. erode gray . copy None iterations = i + 
1 # 参数 1 需要 侵蚀 的 图像 参数 2 
结构 元素 参数 3 迭代 次数 值 越大 侵蚀 越 
严重 cv2 . imshow Eroded { } times . format 
i + 1 eroded cv2 . waitKey 0 # 扩张 
将 前景 物体 变大 理解 成将/nr 图像 断开 裂缝 变小 
在 图片 上 画上 黑色 印记 印记 越来越 小 for 
i in xrange 0 3 dilated = cv2 . dilate 
gray . copy None iterations = i + 1 # 
参数 1 需要 侵蚀 的 图像 参数 2 结构 元素 
参数 3 迭代 次数 值 越大 扩张 越大 cv2 . 
imshow Dilated { } times . format i + 1 
dilated cv2 . waitKey 0 # 开盘 应用 侵蚀 以 
去除 小斑点 然后 应用 扩张 以 重新 生成 原始 对象 
的 大小 用于 消除 杂质 kernelSizes = 3 3 5 
5 7 7 # 定义 结构化 元素 的 宽度 和 
高度 for kernelSize in kernelSizes kernel = cv2 . g 
e t t r u c t u r i 
n g E l e m e n t cv2 
. MORPH _ RECT kernelSize # 参数 1 结构化 元素 
的 类型 参数 2 构造 元素 的 大小 opening = 
cv2 . morphologyEx gray cv2 . MORPH _ OPEN kernel 
# 参数 1 形态学 运算 的 图像 参数 2 形态 
操作 的 实际 类型 参数 3 内核 / 结构 化元素 
cv2 . imshow Opening { } { } . format 
kernelSize 0 kernelSize 1 opening cv2 . waitKey 0 形态 
操作 实际 类型 cv2 . MORPH _ CLOSE 闭幕 用于 
封闭 对象 内 的 孔 或将 组件 连接 在 一起 
cv2 . MORPH _ GRADIENT 形态 梯度 用于 确定 图像 
的 特定 对象 的 轮廓 # 顶帽 / 黑帽 显示 
黑色 背景 上 的 图像 的 明亮 区域 适合于 灰度 
图像 rectKernel = cv2 . g e t t r 
u c t u r i n g E l 
e m e n t cv2 . MORPH _ RECT 
13 5 # 定义 宽度 为 13 像素 和 高度 
为 5 像素 的 矩形 结构 元素 blackhat = cv2 
. morphologyEx gray cv2 . MORPH _ BLACKHAT rectKernel # 
参数 1 形态学 运算 的 图像 参数 2 形态 操作 
的 实际 类型 参数 3 内核 / 结构 化元素 tophat 
= cv2 . morphologyEx gray cv2 . MORPH _ TOPHAT 
rectKernel # 参数 1 形态学 运算 的 图像 参数 2 
形态 操作 的 实际 类型 参数 3 内核 / 结构 
化元素 7 平滑 和 模糊 kernelSizes = 3 3 9 
9 15 15 # 定义 内核 大小 参数 列表 内核 
越大 模糊 越 明显 # loop over the kernel sizes 
and apply an average blur to the image for kX 
kY in kernelSizes blurred = cv2 . blur image kX 
kY # 使用 平均 模糊 方法 参数 1 模糊 对象 
参数 2 矩阵 大小 cv2 . imshow Average { } 
{ } . format kX kY blurred cv2 . waitKey 
0 模糊 方法 平均 模糊 过度 模糊 图像 并 忽略 
重要 的 边缘 blurred = cv2 . blur image kX 
kY 高斯 保留 更多 的 图像 边缘 blurred = cv2 
. GaussianBlur image kX kY 0 参数 1 模糊 对象 
参数 2 矩阵 大小 参数 3 标准 方差 中位数 模糊 
图像 中 去除 盐 和 胡椒 图像 中 的 杂质 
点 blurred = cv2 . medianBlur image k 参数 1 
模糊 对象 参数 2 中位数 值 为 整型数据 数据 越大 
图像 越 模糊 双边 模糊 减少 噪音 同时 仍然 保持 
边缘 我们 可以 使用 双边 模糊 双边 模糊 通过 引入 
两个 高斯分布 来 实现 blurred = cv2 . bilateralFilter image 
diameter sigmaColor sigmaSpace 参数 1 想要 模糊 的 图像 参数 
2 像素 邻域 的 直径 这个 直径 越大 模糊 计算 
中 包含 的 像素 越多 参数 3 颜色 标准差 模糊 
时将/nr 考虑 邻域 中的 更多 颜色 相似 颜色 的 像素 
才能 显着 地 影响 模糊 参数 4 空间 标准偏差 更大 
的 值 意味着 像素 越 远离 中心 像素 直径 将 
影响 模糊 计算 后面 3个 参数 都为 整型 参数 8 
照明 和 色彩 空间 # RGB 红 黄 蓝 组成 
的 颜色 矩阵 每个 色度 值 范围 0 255 image 
= cv2 . imread args image for name chan in 
zip B G R cv2 . split image cv2 . 
imshow name chan # HSV 色调 H 们 正在 研究 
哪种 纯 的 颜色 饱和度 S 颜色 如何 白 例如 
纯红 随着 零 饱和度 的 颜色 是 纯白色 价值 V 
该 值 允许 我们 控制 我们 的 颜色 的 亮度 
零值 表示 纯 黑色 hsv = cv2 . cvtColor image 
cv2 . COLOR _ BGR2HSV for name chan in zip 
H S V cv2 . split hsv cv2 . imshow 
name chan # L * a * b * 表 
L 通道 像素 的 亮度 a 通道 源于 L 通道 
的 中心 在 频谱 的 一端 定义 纯 绿色 另一端 
定义 纯 红色 b 通道 也 来自 于L/nr 通道 的 
中心 但是 垂直于 a 通道 lab = cv2 . cvtColor 
image cv2 . COLOR _ BGR2LAB for name chan in 
zip L * a * b * cv2 . split 
lab cv2 . imshow name chan # 灰度 转换成 灰度级 
时 每个 RGB 通道 不是 均匀 加权 gray = cv2 
. cvtColor image cv2 . COLOR _ BGR2GRAY 9 阀值 
阀值 图像 的 二 值 化 image = cv2 . 
imread args image gray = cv2 . cvtColor image cv2 
. COLOR _ BGR2GRAY # 将 图像 二 值 化 
blurred = cv2 . GaussianBlur gray 7 7 0 T 
threshInv = cv2 . threshold blurred 200 255 cv2 . 
THRESH _ BINARY _ INV # 参数 1 希望 阈值 
的 灰度 图像 参数 2 手动 提供 我们 的 T 
阈值 参数 3 设置 输出 值 参数 4 阈值 方法 
白色 背景 黑色 图 将 像素 值 小于 参数 2 
的 值 换成 参数 3 输出 大于 参数 2 的 
值 输出 值 为 0 cv2 . imshow Threshold Binary 
Inverse threshInv T thresh = cv2 . threshold blurred 200 
255 cv2 . THRESH _ BINARY # 参数 1 希望 
阈值 的 灰度 图像 参数 2 手动 提供 我们 的 
T 阈值 参数 3 设置 输出 值 参数 4 阈值 
方法 黑 背景 白色 图 将 像素 值 大于 参数 
2 的 值 换成 参数 3 输出 小于 参数 2 
的 值 输出 值 为 0 cv2 . imshow Threshold 
Binary thresh cv2 . imshow Output cv2 . bitwise _ 
and image image mask = threshInv # 大津 方法 参数 
1 希望 阈值 的 灰度 图像 参数 2 大津 的 
方法 将 自动 计算 出 我们 的 T 的 最优 
值 参数 3 阈值 的 输出 值 只要 给定 像素 
通过 阈值 测试 参数 4 对应 于 Otsu 的 阈值 
法 T threshInv = cv2 . threshold blurred 0 255 
cv2 . THRESH _ BINARY _ INV | cv2 . 
THRESH _ OTSU # 自适应 阀值 法 参数 1 希望 
阈值 的 灰度 图像 参数 2 参数 是 输出 阈值 
参数 3 自适应 阈值 法 参数 4 阈值 方法 参数 
5 是 我们 的 像素 邻域 大小 参数 6 微调 
我们 的 阈值 thresh = cv2 . a d a 
p t i v e T h r e s 
h o l d blurred 255 cv2 . ADAPTIVE _ 
THRESH _ MEAN _ C cv2 . THRESH _ BINARY 
_ INV 25 15 thresh = threshold _ adaptive blurred 
29 offset = 5 . astype uint8 * 255 thresh 
= cv2 . bitwise _ not thresh # 阈值 适配 
函数 执行 自适应 阈值 10.1 图像 渐变 图像 渐变 图像 
梯度 主要 应用 与 边缘 检测 # Sobel 内核 gray 
= cv2 . cvtColor image cv2 . COLOR _ BGR2GRAY 
gX = cv2 . Sobel gray ddepth = cv2 . 
CV _ 64F dx = 1 dy = 0 # 
计算 x 方向 的 梯度 gY = cv2 . Sobel 
gray ddepth = cv2 . CV _ 64F dx = 
0 dy = 1 # 计算 y 方向 的 梯度 
gX = cv2 . convertScaleAbs gX # 转 换回 8位 
无符号 整型 gY = cv2 . convertScaleAbs gY # 转 
换回 8位 无符号 整型 sobelCombined = cv2 . addWeighted gX 
0.5 gY 0.5 0 # 将 俩个 图像 组合成 单个 
图像 gX = cv2 . Sobel gray cv2 . CV 
_ 64F 1 0 # 计算 x 梯度方向 gY = 
cv2 . Sobel gray cv2 . CV _ 64F 0 
1 # 计算 y 梯度方向 mag = np . sqrt 
gX * * 2 + gY * * 2 # 
梯度 幅度 计算 平方 梯度 的 平方根 X 和 ÿ 
相加 orientation = np . arctan2 gY gX * 180 
/ np . pi % 180 # 梯度方向 计算 两个 
梯度 的 反 正切 idxs = np . where orientation 
= args lower _ angle orientation 1 # 手柄 选择 
参数 1 函数 是 我们 要 测试 的 条件 寻找 
大于 最小 提供 角度 的 索引 参数 2 要 检查 
的 阵列 在哪里 参数 3 特 定值 设置 为 1 
idxs = np . where orientation = args upper _ 
angle idxs 1 mask = np . zeros gray . 
shape dtype = uint8 # 构造 一个 掩码 所有 具有 
相应 idxs 值 1 的 坐标 都 设置 为 255 
即 前景 否则 它们 保留 为 0 即 背景 mask 
idxs 1 = 25510.2 边缘 检测 边缘 类型 步边/nr 阶跃 
边缘 形式 当 存在 来自 不连续 到 另一 的 一侧 
的 像素 强度 的 突然 变化 斜坡 边缘 斜坡 边缘 
就像 一个 阶跃 边缘 仅在 像素 强度 的 变化 不是 
瞬时 的 相反 像素 值 的 变化 发生 短 而 
有限 的 距离 岭 边 脊 边缘 是 相似 于 
两个 结合     斜坡 边缘 一个 右 对 另一 
碰撞 屋顶 边 顶部 有 一个 短 而 有限 的 
高原 的 边缘 不同 边缘 检测法 对 图像 应用 高斯 
平滑 来 帮助 减少 噪点 使用 Sobel 内核 计算 和 
图像 渐变 应用 非 最大值 抑制 来 仅 保持 指向 
梯度方向 的 梯度 幅度 像素 的 局部 最大值 定义/n 和/c 
应用/v 和/c 阈值/n 滞后/v 阈值/n gray/w = cv2 . cvtColor 
image cv2 . COLOR _ BGR2GRAY blurred = cv2 . 
GaussianBlur gray 5 5 0 wide = cv2 . Canny 
blurred 10 200 # 参数 1 想要 检测 边缘 的 
图像 参数 2 和3/nr 分别 提供 阈值 下限 和 阈值 
上限 # 自动 调整 边缘 检测 参数 # 自动 调整 
边缘 检测 参数 函数 def auto _ canny image sigma 
= 0.33 v = np . median image lower = 
int max 0 1.0 sigma * v upper = int 
min 255 1.0 + sigma * v edged = cv2 
. Canny image lower upper return edged # 自动 调整 
边缘 检测 参数 函数 运用 blurred = cv2 . GaussianBlur 
gray 3 3 0 auto = imutils . auto _ 
canny blurred 11.1 查找 和 绘制 轮廓 gray = cv2 
. cvtColor image cv2 . COLOR _ BGR2GRAY cnts _ 
= cv2 . findContours gray . copy cv2 . RETR 
_ LIST cv2 . CHAIN _ APPROX _ SIMPLE # 
参数 1 需要 绘制 轮廓 的 图像 参数 2 返回 
的 轮廓 数量 的 标志 参数 3 轮廓 压缩 类型 
返回值 第一 个 值 是 轮廓 本上 第二个 值 是 
要 检查 的 轮廓 层次结构 clone = image . copy 
cv2 . drawContours clone cnts 1 0 255 0 2 
# 参数 1 要 绘制 轮廓 的 图像 参数 2 
使用 的 轮廓 列表 参数 3 cnts 列表 中 的 
轮廓 索引 1 表示 绘制 所有 轮廓 0 是 仅 
画 第一个 1 表示 绘制 第二个 轮廓 参数 3 绘制 
轮廓 的 颜色 参数 4 绘制 轮廓线 的 像素 # 
轮廓 单个 绘制 for i c in enumerate cnts print 
Drawing contour # { } . format i + 1 
cv2 . drawContours clone c 1 0 255 0 2 
cv2 . imshow Single Contour clone cv2 . waitKey 0 
# 返回 所有 轮廓 外观 cnts _ = cv2 . 
findContours gray . copy cv2 . RETR _ EXTERNAL cv2 
. CHAIN _ APPROX _ SIMPLE # 轮廓 外观 与 
掩码 的 一起 使用 for c in cnts # construct 
a mask by drawing only the current contour mask = 
np . zeros gray . shape dtype = uint8 cv2 
. drawContours mask c 1 255 1 # show the 
images cv2 . imshow Image image cv2 . imshow Mask 
mask cv2 . imshow Image + Mask cv2 . bitwise 
_ and image image mask = mask # 补充 运用 
霍夫 找 圆心 gray = cv2 . cvtColor img cv2 
. COLOR _ BGR2GRAY # 输出 图像 大小 方便 根据 
图像 大小 调节 minRadius 和 maxRadius print img . shape 
# 霍夫 变换 圆 检测 circles = cv2 . HoughCircles 
gray cv2 . HOUGH _ GRADIENT 1 100 param1 = 
100 param2 = 30 minRadius = 5 maxRadius = 300 
# 输出 返回值 方便 查看 类型 print circles # 输出 
检测 到 圆 的 个数 print len circles 0 # 
根据 检测 到 圆 的 信息 画出 每 一个 圆 
for circle in circles 0 # 圆 的 基本 信息 
print circle 2 # 坐标 行列 x = int circle 
0 y = int circle 1 # 半径 r = 
int circle 2 # 在 原图 用 指定 颜 色标 
记出 圆 的 位置 img = cv2 . circle img 
x y r 0 0 255 1 # 显示 新 
图像 cv2 . imshow res img 11.2 简单 的 轮廓 
属性 质心 质心 或 质心   是 图像 中 物体 
的 中心     x y 坐标 # 绘制 轮廓 
质心 cnts _ = cv2 . findContours gray . copy 
cv2 . RETR _ EXTERNAL cv2 . CHAIN _ APPROX 
_ SIMPLE clone = image . copy for c in 
cnts # compute the moments of the contour which can 
be used to compute the # centroid or center of 
mass of the region M = cv2 . moments c 
cX = int M m10 / M m00 cY = 
int M m01 / M m00 # draw the center 
of the contour on the image cv2 . circle clone 
cX cY 10 0 255 0 1 面积 和 周长 
轮廓 的 面积 是 轮廓 轮廓 内部 的 像素数 类 
似地     周长     有时 称为     
弧长 是 轮廓 的 长度 # 获取 轮廓 的 面积 
与 周长 for i c in enumerate cnts area = 
cv2 . contourArea c perimeter = cv2 . arcLength c 
True print Contour # % d area % . 2f 
perimeter % . 2f % i + 1 area perimeter 
cv2 . drawContours clone c 1 0 255 0 2 
# 计算 图像 的 质心 并在 图像 上 显示 轮廓 
数 以便 我们 可以 将 形状 与 终端 输出 相关联 
M = cv2 . moments c cX = int M 
m10 / M m00 # cY = int M m01 
/ M m00 # cv2 . putText clone # % 
d % i + 1 cX 20 cY cv2 . 
FONT _ HERSHEY _ SIMPLEX 1.25 255 255 255 4 
边框 边界 和 包含 整个 图像 的 轮廓 区域 for 
c in cnts # fit a bounding box to the 
contour x y w h = cv2 . boundingRect c 
cv2 . rectangle clone x y x + w y 
+ h 0 255 0 2 旋转 边框 # 绘制 
轮廓 的 旋转 边框 for c in cnts # fit 
a rotated bounding box to the contour and draw a 
rotated bounding box box = cv2 . minAreaRect c # 
参数 我们 的 轮廓 并 返回 一个 包含 3个 值 
的 元组 元组 的 第一 个 值 是 旋转 的 
边界 框 的 起始 x y 坐标 第二个 值 是 
边界 框 的 宽度 和 高度 而 最终 的 值 
就是 我们 形状 或 旋转 的 角度 box = np 
. int0 cv2 . cv . BoxPoints box # 宽度 
和 高度 以及 旋转角 转换 为 一组 坐标 点 cv2 
. drawContours clone box 1 0 255 0 2 最小 
封闭 圆 for c in cnts x y radius = 
cv2 . m i n E n c l o 
s i n g C i r c l e 
c # 返回 圆 的 中心 的 x y 坐标 
以及 圆 的 半径 cv2 . circle clone int x 
int y int radius 0 255 0 2 装配 椭圆 
将 椭圆 拟 合到 轮廓 上 很像 将 轮廓 的 
矩形 装 配到 轮廓 上 for c in cnts if 
len c = 5 ellipse = cv2 . fitEllipse c 
cv2 . ellipse clone ellipse 0 255 0 2 11.3 
高级 轮廓 长 宽比 宽高比 = 图像 宽度 / 图像 
宽度 程度 边界 框 区域 = 边界 框 宽度 X 
边框 高度 凸 海鸥 欧氏 空间 中 的 一组   
  X 点 凸包 是 包含 这些 X 点 的 
最小 可能 凸 集 密实度 坚固 度 = 轮廓 面积 
/ 凸包 面积 # 识别 X 与 O cnts _ 
= cv2 . findContours gray . copy cv2 . RETR 
_ EXTERNAL cv2 . CHAIN _ APPROX _ SIMPLE # 
获取 轮廓 列表 for i c in enumerate cnts area 
= cv2 . contourArea c # 获取 轮廓 面积 x 
y w h = cv2 . boundingRect c # 获取 
轮廓 的 起始 坐标 边界 的 宽度 和 高度 hull 
= cv2 . convexHull c # 获取 形状 的 实际 
凸包 hullArea = cv2 . contourArea hull # 计算 凸包 
面积 solidity = area / float hullArea # 获取 坚固 
度 char = # 依据 坚固 度 判断 图像 的 
形状 if solidity 0.9 char = O elif solidity 0.5 
char = X # 绘制 轮廓 if char = cv2 
. drawContours image c 1 0 255 0 3 cv2 
. putText image char x y 10 cv2 . FONT 
_ HERSHEY _ SIMPLEX 1.25 0 255 0 4 print 
% s Contour # % d solidity = % . 
2f % char i + 1 solidity cv2 . imshow 
Output image cv2 . waitKey 0 # 识别 俄罗斯 方块 
cnts _ = cv2 . findContours thresh . copy cv2 
. RETR _ EXTERNAL cv2 . CHAIN _ APPROX _ 
SIMPLE # 获取 图 片中 的 轮廓 列表 hullImage = 
np . zeros gray . shape 2 dtype = uint8 
for i c in enumerate cnts area = cv2 . 
contourArea c # 获取 轮廓 面积 x y w h 
= cv2 . boundingRect c # 获取 轮廓 边界 aspectRatio 
= w / float h # 获取 宽高比 extent = 
area / float w * h # 获取 当前 轮廓 
的 范围 hull = cv2 . convexHull c hullArea = 
cv2 . contourArea hull # solidity = area / float 
hullArea # 获取 坚固 度 依据 坚固 度 判断 物体 
形状 cv2 . drawContours hullImage hull 1 255 1 cv2 
. drawContours image c 1 240 0 159 3 shape 
= 11.4 轮廓 近似 轮廓 逼近 一种 用 减少 的 
点集合 减少 曲线 中的 点数 的 算法 简单 的 称为 
分裂 合并 算法 # 检测 图像 中 的 正方形 import 
cv2 image = cv2 . imread images / circles _ 
and _ squares . png gray = cv2 . cvtColor 
image cv2 . COLOR _ BGR2GRAY # 获得 图像 轮廓 
列表 cnts _ = cv2 . findContours gray . copy 
cv2 . RETR _ EXTERNAL cv2 . CHAIN _ APPROX 
_ SIMPLE # 循环 每个 轮廓 for c in cnts 
# 获取 轮廓 的 周长 peri = cv2 . arcLength 
c True approx = cv2 . approxPolyDP c 0.01 * 
peri True if len approx = = 4 #/i 判断/v 
处理/v 后的/nr 轮廓/n 是否/v 有/v 4个/mq 顶点/n # draw the 
outline of the contour and draw the text on the 
image cv2 . drawContours image c 1 0 255 255 
2 x y w h = cv2 . boundingRect approx 
cv2 . putText image Rectangle x y 10 cv2 . 
FONT _ HERSHEY _ SIMPLEX 0.5 0 255 255 2 
cv2 . imshow Image image cv2 . waitKey 0 物体 
轮廓 检测 import cv2 image = cv2 . imread images 
/ receipt . png gray = cv2 . cvtColor image 
cv2 . COLOR _ BGR2GRAY edged = cv2 . Canny 
gray 75 200 cv2 . imshow Original image cv2 . 
imshow Edge Map edged cnts _ = cv2 . findContours 
edged . copy cv2 . RETR _ EXTERNAL cv2 . 
CHAIN _ APPROX _ SIMPLE cnts = sorted cnts key 
= cv2 . contourArea reverse = True 7 # loop 
over the contours for c in cnts peri = cv2 
. arcLength c True approx = cv2 . approxPolyDP c 
0.01 * peri True print original { } approx { 
} . format len c len approx if len approx 
= = 4 cv2 . drawContours image approx 1 0 
255 0 2 cv2 . imshow Output image cv2 . 
waitKey 0 11.5 排列 轮廓 import numpy as np import 
argparse import cv2 # 参数 1 轮廓 列表 参数 2 
排列 方法 def sort _ contours cnts method = left 
to right reverse = False i = 0 if method 
= = right to left or method = = bottom 
to top reverse = True if method = = top 
to bottom or method = = bottom to top i 
= 1 boundingBoxes = cv2 . boundingRect c for c 
in cnts cnts boundingBoxes = zip * sorted zip cnts 
boundingBoxes key = lambda b b 1 i reverse = 
reverse return cnts boundingBoxes def draw _ contour image c 
i M = cv2 . moments c cX = int 
M m10 / M m00 cY = int M m01 
/ M m00 cv2 . putText image # { } 
. format i + 1 cX 20 cY cv2 . 
FONT _ HERSHEY _ SIMPLEX 1.0 255 255 255 2 
return image ap = argparse . ArgumentParser ap . add 
_ argument i image required = True help = Path 
to the input image ap . add _ argument m 
method required = True help = Sorting method args = 
vars ap . parse _ args image = cv2 . 
imread args image accumEdged = np . zeros image . 
shape 2 dtype = uint8 for chan in cv2 . 
split image chan = cv2 . medianBlur chan 11 edged 
= cv2 . Canny chan 50 200 accumEdged = cv2 
. bitwise _ or accumEdged edged cv2 . imshow Edge 
Map accumEdged cnts _ = cv2 . findContours accumEdged . 
copy cv2 . RETR _ EXTERNAL cv2 . CHAIN _ 
APPROX _ SIMPLE cnts = sorted cnts key = cv2 
. contourArea reverse = True 5 orig = image . 
copy for i c in enumerate cnts orig = draw 
_ contour orig c i cv2 . imshow Unsorted orig 
cnts boundingBoxes = sort _ contours cnts method = args 
method for i c in enumerate cnts draw _ contour 
image c i cv2 . imshow Sorted image cv2 . 
waitKey 0 12 直方图 直方图 表示 图像 中 的 像素 
强度 运用 cv2 . calcHist 函数 构建 直方图 cv2 . 
calcHist 图像 通道 掩码 histSize 范围 参数 详解 图像 我们 
要 计算 的 直方图 的 图像 通道 索引 列表 其中 
指定 要 计算 直方图 的 通道 的 索引 掩码 提供 
一个 掩码 那么 只对 被 掩盖 的 像素 计算 一个 
直方图 histSize 计算 直方图 时要/nr 使用 的 分组 数 范围 
可能 的 像素 值 的 范围 # 灰度 直方图 from 
matplotlib import pyplot as plt import argparse import cv2 ap 
= argparse . ArgumentParser ap . add _ argument i 
image required = True help = Path to the image 
args = vars ap . parse _ args image = 
cv2 . imread args image image = cv2 . cvtColor 
image cv2 . COLOR _ BGR2GRAY cv2 . imshow Original 
image hist = cv2 . calcHist image 0 None 256 
0 256 plt . figure plt . title Grayscale Histogram 
plt . xlabel Bins plt . ylabel # of Pixels 
plt . plot hist plt . xlim 0 256 hist 
/ = hist . sum plt . figure plt . 
title Grayscale Histogram Normalized plt . xlabel Bins plt . 
ylabel % of Pixels plt . plot hist plt . 
xlim 0 256 plt . show # 颜色 直方图 from 
matplotlib import pyplot as plt import argparse import cv2 ap 
= argparse . ArgumentParser ap . add _ argument i 
image required = True help = Path to the image 
args = vars ap . parse _ args image = 
cv2 . imread args image cv2 . imshow Original image 
chans = cv2 . split image colors = b g 
r plt . figure plt . title Flattened Color Histogram 
plt . xlabel Bins plt . ylabel # of Pixels 
for chan color in zip chans colors hist = cv2 
. calcHist chan 0 None 256 0 256 plt . 
plot hist color = color plt . xlim 0 256 
fig = plt . figure ax = fig . add 
_ subplot 131 hist = cv2 . calcHist chans 1 
chans 0 0 1 None 32 32 0 256 0 
256 p = ax . imshow hist interpolation = nearest 
ax . set _ title 2D Color Histogram for G 
and B plt . colorbar p ax = fig . 
add _ subplot 132 hist = cv2 . calcHist chans 
1 chans 2 0 1 None 32 32 0 256 
0 256 p = ax . imshow hist interpolation = 
nearest ax . set _ title 2D Color Histogram for 
G and R plt . colorbar p ax = fig 
. add _ subplot 133 hist = cv2 . calcHist 
chans 0 chans 2 0 1 None 32 32 0 
256 0 256 p = ax . imshow hist interpolation 
= nearest ax . set _ title 2D Color Histogram 
for B and R plt . colorbar p print 2D 
histogram shape % s with % d values % hist 
. shape hist . flatten . shape 0 hist = 
cv2 . calcHist image 0 1 2 None 8 8 
8 0 256 0 256 0 256 print 3D histogram 
shape % s with % d values % hist . 
shape hist . flatten . shape 0 plt . show 
# 直方图 均衡 import argparse import cv2 # construct the 
argument parser and parse the arguments ap = argparse . 
ArgumentParser ap . add _ argument i image required = 
True help = Path to the image args = vars 
ap . parse _ args # load the image and 
convert it to grayscale image = cv2 . imread args 
image image = cv2 . cvtColor image cv2 . COLOR 
_ BGR2GRAY # apply histogram equalization to stretch the constrast 
of our image eq = cv2 . equalizeHist image # 
show our images notice how the constrast of the second 
image has # been stretched cv2 . imshow Original image 
cv2 . imshow Histogram Equalization eq cv2 . waitKey 0 
# 直方图 和 面具 from matplotlib import pyplot as plt 
import numpy as np import cv2 def plot _ histogram 
image title mask = None chans = cv2 . split 
image colors = b g r plt . figure plt 
. title title plt . xlabel Bins plt . ylabel 
# of Pixels for chan color in zip chans colors 
hist = cv2 . calcHist chan 0 mask 256 0 
256 plt . plot hist color = color plt . 
xlim 0 256 image = cv2 . imread beach . 
png cv2 . imshow Original image plot _ histogram image 
Histogram for Original Image mask = np . zeros image 
. shape 2 dtype = uint8 cv2 . rectangle mask 
60 290 210 390 255 1 cv2 . imshow Mask 
mask masked = cv2 . bitwise _ and image image 
mask = mask cv2 . imshow Applying the Mask masked 
plot _ histogram image Histogram for Masked Image mask = 
mask plt . show 13 连接 分量 标签 略 