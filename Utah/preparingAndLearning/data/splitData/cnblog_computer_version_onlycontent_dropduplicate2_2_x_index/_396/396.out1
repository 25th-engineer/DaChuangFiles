原文 http / / blog . csdn . NET / 
chenyusiyuan / article / details / 5967291 立体匹配 主要 是 
通过 找出 每对 图像 间 的 对应 关系 根据 三角测量 
原理 得到 视差 图 在 获得 了 视差 信息 后 
根据 投影 模型 很容易 地 可以 得到 原始 图像 的 
深度 信息 和 三维 信息 立体匹配 技术 被 普遍 认为 
是 立体 视觉 中最 困难 也是 最 关键 的 问题 
主要 是 以下 因素 的 影响 1 光学 失真 和 
噪声 亮度 色调 饱和度 等 失衡 2 平滑 表面 的 
镜面反射 3 投影 缩减 Foreshortening 4 透视 失真 Perspective distortions 
5 低 纹理 Low texture 6 重复 纹理 Repetitive / 
ambiguous patterns 7 透明 物体 8 重叠/v 和非/nr 连续/a 目前/t 
立体匹配/nz 算法/n 是/v 计算机/n 视觉/n 中/f 的/uj 一个/m 难点/d 和/c 
热点/n 算法 很多 但是 一般 的 步骤 是 A 匹配 
代价 计算 匹配 代价 计算 是 整个 立体匹配 算法 的 
基础 实际 是 对 不同 视差 下 进行 灰度 相似性 
测量 常见 的 方法 有 灰度 差 的 平方 SD 
squared intensity differences 灰度 差 的 绝对值 AD absolute intensity 
differences 等 另外 在 求 原始 匹配 代价 时 可以 
设定 一个 上 限值 来 减弱 叠加 过程 中 的 
误 匹配 的 影响 以 AD 法求/nr 匹配 代价 为例 
可用 下式 进行 计算 其中 T 为 设定 的 阈值 
B 匹配 代价 叠加 一般来说 全局 算法 基于 原始 匹配 
代价 进行 后续 算法 计算 而 区域 算法 则 需要 
通过 窗口 叠加 来 增强 匹配 代价 的 可靠性 根据 
原始 匹配 代价 不同 可分为 C 视差 获取 对于 区域 
算法 来说 在 完成 匹配 代价 的 叠加 以后 视差 
的 获取 就 很容易 了 只需 在 一定 范围 内 
选取 叠加 匹配 代价 最优 的 点 SAD 和 SSD 
取 最小值 NCC 取 最大值 作为 对应 匹配 点 如 
胜者为王 算法 WTA Winner take all 而 全局 算法 则 
直接 对 原始 匹配 代价 进行 处理 一般 会 先给 
出 一个 能量 评价 函数 然后 通过 不同 的 优化 
算法 来 求得 能量 的 最小值 同时 每个 点 的 
视 差值 也就 计算 出来 了 D 视差 细化 亚 
像素 级 大多数 立体匹配 算法 计算 出来 的 视差 都是 
一些 离散 的 特定 整 数值 可满足 一般 应用 的 
精度 要求 但 在 一些 精度 要求 比 较高 的 
场合 如 精确 的 三维 重构 中 就 需要 在 
初始 视差 获取 后 采用 一些 措施 对 视差 进行 
细化 如 匹配 代价 的 曲线拟合 图像 滤波 图像 分割 
等 有关 立体匹配 的 介绍 和 常见 匹配 算法 的 
比较 推荐 大家 看看 Stefano Mattoccia   的 讲义   
Stereo Vision algorithms and applications 190页 的 ppt 讲解 得 
非常 形象 详尽 1 ． opencv2 . 1 和 opencv2 
. 0 在做 stereo vision 方面 有 什么 区别 了 
2.1版 增强 了 Stereo Vision 方面 的 功能 1 新增 
了 SGBM 立体匹配 算法 源自 Heiko Hirschmuller 的 Stereo Processing 
by Semi global Matching and Mutual Information 可以 获得 比 
BM 算法 物体 轮廓 更 清晰 的 视差 图 但 
低 纹理 区域 容易 出现 横 / 斜 纹路 在 
GCstate fullDP 选项 使能 时可/nr 消减 这种 异常 纹路 但 
对应 区域 视差 变为 0 且 运行 速度 会 有所 
下降 速度 比 BM 稍慢 352 * 288 的 帧 
处理 速度 大约 是 5 帧 / 秒 2 视差 
效果 BM SGBM GC 处理速度 BM SGBM GC 3 BM 
算法 比 2.0版 性能 有所 提升 其 状态参数 新增 了 
对 左右 视图 感兴趣 区域 ROI 的 支持 roi1 和 
roi2 由 stereoRectify 函数 产生 4 BM 算法 和 GC 
算法 的 核心 代码 改动 不大 主要 是 面向 多线程 
运算 方面 的 由 OpenMP 转向 Intel TBB 5 c 
v F i n d t e r e o 
C o r r e s p o n d 
e n c e B M 函数 的 disparity 参数 
的 数据格式 新增 了 CV _ 32F 的 支持 这种 
格式 的 数据 给 出 实际 视差 而 2.0 版 
只 支持 CV _ 16S 需要 除以 16.0 才能 得到 
实际 的 视差 数值 2 ． 用于 立体匹配 的 图像 
可以 是 彩色 的 吗 在 OpenCV2 . 1 中 
BM 和 GC 算法 只能 对 8位 灰度 图像 计算 
视差 SGBM 算法 则 可以 处理 24位 8bits * 3 
彩色图像 所以在 读入 图像 时 应该 根据 采用 的 算法 
来 处理 图像 int color _ mode = alg = 
= STEREO _ SGBM 1 0 / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / 载入 图像 cvGrabFrame lfCam cvGrabFrame riCam frame1 = 
cvRetrieveFrame lfCam frame2 = cvRetrieveFrame riCam if frame1 . empty 
break resize frame1 img1 img _ size 0 0 resize 
frame2 img2 img _ size 0 0 / / 选择 
彩色 或 灰度 格式 作为 双目 匹配 的 处理 图像 
if color _ mode & & cn 1 { cvtColor 
img1 img1gray CV _ BGR2GRAY cvtColor img2 img2gray CV _ 
BGR2GRAY img1p = img1gray img2p = img2gray } else { 
img1p = img1 img2p = img2 } 3 ． 怎样 
获取 与 原 图像 有效 像素 区域 相同 的 视差 
图 在 OpenCV2 . 0 及 以前 的 版本 中 
所/c 获取/v 的/uj 视差/n 图/n 总是/c 在/p 左侧/f 和/c 右侧/f 
有/v 明显/a 的/uj 黑色/n 区域/n 这些 区域 没有 有效 的 
视差 数据 视差 图 有效 像素 区域 与 视差 窗口 
ndisp 一般 取 正值 且 能被 16 整除 和最/nr 小视 
差值 mindisp 一般 取 0 或 负值 相关 视差 窗口 
越大 视差 图 左侧 的 黑色 区域 越大 最 小视 
差值 越小 视差 图 右侧 的 黑色 区域 越大 其 
原因 是 为了 保证 参考 图像 一般 是 左视图 的 
像素点 能在 目标 图像 右 视图 中 按照 设定 的 
视差 匹配 窗口 匹配 对应点 OpenCV   只从 参考 图像 
的 第 ndisp 1 + mindisp 列 开始 向右 计算 
视差 第 0 列到 第 ndisp 1 + mindisp 列 
的 区域 视差 统一 设置 为 mindisp 1 * 16 
视差 计算 到 第 width + mindisp 列 时 停止 
余下 的 右侧 区域 视 差值 也 统一 设置 为 
mindisp 1 * 16 00177 static const int DISPARITY _ 
SHIFT = 4 00411 int ndisp = state n u 
m b e r O f D i s p 
a r i t i e s 00412 int mindisp 
= state minDisparity 00413 int lofs = MAX ndisp 1 
+ mindisp 0 00414 int rofs = MIN ndisp 1 
+ mindisp 0 00415 int width = left cols height 
= left rows 00416 int width1 = width rofs ndisp 
+ 1 00420 short FILTERED = short mindisp 1 DISPARITY 
_ SHIFT 00466 / / initialize the left and right 
borders of the disparity map 00467 for y = 0 
y height y + + 00468 { 00469 for x 
= 0 x lofs x + + 00470 dptr y 
* dstep + x = FILTERED 00471 for x = 
lofs + width1 x width x + + 00472 dptr 
y * dstep + x = FILTERED 00473 } 00474 
dptr + = lofs 00475 00476 for x = 0 
x width1 x + + dptr + + 这样 的 
设置 很 明显 是 不 符合 实际 应用 的 需求 
的 它 相当于 把 摄像头 的 视场 范围 缩窄 了 
因此 OpenCV2 . 1   做了 明显 的 改进 不再 
要求 左右 视图 和 视差 图 的 大小 size 一致 
允许 对 视差 图 进行 左右 边界 延拓 这样 虽然 
计算 视差 时 还是 按 上面 的 代码 思路 来 
处理 左右 边界 但是 视差 图 的 边界 得到 延拓 
后 有效 视差 的 范围 就 能够 与 对应 视图 
完全 对应 具体 的 实现 代码 范例 如下 / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / 对 左右 视图 的 左边 进行 
边界 延拓 以 获取 与 原始 视图 相同 大小 的 
有效 视差 区域 copyMakeBorder img1r img1b 0 0 m _ 
nMaxDisp 0 IPL _ BORDER _ REPLICATE copyMakeBorder img2r img2b 
0 0 m _ nMaxDisp 0 IPL _ BORDER _ 
REPLICATE / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / 计算 视差 if 
alg = = STEREO _ BM { bm img1b img2b 
dispb / / 截取 与 原始 画面 对应 的 视差 
区域 舍去 加宽 的 部分 displf = dispb . colRange 
m _ nMaxDisp img1b . cols } else if alg 
= = STEREO _ SGBM { sgbm img1b img2b dispb 
displf = dispb . colRange m _ nMaxDisp img1b . 
cols } 4 ． c v F i n d 
t e r e o C o r r e 
s p o n d e n c e B 
M 的 输出 结果 好像 不是 以 像素点 为 单位 
的 视差 @ scyscyao 在 OpenCV2 . 0 中 BM 
函数 得出 的 结果 是以 16位 符 号数 的 形式 
的 存储 的 出于 精度 需要 所有/b 的/uj 视差/n 在/p 
输出/v 时都/nr 扩大/v 了/ul 16倍/mq 2 ^ 4 其 具体 
代码 表示 如下 dptr y * dstep = short ndisp 
mind 1 + mindisp * 256 + d = 0 
p n * 128 / d 0 + 15 4 
可以 看到 原始 视差 在 左移 8位 256 并且 加上 
一个 修 正值 之后 又 右 移了 4位 最终 的 
结果 就是 左移 4位 因此 在 实际 求 距离 时 
cvReprojectTo3D 出来 的 X / W Y / W Z 
/ W 都要 乘以 16 也 就是 W 除以 16 
才能 得到 正确 的 三维 坐标 信息 在 OpenCV2 . 
1 中 BM 算法 可以用 CV _ 16S 或者 CV 
_ 32F 的 方式 输出 视差 数据 使用 32位 float 
格式 可以 得到 真实 的 视 差值 而 CV _ 
16S 格式 得到 的 视差 矩阵 则 需要 除以 16 
才能 得到 正确 的 视差 另外 OpenCV2 . 1 另外 
两种 立体匹配 算法   SGBM 和 GC 只 支持 CV 
_ 16S 格式 的 disparity 矩阵 5 ． 如何 设置 
BM SGBM 和 GC 算法 的 状态参数 1 StereoBMState / 
/ 预处理 滤 波参数 preFilterType 预处理 滤波器 的 类型 主要 
是 用于 降低 亮度 失真 photometric distortions 消除 噪声 和 
增强 纹理 等 有 两种 可选 类型 CV _ STEREO 
_ BM _ NORMALIZED _ RESPONSE 归一化 响应 或者   
CV _ STEREO _ BM _ XSOBEL 水平 方向 Sobel 
算子 默认 类型 该 参数 为 int 型 preFilterSize 预处理 
滤波器 窗口 大小 容许 范围 是 5 255 一般 应该 
在 5x5 . . 21x21 之间 参数 必须 为奇 数值 
int 型 preFilterCap 预处理 滤波器 的 截断值 预 处理 的 
输出 值 仅 保留 preFilterCap preFilterCap 范围内 的 值 参数 
范围 1 31 文档 中 是 31 但 代码 中 
是 63 int / / SAD 参数 SADWindowSize SAD 窗口 
大小 容许 范围 是 5 255 一般 应该 在 5x5 
至 21x21 之间 参数 必须 是 奇数 int 型 minDisparity 
最小 视差 默认值 为 0 可以 是 负值 int 型 
n u m b e r O f D i 
s p a r i t i e s 视差 
窗口 即 最大 视 差值 与 最 小视 差值 之差 
窗口 大小 必须 是 16 的 整数 倍 int 型 
/ / 后处理 参数 textureThreshold 低 纹理 区域 的 判断 
阈值 如果 当前 SAD 窗口 内 所有 邻居 像素点 的 
x 导数 绝对值 之和 小于 指定 阈值 则 该 窗口 
对应 的 像素点 的 视 差值 为 0 That is 
if the sum of absolute values of x derivatives computed 
over SADWindowSize by SADWindowSize pixel neighborhood is smaller than the 
parameter no disparity is computed at the pixel 该 参数 
不能 为 负值 int 型 uniquenessRatio 视差 唯一性 百分比 视差 
窗口 范围 内 最低 代价 是 次 低 代价 的 
1 + uniquenessRatio / 100 倍 时 最低 代价 对应 
的 视 差值 才是 该 像素点 的 视差 否则 该 
像素点 的 视差 为 0 the minimum margin in percents 
between the best minimum cost function value and the second 
best value to accept the computed disparity that is accept 
the computed disparity d ^ only if SAD d = 
SAD d ^ x 1 + uniquenessRatio / 100 . 
for any d = d * + / 1 within 
the search range 该 参数 不能 为 负值 一般 5 
15 左右 的 值 比较 合适 int 型 s p 
e c k l e W i n d o 
w i z e 检查 视差 连通 区域 变化 度 
的 窗口 大小 值 为 0 时 取消 speckle 检查 
int 型 speckleRange 视差 变化 阈值 当 窗口 内 视差 
变化 大于 阈值 时 该 窗口 内 的 视差 清零 
int 型 / / OpenCV2 . 1 新增 的 状态 
参数 roi1 roi2 左右 视图 的 有效 像素 区域 一般 
由 双目 校正 阶段 的 cvStereoRectify 函数 传递 也 可以 
自行 设定 一旦 在 状态参数 中 设定 了 roi1 和 
roi2 OpenCV 会 通过 c v G e t V 
a l i d D i s p a r 
i t y R O I 函数 计算出 视差 图 
的 有效 区域 在 有效 区域 外 的 视 差值 
将被 清零 disp12MaxDiff 左 视差 图 直接 计算 得出 和右/nr 
视差 图 通过 c v V a l i d 
a t e D i s p a r i 
t y 计算 得出 之间 的 最大 容许 差异 超过 
该 阈值 的 视 差值 将被 清零 该 参数 默认 
为 1 即 不 执行 左右 视差 检查 int 型 
注意 在 程序 调试 阶段 最好 保持 该 值 为 
1 以便 查看 不同 视差 窗口 生成 的 视差 效果 
具体 请 参见 使用 OpenGL 动态显示 双目 视觉 三维 重构 
效果 示例 一 文中 的 讨论 在 上述 参数 中 
对 视差 生成 效果 影响 较大 的 主要 参数 是 
SADWindowSize n u m b e r O f D 
i s p a r i t i e s 
和 uniquenessRatio 三个 一般 只需 对 这三个 参数 进行 调整 
其余 参数 按 默认设置 即可 在 OpenCV2 . 1 中 
BM/w 算法/n 有/v C/w 和C+/nr +/i 两种 实现 模块 2 
t e r e o G B M t a 
t e G B M 算法 的 状态参数 大部分 与 
BM 算法 的 一致 下面 只 解释 不同 的 部分 
SADWindowSize SAD 窗口 大小 容许 范围 是 1 11 一般 
应该 在 3x3 至 11x11 之间 参数 必须 是 奇数 
int 型 P1 P2 控制 视差 变化 平滑 性 的 
参数 P1 P2 的 值 越大 视差 越 平滑 P1 
是 相邻 像素点 视差 增 / 减 1 时的/nr 惩罚 
系数 P2 是 相邻 像素点 视差 变化 值 大于 1时 
的 惩罚 系数 P2 必须 大于 P1 OpenCV2 . 1 
提供 的 例程   stereo _ match . cpp 给 
出了 P1 和 P2 比较 合适 的 数值 fullDP 布尔值 
当 设置 为 TRUE 时 运行 双通道 动态 编程 算法 
full scale 2 pass dynamic programming algorithm 会 占用 O 
W * H * numDisparities 个 字节 对于 高 分辨率 
图像 将 占用 较大 的 内存空间 一般 设置 为 FALSE 
注意 OpenCV2 . 1 的 SGBM 算法 是 用 C 
+ + 语言 编写 的 没有 C 实现 模块 与 
H . Hirschmuller 提出 的 原 算法 相比 主要 有 
如下 变化 算法 默认 运行 单通道 DP 算法 只用了 5个 
方向 而 fullDP 使能 时则/nr 使用 8个 方向 可能 需要 
占用 大量 内存 算法 在 计算 匹配 代价 函数 时 
采用 块 匹 配方法 而非 像素 匹配 不过 SADWindowSize = 
1时 就 等于 像素 匹配 了 匹配 代价 的 计算 
采用 BT 算法 Depth Discontinuities by Pixel to Pixel Stereo 
by . Birchfield and C . Tomasi 并 没有 实现 
基于 互 熵 信息 的 匹配 代价 计算 增加/v 了/ul 
一些/m BM/w 算法/n 中的/i 预处理/vn 和后/nr 处理/v 程序/n 3 StereoGCStateGC 
算法 的 状态参数 只有 两个 n u m b e 
r O f D i s p a r i 
t i e s 和 maxIters   并且 只能 通过 
c v C r e a t e t e 
r e o G C t a t e 在 
创建 算法 状态 结构体 时 一次性 确定 不能 在 循环 
中 更新 状态 信息 GC 算法 并 不是 一种 实时 
算法 但 可以 得到 物体 轮廓 清晰 准确 的 视差 
图 适用于 静态 环境 物体 的 深度 重构 注意 GC 
算法 只能在 C 语言 模式 下 运行 并且 不能 对 
视差 图 进行 预先 的 边界 延拓 左右 视图 和 
左右 视差 矩阵 的 大小 必须 一致 6 ． 如何 
实现 视差 图 的 伪 彩色显示 首先 要 将 16位 
符号 整形 的 视差 矩阵 转换 为 8位 无符号 整形 
矩阵 然后 按照 一定 的 变换 关系 进行 伪 彩色 
处理 我 的 实现 代码 如下 / / 转换 为 
CV _ 8U 格式 彩色显示 dispLfcv = displf dispRicv = 
dispri disp8cv = disp8 if alg = = STEREO _ 
GC { cvNormalize & dispLfcv & disp8cv 0 256 CV 
_ MINMAX } else { displf . convertTo disp8 CV 
_ 8U 255 / m _ nMaxDisp * 16 . 
} F _ Gray2Color & disp8cv vdispRGB 灰度 图 转 
伪 彩色 图 的 代码 主要 功能 是 使 灰度 
图中 亮度 越高 的 像素点 在 伪 彩色 图中 对应 
的 点 越 趋向于 红色 亮度 越低 则 对应 的 
伪 彩色 越 趋向于 蓝色 总体 上 按照 灰度 值 
高低 由 红 渐变 至 蓝 中间色 为 绿色 其 
对应 关系 如下 图 所示 void F _ Gray2Color CvMat 
* gray _ mat CvMat * color _ mat { 
if color _ mat cvZero color _ mat int stype 
= CV _ MAT _ TYPE gray _ mat type 
dtype = CV _ MAT _ TYPE color _ mat 
type int rows = gray _ mat rows cols = 
gray _ mat cols / / 判断 输入 的 灰度 
图 和 输出 的 伪 彩色 图 是否 大小 相同 
格式 是否 符合 要求 if CV _ ARE _ SIZES 
_ EQ gray _ mat color _ mat & & 
stype = = CV _ 8UC1 & & dtype = 
= CV _ 8UC3 { CvMat * red = cvCreateMat 
gray _ mat rows gray _ mat cols CV _ 
8U CvMat * green = cvCreateMat gray _ mat rows 
gray _ mat cols CV _ 8U CvMat * blue 
= cvCreateMat gray _ mat rows gray _ mat cols 
CV _ 8U CvMat * mask = cvCreateMat gray _ 
mat rows gray _ mat cols CV _ 8U / 
/ 计算 各 彩色 通道 的 像素 值 cvSubRS gray 
_ mat cvScalar 255 blue / / blue I = 
255 gray I cvCopy gray _ mat red / / 
red I = gray I cvCopy gray _ mat green 
/ / green I = gray I if gray I 
128 cvCmpS green 128 mask CV _ CMP _ GE 
/ / green I = 255 gray I if gray 
I = 128 cvSubRS green cvScalar 255 green mask cvConvertScale 
green green 2.0 0.0 / / 合成 伪 彩色 图 
cvMerge blue green red NULL color _ mat cvReleaseMat & 
red cvReleaseMat & green cvReleaseMat & blue cvReleaseMat & mask 
} } 7 ． 如何将 视差 数据 保存为 txt 数据文件 
以便 在 Matlab 中 读取 分析 由于 OpenCV 本身 只 
支持 xml yml 的 数据 文件 读写 功能 并且 其 
xml 文件 与 构建 网页 数据 所用 的 xml 文件格式 
不一致 在 Matlab 中 无法 读取 我们 可以 通过 以下 
方式 将 视差 数据 保存为 txt 文件 再 导入到 Matlab 
中 void saveDisp const char * filename const Mat & 
mat { FILE * fp = fopen filename wt fprintf 
fp % 02d / n mat . rows fprintf fp 
% 02d / n mat . cols for int y 
= 0 y mat . rows y + + { 
for int x = 0 x mat . cols x 
+ + { short disp = mat . at short 
y x / / 这里 视差 矩阵 是 CV _ 
16S 格式 的 故 用 short 类型 读取 fprintf fp 
% d / n disp / / 若 视差 矩阵 
是 CV _ 32F 格式 则用 float 类型 读取 } 
} fclose fp } 相应 的 Matlab 代码 为 function 
img = txt2img filename data = importdata filename r = 
data 1 % 行数 c = data 2 % 列数 
disp = data 3 end % 视差 vmin = min 
disp vmax = max disp disp = reshape disp c 
r % 将 列 向量 形式 的 disp 重构 为 
矩阵 形式 % OpenCV 是 行扫描 存储 图像 Matlab 是 
列 扫描 存储 图像 % 故 对 disp 的 重新排列 
是 首先 变成 c 行 r 列 的 矩阵 然后再 
转置 回 r 行 c 列 img = uint8 255 
* disp vmin / vmax vmin mesh disp set gca 
YDir reverse % 通过 mesh 方式 绘图 时 需 倒置 
Y 轴 方向 axis tight % 使 坐标轴 显示 范围 
与 数据 范围 相 贴合 去除 空白 显示 区 显示 
效果 如下 原文 http / / blog . csdn . NET / 
chenyusiyuan / article / details / 5967291 立体匹配 主要 是 
通过 找出 每对 图像 间 的 对应 关系 根据 三角测量 
原理 得到 视差 图 在 获得 了 视差 信息 后 
根据 投影 模型 很容易 地 可以 得到 原始 图像 的 
深度 信息 和 三维 信息 立体匹配 技术 被 普遍 认为 
是 立体 视觉 中最 困难 也是 最 关键 的 问题 
主要 是 以下 因素 的 影响 1 光学 失真 和 
噪声 亮度 色调 饱和度 等 失衡 2 平滑 表面 的 
镜面反射 3 投影 缩减 Foreshortening 4 透视 失真 Perspective distortions 
5 低 纹理 Low texture 6 重复 纹理 Repetitive / 
ambiguous patterns 7 透明 物体 8 重叠/v 和非/nr 连续/a 目前/t 
立体匹配/nz 算法/n 是/v 计算机/n 视觉/n 中/f 的/uj 一个/m 难点/d 和/c 
热点/n 算法 很多 但是 一般 的 步骤 是 A 匹配 
代价 计算 匹配 代价 计算 是 整个 立体匹配 算法 的 
基础 实际 是 对 不同 视差 下 进行 灰度 相似性 
测量 常见 的 方法 有 灰度 差 的 平方 SD 
squared intensity differences 灰度 差 的 绝对值 AD absolute intensity 
differences 等 另外 在 求 原始 匹配 代价 时 可以 
设定 一个 上 限值 来 减弱 叠加 过程 中 的 
误 匹配 的 影响 以 AD 法求/nr 匹配 代价 为例 
可用 下式 进行 计算 其中 T 为 设定 的 阈值 
B 匹配 代价 叠加 一般来说 全局 算法 基于 原始 匹配 
代价 进行 后续 算法 计算 而 区域 算法 则 需要 
通过 窗口 叠加 来 增强 匹配 代价 的 可靠性 根据 
原始 匹配 代价 不同 可分为 C 视差 获取 对于 区域 
算法 来说 在 完成 匹配 代价 的 叠加 以后 视差 
的 获取 就 很容易 了 只需 在 一定 范围 内 
选取 叠加 匹配 代价 最优 的 点 SAD 和 SSD 
取 最小值 NCC 取 最大值 作为 对应 匹配 点 如 
胜者为王 算法 WTA Winner take all 而 全局 算法 则 
直接 对 原始 匹配 代价 进行 处理 一般 会 先给 
出 一个 能量 评价 函数 然后 通过 不同 的 优化 
算法 来 求得 能量 的 最小值 同时 每个 点 的 
视 差值 也就 计算 出来 了 D 视差 细化 亚 
像素 级 大多数 立体匹配 算法 计算 出来 的 视差 都是 
一些 离散 的 特定 整 数值 可满足 一般 应用 的 
精度 要求 但 在 一些 精度 要求 比 较高 的 
场合 如 精确 的 三维 重构 中 就 需要 在 
初始 视差 获取 后 采用 一些 措施 对 视差 进行 
细化 如 匹配 代价 的 曲线拟合 图像 滤波 图像 分割 
等 有关 立体匹配 的 介绍 和 常见 匹配 算法 的 
比较 推荐 大家 看看 Stefano Mattoccia   的 讲义   
Stereo Vision algorithms and applications 190页 的 ppt 讲解 得 
非常 形象 详尽 1 ． opencv2 . 1 和 opencv2 
. 0 在做 stereo vision 方面 有 什么 区别 了 
2.1版 增强 了 Stereo Vision 方面 的 功能 1 新增 
了 SGBM 立体匹配 算法 源自 Heiko Hirschmuller 的 Stereo Processing 
by Semi global Matching and Mutual Information 可以 获得 比 
BM 算法 物体 轮廓 更 清晰 的 视差 图 但 
低 纹理 区域 容易 出现 横 / 斜 纹路 在 
GCstate fullDP 选项 使能 时可/nr 消减 这种 异常 纹路 但 
对应 区域 视差 变为 0 且 运行 速度 会 有所 
下降 速度 比 BM 稍慢 352 * 288 的 帧 
处理 速度 大约 是 5 帧 / 秒 2 视差 
效果 BM SGBM GC 处理速度 BM SGBM GC 3 BM 
算法 比 2.0版 性能 有所 提升 其 状态参数 新增 了 
对 左右 视图 感兴趣 区域 ROI 的 支持 roi1 和 
roi2 由 stereoRectify 函数 产生 4 BM 算法 和 GC 
算法 的 核心 代码 改动 不大 主要 是 面向 多线程 
运算 方面 的 由 OpenMP 转向 Intel TBB 5 c 
v F i n d t e r e o 
C o r r e s p o n d 
e n c e B M 函数 的 disparity 参数 
的 数据格式 新增 了 CV _ 32F 的 支持 这种 
格式 的 数据 给 出 实际 视差 而 2.0 版 
只 支持 CV _ 16S 需要 除以 16.0 才能 得到 
实际 的 视差 数值 2 ． 用于 立体匹配 的 图像 
可以 是 彩色 的 吗 在 OpenCV2 . 1 中 
BM 和 GC 算法 只能 对 8位 灰度 图像 计算 
视差 SGBM 算法 则 可以 处理 24位 8bits * 3 
彩色图像 所以在 读入 图像 时 应该 根据 采用 的 算法 
来 处理 图像 int color _ mode = alg = 
= STEREO _ SGBM 1 0 / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / 载入 图像 cvGrabFrame lfCam cvGrabFrame riCam frame1 = 
cvRetrieveFrame lfCam frame2 = cvRetrieveFrame riCam if frame1 . empty 
break resize frame1 img1 img _ size 0 0 resize 
frame2 img2 img _ size 0 0 / / 选择 
彩色 或 灰度 格式 作为 双目 匹配 的 处理 图像 
if color _ mode & & cn 1 { cvtColor 
img1 img1gray CV _ BGR2GRAY cvtColor img2 img2gray CV _ 
BGR2GRAY img1p = img1gray img2p = img2gray } else { 
img1p = img1 img2p = img2 } 3 ． 怎样 
获取 与 原 图像 有效 像素 区域 相同 的 视差 
图 在 OpenCV2 . 0 及 以前 的 版本 中 
所/c 获取/v 的/uj 视差/n 图/n 总是/c 在/p 左侧/f 和/c 右侧/f 
有/v 明显/a 的/uj 黑色/n 区域/n 这些 区域 没有 有效 的 
视差 数据 视差 图 有效 像素 区域 与 视差 窗口 
ndisp 一般 取 正值 且 能被 16 整除 和最/nr 小视 
差值 mindisp 一般 取 0 或 负值 相关 视差 窗口 
越大 视差 图 左侧 的 黑色 区域 越大 最 小视 
差值 越小 视差 图 右侧 的 黑色 区域 越大 其 
原因 是 为了 保证 参考 图像 一般 是 左视图 的 
像素点 能在 目标 图像 右 视图 中 按照 设定 的 
视差 匹配 窗口 匹配 对应点 OpenCV   只从 参考 图像 
的 第 ndisp 1 + mindisp 列 开始 向右 计算 
视差 第 0 列到 第 ndisp 1 + mindisp 列 
的 区域 视差 统一 设置 为 mindisp 1 * 16 
视差 计算 到 第 width + mindisp 列 时 停止 
余下 的 右侧 区域 视 差值 也 统一 设置 为 
mindisp 1 * 16 00177 static const int DISPARITY _ 
SHIFT = 4 00411 int ndisp = state n u 
m b e r O f D i s p 
a r i t i e s 00412 int mindisp 
= state minDisparity 00413 int lofs = MAX ndisp 1 
+ mindisp 0 00414 int rofs = MIN ndisp 1 
+ mindisp 0 00415 int width = left cols height 
= left rows 00416 int width1 = width rofs ndisp 
+ 1 00420 short FILTERED = short mindisp 1 DISPARITY 
_ SHIFT 00466 / / initialize the left and right 
borders of the disparity map 00467 for y = 0 
y height y + + 00468 { 00469 for x 
= 0 x lofs x + + 00470 dptr y 
* dstep + x = FILTERED 00471 for x = 
lofs + width1 x width x + + 00472 dptr 
y * dstep + x = FILTERED 00473 } 00474 
dptr + = lofs 00475 00476 for x = 0 
x width1 x + + dptr + + 这样 的 
设置 很 明显 是 不 符合 实际 应用 的 需求 
的 它 相当于 把 摄像头 的 视场 范围 缩窄 了 
因此 OpenCV2 . 1   做了 明显 的 改进 不再 
要求 左右 视图 和 视差 图 的 大小 size 一致 
允许 对 视差 图 进行 左右 边界 延拓 这样 虽然 
计算 视差 时 还是 按 上面 的 代码 思路 来 
处理 左右 边界 但是 视差 图 的 边界 得到 延拓 
后 有效 视差 的 范围 就 能够 与 对应 视图 
完全 对应 具体 的 实现 代码 范例 如下 / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / 对 左右 视图 的 左边 进行 
边界 延拓 以 获取 与 原始 视图 相同 大小 的 
有效 视差 区域 copyMakeBorder img1r img1b 0 0 m _ 
nMaxDisp 0 IPL _ BORDER _ REPLICATE copyMakeBorder img2r img2b 
0 0 m _ nMaxDisp 0 IPL _ BORDER _ 
REPLICATE / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / 计算 视差 if 
alg = = STEREO _ BM { bm img1b img2b 
dispb / / 截取 与 原始 画面 对应 的 视差 
区域 舍去 加宽 的 部分 displf = dispb . colRange 
m _ nMaxDisp img1b . cols } else if alg 
= = STEREO _ SGBM { sgbm img1b img2b dispb 
displf = dispb . colRange m _ nMaxDisp img1b . 
cols } 4 ． c v F i n d 
t e r e o C o r r e 
s p o n d e n c e B 
M 的 输出 结果 好像 不是 以 像素点 为 单位 
的 视差 @ scyscyao 在 OpenCV2 . 0 中 BM 
函数 得出 的 结果 是以 16位 符 号数 的 形式 
的 存储 的 出于 精度 需要 所有/b 的/uj 视差/n 在/p 
输出/v 时都/nr 扩大/v 了/ul 16倍/mq 2 ^ 4 其 具体 
代码 表示 如下 dptr y * dstep = short ndisp 
mind 1 + mindisp * 256 + d = 0 
p n * 128 / d 0 + 15 4 
可以 看到 原始 视差 在 左移 8位 256 并且 加上 
一个 修 正值 之后 又 右 移了 4位 最终 的 
结果 就是 左移 4位 因此 在 实际 求 距离 时 
cvReprojectTo3D 出来 的 X / W Y / W Z 
/ W 都要 乘以 16 也 就是 W 除以 16 
才能 得到 正确 的 三维 坐标 信息 在 OpenCV2 . 
1 中 BM 算法 可以用 CV _ 16S 或者 CV 
_ 32F 的 方式 输出 视差 数据 使用 32位 float 
格式 可以 得到 真实 的 视 差值 而 CV _ 
16S 格式 得到 的 视差 矩阵 则 需要 除以 16 
才能 得到 正确 的 视差 另外 OpenCV2 . 1 另外 
两种 立体匹配 算法   SGBM 和 GC 只 支持 CV 
_ 16S 格式 的 disparity 矩阵 5 ． 如何 设置 
BM SGBM 和 GC 算法 的 状态参数 1 StereoBMState / 
/ 预处理 滤 波参数 preFilterType 预处理 滤波器 的 类型 主要 
是 用于 降低 亮度 失真 photometric distortions 消除 噪声 和 
增强 纹理 等 有 两种 可选 类型 CV _ STEREO 
_ BM _ NORMALIZED _ RESPONSE 归一化 响应 或者   
CV _ STEREO _ BM _ XSOBEL 水平 方向 Sobel 
算子 默认 类型 该 参数 为 int 型 preFilterSize 预处理 
滤波器 窗口 大小 容许 范围 是 5 255 一般 应该 
在 5x5 . . 21x21 之间 参数 必须 为奇 数值 
int 型 preFilterCap 预处理 滤波器 的 截断值 预 处理 的 
输出 值 仅 保留 preFilterCap preFilterCap 范围内 的 值 参数 
范围 1 31 文档 中 是 31 但 代码 中 
是 63 int / / SAD 参数 SADWindowSize SAD 窗口 
大小 容许 范围 是 5 255 一般 应该 在 5x5 
至 21x21 之间 参数 必须 是 奇数 int 型 minDisparity 
最小 视差 默认值 为 0 可以 是 负值 int 型 
n u m b e r O f D i 
s p a r i t i e s 视差 
窗口 即 最大 视 差值 与 最 小视 差值 之差 
窗口 大小 必须 是 16 的 整数 倍 int 型 
/ / 后处理 参数 textureThreshold 低 纹理 区域 的 判断 
阈值 如果 当前 SAD 窗口 内 所有 邻居 像素点 的 
x 导数 绝对值 之和 小于 指定 阈值 则 该 窗口 
对应 的 像素点 的 视 差值 为 0 That is 
if the sum of absolute values of x derivatives computed 
over SADWindowSize by SADWindowSize pixel neighborhood is smaller than the 
parameter no disparity is computed at the pixel 该 参数 
不能 为 负值 int 型 uniquenessRatio 视差 唯一性 百分比 视差 
窗口 范围 内 最低 代价 是 次 低 代价 的 
1 + uniquenessRatio / 100 倍 时 最低 代价 对应 
的 视 差值 才是 该 像素点 的 视差 否则 该 
像素点 的 视差 为 0 the minimum margin in percents 
between the best minimum cost function value and the second 
best value to accept the computed disparity that is accept 
the computed disparity d ^ only if SAD d = 
SAD d ^ x 1 + uniquenessRatio / 100 . 
for any d = d * + / 1 within 
the search range 该 参数 不能 为 负值 一般 5 
15 左右 的 值 比较 合适 int 型 s p 
e c k l e W i n d o 
w i z e 检查 视差 连通 区域 变化 度 
的 窗口 大小 值 为 0 时 取消 speckle 检查 
int 型 speckleRange 视差 变化 阈值 当 窗口 内 视差 
变化 大于 阈值 时 该 窗口 内 的 视差 清零 
int 型 / / OpenCV2 . 1 新增 的 状态 
参数 roi1 roi2 左右 视图 的 有效 像素 区域 一般 
由 双目 校正 阶段 的 cvStereoRectify 函数 传递 也 可以 
自行 设定 一旦 在 状态参数 中 设定 了 roi1 和 
roi2 OpenCV 会 通过 c v G e t V 
a l i d D i s p a r 
i t y R O I 函数 计算出 视差 图 
的 有效 区域 在 有效 区域 外 的 视 差值 
将被 清零 disp12MaxDiff 左 视差 图 直接 计算 得出 和右/nr 
视差 图 通过 c v V a l i d 
a t e D i s p a r i 
t y 计算 得出 之间 的 最大 容许 差异 超过 
该 阈值 的 视 差值 将被 清零 该 参数 默认 
为 1 即 不 执行 左右 视差 检查 int 型 
注意 在 程序 调试 阶段 最好 保持 该 值 为 
1 以便 查看 不同 视差 窗口 生成 的 视差 效果 
具体 请 参见 使用 OpenGL 动态显示 双目 视觉 三维 重构 
效果 示例 一 文中 的 讨论 在 上述 参数 中 
对 视差 生成 效果 影响 较大 的 主要 参数 是 
SADWindowSize n u m b e r O f D 
i s p a r i t i e s 
和 uniquenessRatio 三个 一般 只需 对 这三个 参数 进行 调整 
其余 参数 按 默认设置 即可 在 OpenCV2 . 1 中 
BM/w 算法/n 有/v C/w 和C+/nr +/i 两种 实现 模块 2 
t e r e o G B M t a 
t e G B M 算法 的 状态参数 大部分 与 
BM 算法 的 一致 下面 只 解释 不同 的 部分 
SADWindowSize SAD 窗口 大小 容许 范围 是 1 11 一般 
应该 在 3x3 至 11x11 之间 参数 必须 是 奇数 
int 型 P1 P2 控制 视差 变化 平滑 性 的 
参数 P1 P2 的 值 越大 视差 越 平滑 P1 
是 相邻 像素点 视差 增 / 减 1 时的/nr 惩罚 
系数 P2 是 相邻 像素点 视差 变化 值 大于 1时 
的 惩罚 系数 P2 必须 大于 P1 OpenCV2 . 1 
提供 的 例程   stereo _ match . cpp 给 
出了 P1 和 P2 比较 合适 的 数值 fullDP 布尔值 
当 设置 为 TRUE 时 运行 双通道 动态 编程 算法 
full scale 2 pass dynamic programming algorithm 会 占用 O 
W * H * numDisparities 个 字节 对于 高 分辨率 
图像 将 占用 较大 的 内存空间 一般 设置 为 FALSE 
注意 OpenCV2 . 1 的 SGBM 算法 是 用 C 
+ + 语言 编写 的 没有 C 实现 模块 与 
H . Hirschmuller 提出 的 原 算法 相比 主要 有 
如下 变化 算法 默认 运行 单通道 DP 算法 只用了 5个 
方向 而 fullDP 使能 时则/nr 使用 8个 方向 可能 需要 
占用 大量 内存 算法 在 计算 匹配 代价 函数 时 
采用 块 匹 配方法 而非 像素 匹配 不过 SADWindowSize = 
1时 就 等于 像素 匹配 了 匹配 代价 的 计算 
采用 BT 算法 Depth Discontinuities by Pixel to Pixel Stereo 
by . Birchfield and C . Tomasi 并 没有 实现 
基于 互 熵 信息 的 匹配 代价 计算 增加/v 了/ul 
一些/m BM/w 算法/n 中的/i 预处理/vn 和后/nr 处理/v 程序/n 3 StereoGCStateGC 
算法 的 状态参数 只有 两个 n u m b e 
r O f D i s p a r i 
t i e s 和 maxIters   并且 只能 通过 
c v C r e a t e t e 
r e o G C t a t e 在 
创建 算法 状态 结构体 时 一次性 确定 不能 在 循环 
中 更新 状态 信息 GC 算法 并 不是 一种 实时 
算法 但 可以 得到 物体 轮廓 清晰 准确 的 视差 
图 适用于 静态 环境 物体 的 深度 重构 注意 GC 
算法 只能在 C 语言 模式 下 运行 并且 不能 对 
视差 图 进行 预先 的 边界 延拓 左右 视图 和 
左右 视差 矩阵 的 大小 必须 一致 6 ． 如何 
实现 视差 图 的 伪 彩色显示 首先 要 将 16位 
符号 整形 的 视差 矩阵 转换 为 8位 无符号 整形 
矩阵 然后 按照 一定 的 变换 关系 进行 伪 彩色 
处理 我 的 实现 代码 如下 / / 转换 为 
CV _ 8U 格式 彩色显示 dispLfcv = displf dispRicv = 
dispri disp8cv = disp8 if alg = = STEREO _ 
GC { cvNormalize & dispLfcv & disp8cv 0 256 CV 
_ MINMAX } else { displf . convertTo disp8 CV 
_ 8U 255 / m _ nMaxDisp * 16 . 
} F _ Gray2Color & disp8cv vdispRGB 灰度 图 转 
伪 彩色 图 的 代码 主要 功能 是 使 灰度 
图中 亮度 越高 的 像素点 在 伪 彩色 图中 对应 
的 点 越 趋向于 红色 亮度 越低 则 对应 的 
伪 彩色 越 趋向于 蓝色 总体 上 按照 灰度 值 
高低 由 红 渐变 至 蓝 中间色 为 绿色 其 
对应 关系 如下 图 所示 void F _ Gray2Color CvMat 
* gray _ mat CvMat * color _ mat { 
if color _ mat cvZero color _ mat int stype 
= CV _ MAT _ TYPE gray _ mat type 
dtype = CV _ MAT _ TYPE color _ mat 
type int rows = gray _ mat rows cols = 
gray _ mat cols / / 判断 输入 的 灰度 
图 和 输出 的 伪 彩色 图 是否 大小 相同 
格式 是否 符合 要求 if CV _ ARE _ SIZES 
_ EQ gray _ mat color _ mat & & 
stype = = CV _ 8UC1 & & dtype = 
= CV _ 8UC3 { CvMat * red = cvCreateMat 
gray _ mat rows gray _ mat cols CV _ 
8U CvMat * green = cvCreateMat gray _ mat rows 
gray _ mat cols CV _ 8U CvMat * blue 
= cvCreateMat gray _ mat rows gray _ mat cols 
CV _ 8U CvMat * mask = cvCreateMat gray _ 
mat rows gray _ mat cols CV _ 8U / 
/ 计算 各 彩色 通道 的 像素 值 cvSubRS gray 
_ mat cvScalar 255 blue / / blue I = 
255 gray I cvCopy gray _ mat red / / 
red I = gray I cvCopy gray _ mat green 
/ / green I = gray I if gray I 
128 cvCmpS green 128 mask CV _ CMP _ GE 
/ / green I = 255 gray I if gray 
I = 128 cvSubRS green cvScalar 255 green mask cvConvertScale 
green green 2.0 0.0 / / 合成 伪 彩色 图 
cvMerge blue green red NULL color _ mat cvReleaseMat & 
red cvReleaseMat & green cvReleaseMat & blue cvReleaseMat & mask 
} } 7 ． 如何将 视差 数据 保存为 txt 数据文件 
以便 在 Matlab 中 读取 分析 由于 OpenCV 本身 只 
支持 xml yml 的 数据 文件 读写 功能 并且 其 
xml 文件 与 构建 网页 数据 所用 的 xml 文件格式 
不一致 在 Matlab 中 无法 读取 我们 可以 通过 以下 
方式 将 视差 数据 保存为 txt 文件 再 导入到 Matlab 
中 void saveDisp const char * filename const Mat & 
mat { FILE * fp = fopen filename wt fprintf 
fp % 02d / n mat . rows fprintf fp 
% 02d / n mat . cols for int y 
= 0 y mat . rows y + + { 
for int x = 0 x mat . cols x 
+ + { short disp = mat . at short 
y x / / 这里 视差 矩阵 是 CV _ 
16S 格式 的 故 用 short 类型 读取 fprintf fp 
% d / n disp / / 若 视差 矩阵 
是 CV _ 32F 格式 则用 float 类型 读取 } 
} fclose fp } 相应 的 Matlab 代码 为 function 
img = txt2img filename data = importdata filename r = 
data 1 % 行数 c = data 2 % 列数 
disp = data 3 end % 视差 vmin = min 
disp vmax = max disp disp = reshape disp c 
r % 将 列 向量 形式 的 disp 重构 为 
矩阵 形式 % OpenCV 是 行扫描 存储 图像 Matlab 是 
列 扫描 存储 图像 % 故 对 disp 的 重新排列 
是 首先 变成 c 行 r 列 的 矩阵 然后再 
转置 回 r 行 c 列 img = uint8 255 
* disp vmin / vmax vmin mesh disp set gca 
YDir reverse % 通过 mesh 方式 绘图 时 需 倒置 
Y 轴 方向 axis tight % 使 坐标轴 显示 范围 
与 数据 范围 相 贴合 去除 空白 显示 区 显示 
效果 如下 原文 http / / blog . csdn . NET / 
chenyusiyuan / article / details / 5967291 立体匹配 主要 是 
通过 找出 每对 图像 间 的 对应 关系 根据 三角测量 
原理 得到 视差 图 在 获得 了 视差 信息 后 
根据 投影 模型 很容易 地 可以 得到 原始 图像 的 
深度 信息 和 三维 信息 立体匹配 技术 被 普遍 认为 
是 立体 视觉 中最 困难 也是 最 关键 的 问题 
主要 是 以下 因素 的 影响 1 光学 失真 和 
噪声 亮度 色调 饱和度 等 失衡 2 平滑 表面 的 
镜面反射 3 投影 缩减 Foreshortening 4 透视 失真 Perspective distortions 
5 低 纹理 Low texture 6 重复 纹理 Repetitive / 
ambiguous patterns 7 透明 物体 8 重叠/v 和非/nr 连续/a 目前/t 
立体匹配/nz 算法/n 是/v 计算机/n 视觉/n 中/f 的/uj 一个/m 难点/d 和/c 
热点/n 算法 很多 但是 一般 的 步骤 是 A 匹配 
代价 计算 匹配 代价 计算 是 整个 立体匹配 算法 的 
基础 实际 是 对 不同 视差 下 进行 灰度 相似性 
测量 常见 的 方法 有 灰度 差 的 平方 SD 
squared intensity differences 灰度 差 的 绝对值 AD absolute intensity 
differences 等 另外 在 求 原始 匹配 代价 时 可以 
设定 一个 上 限值 来 减弱 叠加 过程 中 的 
误 匹配 的 影响 以 AD 法求/nr 匹配 代价 为例 
可用 下式 进行 计算 其中 T 为 设定 的 阈值 
B 匹配 代价 叠加 一般来说 全局 算法 基于 原始 匹配 
代价 进行 后续 算法 计算 而 区域 算法 则 需要 
通过 窗口 叠加 来 增强 匹配 代价 的 可靠性 根据 
原始 匹配 代价 不同 可分为 C 视差 获取 对于 区域 
算法 来说 在 完成 匹配 代价 的 叠加 以后 视差 
的 获取 就 很容易 了 只需 在 一定 范围 内 
选取 叠加 匹配 代价 最优 的 点 SAD 和 SSD 
取 最小值 NCC 取 最大值 作为 对应 匹配 点 如 
胜者为王 算法 WTA Winner take all 而 全局 算法 则 
直接 对 原始 匹配 代价 进行 处理 一般 会 先给 
出 一个 能量 评价 函数 然后 通过 不同 的 优化 
算法 来 求得 能量 的 最小值 同时 每个 点 的 
视 差值 也就 计算 出来 了 D 视差 细化 亚 
像素 级 大多数 立体匹配 算法 计算 出来 的 视差 都是 
一些 离散 的 特定 整 数值 可满足 一般 应用 的 
精度 要求 但 在 一些 精度 要求 比 较高 的 
场合 如 精确 的 三维 重构 中 就 需要 在 
初始 视差 获取 后 采用 一些 措施 对 视差 进行 
细化 如 匹配 代价 的 曲线拟合 图像 滤波 图像 分割 
等 有关 立体匹配 的 介绍 和 常见 匹配 算法 的 
比较 推荐 大家 看看 Stefano Mattoccia   的 讲义   
Stereo Vision algorithms and applications 190页 的 ppt 讲解 得 
非常 形象 详尽 1 ． opencv2 . 1 和 opencv2 
. 0 在做 stereo vision 方面 有 什么 区别 了 
2.1版 增强 了 Stereo Vision 方面 的 功能 1 新增 
了 SGBM 立体匹配 算法 源自 Heiko Hirschmuller 的 Stereo Processing 
by Semi global Matching and Mutual Information 可以 获得 比 
BM 算法 物体 轮廓 更 清晰 的 视差 图 但 
低 纹理 区域 容易 出现 横 / 斜 纹路 在 
GCstate fullDP 选项 使能 时可/nr 消减 这种 异常 纹路 但 
对应 区域 视差 变为 0 且 运行 速度 会 有所 
下降 速度 比 BM 稍慢 352 * 288 的 帧 
处理 速度 大约 是 5 帧 / 秒 2 视差 
效果 BM SGBM GC 处理速度 BM SGBM GC 3 BM 
算法 比 2.0版 性能 有所 提升 其 状态参数 新增 了 
对 左右 视图 感兴趣 区域 ROI 的 支持 roi1 和 
roi2 由 stereoRectify 函数 产生 4 BM 算法 和 GC 
算法 的 核心 代码 改动 不大 主要 是 面向 多线程 
运算 方面 的 由 OpenMP 转向 Intel TBB 5 c 
v F i n d t e r e o 
C o r r e s p o n d 
e n c e B M 函数 的 disparity 参数 
的 数据格式 新增 了 CV _ 32F 的 支持 这种 
格式 的 数据 给 出 实际 视差 而 2.0 版 
只 支持 CV _ 16S 需要 除以 16.0 才能 得到 
实际 的 视差 数值 2 ． 用于 立体匹配 的 图像 
可以 是 彩色 的 吗 在 OpenCV2 . 1 中 
BM 和 GC 算法 只能 对 8位 灰度 图像 计算 
视差 SGBM 算法 则 可以 处理 24位 8bits * 3 
彩色图像 所以在 读入 图像 时 应该 根据 采用 的 算法 
来 处理 图像 int color _ mode = alg = 
= STEREO _ SGBM 1 0 / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / 载入 图像 cvGrabFrame lfCam cvGrabFrame riCam frame1 = 
cvRetrieveFrame lfCam frame2 = cvRetrieveFrame riCam if frame1 . empty 
break resize frame1 img1 img _ size 0 0 resize 
frame2 img2 img _ size 0 0 / / 选择 
彩色 或 灰度 格式 作为 双目 匹配 的 处理 图像 
if color _ mode & & cn 1 { cvtColor 
img1 img1gray CV _ BGR2GRAY cvtColor img2 img2gray CV _ 
BGR2GRAY img1p = img1gray img2p = img2gray } else { 
img1p = img1 img2p = img2 } 3 ． 怎样 
获取 与 原 图像 有效 像素 区域 相同 的 视差 
图 在 OpenCV2 . 0 及 以前 的 版本 中 
所/c 获取/v 的/uj 视差/n 图/n 总是/c 在/p 左侧/f 和/c 右侧/f 
有/v 明显/a 的/uj 黑色/n 区域/n 这些 区域 没有 有效 的 
视差 数据 视差 图 有效 像素 区域 与 视差 窗口 
ndisp 一般 取 正值 且 能被 16 整除 和最/nr 小视 
差值 mindisp 一般 取 0 或 负值 相关 视差 窗口 
越大 视差 图 左侧 的 黑色 区域 越大 最 小视 
差值 越小 视差 图 右侧 的 黑色 区域 越大 其 
原因 是 为了 保证 参考 图像 一般 是 左视图 的 
像素点 能在 目标 图像 右 视图 中 按照 设定 的 
视差 匹配 窗口 匹配 对应点 OpenCV   只从 参考 图像 
的 第 ndisp 1 + mindisp 列 开始 向右 计算 
视差 第 0 列到 第 ndisp 1 + mindisp 列 
的 区域 视差 统一 设置 为 mindisp 1 * 16 
视差 计算 到 第 width + mindisp 列 时 停止 
余下 的 右侧 区域 视 差值 也 统一 设置 为 
mindisp 1 * 16 00177 static const int DISPARITY _ 
SHIFT = 4 00411 int ndisp = state n u 
m b e r O f D i s p 
a r i t i e s 00412 int mindisp 
= state minDisparity 00413 int lofs = MAX ndisp 1 
+ mindisp 0 00414 int rofs = MIN ndisp 1 
+ mindisp 0 00415 int width = left cols height 
= left rows 00416 int width1 = width rofs ndisp 
+ 1 00420 short FILTERED = short mindisp 1 DISPARITY 
_ SHIFT 00466 / / initialize the left and right 
borders of the disparity map 00467 for y = 0 
y height y + + 00468 { 00469 for x 
= 0 x lofs x + + 00470 dptr y 
* dstep + x = FILTERED 00471 for x = 
lofs + width1 x width x + + 00472 dptr 
y * dstep + x = FILTERED 00473 } 00474 
dptr + = lofs 00475 00476 for x = 0 
x width1 x + + dptr + + 这样 的 
设置 很 明显 是 不 符合 实际 应用 的 需求 
的 它 相当于 把 摄像头 的 视场 范围 缩窄 了 
因此 OpenCV2 . 1   做了 明显 的 改进 不再 
要求 左右 视图 和 视差 图 的 大小 size 一致 
允许 对 视差 图 进行 左右 边界 延拓 这样 虽然 
计算 视差 时 还是 按 上面 的 代码 思路 来 
处理 左右 边界 但是 视差 图 的 边界 得到 延拓 
后 有效 视差 的 范围 就 能够 与 对应 视图 
完全 对应 具体 的 实现 代码 范例 如下 / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / 对 左右 视图 的 左边 进行 
边界 延拓 以 获取 与 原始 视图 相同 大小 的 
有效 视差 区域 copyMakeBorder img1r img1b 0 0 m _ 
nMaxDisp 0 IPL _ BORDER _ REPLICATE copyMakeBorder img2r img2b 
0 0 m _ nMaxDisp 0 IPL _ BORDER _ 
REPLICATE / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / 计算 视差 if 
alg = = STEREO _ BM { bm img1b img2b 
dispb / / 截取 与 原始 画面 对应 的 视差 
区域 舍去 加宽 的 部分 displf = dispb . colRange 
m _ nMaxDisp img1b . cols } else if alg 
= = STEREO _ SGBM { sgbm img1b img2b dispb 
displf = dispb . colRange m _ nMaxDisp img1b . 
cols } 4 ． c v F i n d 
t e r e o C o r r e 
s p o n d e n c e B 
M 的 输出 结果 好像 不是 以 像素点 为 单位 
的 视差 @ scyscyao 在 OpenCV2 . 0 中 BM 
函数 得出 的 结果 是以 16位 符 号数 的 形式 
的 存储 的 出于 精度 需要 所有/b 的/uj 视差/n 在/p 
输出/v 时都/nr 扩大/v 了/ul 16倍/mq 2 ^ 4 其 具体 
代码 表示 如下 dptr y * dstep = short ndisp 
mind 1 + mindisp * 256 + d = 0 
p n * 128 / d 0 + 15 4 
可以 看到 原始 视差 在 左移 8位 256 并且 加上 
一个 修 正值 之后 又 右 移了 4位 最终 的 
结果 就是 左移 4位 因此 在 实际 求 距离 时 
cvReprojectTo3D 出来 的 X / W Y / W Z 
/ W 都要 乘以 16 也 就是 W 除以 16 
才能 得到 正确 的 三维 坐标 信息 在 OpenCV2 . 
1 中 BM 算法 可以用 CV _ 16S 或者 CV 
_ 32F 的 方式 输出 视差 数据 使用 32位 float 
格式 可以 得到 真实 的 视 差值 而 CV _ 
16S 格式 得到 的 视差 矩阵 则 需要 除以 16 
才能 得到 正确 的 视差 另外 OpenCV2 . 1 另外 
两种 立体匹配 算法   SGBM 和 GC 只 支持 CV 
_ 16S 格式 的 disparity 矩阵 5 ． 如何 设置 
BM SGBM 和 GC 算法 的 状态参数 1 StereoBMState / 
/ 预处理 滤 波参数 preFilterType 预处理 滤波器 的 类型 主要 
是 用于 降低 亮度 失真 photometric distortions 消除 噪声 和 
增强 纹理 等 有 两种 可选 类型 CV _ STEREO 
_ BM _ NORMALIZED _ RESPONSE 归一化 响应 或者   
CV _ STEREO _ BM _ XSOBEL 水平 方向 Sobel 
算子 默认 类型 该 参数 为 int 型 preFilterSize 预处理 
滤波器 窗口 大小 容许 范围 是 5 255 一般 应该 
在 5x5 . . 21x21 之间 参数 必须 为奇 数值 
int 型 preFilterCap 预处理 滤波器 的 截断值 预 处理 的 
输出 值 仅 保留 preFilterCap preFilterCap 范围内 的 值 参数 
范围 1 31 文档 中 是 31 但 代码 中 
是 63 int / / SAD 参数 SADWindowSize SAD 窗口 
大小 容许 范围 是 5 255 一般 应该 在 5x5 
至 21x21 之间 参数 必须 是 奇数 int 型 minDisparity 
最小 视差 默认值 为 0 可以 是 负值 int 型 
n u m b e r O f D i 
s p a r i t i e s 视差 
窗口 即 最大 视 差值 与 最 小视 差值 之差 
窗口 大小 必须 是 16 的 整数 倍 int 型 
/ / 后处理 参数 textureThreshold 低 纹理 区域 的 判断 
阈值 如果 当前 SAD 窗口 内 所有 邻居 像素点 的 
x 导数 绝对值 之和 小于 指定 阈值 则 该 窗口 
对应 的 像素点 的 视 差值 为 0 That is 
if the sum of absolute values of x derivatives computed 
over SADWindowSize by SADWindowSize pixel neighborhood is smaller than the 
parameter no disparity is computed at the pixel 该 参数 
不能 为 负值 int 型 uniquenessRatio 视差 唯一性 百分比 视差 
窗口 范围 内 最低 代价 是 次 低 代价 的 
1 + uniquenessRatio / 100 倍 时 最低 代价 对应 
的 视 差值 才是 该 像素点 的 视差 否则 该 
像素点 的 视差 为 0 the minimum margin in percents 
between the best minimum cost function value and the second 
best value to accept the computed disparity that is accept 
the computed disparity d ^ only if SAD d = 
SAD d ^ x 1 + uniquenessRatio / 100 . 
for any d = d * + / 1 within 
the search range 该 参数 不能 为 负值 一般 5 
15 左右 的 值 比较 合适 int 型 s p 
e c k l e W i n d o 
w i z e 检查 视差 连通 区域 变化 度 
的 窗口 大小 值 为 0 时 取消 speckle 检查 
int 型 speckleRange 视差 变化 阈值 当 窗口 内 视差 
变化 大于 阈值 时 该 窗口 内 的 视差 清零 
int 型 / / OpenCV2 . 1 新增 的 状态 
参数 roi1 roi2 左右 视图 的 有效 像素 区域 一般 
由 双目 校正 阶段 的 cvStereoRectify 函数 传递 也 可以 
自行 设定 一旦 在 状态参数 中 设定 了 roi1 和 
roi2 OpenCV 会 通过 c v G e t V 
a l i d D i s p a r 
i t y R O I 函数 计算出 视差 图 
的 有效 区域 在 有效 区域 外 的 视 差值 
将被 清零 disp12MaxDiff 左 视差 图 直接 计算 得出 和右/nr 
视差 图 通过 c v V a l i d 
a t e D i s p a r i 
t y 计算 得出 之间 的 最大 容许 差异 超过 
该 阈值 的 视 差值 将被 清零 该 参数 默认 
为 1 即 不 执行 左右 视差 检查 int 型 
注意 在 程序 调试 阶段 最好 保持 该 值 为 
1 以便 查看 不同 视差 窗口 生成 的 视差 效果 
具体 请 参见 使用 OpenGL 动态显示 双目 视觉 三维 重构 
效果 示例 一 文中 的 讨论 在 上述 参数 中 
对 视差 生成 效果 影响 较大 的 主要 参数 是 
SADWindowSize n u m b e r O f D 
i s p a r i t i e s 
和 uniquenessRatio 三个 一般 只需 对 这三个 参数 进行 调整 
其余 参数 按 默认设置 即可 在 OpenCV2 . 1 中 
BM/w 算法/n 有/v C/w 和C+/nr +/i 两种 实现 模块 2 
t e r e o G B M t a 
t e G B M 算法 的 状态参数 大部分 与 
BM 算法 的 一致 下面 只 解释 不同 的 部分 
SADWindowSize SAD 窗口 大小 容许 范围 是 1 11 一般 
应该 在 3x3 至 11x11 之间 参数 必须 是 奇数 
int 型 P1 P2 控制 视差 变化 平滑 性 的 
参数 P1 P2 的 值 越大 视差 越 平滑 P1 
是 相邻 像素点 视差 增 / 减 1 时的/nr 惩罚 
系数 P2 是 相邻 像素点 视差 变化 值 大于 1时 
的 惩罚 系数 P2 必须 大于 P1 OpenCV2 . 1 
提供 的 例程   stereo _ match . cpp 给 
出了 P1 和 P2 比较 合适 的 数值 fullDP 布尔值 
当 设置 为 TRUE 时 运行 双通道 动态 编程 算法 
full scale 2 pass dynamic programming algorithm 会 占用 O 
W * H * numDisparities 个 字节 对于 高 分辨率 
图像 将 占用 较大 的 内存空间 一般 设置 为 FALSE 
注意 OpenCV2 . 1 的 SGBM 算法 是 用 C 
+ + 语言 编写 的 没有 C 实现 模块 与 
H . Hirschmuller 提出 的 原 算法 相比 主要 有 
如下 变化 算法 默认 运行 单通道 DP 算法 只用了 5个 
方向 而 fullDP 使能 时则/nr 使用 8个 方向 可能 需要 
占用 大量 内存 算法 在 计算 匹配 代价 函数 时 
采用 块 匹 配方法 而非 像素 匹配 不过 SADWindowSize = 
1时 就 等于 像素 匹配 了 匹配 代价 的 计算 
采用 BT 算法 Depth Discontinuities by Pixel to Pixel Stereo 
by . Birchfield and C . Tomasi 并 没有 实现 
基于 互 熵 信息 的 匹配 代价 计算 增加/v 了/ul 
一些/m BM/w 算法/n 中的/i 预处理/vn 和后/nr 处理/v 程序/n 3 StereoGCStateGC 
算法 的 状态参数 只有 两个 n u m b e 
r O f D i s p a r i 
t i e s 和 maxIters   并且 只能 通过 
c v C r e a t e t e 
r e o G C t a t e 在 
创建 算法 状态 结构体 时 一次性 确定 不能 在 循环 
中 更新 状态 信息 GC 算法 并 不是 一种 实时 
算法 但 可以 得到 物体 轮廓 清晰 准确 的 视差 
图 适用于 静态 环境 物体 的 深度 重构 注意 GC 
算法 只能在 C 语言 模式 下 运行 并且 不能 对 
视差 图 进行 预先 的 边界 延拓 左右 视图 和 
左右 视差 矩阵 的 大小 必须 一致 6 ． 如何 
实现 视差 图 的 伪 彩色显示 首先 要 将 16位 
符号 整形 的 视差 矩阵 转换 为 8位 无符号 整形 
矩阵 然后 按照 一定 的 变换 关系 进行 伪 彩色 
处理 我 的 实现 代码 如下 / / 转换 为 
CV _ 8U 格式 彩色显示 dispLfcv = displf dispRicv = 
dispri disp8cv = disp8 if alg = = STEREO _ 
GC { cvNormalize & dispLfcv & disp8cv 0 256 CV 
_ MINMAX } else { displf . convertTo disp8 CV 
_ 8U 255 / m _ nMaxDisp * 16 . 
} F _ Gray2Color & disp8cv vdispRGB 灰度 图 转 
伪 彩色 图 的 代码 主要 功能 是 使 灰度 
图中 亮度 越高 的 像素点 在 伪 彩色 图中 对应 
的 点 越 趋向于 红色 亮度 越低 则 对应 的 
伪 彩色 越 趋向于 蓝色 总体 上 按照 灰度 值 
高低 由 红 渐变 至 蓝 中间色 为 绿色 其 
对应 关系 如下 图 所示 void F _ Gray2Color CvMat 
* gray _ mat CvMat * color _ mat { 
if color _ mat cvZero color _ mat int stype 
= CV _ MAT _ TYPE gray _ mat type 
dtype = CV _ MAT _ TYPE color _ mat 
type int rows = gray _ mat rows cols = 
gray _ mat cols / / 判断 输入 的 灰度 
图 和 输出 的 伪 彩色 图 是否 大小 相同 
格式 是否 符合 要求 if CV _ ARE _ SIZES 
_ EQ gray _ mat color _ mat & & 
stype = = CV _ 8UC1 & & dtype = 
= CV _ 8UC3 { CvMat * red = cvCreateMat 
gray _ mat rows gray _ mat cols CV _ 
8U CvMat * green = cvCreateMat gray _ mat rows 
gray _ mat cols CV _ 8U CvMat * blue 
= cvCreateMat gray _ mat rows gray _ mat cols 
CV _ 8U CvMat * mask = cvCreateMat gray _ 
mat rows gray _ mat cols CV _ 8U / 
/ 计算 各 彩色 通道 的 像素 值 cvSubRS gray 
_ mat cvScalar 255 blue / / blue I = 
255 gray I cvCopy gray _ mat red / / 
red I = gray I cvCopy gray _ mat green 
/ / green I = gray I if gray I 
128 cvCmpS green 128 mask CV _ CMP _ GE 
/ / green I = 255 gray I if gray 
I = 128 cvSubRS green cvScalar 255 green mask cvConvertScale 
green green 2.0 0.0 / / 合成 伪 彩色 图 
cvMerge blue green red NULL color _ mat cvReleaseMat & 
red cvReleaseMat & green cvReleaseMat & blue cvReleaseMat & mask 
} } 7 ． 如何将 视差 数据 保存为 txt 数据文件 
以便 在 Matlab 中 读取 分析 由于 OpenCV 本身 只 
支持 xml yml 的 数据 文件 读写 功能 并且 其 
xml 文件 与 构建 网页 数据 所用 的 xml 文件格式 
不一致 在 Matlab 中 无法 读取 我们 可以 通过 以下 
方式 将 视差 数据 保存为 txt 文件 再 导入到 Matlab 
中 void saveDisp const char * filename const Mat & 
mat { FILE * fp = fopen filename wt fprintf 
fp % 02d / n mat . rows fprintf fp 
% 02d / n mat . cols for int y 
= 0 y mat . rows y + + { 
for int x = 0 x mat . cols x 
+ + { short disp = mat . at short 
y x / / 这里 视差 矩阵 是 CV _ 
16S 格式 的 故 用 short 类型 读取 fprintf fp 
% d / n disp / / 若 视差 矩阵 
是 CV _ 32F 格式 则用 float 类型 读取 } 
} fclose fp } 相应 的 Matlab 代码 为 function 
img = txt2img filename data = importdata filename r = 
data 1 % 行数 c = data 2 % 列数 
disp = data 3 end % 视差 vmin = min 
disp vmax = max disp disp = reshape disp c 
r % 将 列 向量 形式 的 disp 重构 为 
矩阵 形式 % OpenCV 是 行扫描 存储 图像 Matlab 是 
列 扫描 存储 图像 % 故 对 disp 的 重新排列 
是 首先 变成 c 行 r 列 的 矩阵 然后再 
转置 回 r 行 c 列 img = uint8 255 
* disp vmin / vmax vmin mesh disp set gca 
YDir reverse % 通过 mesh 方式 绘图 时 需 倒置 
Y 轴 方向 axis tight % 使 坐标轴 显示 范围 
与 数据 范围 相 贴合 去除 空白 显示 区 显示 
效果 如下 