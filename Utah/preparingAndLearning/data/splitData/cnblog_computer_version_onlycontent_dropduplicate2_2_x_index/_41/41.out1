1 验证码 的 基本 知识 及 来由 网络 安全 技术 
中 的 验证码 的 主要 目的 是 强制 人机交互 来 
抵御 机器 自动化 攻击 用来 防止 机器 模拟 http 行为 
直接 抓取 文本 进行 导航 或 直接 提交 文本 进行 
登录 尝试 在 现在 带宽 较大 的 今天 在线 密码 
穷举 带宽 已经 不能 作为 瓶颈 了 验证码 识别 以 
2M ADSL 连接 实际 测试 20 线程 大概 每秒 可以 
完成 30个 左右 的 连接 如果 是 6位 数字 密码 
在 不考虑 字典 完全 穷举 的 时候 也 只 需要 
几 个 小时 便 可 破解 严重 的 威胁 了 
网络 账号 的 安全 因此 网络 登录 注册 验证码 的 
普及 势在必行 而 如今 国内 大 部分 的 验证码 设计者 
并 不得要领 要么 不 了解 图像处理 机器 视觉 模式识别 人工智能 
的 基本 概念 要么 设计 出 的 验证码 连人 都 
难以 识别 导致用户 体验 度 下降 比如 工商 银行 的 
WAP 手机 银行 验证码 只有 4位 而且 验证码 的 薄弱 
形同虚设 使用 穷举 计算机 很快 就 能 破解 一个 六 
位 数字 密码 的 账户 当然 也有 设计 得 比较 
好 的 比如 Yahoo Google baidu 等 2 验证码 的 
展望 未来 的 网络 安全 验证码 可能 更多 地 使用 
渐进 色层 同级 灰度 色差 更多 曲线 反转 随机 字符 
数量 字符 粘连 等 手段 防止 机器 的 识别 但 
加密 与 破解 总是 一对 孪生 兄弟 不 可能 消失 
一方 的 我们 只是 希望 通过 本文 给 编写 验证码 
算法 的 人员 一些 建议 使 我们 的 网络 更 
安全 操作 也 不会 因此 而 繁琐 算法 分析 在 
验证码 处理 方面 我们 大概 要 涉及 到 如下 内容 
人工智能 模式识别 机器 视觉 图像处理 1 主要 流程 如果 我们 
要 从一 幅 图片 中 识别 出 验证码 又 或者 
我们 要 从一 幅 图片 中 检测 并 识别 出 
一个 字符 其 步骤 可 概括 如下 图像 采集 取得 
一个 验证码 就 直接 通过 HTTP 抓 HTML 然后 分 
析出 图片 的 URL 下载 保存 预处理 检测 是 正确 
的 图像格式 转换 到 合适 的 格式 压缩 剪 切出 
ROI 去除 噪音 灰度 化 转换 色彩 空间 检测 找出 
文字 所在 的 主要 区域 前 处理 文字 的 切割 
缩放 和 扭曲 校正 训练 通过 各种 模式识别 机器学习 算法 
来 挑选 和 训练 合适 数量 的 训练 集 训练 
的 样本 并非 越多越好 通过学习 泛化 能力差 的 问题 可能 
会 出现 在 这里 识别 输入 待 识别 的 处理 
后的/nr 图片 转换成 分类器 需要 的 输入 格式 通过 输出 
的 类 和 置信度 来 判断 大概 可能 是 哪个 
字母 识别 本质 上 就是 分类 2 关键 概念 图像处理 
一般指 针对 数字 图像 的 某种 数学 处理 比如 投影 
钝化 锐化 细化 边缘 检测 二 值 化 压缩 以及 
各种 数据 变换 等等 二 值 化 一般 图片 都是/nr 
彩色 的 按照 逼真 程度 可能 很多 级别 为了 降低 
计算 复杂度 方便 后续 的 处理 如果在 不 损失 关键 
信息 的 情况 下 能将 图片 处理 成 黑白 两 
种颜色 那就 最好 不过 了 细化 找出 图像 的 骨架 
图像 线条 可能 是 很宽 的 通过 细化 将 宽度 
降为 1 某些 地方 可能 大于 1 不同 的 细化 
算法 可能 有 不同 的 差异 比如 是否 更 靠近 
线条 中间 比如 是否 保持 联 通行 等 边缘 检测 
主要 是 理解 边缘 的 概念 边缘 实际上 是 图像 
中 图像 像素 属性 变化 剧烈 的 地方 可以 通过 
一个 固定 的 门 限值 来 判断 也 可以 是 
自适应 的 门限 可以 是 图像 全 局 的 也 
可以 是 局部 的 不能 说 哪个 就 一定 好 
不过 大部分 时候 自适应 的 局部 的 门限 可能要 好点 
被 分析 的 可能 是 颜色 也 可能 是 灰度 
图像 的 灰度 机器 视觉 利用 计算机 来 模式 实现 
人 的 视觉 比如 物体 检测 定位 识别 按照 对 
图像 理解 的 层次 的 差别 分 高阶 和 低阶 
的 理解 模式识别 对 事物 或者 现象 的 某种 表示 
方式 数值 文字 我们 这里 主要 想 说 的 是 
数值 通过 一些 处理 和 分析 来 描述 归类 理解 
解释 这些 事物 现象 及其 某种 抽象 人工智能 这种 概念 
比较 宽 上面 这些 都 属于 人工智能 这个 大 的 
方向 简单 点 不要 过分 学院派 的 理解 就是 把 
人类 的 很 智能 的 东西 给 模拟 出来 协助 
生物 的 人 来 处理 问题 特别 是 在 计算机 
里面 验证码 识别 原理 及 代码 演示 本来 拿 一个 
银行 网站 来 进行 验证码 解密 是 很 危险 的 
但 我们 发现 工行 的 算法 已经 进行 了 改变 
所以 姑且 以 之前 的 工行 WAP 银行 做个 举例 
好了 同时 也 希望 工行 的 加密 能越 做 越好 
其实 工行 的 WAP 验证码 是 很 简单 的 是 
未加 干扰 的 原始 字符 打印 图片 而已 针对 这种 
验证码 我们 将 使用 点阵 库 校验 的 方式 进行 
首先 从 整个 程序 的 编写 及 操作 顺序 开始 
首先 要 知道 我们 需要 取得 的 字 的 点阵 
有 哪些 工行 的 WAP 银行 验证码 只有 0 ~ 
9 10个 数字 那么 我们 先 将 验证码 图片 下载 
到 本机 这里 我们 必须 将 所有 字符 的 图样 
都下 载到 本机 以便 建立 基础 点阵 库 得到 这些 
图片 文件 后 我们 将 用 程序 来 获得 图片 
点阵 从 本地 磁盘 加载 一个 图像文件 这个 文件 是 
我们 已经 下载 好 的 首先 应该 让 程序 先将 
0 ~ 9 的 图像 都 识别 一遍 使 我们 
的 程序 记住 它们 的 点阵 样 例如 所示 该 
图像 包含 的 验证码 从左到右 就是 0123 将 这个 图像 
逐点 转换 灰度 也 就是 将 彩色图片 先 进行 灰 
度 化 去 色 变成 黑白照片 便于 下 一步 操作 
{ for int i = 0 i bmpobj . Height 
i + + / / 遍历 高度 { for int 
j = 0 j bmpobj . Width j + + 
/ / 遍历 宽度 双层 for 就 循环 了 整个 
图片 的 像素点 { int tmpValue = GetGrayNumColor bmpobj . 
GetPixel j i bmpobj . SetPixel j i Color . 
FromArgb tmpValue tmpValue tmpValue } } } 灰度 化 之后 
像素 的 RGB 三色 都是 相同 的 值了 亮度 从0~/nr 
255 HxFF 但 用于 识别 程序 灰度 值 并 不能 
很好 的 区分 背景色 和 前景色 尤其 是 对于 渐进 
的 背景 来说 所以 我们 还要 将 图像 进一步 处理 
就是 将 灰度 图片 2 值 化 类似 的 算法 
还有 分水岭 算法 等 因为本 文中 的 验证码 相对 简单 
故 直接 使用 2 值 化 转换 寻找 有效 区 
并 转为 单色 黑白 图 { int dgGrayValue = 128 
/ / 灰度 背景 分 界值 int CharsCount = 4 
/ / 有效 字符 数 已知 int posx1 = bmpobj 
. Width int posy1 = bmpobj . Height int posx2 
= 0 int posy2 = 0 for int i = 
0 i bmpobj . Height i + + / / 
找 有效 区 { for int j = 0 j 
bmpobj . Width j + + { int pixelValue = 
bmpobj . GetPixel j i . R / / 取得 
红色 值 R 因为 转成 黑白 图 后 红 黄 
蓝 三位 都是 一样 的 值 所以 这里 取 什么 
色 值 都是 一样 的 if pixelValue dgGrayValue / / 
根据 灰度 值 { if posx1 j posx1 = j 
if posy1 i posy1 = i if posx2 j posx2 
= j if posy2 i posy2 = i } } 
} / / 确保 能整除 int Span = CharsCount posx2 
posx1 + 1 % CharsCount / / 可 整除 的 
差额 数 if Span CharsCount { int leftSpan = Span 
/ 2 / / 分配 到 左边 的 空列/nr 如 
span 为 单数 则 右边 比 左边 大 1if posx1 
leftSpan posx1 = posx1 leftSpan if posx2 + Span leftSpan 
bmpobj . Width posx2 = posx2 + Span leftSpan } 
/ / 复制 新图 Rectangle cloneRect = new Rectangle posx1 
posy1 posx2 posx1 + 1 posy2 posy1 + 1 bmpobj 
= bmpobj . Clone cloneRect bmpobj . PixelFormat } Bitmap 
pics = GetSplitPics 4 1 / / 分割 pics 0 
中 的 图片 如 所示 在 平均 分割 图片 的 
部分 设置 水平 上 分割 数 为 RowNum 垂 直上 
分割 数 为 ColNum 返回 分割 好 的 图片 数组 
程序 编写 如下 public Bitmap GetSplitPics int RowNum int ColNum 
{ if RowNum = = 0 | | ColNum = 
= 0 return null int singW = bmpobj . Width 
/ RowNum int singH = bmpobj . Height / ColNum 
Bitmap PicArray = new Bitmap RowNum * ColNum Rectangle cloneRect 
for int i = 0 i ColNum i + + 
/ / 找 有效 区 { for int j = 
0 j RowNum j + + { cloneRect = new 
Rectangle j * singW i * singH singW singH PicArray 
i * RowNum + j = bmpobj . Clone cloneRect 
bmpobj . PixelFormat / / 复制 小块 图 } } 
return PicArray } 此时 图像 分割 已 结束 pics 的 
长度 应该 是 4 并且 每 一个 pics 就是 一个 
验证码 的 位图 经过 错误处理 修边 和 去除 无用 背景 
空白 修正 完 的 位图 为 数字 0 得到 有效 
图形 后 由 外面 传入 该 图形 设置 灰度 背景 
分 界值 为 dgGrayValue 有效 字符 数 为 CharsCount 程序 
编写 如下 public Bitmap G e t P i c 
V a l i d B y V a l 
u e Bitmap singlepic int dgGrayValue { int posx1 = 
singlepic . Width int posy1 = singlepic . Height int 
posx2 = 0 int posy2 = 0 for int i 
= 0 i singlepic . Height i + + / 
/ 找 有效 区 { for int j = 0 
j singlepic . Width j + + { int pixelValue 
= singlepic . GetPixel j i . R if pixelValue 
dgGrayValue / / 根据 灰度 值 { if posx1 j 
posx1 = j if posy1 i posy1 = i if 
posx2 j posx2 = j if posy2 i posy2 = 
i } } } / / 复制 新图 Rectangle cloneRect 
= new Rectangle posx1 posy1 posx2 posx1 + 1 posy2 
posy1 + 1 return singlepic . Clone cloneRect singlepic . 
PixelFormat } 至此 pics 图像 组 中 就是 有效 的 
点阵图 了 下面 我们 把 pics 中的 图形 转换 为 
代表 点阵 的 字符串 返回 灰度 图片 的 点阵 描述 
字串 1 表示 灰 点 0 表示 背景 设置 灰度 
图为 singlepic 背 前景 灰 色界 限为 dgGrayValue string code 
= GetSingleBmpCode pics 0 128 public string GetSingleBmpCode Bitmap singlepic 
int dgGrayValue { Color piexl StringBuilder sbCode = new StringBuilder 
for int posy = 0 posy singlepic . Height posy 
+ + for int posx = 0 posx singlepic . 
Width posx + + { piexl = singlepic . GetPixel 
posx posy if piexl . R dgGrayValue / / Color 
. Black sbCode . Append 1 elsesbCode . Append 0 
} return sbCode . ToString } 此时 code 中的 字符串 
就 代表 字符 0 在 工行 WAP 银行 上 图像 
验证码 的 值了 以此类推 我们 可以 得到 一个 完整 的 
代表 图像 0 ~ 9 的 数组 字符 表 的 
顺序 为 0 ~ 9 A ~ Z a ~ 
z 现在 图片 点阵 数组 已经 取得 了 接下来 我们 
看看 如何 把 一个 图片 识别 出来 吧 已知 如下 
的 点阵 表 string CodeArray = new string { 0 
0 1 1 1 0 0 0 1 1 0 
1 1 0 1 1 0 0 0 1 1 
1 1 0 0 0 1 1 1 1 0 
1 0 1 1 1 1 0 1 0 1 
1 1 1 0 0 0 1 1 1 1 
0 0 0 1 1 0 1 1 0 1 
1 0 0 0 1 1 1 0 0 0 
0 1 1 0 0 0 1 1 1 0 
0 1 1 1 1 0 0 0 0 1 
1 0 0 0 0 1 1 0 0 0 
0 1 1 0 0 0 0 1 1 0 
0 0 0 1 1 0 0 0 0 1 
1 0 0 1 1 1 1 1 1 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 0 0 0 0 0 1 1 
0 0 0 0 1 1 0 0 0 0 
1 1 0 0 0 0 1 1 0 0 
0 0 1 1 0 0 0 0 1 1 
0 0 0 0 0 1 1 0 0 0 
1 1 1 1 1 1 1 1 1 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 0 0 0 0 0 1 1 
0 0 0 0 0 1 1 0 0 1 
1 1 1 0 0 0 0 0 0 1 
1 0 0 0 0 0 1 1 0 0 
0 0 0 1 1 1 1 0 0 0 
1 1 0 1 1 1 1 1 0 0 
0 0 0 1 1 0 0 0 0 1 
1 1 0 0 0 1 1 1 1 0 
0 1 1 0 1 1 0 1 1 0 
0 1 1 0 1 1 1 1 1 1 
1 0 0 0 0 1 1 0 0 0 
0 0 1 1 0 0 0 0 0 1 
1 0 0 0 0 1 1 1 1 0 
0 0 1 1 1 1 1 0 0 0 
1 1 0 0 0 0 0 0 1 1 
0 0 0 0 0 0 1 1 0 0 
0 0 0 0 1 1 1 1 1 1 
0 0 0 0 0 0 0 1 0 0 
0 0 0 0 0 1 0 0 0 0 
0 0 0 1 0 0 1 1 0 0 
0 0 0 0 0 1 1 1 1 0 
0 1 1 1 0 0 1 1 0 0 
0 1 1 0 0 0 0 1 1 0 
0 0 0 1 1 1 1 1 1 1 
1 0 0 0 1 1 1 0 0 0 
1 1 1 0 0 0 1 1 1 0 
0 0 1 0 1 1 1 1 1 0 
0 0 1 1 1 1 1 0 0 0 
1 1 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 1 1 
0 0 0 0 0 1 1 1 0 0 
0 0 1 1 0 1 0 0 0 0 
1 1 0 1 0 0 0 0 1 1 
0 0 0 0 0 0 1 1 0 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 1 1 0 0 0 1 1 
1 1 0 0 0 1 1 0 1 1 
1 1 1 0 1 1 0 0 0 1 
1 1 1 0 0 0 1 1 1 1 
0 0 0 1 1 1 1 0 0 0 
1 1 0 1 1 1 1 1 0 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 1 1 0 0 0 1 1 
1 1 0 0 0 1 1 0 1 1 
1 1 1 1 0 0 0 0 0 1 
1 0 0 0 0 0 1 1 0 0 
0 0 0 1 1 0 0 0 0 1 
1 0 0 1 1 1 1 0 0 } 
开始 处理 比较 操作 StringBuilder sbResult = new StringBuilder { 
for int i = 0 i 4 i + + 
{ string code = GetSingleBmpCode pics i 128 / / 
得到 代码 串 System . Collections . Generic . Dictionary 
char double E q u a l s P e 
r c e n t L i s t = 
new Dictionary char double / / 建立 差异 程度 列表 
for int arrayIndex = 0 arrayIndex CodeArray . Length arrayIndex 
+ + { if arrayIndex 10 / / 0 ~ 
9 { E q u a l s P e 
r c e n t L i s t . 
Add char 48 + arrayIndex 100 / / 数字 转 
字符 c 语法 习惯 } } for int arrayIndex = 
0 arrayIndex CodeArray . Length arrayIndex + + / / 
和 点阵 表内 的 字符 序列 进行 比较 { if 
arrayIndex 10 / / 0 ~ 9 { E q 
u a l s P e r c e n 
t L i s t char 48 + arrayIndex = 
EqualsPercent code CodeArray arrayIndex / / 每一个 图像 的 点阵 
的 差异 度 这里 的 差异 度 运 算是 误差 
程度 也 就是 不同 的 百分比 } 进行 获得 匹配 
{ double Perc = 20 / / 差异 百分比 必须 
小于 20% 否则 肯定 不对 string SelectKey = foreach char 
key in E q u a l s P e 
r c e n t L i s t . 
Keys / / 获取 匹配 程度 列表 中最 匹配 的 
一项 { if E q u a l s P 
e r c e n t L i s t 
key Perc { Perc = E q u a l 
s P e r c e n t L i 
s t key SelectKey = key . ToString } } 
sbResult . Append SelectKey } 至此 sbResult 中的 4个 数字 
就是 图 像上 的 4个 数字 了 结论 验证码 识别 
肯定 不 只是 这么 简单 但/c 现在/t 还是/c 有/v 很多/m 
网站/n 都/d 在用/b 这种/r 未经/d 任何/r 变换/v 的/uj 验证码/n 所以 
我们 的 网络 安全 还 任重而道远 上面 的 验证码 识别 
是 一个 最 基本 的 算法 但是 很多 扩展 算法 
都 可以 基于 上面 的 思路 进行 扩充 例如 有些 
验证码 进行 了 旋转 输出 那么 上面 的 程序 可以 
在 校对 的 时候 进行 360度 旋转 旋转 后的/nr 图像 
再取得 序列 再 和 图像 序列 比较 直至 得到 最 
符合 的 有些 验证码 添加 了 边框 此时 我们 可以 
先 去掉 边框 再 进行 切割 匹配 通过 上面 的 
算法 可以 得出 我们 今后 在 设计 验证码 的 时候 
应该 注意 如下 因素 1 在 噪音 等 类型 的 
使用 上 尽力/d 让/v 字符/n 和/c 用来/v 混淆/v 的/uj 前景/n 
和/c 背景/n 不容易/i 区分/n 尽力 让 噪音 长得 和 字母 
一样 2 特别 好 的 验证码 的 设计 要 尽力 
发挥 人类 擅长 而 AI 算法 不 擅长 的 比如 
粘 连字符 的 分割 和 手写体 通过 印刷体 做 特别 
的 变形 也 可以 而 不要 一味 的 去 加 
一些 看起来 比较 复杂 的 噪音 或者 其他 的 花哨 
东西 3 从 专业 的 机器 视觉 的 角度 来说 
网络安全 验证码 的 设计 一定 要 让 破 解者 在 
识别 阶段 反复 在 低阶 视觉 和 高阶 视觉 之间 
多 反复 几次 才能 识 别出来 这样 可以 大大 降低 
破解 难度 和 破解 的 准确率 1 验证码 的 基本 知识 及 来由 网络 安全 技术 
中 的 验证码 的 主要 目的 是 强制 人机交互 来 
抵御 机器 自动化 攻击 用来 防止 机器 模拟 http 行为 
直接 抓取 文本 进行 导航 或 直接 提交 文本 进行 
登录 尝试 在 现在 带宽 较大 的 今天 在线 密码 
穷举 带宽 已经 不能 作为 瓶颈 了 验证码 识别 以 
2M ADSL 连接 实际 测试 20 线程 大概 每秒 可以 
完成 30个 左右 的 连接 如果 是 6位 数字 密码 
在 不考虑 字典 完全 穷举 的 时候 也 只 需要 
几 个 小时 便 可 破解 严重 的 威胁 了 
网络 账号 的 安全 因此 网络 登录 注册 验证码 的 
普及 势在必行 而 如今 国内 大 部分 的 验证码 设计者 
并 不得要领 要么 不 了解 图像处理 机器 视觉 模式识别 人工智能 
的 基本 概念 要么 设计 出 的 验证码 连人 都 
难以 识别 导致用户 体验 度 下降 比如 工商 银行 的 
WAP 手机 银行 验证码 只有 4位 而且 验证码 的 薄弱 
形同虚设 使用 穷举 计算机 很快 就 能 破解 一个 六 
位 数字 密码 的 账户 当然 也有 设计 得 比较 
好 的 比如 Yahoo Google baidu 等 2 验证码 的 
展望 未来 的 网络 安全 验证码 可能 更多 地 使用 
渐进 色层 同级 灰度 色差 更多 曲线 反转 随机 字符 
数量 字符 粘连 等 手段 防止 机器 的 识别 但 
加密 与 破解 总是 一对 孪生 兄弟 不 可能 消失 
一方 的 我们 只是 希望 通过 本文 给 编写 验证码 
算法 的 人员 一些 建议 使 我们 的 网络 更 
安全 操作 也 不会 因此 而 繁琐 算法 分析 在 
验证码 处理 方面 我们 大概 要 涉及 到 如下 内容 
人工智能 模式识别 机器 视觉 图像处理 1 主要 流程 如果 我们 
要 从一 幅 图片 中 识别 出 验证码 又 或者 
我们 要 从一 幅 图片 中 检测 并 识别 出 
一个 字符 其 步骤 可 概括 如下 图像 采集 取得 
一个 验证码 就 直接 通过 HTTP 抓 HTML 然后 分 
析出 图片 的 URL 下载 保存 预处理 检测 是 正确 
的 图像格式 转换 到 合适 的 格式 压缩 剪 切出 
ROI 去除 噪音 灰度 化 转换 色彩 空间 检测 找出 
文字 所在 的 主要 区域 前 处理 文字 的 切割 
缩放 和 扭曲 校正 训练 通过 各种 模式识别 机器学习 算法 
来 挑选 和 训练 合适 数量 的 训练 集 训练 
的 样本 并非 越多越好 通过学习 泛化 能力差 的 问题 可能 
会 出现 在 这里 识别 输入 待 识别 的 处理 
后的/nr 图片 转换成 分类器 需要 的 输入 格式 通过 输出 
的 类 和 置信度 来 判断 大概 可能 是 哪个 
字母 识别 本质 上 就是 分类 2 关键 概念 图像处理 
一般指 针对 数字 图像 的 某种 数学 处理 比如 投影 
钝化 锐化 细化 边缘 检测 二 值 化 压缩 以及 
各种 数据 变换 等等 二 值 化 一般 图片 都是/nr 
彩色 的 按照 逼真 程度 可能 很多 级别 为了 降低 
计算 复杂度 方便 后续 的 处理 如果在 不 损失 关键 
信息 的 情况 下 能将 图片 处理 成 黑白 两 
种颜色 那就 最好 不过 了 细化 找出 图像 的 骨架 
图像 线条 可能 是 很宽 的 通过 细化 将 宽度 
降为 1 某些 地方 可能 大于 1 不同 的 细化 
算法 可能 有 不同 的 差异 比如 是否 更 靠近 
线条 中间 比如 是否 保持 联 通行 等 边缘 检测 
主要 是 理解 边缘 的 概念 边缘 实际上 是 图像 
中 图像 像素 属性 变化 剧烈 的 地方 可以 通过 
一个 固定 的 门 限值 来 判断 也 可以 是 
自适应 的 门限 可以 是 图像 全 局 的 也 
可以 是 局部 的 不能 说 哪个 就 一定 好 
不过 大部分 时候 自适应 的 局部 的 门限 可能要 好点 
被 分析 的 可能 是 颜色 也 可能 是 灰度 
图像 的 灰度 机器 视觉 利用 计算机 来 模式 实现 
人 的 视觉 比如 物体 检测 定位 识别 按照 对 
图像 理解 的 层次 的 差别 分 高阶 和 低阶 
的 理解 模式识别 对 事物 或者 现象 的 某种 表示 
方式 数值 文字 我们 这里 主要 想 说 的 是 
数值 通过 一些 处理 和 分析 来 描述 归类 理解 
解释 这些 事物 现象 及其 某种 抽象 人工智能 这种 概念 
比较 宽 上面 这些 都 属于 人工智能 这个 大 的 
方向 简单 点 不要 过分 学院派 的 理解 就是 把 
人类 的 很 智能 的 东西 给 模拟 出来 协助 
生物 的 人 来 处理 问题 特别 是 在 计算机 
里面 验证码 识别 原理 及 代码 演示 本来 拿 一个 
银行 网站 来 进行 验证码 解密 是 很 危险 的 
但 我们 发现 工行 的 算法 已经 进行 了 改变 
所以 姑且 以 之前 的 工行 WAP 银行 做个 举例 
好了 同时 也 希望 工行 的 加密 能越 做 越好 
其实 工行 的 WAP 验证码 是 很 简单 的 是 
未加 干扰 的 原始 字符 打印 图片 而已 针对 这种 
验证码 我们 将 使用 点阵 库 校验 的 方式 进行 
首先 从 整个 程序 的 编写 及 操作 顺序 开始 
首先 要 知道 我们 需要 取得 的 字 的 点阵 
有 哪些 工行 的 WAP 银行 验证码 只有 0 ~ 
9 10个 数字 那么 我们 先 将 验证码 图片 下载 
到 本机 这里 我们 必须 将 所有 字符 的 图样 
都下 载到 本机 以便 建立 基础 点阵 库 得到 这些 
图片 文件 后 我们 将 用 程序 来 获得 图片 
点阵 从 本地 磁盘 加载 一个 图像文件 这个 文件 是 
我们 已经 下载 好 的 首先 应该 让 程序 先将 
0 ~ 9 的 图像 都 识别 一遍 使 我们 
的 程序 记住 它们 的 点阵 样 例如 所示 该 
图像 包含 的 验证码 从左到右 就是 0123 将 这个 图像 
逐点 转换 灰度 也 就是 将 彩色图片 先 进行 灰 
度 化 去 色 变成 黑白照片 便于 下 一步 操作 
{ for int i = 0 i bmpobj . Height 
i + + / / 遍历 高度 { for int 
j = 0 j bmpobj . Width j + + 
/ / 遍历 宽度 双层 for 就 循环 了 整个 
图片 的 像素点 { int tmpValue = GetGrayNumColor bmpobj . 
GetPixel j i bmpobj . SetPixel j i Color . 
FromArgb tmpValue tmpValue tmpValue } } } 灰度 化 之后 
像素 的 RGB 三色 都是 相同 的 值了 亮度 从0~/nr 
255 HxFF 但 用于 识别 程序 灰度 值 并 不能 
很好 的 区分 背景色 和 前景色 尤其 是 对于 渐进 
的 背景 来说 所以 我们 还要 将 图像 进一步 处理 
就是 将 灰度 图片 2 值 化 类似 的 算法 
还有 分水岭 算法 等 因为本 文中 的 验证码 相对 简单 
故 直接 使用 2 值 化 转换 寻找 有效 区 
并 转为 单色 黑白 图 { int dgGrayValue = 128 
/ / 灰度 背景 分 界值 int CharsCount = 4 
/ / 有效 字符 数 已知 int posx1 = bmpobj 
. Width int posy1 = bmpobj . Height int posx2 
= 0 int posy2 = 0 for int i = 
0 i bmpobj . Height i + + / / 
找 有效 区 { for int j = 0 j 
bmpobj . Width j + + { int pixelValue = 
bmpobj . GetPixel j i . R / / 取得 
红色 值 R 因为 转成 黑白 图 后 红 黄 
蓝 三位 都是 一样 的 值 所以 这里 取 什么 
色 值 都是 一样 的 if pixelValue dgGrayValue / / 
根据 灰度 值 { if posx1 j posx1 = j 
if posy1 i posy1 = i if posx2 j posx2 
= j if posy2 i posy2 = i } } 
} / / 确保 能整除 int Span = CharsCount posx2 
posx1 + 1 % CharsCount / / 可 整除 的 
差额 数 if Span CharsCount { int leftSpan = Span 
/ 2 / / 分配 到 左边 的 空列/nr 如 
span 为 单数 则 右边 比 左边 大 1if posx1 
leftSpan posx1 = posx1 leftSpan if posx2 + Span leftSpan 
bmpobj . Width posx2 = posx2 + Span leftSpan } 
/ / 复制 新图 Rectangle cloneRect = new Rectangle posx1 
posy1 posx2 posx1 + 1 posy2 posy1 + 1 bmpobj 
= bmpobj . Clone cloneRect bmpobj . PixelFormat } Bitmap 
pics = GetSplitPics 4 1 / / 分割 pics 0 
中 的 图片 如 所示 在 平均 分割 图片 的 
部分 设置 水平 上 分割 数 为 RowNum 垂 直上 
分割 数 为 ColNum 返回 分割 好 的 图片 数组 
程序 编写 如下 public Bitmap GetSplitPics int RowNum int ColNum 
{ if RowNum = = 0 | | ColNum = 
= 0 return null int singW = bmpobj . Width 
/ RowNum int singH = bmpobj . Height / ColNum 
Bitmap PicArray = new Bitmap RowNum * ColNum Rectangle cloneRect 
for int i = 0 i ColNum i + + 
/ / 找 有效 区 { for int j = 
0 j RowNum j + + { cloneRect = new 
Rectangle j * singW i * singH singW singH PicArray 
i * RowNum + j = bmpobj . Clone cloneRect 
bmpobj . PixelFormat / / 复制 小块 图 } } 
return PicArray } 此时 图像 分割 已 结束 pics 的 
长度 应该 是 4 并且 每 一个 pics 就是 一个 
验证码 的 位图 经过 错误处理 修边 和 去除 无用 背景 
空白 修正 完 的 位图 为 数字 0 得到 有效 
图形 后 由 外面 传入 该 图形 设置 灰度 背景 
分 界值 为 dgGrayValue 有效 字符 数 为 CharsCount 程序 
编写 如下 public Bitmap G e t P i c 
V a l i d B y V a l 
u e Bitmap singlepic int dgGrayValue { int posx1 = 
singlepic . Width int posy1 = singlepic . Height int 
posx2 = 0 int posy2 = 0 for int i 
= 0 i singlepic . Height i + + / 
/ 找 有效 区 { for int j = 0 
j singlepic . Width j + + { int pixelValue 
= singlepic . GetPixel j i . R if pixelValue 
dgGrayValue / / 根据 灰度 值 { if posx1 j 
posx1 = j if posy1 i posy1 = i if 
posx2 j posx2 = j if posy2 i posy2 = 
i } } } / / 复制 新图 Rectangle cloneRect 
= new Rectangle posx1 posy1 posx2 posx1 + 1 posy2 
posy1 + 1 return singlepic . Clone cloneRect singlepic . 
PixelFormat } 至此 pics 图像 组 中 就是 有效 的 
点阵图 了 下面 我们 把 pics 中的 图形 转换 为 
代表 点阵 的 字符串 返回 灰度 图片 的 点阵 描述 
字串 1 表示 灰 点 0 表示 背景 设置 灰度 
图为 singlepic 背 前景 灰 色界 限为 dgGrayValue string code 
= GetSingleBmpCode pics 0 128 public string GetSingleBmpCode Bitmap singlepic 
int dgGrayValue { Color piexl StringBuilder sbCode = new StringBuilder 
for int posy = 0 posy singlepic . Height posy 
+ + for int posx = 0 posx singlepic . 
Width posx + + { piexl = singlepic . GetPixel 
posx posy if piexl . R dgGrayValue / / Color 
. Black sbCode . Append 1 elsesbCode . Append 0 
} return sbCode . ToString } 此时 code 中的 字符串 
就 代表 字符 0 在 工行 WAP 银行 上 图像 
验证码 的 值了 以此类推 我们 可以 得到 一个 完整 的 
代表 图像 0 ~ 9 的 数组 字符 表 的 
顺序 为 0 ~ 9 A ~ Z a ~ 
z 现在 图片 点阵 数组 已经 取得 了 接下来 我们 
看看 如何 把 一个 图片 识别 出来 吧 已知 如下 
的 点阵 表 string CodeArray = new string { 0 
0 1 1 1 0 0 0 1 1 0 
1 1 0 1 1 0 0 0 1 1 
1 1 0 0 0 1 1 1 1 0 
1 0 1 1 1 1 0 1 0 1 
1 1 1 0 0 0 1 1 1 1 
0 0 0 1 1 0 1 1 0 1 
1 0 0 0 1 1 1 0 0 0 
0 1 1 0 0 0 1 1 1 0 
0 1 1 1 1 0 0 0 0 1 
1 0 0 0 0 1 1 0 0 0 
0 1 1 0 0 0 0 1 1 0 
0 0 0 1 1 0 0 0 0 1 
1 0 0 1 1 1 1 1 1 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 0 0 0 0 0 1 1 
0 0 0 0 1 1 0 0 0 0 
1 1 0 0 0 0 1 1 0 0 
0 0 1 1 0 0 0 0 1 1 
0 0 0 0 0 1 1 0 0 0 
1 1 1 1 1 1 1 1 1 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 0 0 0 0 0 1 1 
0 0 0 0 0 1 1 0 0 1 
1 1 1 0 0 0 0 0 0 1 
1 0 0 0 0 0 1 1 0 0 
0 0 0 1 1 1 1 0 0 0 
1 1 0 1 1 1 1 1 0 0 
0 0 0 1 1 0 0 0 0 1 
1 1 0 0 0 1 1 1 1 0 
0 1 1 0 1 1 0 1 1 0 
0 1 1 0 1 1 1 1 1 1 
1 0 0 0 0 1 1 0 0 0 
0 0 1 1 0 0 0 0 0 1 
1 0 0 0 0 1 1 1 1 0 
0 0 1 1 1 1 1 0 0 0 
1 1 0 0 0 0 0 0 1 1 
0 0 0 0 0 0 1 1 0 0 
0 0 0 0 1 1 1 1 1 1 
0 0 0 0 0 0 0 1 0 0 
0 0 0 0 0 1 0 0 0 0 
0 0 0 1 0 0 1 1 0 0 
0 0 0 0 0 1 1 1 1 0 
0 1 1 1 0 0 1 1 0 0 
0 1 1 0 0 0 0 1 1 0 
0 0 0 1 1 1 1 1 1 1 
1 0 0 0 1 1 1 0 0 0 
1 1 1 0 0 0 1 1 1 0 
0 0 1 0 1 1 1 1 1 0 
0 0 1 1 1 1 1 0 0 0 
1 1 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 1 1 
0 0 0 0 0 1 1 1 0 0 
0 0 1 1 0 1 0 0 0 0 
1 1 0 1 0 0 0 0 1 1 
0 0 0 0 0 0 1 1 0 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 1 1 0 0 0 1 1 
1 1 0 0 0 1 1 0 1 1 
1 1 1 0 1 1 0 0 0 1 
1 1 1 0 0 0 1 1 1 1 
0 0 0 1 1 1 1 0 0 0 
1 1 0 1 1 1 1 1 0 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 1 1 0 0 0 1 1 
1 1 0 0 0 1 1 0 1 1 
1 1 1 1 0 0 0 0 0 1 
1 0 0 0 0 0 1 1 0 0 
0 0 0 1 1 0 0 0 0 1 
1 0 0 1 1 1 1 0 0 } 
开始 处理 比较 操作 StringBuilder sbResult = new StringBuilder { 
for int i = 0 i 4 i + + 
{ string code = GetSingleBmpCode pics i 128 / / 
得到 代码 串 System . Collections . Generic . Dictionary 
char double E q u a l s P e 
r c e n t L i s t = 
new Dictionary char double / / 建立 差异 程度 列表 
for int arrayIndex = 0 arrayIndex CodeArray . Length arrayIndex 
+ + { if arrayIndex 10 / / 0 ~ 
9 { E q u a l s P e 
r c e n t L i s t . 
Add char 48 + arrayIndex 100 / / 数字 转 
字符 c 语法 习惯 } } for int arrayIndex = 
0 arrayIndex CodeArray . Length arrayIndex + + / / 
和 点阵 表内 的 字符 序列 进行 比较 { if 
arrayIndex 10 / / 0 ~ 9 { E q 
u a l s P e r c e n 
t L i s t char 48 + arrayIndex = 
EqualsPercent code CodeArray arrayIndex / / 每一个 图像 的 点阵 
的 差异 度 这里 的 差异 度 运 算是 误差 
程度 也 就是 不同 的 百分比 } 进行 获得 匹配 
{ double Perc = 20 / / 差异 百分比 必须 
小于 20% 否则 肯定 不对 string SelectKey = foreach char 
key in E q u a l s P e 
r c e n t L i s t . 
Keys / / 获取 匹配 程度 列表 中最 匹配 的 
一项 { if E q u a l s P 
e r c e n t L i s t 
key Perc { Perc = E q u a l 
s P e r c e n t L i 
s t key SelectKey = key . ToString } } 
sbResult . Append SelectKey } 至此 sbResult 中的 4个 数字 
就是 图 像上 的 4个 数字 了 结论 验证码 识别 
肯定 不 只是 这么 简单 但/c 现在/t 还是/c 有/v 很多/m 
网站/n 都/d 在用/b 这种/r 未经/d 任何/r 变换/v 的/uj 验证码/n 所以 
我们 的 网络 安全 还 任重而道远 上面 的 验证码 识别 
是 一个 最 基本 的 算法 但是 很多 扩展 算法 
都 可以 基于 上面 的 思路 进行 扩充 例如 有些 
验证码 进行 了 旋转 输出 那么 上面 的 程序 可以 
在 校对 的 时候 进行 360度 旋转 旋转 后的/nr 图像 
再取得 序列 再 和 图像 序列 比较 直至 得到 最 
符合 的 有些 验证码 添加 了 边框 此时 我们 可以 
先 去掉 边框 再 进行 切割 匹配 通过 上面 的 
算法 可以 得出 我们 今后 在 设计 验证码 的 时候 
应该 注意 如下 因素 1 在 噪音 等 类型 的 
使用 上 尽力/d 让/v 字符/n 和/c 用来/v 混淆/v 的/uj 前景/n 
和/c 背景/n 不容易/i 区分/n 尽力 让 噪音 长得 和 字母 
一样 2 特别 好 的 验证码 的 设计 要 尽力 
发挥 人类 擅长 而 AI 算法 不 擅长 的 比如 
粘 连字符 的 分割 和 手写体 通过 印刷体 做 特别 
的 变形 也 可以 而 不要 一味 的 去 加 
一些 看起来 比较 复杂 的 噪音 或者 其他 的 花哨 
东西 3 从 专业 的 机器 视觉 的 角度 来说 
网络安全 验证码 的 设计 一定 要 让 破 解者 在 
识别 阶段 反复 在 低阶 视觉 和 高阶 视觉 之间 
多 反复 几次 才能 识 别出来 这样 可以 大大 降低 
破解 难度 和 破解 的 准确率 1 验证码 的 基本 知识 及 来由 网络 安全 技术 
中 的 验证码 的 主要 目的 是 强制 人机交互 来 
抵御 机器 自动化 攻击 用来 防止 机器 模拟 http 行为 
直接 抓取 文本 进行 导航 或 直接 提交 文本 进行 
登录 尝试 在 现在 带宽 较大 的 今天 在线 密码 
穷举 带宽 已经 不能 作为 瓶颈 了 验证码 识别 以 
2M ADSL 连接 实际 测试 20 线程 大概 每秒 可以 
完成 30个 左右 的 连接 如果 是 6位 数字 密码 
在 不考虑 字典 完全 穷举 的 时候 也 只 需要 
几 个 小时 便 可 破解 严重 的 威胁 了 
网络 账号 的 安全 因此 网络 登录 注册 验证码 的 
普及 势在必行 而 如今 国内 大 部分 的 验证码 设计者 
并 不得要领 要么 不 了解 图像处理 机器 视觉 模式识别 人工智能 
的 基本 概念 要么 设计 出 的 验证码 连人 都 
难以 识别 导致用户 体验 度 下降 比如 工商 银行 的 
WAP 手机 银行 验证码 只有 4位 而且 验证码 的 薄弱 
形同虚设 使用 穷举 计算机 很快 就 能 破解 一个 六 
位 数字 密码 的 账户 当然 也有 设计 得 比较 
好 的 比如 Yahoo Google baidu 等 2 验证码 的 
展望 未来 的 网络 安全 验证码 可能 更多 地 使用 
渐进 色层 同级 灰度 色差 更多 曲线 反转 随机 字符 
数量 字符 粘连 等 手段 防止 机器 的 识别 但 
加密 与 破解 总是 一对 孪生 兄弟 不 可能 消失 
一方 的 我们 只是 希望 通过 本文 给 编写 验证码 
算法 的 人员 一些 建议 使 我们 的 网络 更 
安全 操作 也 不会 因此 而 繁琐 算法 分析 在 
验证码 处理 方面 我们 大概 要 涉及 到 如下 内容 
人工智能 模式识别 机器 视觉 图像处理 1 主要 流程 如果 我们 
要 从一 幅 图片 中 识别 出 验证码 又 或者 
我们 要 从一 幅 图片 中 检测 并 识别 出 
一个 字符 其 步骤 可 概括 如下 图像 采集 取得 
一个 验证码 就 直接 通过 HTTP 抓 HTML 然后 分 
析出 图片 的 URL 下载 保存 预处理 检测 是 正确 
的 图像格式 转换 到 合适 的 格式 压缩 剪 切出 
ROI 去除 噪音 灰度 化 转换 色彩 空间 检测 找出 
文字 所在 的 主要 区域 前 处理 文字 的 切割 
缩放 和 扭曲 校正 训练 通过 各种 模式识别 机器学习 算法 
来 挑选 和 训练 合适 数量 的 训练 集 训练 
的 样本 并非 越多越好 通过学习 泛化 能力差 的 问题 可能 
会 出现 在 这里 识别 输入 待 识别 的 处理 
后的/nr 图片 转换成 分类器 需要 的 输入 格式 通过 输出 
的 类 和 置信度 来 判断 大概 可能 是 哪个 
字母 识别 本质 上 就是 分类 2 关键 概念 图像处理 
一般指 针对 数字 图像 的 某种 数学 处理 比如 投影 
钝化 锐化 细化 边缘 检测 二 值 化 压缩 以及 
各种 数据 变换 等等 二 值 化 一般 图片 都是/nr 
彩色 的 按照 逼真 程度 可能 很多 级别 为了 降低 
计算 复杂度 方便 后续 的 处理 如果在 不 损失 关键 
信息 的 情况 下 能将 图片 处理 成 黑白 两 
种颜色 那就 最好 不过 了 细化 找出 图像 的 骨架 
图像 线条 可能 是 很宽 的 通过 细化 将 宽度 
降为 1 某些 地方 可能 大于 1 不同 的 细化 
算法 可能 有 不同 的 差异 比如 是否 更 靠近 
线条 中间 比如 是否 保持 联 通行 等 边缘 检测 
主要 是 理解 边缘 的 概念 边缘 实际上 是 图像 
中 图像 像素 属性 变化 剧烈 的 地方 可以 通过 
一个 固定 的 门 限值 来 判断 也 可以 是 
自适应 的 门限 可以 是 图像 全 局 的 也 
可以 是 局部 的 不能 说 哪个 就 一定 好 
不过 大部分 时候 自适应 的 局部 的 门限 可能要 好点 
被 分析 的 可能 是 颜色 也 可能 是 灰度 
图像 的 灰度 机器 视觉 利用 计算机 来 模式 实现 
人 的 视觉 比如 物体 检测 定位 识别 按照 对 
图像 理解 的 层次 的 差别 分 高阶 和 低阶 
的 理解 模式识别 对 事物 或者 现象 的 某种 表示 
方式 数值 文字 我们 这里 主要 想 说 的 是 
数值 通过 一些 处理 和 分析 来 描述 归类 理解 
解释 这些 事物 现象 及其 某种 抽象 人工智能 这种 概念 
比较 宽 上面 这些 都 属于 人工智能 这个 大 的 
方向 简单 点 不要 过分 学院派 的 理解 就是 把 
人类 的 很 智能 的 东西 给 模拟 出来 协助 
生物 的 人 来 处理 问题 特别 是 在 计算机 
里面 验证码 识别 原理 及 代码 演示 本来 拿 一个 
银行 网站 来 进行 验证码 解密 是 很 危险 的 
但 我们 发现 工行 的 算法 已经 进行 了 改变 
所以 姑且 以 之前 的 工行 WAP 银行 做个 举例 
好了 同时 也 希望 工行 的 加密 能越 做 越好 
其实 工行 的 WAP 验证码 是 很 简单 的 是 
未加 干扰 的 原始 字符 打印 图片 而已 针对 这种 
验证码 我们 将 使用 点阵 库 校验 的 方式 进行 
首先 从 整个 程序 的 编写 及 操作 顺序 开始 
首先 要 知道 我们 需要 取得 的 字 的 点阵 
有 哪些 工行 的 WAP 银行 验证码 只有 0 ~ 
9 10个 数字 那么 我们 先 将 验证码 图片 下载 
到 本机 这里 我们 必须 将 所有 字符 的 图样 
都下 载到 本机 以便 建立 基础 点阵 库 得到 这些 
图片 文件 后 我们 将 用 程序 来 获得 图片 
点阵 从 本地 磁盘 加载 一个 图像文件 这个 文件 是 
我们 已经 下载 好 的 首先 应该 让 程序 先将 
0 ~ 9 的 图像 都 识别 一遍 使 我们 
的 程序 记住 它们 的 点阵 样 例如 所示 该 
图像 包含 的 验证码 从左到右 就是 0123 将 这个 图像 
逐点 转换 灰度 也 就是 将 彩色图片 先 进行 灰 
度 化 去 色 变成 黑白照片 便于 下 一步 操作 
{ for int i = 0 i bmpobj . Height 
i + + / / 遍历 高度 { for int 
j = 0 j bmpobj . Width j + + 
/ / 遍历 宽度 双层 for 就 循环 了 整个 
图片 的 像素点 { int tmpValue = GetGrayNumColor bmpobj . 
GetPixel j i bmpobj . SetPixel j i Color . 
FromArgb tmpValue tmpValue tmpValue } } } 灰度 化 之后 
像素 的 RGB 三色 都是 相同 的 值了 亮度 从0~/nr 
255 HxFF 但 用于 识别 程序 灰度 值 并 不能 
很好 的 区分 背景色 和 前景色 尤其 是 对于 渐进 
的 背景 来说 所以 我们 还要 将 图像 进一步 处理 
就是 将 灰度 图片 2 值 化 类似 的 算法 
还有 分水岭 算法 等 因为本 文中 的 验证码 相对 简单 
故 直接 使用 2 值 化 转换 寻找 有效 区 
并 转为 单色 黑白 图 { int dgGrayValue = 128 
/ / 灰度 背景 分 界值 int CharsCount = 4 
/ / 有效 字符 数 已知 int posx1 = bmpobj 
. Width int posy1 = bmpobj . Height int posx2 
= 0 int posy2 = 0 for int i = 
0 i bmpobj . Height i + + / / 
找 有效 区 { for int j = 0 j 
bmpobj . Width j + + { int pixelValue = 
bmpobj . GetPixel j i . R / / 取得 
红色 值 R 因为 转成 黑白 图 后 红 黄 
蓝 三位 都是 一样 的 值 所以 这里 取 什么 
色 值 都是 一样 的 if pixelValue dgGrayValue / / 
根据 灰度 值 { if posx1 j posx1 = j 
if posy1 i posy1 = i if posx2 j posx2 
= j if posy2 i posy2 = i } } 
} / / 确保 能整除 int Span = CharsCount posx2 
posx1 + 1 % CharsCount / / 可 整除 的 
差额 数 if Span CharsCount { int leftSpan = Span 
/ 2 / / 分配 到 左边 的 空列/nr 如 
span 为 单数 则 右边 比 左边 大 1if posx1 
leftSpan posx1 = posx1 leftSpan if posx2 + Span leftSpan 
bmpobj . Width posx2 = posx2 + Span leftSpan } 
/ / 复制 新图 Rectangle cloneRect = new Rectangle posx1 
posy1 posx2 posx1 + 1 posy2 posy1 + 1 bmpobj 
= bmpobj . Clone cloneRect bmpobj . PixelFormat } Bitmap 
pics = GetSplitPics 4 1 / / 分割 pics 0 
中 的 图片 如 所示 在 平均 分割 图片 的 
部分 设置 水平 上 分割 数 为 RowNum 垂 直上 
分割 数 为 ColNum 返回 分割 好 的 图片 数组 
程序 编写 如下 public Bitmap GetSplitPics int RowNum int ColNum 
{ if RowNum = = 0 | | ColNum = 
= 0 return null int singW = bmpobj . Width 
/ RowNum int singH = bmpobj . Height / ColNum 
Bitmap PicArray = new Bitmap RowNum * ColNum Rectangle cloneRect 
for int i = 0 i ColNum i + + 
/ / 找 有效 区 { for int j = 
0 j RowNum j + + { cloneRect = new 
Rectangle j * singW i * singH singW singH PicArray 
i * RowNum + j = bmpobj . Clone cloneRect 
bmpobj . PixelFormat / / 复制 小块 图 } } 
return PicArray } 此时 图像 分割 已 结束 pics 的 
长度 应该 是 4 并且 每 一个 pics 就是 一个 
验证码 的 位图 经过 错误处理 修边 和 去除 无用 背景 
空白 修正 完 的 位图 为 数字 0 得到 有效 
图形 后 由 外面 传入 该 图形 设置 灰度 背景 
分 界值 为 dgGrayValue 有效 字符 数 为 CharsCount 程序 
编写 如下 public Bitmap G e t P i c 
V a l i d B y V a l 
u e Bitmap singlepic int dgGrayValue { int posx1 = 
singlepic . Width int posy1 = singlepic . Height int 
posx2 = 0 int posy2 = 0 for int i 
= 0 i singlepic . Height i + + / 
/ 找 有效 区 { for int j = 0 
j singlepic . Width j + + { int pixelValue 
= singlepic . GetPixel j i . R if pixelValue 
dgGrayValue / / 根据 灰度 值 { if posx1 j 
posx1 = j if posy1 i posy1 = i if 
posx2 j posx2 = j if posy2 i posy2 = 
i } } } / / 复制 新图 Rectangle cloneRect 
= new Rectangle posx1 posy1 posx2 posx1 + 1 posy2 
posy1 + 1 return singlepic . Clone cloneRect singlepic . 
PixelFormat } 至此 pics 图像 组 中 就是 有效 的 
点阵图 了 下面 我们 把 pics 中的 图形 转换 为 
代表 点阵 的 字符串 返回 灰度 图片 的 点阵 描述 
字串 1 表示 灰 点 0 表示 背景 设置 灰度 
图为 singlepic 背 前景 灰 色界 限为 dgGrayValue string code 
= GetSingleBmpCode pics 0 128 public string GetSingleBmpCode Bitmap singlepic 
int dgGrayValue { Color piexl StringBuilder sbCode = new StringBuilder 
for int posy = 0 posy singlepic . Height posy 
+ + for int posx = 0 posx singlepic . 
Width posx + + { piexl = singlepic . GetPixel 
posx posy if piexl . R dgGrayValue / / Color 
. Black sbCode . Append 1 elsesbCode . Append 0 
} return sbCode . ToString } 此时 code 中的 字符串 
就 代表 字符 0 在 工行 WAP 银行 上 图像 
验证码 的 值了 以此类推 我们 可以 得到 一个 完整 的 
代表 图像 0 ~ 9 的 数组 字符 表 的 
顺序 为 0 ~ 9 A ~ Z a ~ 
z 现在 图片 点阵 数组 已经 取得 了 接下来 我们 
看看 如何 把 一个 图片 识别 出来 吧 已知 如下 
的 点阵 表 string CodeArray = new string { 0 
0 1 1 1 0 0 0 1 1 0 
1 1 0 1 1 0 0 0 1 1 
1 1 0 0 0 1 1 1 1 0 
1 0 1 1 1 1 0 1 0 1 
1 1 1 0 0 0 1 1 1 1 
0 0 0 1 1 0 1 1 0 1 
1 0 0 0 1 1 1 0 0 0 
0 1 1 0 0 0 1 1 1 0 
0 1 1 1 1 0 0 0 0 1 
1 0 0 0 0 1 1 0 0 0 
0 1 1 0 0 0 0 1 1 0 
0 0 0 1 1 0 0 0 0 1 
1 0 0 1 1 1 1 1 1 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 0 0 0 0 0 1 1 
0 0 0 0 1 1 0 0 0 0 
1 1 0 0 0 0 1 1 0 0 
0 0 1 1 0 0 0 0 1 1 
0 0 0 0 0 1 1 0 0 0 
1 1 1 1 1 1 1 1 1 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 0 0 0 0 0 1 1 
0 0 0 0 0 1 1 0 0 1 
1 1 1 0 0 0 0 0 0 1 
1 0 0 0 0 0 1 1 0 0 
0 0 0 1 1 1 1 0 0 0 
1 1 0 1 1 1 1 1 0 0 
0 0 0 1 1 0 0 0 0 1 
1 1 0 0 0 1 1 1 1 0 
0 1 1 0 1 1 0 1 1 0 
0 1 1 0 1 1 1 1 1 1 
1 0 0 0 0 1 1 0 0 0 
0 0 1 1 0 0 0 0 0 1 
1 0 0 0 0 1 1 1 1 0 
0 0 1 1 1 1 1 0 0 0 
1 1 0 0 0 0 0 0 1 1 
0 0 0 0 0 0 1 1 0 0 
0 0 0 0 1 1 1 1 1 1 
0 0 0 0 0 0 0 1 0 0 
0 0 0 0 0 1 0 0 0 0 
0 0 0 1 0 0 1 1 0 0 
0 0 0 0 0 1 1 1 1 0 
0 1 1 1 0 0 1 1 0 0 
0 1 1 0 0 0 0 1 1 0 
0 0 0 1 1 1 1 1 1 1 
1 0 0 0 1 1 1 0 0 0 
1 1 1 0 0 0 1 1 1 0 
0 0 1 0 1 1 1 1 1 0 
0 0 1 1 1 1 1 0 0 0 
1 1 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 0 0 
0 0 0 0 0 0 0 0 1 1 
0 0 0 0 0 1 1 1 0 0 
0 0 1 1 0 1 0 0 0 0 
1 1 0 1 0 0 0 0 1 1 
0 0 0 0 0 0 1 1 0 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 1 1 0 0 0 1 1 
1 1 0 0 0 1 1 0 1 1 
1 1 1 0 1 1 0 0 0 1 
1 1 1 0 0 0 1 1 1 1 
0 0 0 1 1 1 1 0 0 0 
1 1 0 1 1 1 1 1 0 0 
1 1 1 1 1 0 1 1 0 0 
0 1 1 1 1 0 0 0 1 1 
1 1 0 0 0 1 1 0 1 1 
1 1 1 1 0 0 0 0 0 1 
1 0 0 0 0 0 1 1 0 0 
0 0 0 1 1 0 0 0 0 1 
1 0 0 1 1 1 1 0 0 } 
开始 处理 比较 操作 StringBuilder sbResult = new StringBuilder { 
for int i = 0 i 4 i + + 
{ string code = GetSingleBmpCode pics i 128 / / 
得到 代码 串 System . Collections . Generic . Dictionary 
char double E q u a l s P e 
r c e n t L i s t = 
new Dictionary char double / / 建立 差异 程度 列表 
for int arrayIndex = 0 arrayIndex CodeArray . Length arrayIndex 
+ + { if arrayIndex 10 / / 0 ~ 
9 { E q u a l s P e 
r c e n t L i s t . 
Add char 48 + arrayIndex 100 / / 数字 转 
字符 c 语法 习惯 } } for int arrayIndex = 
0 arrayIndex CodeArray . Length arrayIndex + + / / 
和 点阵 表内 的 字符 序列 进行 比较 { if 
arrayIndex 10 / / 0 ~ 9 { E q 
u a l s P e r c e n 
t L i s t char 48 + arrayIndex = 
EqualsPercent code CodeArray arrayIndex / / 每一个 图像 的 点阵 
的 差异 度 这里 的 差异 度 运 算是 误差 
程度 也 就是 不同 的 百分比 } 进行 获得 匹配 
{ double Perc = 20 / / 差异 百分比 必须 
小于 20% 否则 肯定 不对 string SelectKey = foreach char 
key in E q u a l s P e 
r c e n t L i s t . 
Keys / / 获取 匹配 程度 列表 中最 匹配 的 
一项 { if E q u a l s P 
e r c e n t L i s t 
key Perc { Perc = E q u a l 
s P e r c e n t L i 
s t key SelectKey = key . ToString } } 
sbResult . Append SelectKey } 至此 sbResult 中的 4个 数字 
就是 图 像上 的 4个 数字 了 结论 验证码 识别 
肯定 不 只是 这么 简单 但/c 现在/t 还是/c 有/v 很多/m 
网站/n 都/d 在用/b 这种/r 未经/d 任何/r 变换/v 的/uj 验证码/n 所以 
我们 的 网络 安全 还 任重而道远 上面 的 验证码 识别 
是 一个 最 基本 的 算法 但是 很多 扩展 算法 
都 可以 基于 上面 的 思路 进行 扩充 例如 有些 
验证码 进行 了 旋转 输出 那么 上面 的 程序 可以 
在 校对 的 时候 进行 360度 旋转 旋转 后的/nr 图像 
再取得 序列 再 和 图像 序列 比较 直至 得到 最 
符合 的 有些 验证码 添加 了 边框 此时 我们 可以 
先 去掉 边框 再 进行 切割 匹配 通过 上面 的 
算法 可以 得出 我们 今后 在 设计 验证码 的 时候 
应该 注意 如下 因素 1 在 噪音 等 类型 的 
使用 上 尽力/d 让/v 字符/n 和/c 用来/v 混淆/v 的/uj 前景/n 
和/c 背景/n 不容易/i 区分/n 尽力 让 噪音 长得 和 字母 
一样 2 特别 好 的 验证码 的 设计 要 尽力 
发挥 人类 擅长 而 AI 算法 不 擅长 的 比如 
粘 连字符 的 分割 和 手写体 通过 印刷体 做 特别 
的 变形 也 可以 而 不要 一味 的 去 加 
一些 看起来 比较 复杂 的 噪音 或者 其他 的 花哨 
东西 3 从 专业 的 机器 视觉 的 角度 来说 
网络安全 验证码 的 设计 一定 要 让 破 解者 在 
识别 阶段 反复 在 低阶 视觉 和 高阶 视觉 之间 
多 反复 几次 才能 识 别出来 这样 可以 大大 降低 
破解 难度 和 破解 的 准确率 