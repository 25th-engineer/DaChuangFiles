前言最近又开始进行人脸检测方向的内容，看到于仕琪老师的多角度检测想试一下，还不清楚原理，先测试效果如何。libfacedetect人脸检测库是深圳大学于仕琪老师发布的开源库，与opencv自带的人脸检测器相比，在速度和精度上都有较大的优势。本文主要基于libfacedetect库测试人脸检测的效果。环境系统：win10_x64;opencv版本：2410；VisualStudio版本：VS2013；注意，libfacedetect目前仅支持windows系统，86和64均可，且不支持多线程并行计算；配置1.下载libfacedetect开源库；于老师的github；2.新建VS工程项目(此处为x64版本)，添加或者配置opencv的属性表，opencv环境配置请参见here；3.项目属性中VC++目录选项中添加opencv和libfacedetect的包含目录和库目录；libfacedetect包含目录：.\libfacedetection-master\includelibfacedetect库目录：.\libfacedetection-master\lib3.链接器选项添加库文件到附加依赖项选项；libfacedetect.lib ------------ x86 libfacedetect-x64.lib ------------ x644.将bin目录下的dll文件放在exe的同一个目录，对应版本同步骤3；至此，完成项目的环境配置；测试code：单张图片测试/* The MIT License (MIT) Copyright (c) 2015-2017 Shiqi Yu shiqi.yu@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ #include <stdio.h> #include <opencv2/opencv.hpp> #include "facedetect-dll.h" //#pragma comment(lib,"libfacedetect.lib") #pragma comment(lib,"libfacedetect-x64.lib") //define the buffer size. Do not change the size! #define DETECT_BUFFER_SIZE 0x20000 using namespace cv; //int main(int argc, char* argv[]) int main( ) { //load an image and convert it to gray (single-channel) char* image_name = ".\\..\\images\\chloecalmon.png"; std::cout << image_name << std::endl; Mat image = imread(image_name); if (image.empty()) { fprintf(stderr, "Can not load the image file %s.\n", image_name); return -1; } Mat gray; cvtColor(image, gray, CV_BGR2GRAY); int * pResults = NULL; //pBuffer is used in the detection functions. //If you call functions in multiple threads, please create one buffer for each thread! unsigned char * pBuffer = (unsigned char *)malloc(DETECT_BUFFER_SIZE); if (!pBuffer) { fprintf(stderr, "Can not alloc buffer.\n"); return -1; } int doLandmark = 1; /////////////////////////////////////////// // frontal face detection / 68 landmark detection // it's fast, but cannot detect side view faces ////////////////////////////////////////// //!!! The input image must be a gray one (single-channel) //!!! DO NOT RELEASE pResults !!! pResults = facedetect_frontal(pBuffer, (unsigned char*)(gray.ptr(0)), gray.cols, gray.rows, (int)gray.step, 1.2f, 2, 48, 0, doLandmark); printf("%d faces detected.\n", (pResults ? *pResults : 0)); Mat result_frontal = image.clone(); //print the detection results for (int i = 0; i < (pResults ? *pResults : 0); i++) { short * p = ((short*)(pResults + 1)) + 142 * i; int x = p[0]; int y = p[1]; int w = p[2]; int h = p[3]; int neighbors = p[4]; int angle = p[5]; printf("face_rect=[%d, %d, %d, %d], neighbors=%d, angle=%d\n", x, y, w, h, neighbors, angle); rectangle(result_frontal, Rect(x, y, w, h), Scalar(0, 255, 0), 2); if (doLandmark) { for (int j = 0; j < 68; j++) circle(result_frontal, Point((int)p[6 + 2 * j], (int)p[6 + 2 * j + 1]), 1, Scalar(0, 255, 0)); } } imshow("Results_frontal", result_frontal); /////////////////////////////////////////// // frontal face detection designed for video surveillance / 68 landmark detection // it can detect faces with bad illumination. ////////////////////////////////////////// //!!! The input image must be a gray one (single-channel) //!!! DO NOT RELEASE pResults !!! pResults = facedetect_frontal_surveillance(pBuffer, (unsigned char*)(gray.ptr(0)), gray.cols, gray.rows, (int)gray.step, 1.2f, 2, 48, 0, doLandmark); printf("%d faces detected.\n", (pResults ? *pResults : 0)); Mat result_frontal_surveillance = image.clone();; //print the detection results for (int i = 0; i < (pResults ? *pResults : 0); i++) { short * p = ((short*)(pResults + 1)) + 142 * i; int x = p[0]; int y = p[1]; int w = p[2]; int h = p[3]; int neighbors = p[4]; int angle = p[5]; printf("face_rect=[%d, %d, %d, %d], neighbors=%d, angle=%d\n", x, y, w, h, neighbors, angle); rectangle(result_frontal_surveillance, Rect(x, y, w, h), Scalar(0, 255, 0), 2); if (doLandmark) { for (int j = 0; j < 68; j++) circle(result_frontal_surveillance, Point((int)p[6 + 2 * j], (int)p[6 + 2 * j + 1]), 1, Scalar(0, 255, 0)); } } imshow("Results_frontal_surveillance", result_frontal_surveillance); /////////////////////////////////////////// // multiview face detection / 68 landmark detection // it can detect side view faces, but slower than facedetect_frontal(). ////////////////////////////////////////// //!!! The input image must be a gray one (single-channel) //!!! DO NOT RELEASE pResults !!! pResults = facedetect_multiview(pBuffer, (unsigned char*)(gray.ptr(0)), gray.cols, gray.rows, (int)gray.step, 1.2f, 2, 48, 0, doLandmark); printf("%d faces detected.\n", (pResults ? *pResults : 0)); Mat result_multiview = image.clone();; //print the detection results for (int i = 0; i < (pResults ? *pResults : 0); i++) { short * p = ((short*)(pResults + 1)) + 142 * i; int x = p[0]; int y = p[1]; int w = p[2]; int h = p[3]; int neighbors = p[4]; int angle = p[5]; printf("face_rect=[%d, %d, %d, %d], neighbors=%d, angle=%d\n", x, y, w, h, neighbors, angle); rectangle(result_multiview, Rect(x, y, w, h), Scalar(0, 255, 0), 2); if (doLandmark) { for (int j = 0; j < 68; j++) circle(result_multiview, Point((int)p[6 + 2 * j], (int)p[6 + 2 * j + 1]), 1, Scalar(0, 255, 0)); } } imshow("Results_multiview", result_multiview); /////////////////////////////////////////// // reinforced multiview face detection / 68 landmark detection // it can detect side view faces, better but slower than facedetect_multiview(). ////////////////////////////////////////// //!!! The input image must be a gray one (single-channel) //!!! DO NOT RELEASE pResults !!! pResults = facedetect_multiview_reinforce(pBuffer, (unsigned char*)(gray.ptr(0)), gray.cols, gray.rows, (int)gray.step, 1.2f, 3, 48, 0, doLandmark); printf("%d faces detected.\n", (pResults ? *pResults : 0)); Mat result_multiview_reinforce = image.clone();; //print the detection results for (int i = 0; i < (pResults ? *pResults : 0); i++) { short * p = ((short*)(pResults + 1)) + 142 * i; int x = p[0]; int y = p[1]; int w = p[2]; int h = p[3]; int neighbors = p[4]; int angle = p[5]; printf("face_rect=[%d, %d, %d, %d], neighbors=%d, angle=%d\n", x, y, w, h, neighbors, angle); rectangle(result_multiview_reinforce, Rect(x, y, w, h), Scalar(0, 255, 0), 2); if (doLandmark) { for (int j = 0; j < 68; j++) circle(result_multiview_reinforce, Point((int)p[6 + 2 * j], (int)p[6 + 2 * j + 1]), 1, Scalar(0, 255, 0)); } } imshow("Results_multiview_reinforce", result_multiview_reinforce); waitKey(100); //release the buffer free(pBuffer); return 0; }View Codecamera测试/* The MIT License (MIT) Copyright (c) 2015-2017 Shiqi Yu shiqi.yu@gmail.com Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ #include <stdio.h> #include <opencv2/opencv.hpp> #include "facedetect-dll.h" //#pragma comment(lib,"libfacedetect.lib") #pragma comment(lib,"libfacedetect-x64.lib") //define the buffer size. Do not change the size! #define DETECT_BUFFER_SIZE 0x20000 using namespace cv; //int main(int argc, char* argv[]) int main() { cv::VideoCapture capture; capture.open(0); if (!capture.isOpened()) { std::cout << "video capture failed..." << std::endl; return 0; } cv::Mat image; cv::namedWindow("video test", CV_WINDOW_NORMAL); while (true) { image.release(); capture >> image; cv::Mat gray; cv::cvtColor(image, gray, CV_BGR2GRAY); int * pResults = NULL; //pBuffer is used in the detection functions. //If you call functions in multiple threads, please create one buffer for each thread! unsigned char * pBuffer = (unsigned char *)malloc(DETECT_BUFFER_SIZE); if (!pBuffer) { fprintf(stderr, "Can not alloc buffer.\n"); return -1; } int doLandmark = 1; /////////////////////////////////////////// // frontal face detection / 68 landmark detection // it's fast, but cannot detect side view faces ////////////////////////////////////////// //!!! The input image must be a gray one (single-channel) //!!! DO NOT RELEASE pResults !!! pResults = facedetect_frontal(pBuffer, (unsigned char*)(gray.ptr(0)), gray.cols, gray.rows, (int)gray.step, 1.2f, 2, 48, 0, doLandmark); printf("%d faces detected.\n", (pResults ? *pResults : 0)); Mat result_frontal = image.clone(); //print the detection results for (int i = 0; i < (pResults ? *pResults : 0); i++) { short * p = ((short*)(pResults + 1)) + 142 * i; int x = p[0]; int y = p[1]; int w = p[2]; int h = p[3]; int neighbors = p[4]; int angle = p[5]; printf("face_rect=[%d, %d, %d, %d], neighbors=%d, angle=%d\n", x, y, w, h, neighbors, angle); rectangle(result_frontal, Rect(x, y, w, h), Scalar(0, 255, 0), 2); if (doLandmark) { for (int j = 0; j < 68; j++) circle(result_frontal, Point((int)p[6 + 2 * j], (int)p[6 + 2 * j + 1]), 1, Scalar(0, 255, 0)); } } imshow("video test", result_frontal); /////////////////////////////////////////// // frontal face detection designed for video surveillance / 68 landmark detection // it can detect faces with bad illumination. ////////////////////////////////////////// //!!! The input image must be a gray one (single-channel) //!!! DO NOT RELEASE pResults !!! pResults = facedetect_frontal_surveillance(pBuffer, (unsigned char*)(gray.ptr(0)), gray.cols, gray.rows, (int)gray.step, 1.2f, 2, 48, 0, doLandmark); printf("%d faces detected.\n", (pResults ? *pResults : 0)); Mat result_frontal_surveillance = image.clone();; //print the detection results for (int i = 0; i < (pResults ? *pResults : 0); i++) { short * p = ((short*)(pResults + 1)) + 142 * i; int x = p[0]; int y = p[1]; int w = p[2]; int h = p[3]; int neighbors = p[4]; int angle = p[5]; printf("face_rect=[%d, %d, %d, %d], neighbors=%d, angle=%d\n", x, y, w, h, neighbors, angle); rectangle(result_frontal_surveillance, Rect(x, y, w, h), Scalar(0, 255, 0), 2); if (doLandmark) { for (int j = 0; j < 68; j++) circle(result_frontal_surveillance, Point((int)p[6 + 2 * j], (int)p[6 + 2 * j + 1]), 1, Scalar(0, 255, 0)); } } imshow("video test", result_frontal_surveillance); /////////////////////////////////////////// // multiview face detection / 68 landmark detection // it can detect side view faces, but slower than facedetect_frontal(). ////////////////////////////////////////// //!!! The input image must be a gray one (single-channel) //!!! DO NOT RELEASE pResults !!! pResults = facedetect_multiview(pBuffer, (unsigned char*)(gray.ptr(0)), gray.cols, gray.rows, (int)gray.step, 1.2f, 2, 48, 0, doLandmark); printf("%d faces detected.\n", (pResults ? *pResults : 0)); Mat result_multiview = image.clone();; //print the detection results for (int i = 0; i < (pResults ? *pResults : 0); i++) { short * p = ((short*)(pResults + 1)) + 142 * i; int x = p[0]; int y = p[1]; int w = p[2]; int h = p[3]; int neighbors = p[4]; int angle = p[5]; printf("face_rect=[%d, %d, %d, %d], neighbors=%d, angle=%d\n", x, y, w, h, neighbors, angle); rectangle(result_multiview, Rect(x, y, w, h), Scalar(0, 255, 0), 2); if (doLandmark) { for (int j = 0; j < 68; j++) circle(result_multiview, Point((int)p[6 + 2 * j], (int)p[6 + 2 * j + 1]), 1, Scalar(0, 255, 0)); } } imshow("video test", result_multiview); /////////////////////////////////////////// // reinforced multiview face detection / 68 landmark detection // it can detect side view faces, better but slower than facedetect_multiview(). ////////////////////////////////////////// //!!! The input image must be a gray one (single-channel) //!!! DO NOT RELEASE pResults !!! pResults = facedetect_multiview_reinforce(pBuffer, (unsigned char*)(gray.ptr(0)), gray.cols, gray.rows, (int)gray.step, 1.2f, 3, 48, 0, doLandmark); printf("%d faces detected.\n", (pResults ? *pResults : 0)); Mat result_multiview_reinforce = image.clone();; //print the detection results for (int i = 0; i < (pResults ? *pResults : 0); i++) { short * p = ((short*)(pResults + 1)) + 142 * i; int x = p[0]; int y = p[1]; int w = p[2]; int h = p[3]; int neighbors = p[4]; int angle = p[5]; printf("face_rect=[%d, %d, %d, %d], neighbors=%d, angle=%d\n", x, y, w, h, neighbors, angle); rectangle(result_multiview_reinforce, Rect(x, y, w, h), Scalar(0, 255, 0), 2); if (doLandmark) { for (int j = 0; j < 68; j++) circle(result_multiview_reinforce, Point((int)p[6 + 2 * j], (int)p[6 + 2 * j + 1]), 1, Scalar(0, 255, 0)); } } imshow("video test", result_multiview_reinforce); waitKey(100); //release the buffer free(pBuffer); } return 0; }View Code其中的neighbours的含义是int min_neighbors, //how many neighbors each candidate rectangle should have to retain it注意，工程记得添加头文件；参考1.github；2.如何使用libfacedetect；3.人脸检测算法；4.CSDN大神介绍；5.如何将人脸检测的速度做到极致；完