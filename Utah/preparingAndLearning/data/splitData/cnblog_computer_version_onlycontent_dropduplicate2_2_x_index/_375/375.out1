前言 最近 又 开始 进行 人脸 检测 方向 的 内容 
看到 于仕琪/nr 老师 的 多角度 检测 想 试一下 还 不 
清楚 原理 先 测试 效果 如何 libfacedetect 人脸 检测 库 
是 深圳 大学 于仕琪/nr 老师 发布 的 开源 库 与 
opencv 自带 的 人脸 检测器 相比 在/p 速度/n 和/c 精度/n 
上都/i 有/v 较大/a 的/uj 优势/n 本文 主要 基于 libfacedetect 库 
测试 人脸 检测 的 效果 环境系统 win10 _ x64 opencv 
版本 2410 VisualStudio 版本 VS2013 注意 libfacedetect 目前 仅 支持 
windows 系统 86 和 64 均可 且 不支持 多线程 并行计算 
配置 1 . 下载 libfacedetect 开源 库 于 老师 的 
github 2 . 新建 VS 工程项目 此处 为 x64 版本 
添加 或者 配置 opencv 的 属性 表 opencv 环境 配置 
请 参见 here 3/m ./i 项目/n 属性/n 中/f VC/w +/i 
+/i 目录/n 选项/n 中/f 添加/v opencv/w 和/c libfacedetect/w 的/uj 包含/v 
目录/n 和库/nr 目录/n libfacedetect 包含 目录 . \ libfacedetection master 
\ i n c l u d e l i 
b f a c e d e t e c 
t 库 目录 . \ libfacedetection master \ lib3 . 
链 接器 选项 添加 库文件 到 附加 依赖 项 选项 
libfacedetect . lib x86 libfacedetect x64 . lib x644 . 
将 bin 目 录下 的 dll 文件 放在 exe 的 
同一个 目录 对应 版本 同 步骤 3 至此 完成 项目 
的 环境 配置 测试 code 单张 图片 测试 / * 
The MIT License MIT Copyright c 2015 2017 Shiqi Yu 
shiqi . yu @ gmail . com Permission is hereby 
granted free of charge to any person obtaining a copy 
of this software and associated documentation files the Software to 
deal in the Software without restriction including without limitation the 
rights to use copy modify merge publish distribute sublicense and 
/ or sell copies of the Software and to permit 
persons to whom the Software is furnished to do so 
subject to the following conditions The above copyright notice and 
this permission notice shall be included in all copies or 
substantial portions of the Software . THE SOFTWARE IS PROVIDED 
AS IS WITHOUT WARRANTY OF ANY KIND EXPRESS OR IMPLIED 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY FITNESS 
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT 
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
CLAIM DAMAGES OR OTHER LIABILITY WHETHER IN AN ACTION OF 
CONTRACT TORT OR OTHERWISE ARISING FROM OUT OF OR IN 
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE . * / # include stdio . 
h # include opencv2 / opencv . hpp # include 
facedetect dll . h / / # pragma comment lib 
libfacedetect . lib # pragma comment lib libfacedetect x64 . 
lib / / define the buffer size . Do not 
change the size # define DETECT _ BUFFER _ SIZE 
0x20000 using namespace cv / / int main int argc 
char * argv int main { / / load an 
image and convert it to gray single channel char * 
image _ name = . \ \ . . \ 
\ images \ \ chloecalmon . png std cout image 
_ name std endl Mat image = imread image _ 
name if image . empty { fprintf stderr Can not 
load the image file % s . \ n image 
_ name return 1 } Mat gray cvtColor image gray 
CV _ BGR2GRAY int * pResults = NULL / / 
pBuffer is used in the detection functions . / / 
If you call functions in multiple threads please create one 
buffer for each thread unsigned char * pBuffer = unsigned 
char * malloc DETECT _ BUFFER _ SIZE if pBuffer 
{ fprintf stderr Can not alloc buffer . \ n 
return 1 } int doLandmark = 1 / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / frontal face detection / 68 landmark detection / 
/ it s fast but cannot detect side view faces 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / The input image must be a 
gray one single channel / / DO NOT RELEASE pResults 
pResults = facedetect _ frontal pBuffer unsigned char * gray 
. ptr 0 gray . cols gray . rows int 
gray . step 1.2 f 2 48 0 doLandmark printf 
% d faces detected . \ n pResults * pResults 
0 Mat result _ frontal = image . clone / 
/ print the detection results for int i = 0 
i pResults * pResults 0 i + + { short 
* p = short * pResults + 1 + 142 
* i int x = p 0 int y = 
p 1 int w = p 2 int h = 
p 3 int neighbors = p 4 int angle = 
p 5 printf face _ rect = % d % 
d % d % d neighbors = % d angle 
= % d \ n x y w h neighbors 
angle rectangle result _ frontal Rect x y w h 
Scalar 0 255 0 2 if doLandmark { for int 
j = 0 j 68 j + + circle result 
_ frontal Point int p 6 + 2 * j 
int p 6 + 2 * j + 1 1 
Scalar 0 255 0 } } imshow Results _ frontal 
result _ frontal / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / frontal face 
detection designed for video surveillance / 68 landmark detection / 
/ it can detect faces with bad illumination . / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / The input image must be a gray 
one single channel / / DO NOT RELEASE pResults pResults 
= facedetect _ frontal _ surveillance pBuffer unsigned char * 
gray . ptr 0 gray . cols gray . rows 
int gray . step 1.2 f 2 48 0 doLandmark 
printf % d faces detected . \ n pResults * 
pResults 0 Mat result _ frontal _ surveillance = image 
. clone / / print the detection results for int 
i = 0 i pResults * pResults 0 i + 
+ { short * p = short * pResults + 
1 + 142 * i int x = p 0 
int y = p 1 int w = p 2 
int h = p 3 int neighbors = p 4 
int angle = p 5 printf face _ rect = 
% d % d % d % d neighbors = 
% d angle = % d \ n x y 
w h neighbors angle rectangle result _ frontal _ surveillance 
Rect x y w h Scalar 0 255 0 2 
if doLandmark { for int j = 0 j 68 
j + + circle result _ frontal _ surveillance Point 
int p 6 + 2 * j int p 6 
+ 2 * j + 1 1 Scalar 0 255 
0 } } imshow Results _ frontal _ surveillance result 
_ frontal _ surveillance / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / multiview 
face detection / 68 landmark detection / / it can 
detect side view faces but slower than facedetect _ frontal 
. / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / The input image must be 
a gray one single channel / / DO NOT RELEASE 
pResults pResults = facedetect _ multiview pBuffer unsigned char * 
gray . ptr 0 gray . cols gray . rows 
int gray . step 1.2 f 2 48 0 doLandmark 
printf % d faces detected . \ n pResults * 
pResults 0 Mat result _ multiview = image . clone 
/ / print the detection results for int i = 
0 i pResults * pResults 0 i + + { 
short * p = short * pResults + 1 + 
142 * i int x = p 0 int y 
= p 1 int w = p 2 int h 
= p 3 int neighbors = p 4 int angle 
= p 5 printf face _ rect = % d 
% d % d % d neighbors = % d 
angle = % d \ n x y w h 
neighbors angle rectangle result _ multiview Rect x y w 
h Scalar 0 255 0 2 if doLandmark { for 
int j = 0 j 68 j + + circle 
result _ multiview Point int p 6 + 2 * 
j int p 6 + 2 * j + 1 
1 Scalar 0 255 0 } } imshow Results _ 
multiview result _ multiview / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / reinforced 
multiview face detection / 68 landmark detection / / it 
can detect side view faces better but slower than facedetect 
_ multiview . / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / The input image 
must be a gray one single channel / / DO 
NOT RELEASE pResults pResults = facedetect _ multiview _ reinforce 
pBuffer unsigned char * gray . ptr 0 gray . 
cols gray . rows int gray . step 1.2 f 
3 48 0 doLandmark printf % d faces detected . 
\ n pResults * pResults 0 Mat result _ multiview 
_ reinforce = image . clone / / print the 
detection results for int i = 0 i pResults * 
pResults 0 i + + { short * p = 
short * pResults + 1 + 142 * i int 
x = p 0 int y = p 1 int 
w = p 2 int h = p 3 int 
neighbors = p 4 int angle = p 5 printf 
face _ rect = % d % d % d 
% d neighbors = % d angle = % d 
\ n x y w h neighbors angle rectangle result 
_ multiview _ reinforce Rect x y w h Scalar 
0 255 0 2 if doLandmark { for int j 
= 0 j 68 j + + circle result _ 
multiview _ reinforce Point int p 6 + 2 * 
j int p 6 + 2 * j + 1 
1 Scalar 0 255 0 } } imshow Results _ 
multiview _ reinforce result _ multiview _ reinforce waitKey 100 
/ / release the buffer free pBuffer return 0 } 
View Codecamera 测试 / * The MIT License MIT Copyright 
c 2015 2017 Shiqi Yu shiqi . yu @ gmail 
. com Permission is hereby granted free of charge to 
any person obtaining a copy of this software and associated 
documentation files the Software to deal in the Software without 
restriction including without limitation the rights to use copy modify 
merge publish distribute sublicense and / or sell copies of 
the Software and to permit persons to whom the Software 
is furnished to do so subject to the following conditions 
The above copyright notice and this permission notice shall be 
included in all copies or substantial portions of the Software 
. THE SOFTWARE IS PROVIDED AS IS WITHOUT WARRANTY OF 
ANY KIND EXPRESS OR IMPLIED INCLUDING BUT NOT LIMITED TO 
THE WARRANTIES OF MERCHANTABILITY FITNESS FOR A PARTICULAR PURPOSE AND 
NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM DAMAGES OR OTHER LIABILITY 
WHETHER IN AN ACTION OF CONTRACT TORT OR OTHERWISE ARISING 
FROM OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
THE USE OR OTHER DEALINGS IN THE SOFTWARE . * 
/ # include stdio . h # include opencv2 / 
opencv . hpp # include facedetect dll . h / 
/ # pragma comment lib libfacedetect . lib # pragma 
comment lib libfacedetect x64 . lib / / define the 
buffer size . Do not change the size # define 
DETECT _ BUFFER _ SIZE 0x20000 using namespace cv / 
/ int main int argc char * argv int main 
{ cv VideoCapture capture capture . open 0 if capture 
. isOpened { std cout video capture failed . . 
. std endl return 0 } cv Mat image cv 
namedWindow video test CV _ WINDOW _ NORMAL while true 
{ image . release capture image cv Mat gray cv 
cvtColor image gray CV _ BGR2GRAY int * pResults = 
NULL / / pBuffer is used in the detection functions 
. / / If you call functions in multiple threads 
please create one buffer for each thread unsigned char * 
pBuffer = unsigned char * malloc DETECT _ BUFFER _ 
SIZE if pBuffer { fprintf stderr Can not alloc buffer 
. \ n return 1 } int doLandmark = 1 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / frontal face detection / 68 
landmark detection / / it s fast but cannot detect 
side view faces / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / The input image 
must be a gray one single channel / / DO 
NOT RELEASE pResults pResults = facedetect _ frontal pBuffer unsigned 
char * gray . ptr 0 gray . cols gray 
. rows int gray . step 1.2 f 2 48 
0 doLandmark printf % d faces detected . \ n 
pResults * pResults 0 Mat result _ frontal = image 
. clone / / print the detection results for int 
i = 0 i pResults * pResults 0 i + 
+ { short * p = short * pResults + 
1 + 142 * i int x = p 0 
int y = p 1 int w = p 2 
int h = p 3 int neighbors = p 4 
int angle = p 5 printf face _ rect = 
% d % d % d % d neighbors = 
% d angle = % d \ n x y 
w h neighbors angle rectangle result _ frontal Rect x 
y w h Scalar 0 255 0 2 if doLandmark 
{ for int j = 0 j 68 j + 
+ circle result _ frontal Point int p 6 + 
2 * j int p 6 + 2 * j 
+ 1 1 Scalar 0 255 0 } } imshow 
video test result _ frontal / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
frontal face detection designed for video surveillance / 68 landmark 
detection / / it can detect faces with bad illumination 
. / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / The input image must be 
a gray one single channel / / DO NOT RELEASE 
pResults pResults = facedetect _ frontal _ surveillance pBuffer unsigned 
char * gray . ptr 0 gray . cols gray 
. rows int gray . step 1.2 f 2 48 
0 doLandmark printf % d faces detected . \ n 
pResults * pResults 0 Mat result _ frontal _ surveillance 
= image . clone / / print the detection results 
for int i = 0 i pResults * pResults 0 
i + + { short * p = short * 
pResults + 1 + 142 * i int x = 
p 0 int y = p 1 int w = 
p 2 int h = p 3 int neighbors = 
p 4 int angle = p 5 printf face _ 
rect = % d % d % d % d 
neighbors = % d angle = % d \ n 
x y w h neighbors angle rectangle result _ frontal 
_ surveillance Rect x y w h Scalar 0 255 
0 2 if doLandmark { for int j = 0 
j 68 j + + circle result _ frontal _ 
surveillance Point int p 6 + 2 * j int 
p 6 + 2 * j + 1 1 Scalar 
0 255 0 } } imshow video test result _ 
frontal _ surveillance / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / multiview face 
detection / 68 landmark detection / / it can detect 
side view faces but slower than facedetect _ frontal . 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / The input image must be a 
gray one single channel / / DO NOT RELEASE pResults 
pResults = facedetect _ multiview pBuffer unsigned char * gray 
. ptr 0 gray . cols gray . rows int 
gray . step 1.2 f 2 48 0 doLandmark printf 
% d faces detected . \ n pResults * pResults 
0 Mat result _ multiview = image . clone / 
/ print the detection results for int i = 0 
i pResults * pResults 0 i + + { short 
* p = short * pResults + 1 + 142 
* i int x = p 0 int y = 
p 1 int w = p 2 int h = 
p 3 int neighbors = p 4 int angle = 
p 5 printf face _ rect = % d % 
d % d % d neighbors = % d angle 
= % d \ n x y w h neighbors 
angle rectangle result _ multiview Rect x y w h 
Scalar 0 255 0 2 if doLandmark { for int 
j = 0 j 68 j + + circle result 
_ multiview Point int p 6 + 2 * j 
int p 6 + 2 * j + 1 1 
Scalar 0 255 0 } } imshow video test result 
_ multiview / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / reinforced multiview face 
detection / 68 landmark detection / / it can detect 
side view faces better but slower than facedetect _ multiview 
. / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / The input image must be 
a gray one single channel / / DO NOT RELEASE 
pResults pResults = facedetect _ multiview _ reinforce pBuffer unsigned 
char * gray . ptr 0 gray . cols gray 
. rows int gray . step 1.2 f 3 48 
0 doLandmark printf % d faces detected . \ n 
pResults * pResults 0 Mat result _ multiview _ reinforce 
= image . clone / / print the detection results 
for int i = 0 i pResults * pResults 0 
i + + { short * p = short * 
pResults + 1 + 142 * i int x = 
p 0 int y = p 1 int w = 
p 2 int h = p 3 int neighbors = 
p 4 int angle = p 5 printf face _ 
rect = % d % d % d % d 
neighbors = % d angle = % d \ n 
x y w h neighbors angle rectangle result _ multiview 
_ reinforce Rect x y w h Scalar 0 255 
0 2 if doLandmark { for int j = 0 
j 68 j + + circle result _ multiview _ 
reinforce Point int p 6 + 2 * j int 
p 6 + 2 * j + 1 1 Scalar 
0 255 0 } } imshow video test result _ 
multiview _ reinforce waitKey 100 / / release the buffer 
free pBuffer } return 0 } View Code 其中 的 
neighbours 的 含义 是 int min _ neighbors / / 
how many neighbors each candidate rectangle should have to retain 
it 注意 工程 记得 添加 头文件 参考 1 . github 
2 . 如何 使用 libfacedetect 3 . 人脸 检测 算法 
4 . CSDN 大神 介绍 5 . 如何将 人脸 检测 
的 速度 做到 极致 完 前言 最近 又 开始 进行 人脸 检测 方向 的 内容 
看到 于仕琪/nr 老师 的 多角度 检测 想 试一下 还 不 
清楚 原理 先 测试 效果 如何 libfacedetect 人脸 检测 库 
是 深圳 大学 于仕琪/nr 老师 发布 的 开源 库 与 
opencv 自带 的 人脸 检测器 相比 在/p 速度/n 和/c 精度/n 
上都/i 有/v 较大/a 的/uj 优势/n 本文 主要 基于 libfacedetect 库 
测试 人脸 检测 的 效果 环境系统 win10 _ x64 opencv 
版本 2410 VisualStudio 版本 VS2013 注意 libfacedetect 目前 仅 支持 
windows 系统 86 和 64 均可 且 不支持 多线程 并行计算 
配置 1 . 下载 libfacedetect 开源 库 于 老师 的 
github 2 . 新建 VS 工程项目 此处 为 x64 版本 
添加 或者 配置 opencv 的 属性 表 opencv 环境 配置 
请 参见 here 3/m ./i 项目/n 属性/n 中/f VC/w +/i 
+/i 目录/n 选项/n 中/f 添加/v opencv/w 和/c libfacedetect/w 的/uj 包含/v 
目录/n 和库/nr 目录/n libfacedetect 包含 目录 . \ libfacedetection master 
\ i n c l u d e l i 
b f a c e d e t e c 
t 库 目录 . \ libfacedetection master \ lib3 . 
链 接器 选项 添加 库文件 到 附加 依赖 项 选项 
libfacedetect . lib x86 libfacedetect x64 . lib x644 . 
将 bin 目 录下 的 dll 文件 放在 exe 的 
同一个 目录 对应 版本 同 步骤 3 至此 完成 项目 
的 环境 配置 测试 code 单张 图片 测试 / * 
The MIT License MIT Copyright c 2015 2017 Shiqi Yu 
shiqi . yu @ gmail . com Permission is hereby 
granted free of charge to any person obtaining a copy 
of this software and associated documentation files the Software to 
deal in the Software without restriction including without limitation the 
rights to use copy modify merge publish distribute sublicense and 
/ or sell copies of the Software and to permit 
persons to whom the Software is furnished to do so 
subject to the following conditions The above copyright notice and 
this permission notice shall be included in all copies or 
substantial portions of the Software . THE SOFTWARE IS PROVIDED 
AS IS WITHOUT WARRANTY OF ANY KIND EXPRESS OR IMPLIED 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY FITNESS 
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT 
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
CLAIM DAMAGES OR OTHER LIABILITY WHETHER IN AN ACTION OF 
CONTRACT TORT OR OTHERWISE ARISING FROM OUT OF OR IN 
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE . * / # include stdio . 
h # include opencv2 / opencv . hpp # include 
facedetect dll . h / / # pragma comment lib 
libfacedetect . lib # pragma comment lib libfacedetect x64 . 
lib / / define the buffer size . Do not 
change the size # define DETECT _ BUFFER _ SIZE 
0x20000 using namespace cv / / int main int argc 
char * argv int main { / / load an 
image and convert it to gray single channel char * 
image _ name = . \ \ . . \ 
\ images \ \ chloecalmon . png std cout image 
_ name std endl Mat image = imread image _ 
name if image . empty { fprintf stderr Can not 
load the image file % s . \ n image 
_ name return 1 } Mat gray cvtColor image gray 
CV _ BGR2GRAY int * pResults = NULL / / 
pBuffer is used in the detection functions . / / 
If you call functions in multiple threads please create one 
buffer for each thread unsigned char * pBuffer = unsigned 
char * malloc DETECT _ BUFFER _ SIZE if pBuffer 
{ fprintf stderr Can not alloc buffer . \ n 
return 1 } int doLandmark = 1 / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / frontal face detection / 68 landmark detection / 
/ it s fast but cannot detect side view faces 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / The input image must be a 
gray one single channel / / DO NOT RELEASE pResults 
pResults = facedetect _ frontal pBuffer unsigned char * gray 
. ptr 0 gray . cols gray . rows int 
gray . step 1.2 f 2 48 0 doLandmark printf 
% d faces detected . \ n pResults * pResults 
0 Mat result _ frontal = image . clone / 
/ print the detection results for int i = 0 
i pResults * pResults 0 i + + { short 
* p = short * pResults + 1 + 142 
* i int x = p 0 int y = 
p 1 int w = p 2 int h = 
p 3 int neighbors = p 4 int angle = 
p 5 printf face _ rect = % d % 
d % d % d neighbors = % d angle 
= % d \ n x y w h neighbors 
angle rectangle result _ frontal Rect x y w h 
Scalar 0 255 0 2 if doLandmark { for int 
j = 0 j 68 j + + circle result 
_ frontal Point int p 6 + 2 * j 
int p 6 + 2 * j + 1 1 
Scalar 0 255 0 } } imshow Results _ frontal 
result _ frontal / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / frontal face 
detection designed for video surveillance / 68 landmark detection / 
/ it can detect faces with bad illumination . / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / The input image must be a gray 
one single channel / / DO NOT RELEASE pResults pResults 
= facedetect _ frontal _ surveillance pBuffer unsigned char * 
gray . ptr 0 gray . cols gray . rows 
int gray . step 1.2 f 2 48 0 doLandmark 
printf % d faces detected . \ n pResults * 
pResults 0 Mat result _ frontal _ surveillance = image 
. clone / / print the detection results for int 
i = 0 i pResults * pResults 0 i + 
+ { short * p = short * pResults + 
1 + 142 * i int x = p 0 
int y = p 1 int w = p 2 
int h = p 3 int neighbors = p 4 
int angle = p 5 printf face _ rect = 
% d % d % d % d neighbors = 
% d angle = % d \ n x y 
w h neighbors angle rectangle result _ frontal _ surveillance 
Rect x y w h Scalar 0 255 0 2 
if doLandmark { for int j = 0 j 68 
j + + circle result _ frontal _ surveillance Point 
int p 6 + 2 * j int p 6 
+ 2 * j + 1 1 Scalar 0 255 
0 } } imshow Results _ frontal _ surveillance result 
_ frontal _ surveillance / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / multiview 
face detection / 68 landmark detection / / it can 
detect side view faces but slower than facedetect _ frontal 
. / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / The input image must be 
a gray one single channel / / DO NOT RELEASE 
pResults pResults = facedetect _ multiview pBuffer unsigned char * 
gray . ptr 0 gray . cols gray . rows 
int gray . step 1.2 f 2 48 0 doLandmark 
printf % d faces detected . \ n pResults * 
pResults 0 Mat result _ multiview = image . clone 
/ / print the detection results for int i = 
0 i pResults * pResults 0 i + + { 
short * p = short * pResults + 1 + 
142 * i int x = p 0 int y 
= p 1 int w = p 2 int h 
= p 3 int neighbors = p 4 int angle 
= p 5 printf face _ rect = % d 
% d % d % d neighbors = % d 
angle = % d \ n x y w h 
neighbors angle rectangle result _ multiview Rect x y w 
h Scalar 0 255 0 2 if doLandmark { for 
int j = 0 j 68 j + + circle 
result _ multiview Point int p 6 + 2 * 
j int p 6 + 2 * j + 1 
1 Scalar 0 255 0 } } imshow Results _ 
multiview result _ multiview / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / reinforced 
multiview face detection / 68 landmark detection / / it 
can detect side view faces better but slower than facedetect 
_ multiview . / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / The input image 
must be a gray one single channel / / DO 
NOT RELEASE pResults pResults = facedetect _ multiview _ reinforce 
pBuffer unsigned char * gray . ptr 0 gray . 
cols gray . rows int gray . step 1.2 f 
3 48 0 doLandmark printf % d faces detected . 
\ n pResults * pResults 0 Mat result _ multiview 
_ reinforce = image . clone / / print the 
detection results for int i = 0 i pResults * 
pResults 0 i + + { short * p = 
short * pResults + 1 + 142 * i int 
x = p 0 int y = p 1 int 
w = p 2 int h = p 3 int 
neighbors = p 4 int angle = p 5 printf 
face _ rect = % d % d % d 
% d neighbors = % d angle = % d 
\ n x y w h neighbors angle rectangle result 
_ multiview _ reinforce Rect x y w h Scalar 
0 255 0 2 if doLandmark { for int j 
= 0 j 68 j + + circle result _ 
multiview _ reinforce Point int p 6 + 2 * 
j int p 6 + 2 * j + 1 
1 Scalar 0 255 0 } } imshow Results _ 
multiview _ reinforce result _ multiview _ reinforce waitKey 100 
/ / release the buffer free pBuffer return 0 } 
View Codecamera 测试 / * The MIT License MIT Copyright 
c 2015 2017 Shiqi Yu shiqi . yu @ gmail 
. com Permission is hereby granted free of charge to 
any person obtaining a copy of this software and associated 
documentation files the Software to deal in the Software without 
restriction including without limitation the rights to use copy modify 
merge publish distribute sublicense and / or sell copies of 
the Software and to permit persons to whom the Software 
is furnished to do so subject to the following conditions 
The above copyright notice and this permission notice shall be 
included in all copies or substantial portions of the Software 
. THE SOFTWARE IS PROVIDED AS IS WITHOUT WARRANTY OF 
ANY KIND EXPRESS OR IMPLIED INCLUDING BUT NOT LIMITED TO 
THE WARRANTIES OF MERCHANTABILITY FITNESS FOR A PARTICULAR PURPOSE AND 
NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM DAMAGES OR OTHER LIABILITY 
WHETHER IN AN ACTION OF CONTRACT TORT OR OTHERWISE ARISING 
FROM OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
THE USE OR OTHER DEALINGS IN THE SOFTWARE . * 
/ # include stdio . h # include opencv2 / 
opencv . hpp # include facedetect dll . h / 
/ # pragma comment lib libfacedetect . lib # pragma 
comment lib libfacedetect x64 . lib / / define the 
buffer size . Do not change the size # define 
DETECT _ BUFFER _ SIZE 0x20000 using namespace cv / 
/ int main int argc char * argv int main 
{ cv VideoCapture capture capture . open 0 if capture 
. isOpened { std cout video capture failed . . 
. std endl return 0 } cv Mat image cv 
namedWindow video test CV _ WINDOW _ NORMAL while true 
{ image . release capture image cv Mat gray cv 
cvtColor image gray CV _ BGR2GRAY int * pResults = 
NULL / / pBuffer is used in the detection functions 
. / / If you call functions in multiple threads 
please create one buffer for each thread unsigned char * 
pBuffer = unsigned char * malloc DETECT _ BUFFER _ 
SIZE if pBuffer { fprintf stderr Can not alloc buffer 
. \ n return 1 } int doLandmark = 1 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / frontal face detection / 68 
landmark detection / / it s fast but cannot detect 
side view faces / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / The input image 
must be a gray one single channel / / DO 
NOT RELEASE pResults pResults = facedetect _ frontal pBuffer unsigned 
char * gray . ptr 0 gray . cols gray 
. rows int gray . step 1.2 f 2 48 
0 doLandmark printf % d faces detected . \ n 
pResults * pResults 0 Mat result _ frontal = image 
. clone / / print the detection results for int 
i = 0 i pResults * pResults 0 i + 
+ { short * p = short * pResults + 
1 + 142 * i int x = p 0 
int y = p 1 int w = p 2 
int h = p 3 int neighbors = p 4 
int angle = p 5 printf face _ rect = 
% d % d % d % d neighbors = 
% d angle = % d \ n x y 
w h neighbors angle rectangle result _ frontal Rect x 
y w h Scalar 0 255 0 2 if doLandmark 
{ for int j = 0 j 68 j + 
+ circle result _ frontal Point int p 6 + 
2 * j int p 6 + 2 * j 
+ 1 1 Scalar 0 255 0 } } imshow 
video test result _ frontal / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
frontal face detection designed for video surveillance / 68 landmark 
detection / / it can detect faces with bad illumination 
. / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / The input image must be 
a gray one single channel / / DO NOT RELEASE 
pResults pResults = facedetect _ frontal _ surveillance pBuffer unsigned 
char * gray . ptr 0 gray . cols gray 
. rows int gray . step 1.2 f 2 48 
0 doLandmark printf % d faces detected . \ n 
pResults * pResults 0 Mat result _ frontal _ surveillance 
= image . clone / / print the detection results 
for int i = 0 i pResults * pResults 0 
i + + { short * p = short * 
pResults + 1 + 142 * i int x = 
p 0 int y = p 1 int w = 
p 2 int h = p 3 int neighbors = 
p 4 int angle = p 5 printf face _ 
rect = % d % d % d % d 
neighbors = % d angle = % d \ n 
x y w h neighbors angle rectangle result _ frontal 
_ surveillance Rect x y w h Scalar 0 255 
0 2 if doLandmark { for int j = 0 
j 68 j + + circle result _ frontal _ 
surveillance Point int p 6 + 2 * j int 
p 6 + 2 * j + 1 1 Scalar 
0 255 0 } } imshow video test result _ 
frontal _ surveillance / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / multiview face 
detection / 68 landmark detection / / it can detect 
side view faces but slower than facedetect _ frontal . 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / The input image must be a 
gray one single channel / / DO NOT RELEASE pResults 
pResults = facedetect _ multiview pBuffer unsigned char * gray 
. ptr 0 gray . cols gray . rows int 
gray . step 1.2 f 2 48 0 doLandmark printf 
% d faces detected . \ n pResults * pResults 
0 Mat result _ multiview = image . clone / 
/ print the detection results for int i = 0 
i pResults * pResults 0 i + + { short 
* p = short * pResults + 1 + 142 
* i int x = p 0 int y = 
p 1 int w = p 2 int h = 
p 3 int neighbors = p 4 int angle = 
p 5 printf face _ rect = % d % 
d % d % d neighbors = % d angle 
= % d \ n x y w h neighbors 
angle rectangle result _ multiview Rect x y w h 
Scalar 0 255 0 2 if doLandmark { for int 
j = 0 j 68 j + + circle result 
_ multiview Point int p 6 + 2 * j 
int p 6 + 2 * j + 1 1 
Scalar 0 255 0 } } imshow video test result 
_ multiview / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / reinforced multiview face 
detection / 68 landmark detection / / it can detect 
side view faces better but slower than facedetect _ multiview 
. / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / The input image must be 
a gray one single channel / / DO NOT RELEASE 
pResults pResults = facedetect _ multiview _ reinforce pBuffer unsigned 
char * gray . ptr 0 gray . cols gray 
. rows int gray . step 1.2 f 3 48 
0 doLandmark printf % d faces detected . \ n 
pResults * pResults 0 Mat result _ multiview _ reinforce 
= image . clone / / print the detection results 
for int i = 0 i pResults * pResults 0 
i + + { short * p = short * 
pResults + 1 + 142 * i int x = 
p 0 int y = p 1 int w = 
p 2 int h = p 3 int neighbors = 
p 4 int angle = p 5 printf face _ 
rect = % d % d % d % d 
neighbors = % d angle = % d \ n 
x y w h neighbors angle rectangle result _ multiview 
_ reinforce Rect x y w h Scalar 0 255 
0 2 if doLandmark { for int j = 0 
j 68 j + + circle result _ multiview _ 
reinforce Point int p 6 + 2 * j int 
p 6 + 2 * j + 1 1 Scalar 
0 255 0 } } imshow video test result _ 
multiview _ reinforce waitKey 100 / / release the buffer 
free pBuffer } return 0 } View Code 其中 的 
neighbours 的 含义 是 int min _ neighbors / / 
how many neighbors each candidate rectangle should have to retain 
it 注意 工程 记得 添加 头文件 参考 1 . github 
2 . 如何 使用 libfacedetect 3 . 人脸 检测 算法 
4 . CSDN 大神 介绍 5 . 如何将 人脸 检测 
的 速度 做到 极致 完 前言 最近 又 开始 进行 人脸 检测 方向 的 内容 
看到 于仕琪/nr 老师 的 多角度 检测 想 试一下 还 不 
清楚 原理 先 测试 效果 如何 libfacedetect 人脸 检测 库 
是 深圳 大学 于仕琪/nr 老师 发布 的 开源 库 与 
opencv 自带 的 人脸 检测器 相比 在/p 速度/n 和/c 精度/n 
上都/i 有/v 较大/a 的/uj 优势/n 本文 主要 基于 libfacedetect 库 
测试 人脸 检测 的 效果 环境系统 win10 _ x64 opencv 
版本 2410 VisualStudio 版本 VS2013 注意 libfacedetect 目前 仅 支持 
windows 系统 86 和 64 均可 且 不支持 多线程 并行计算 
配置 1 . 下载 libfacedetect 开源 库 于 老师 的 
github 2 . 新建 VS 工程项目 此处 为 x64 版本 
添加 或者 配置 opencv 的 属性 表 opencv 环境 配置 
请 参见 here 3/m ./i 项目/n 属性/n 中/f VC/w +/i 
+/i 目录/n 选项/n 中/f 添加/v opencv/w 和/c libfacedetect/w 的/uj 包含/v 
目录/n 和库/nr 目录/n libfacedetect 包含 目录 . \ libfacedetection master 
\ i n c l u d e l i 
b f a c e d e t e c 
t 库 目录 . \ libfacedetection master \ lib3 . 
链 接器 选项 添加 库文件 到 附加 依赖 项 选项 
libfacedetect . lib x86 libfacedetect x64 . lib x644 . 
将 bin 目 录下 的 dll 文件 放在 exe 的 
同一个 目录 对应 版本 同 步骤 3 至此 完成 项目 
的 环境 配置 测试 code 单张 图片 测试 / * 
The MIT License MIT Copyright c 2015 2017 Shiqi Yu 
shiqi . yu @ gmail . com Permission is hereby 
granted free of charge to any person obtaining a copy 
of this software and associated documentation files the Software to 
deal in the Software without restriction including without limitation the 
rights to use copy modify merge publish distribute sublicense and 
/ or sell copies of the Software and to permit 
persons to whom the Software is furnished to do so 
subject to the following conditions The above copyright notice and 
this permission notice shall be included in all copies or 
substantial portions of the Software . THE SOFTWARE IS PROVIDED 
AS IS WITHOUT WARRANTY OF ANY KIND EXPRESS OR IMPLIED 
INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY FITNESS 
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT . IN NO EVENT 
SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY 
CLAIM DAMAGES OR OTHER LIABILITY WHETHER IN AN ACTION OF 
CONTRACT TORT OR OTHERWISE ARISING FROM OUT OF OR IN 
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS 
IN THE SOFTWARE . * / # include stdio . 
h # include opencv2 / opencv . hpp # include 
facedetect dll . h / / # pragma comment lib 
libfacedetect . lib # pragma comment lib libfacedetect x64 . 
lib / / define the buffer size . Do not 
change the size # define DETECT _ BUFFER _ SIZE 
0x20000 using namespace cv / / int main int argc 
char * argv int main { / / load an 
image and convert it to gray single channel char * 
image _ name = . \ \ . . \ 
\ images \ \ chloecalmon . png std cout image 
_ name std endl Mat image = imread image _ 
name if image . empty { fprintf stderr Can not 
load the image file % s . \ n image 
_ name return 1 } Mat gray cvtColor image gray 
CV _ BGR2GRAY int * pResults = NULL / / 
pBuffer is used in the detection functions . / / 
If you call functions in multiple threads please create one 
buffer for each thread unsigned char * pBuffer = unsigned 
char * malloc DETECT _ BUFFER _ SIZE if pBuffer 
{ fprintf stderr Can not alloc buffer . \ n 
return 1 } int doLandmark = 1 / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / frontal face detection / 68 landmark detection / 
/ it s fast but cannot detect side view faces 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / The input image must be a 
gray one single channel / / DO NOT RELEASE pResults 
pResults = facedetect _ frontal pBuffer unsigned char * gray 
. ptr 0 gray . cols gray . rows int 
gray . step 1.2 f 2 48 0 doLandmark printf 
% d faces detected . \ n pResults * pResults 
0 Mat result _ frontal = image . clone / 
/ print the detection results for int i = 0 
i pResults * pResults 0 i + + { short 
* p = short * pResults + 1 + 142 
* i int x = p 0 int y = 
p 1 int w = p 2 int h = 
p 3 int neighbors = p 4 int angle = 
p 5 printf face _ rect = % d % 
d % d % d neighbors = % d angle 
= % d \ n x y w h neighbors 
angle rectangle result _ frontal Rect x y w h 
Scalar 0 255 0 2 if doLandmark { for int 
j = 0 j 68 j + + circle result 
_ frontal Point int p 6 + 2 * j 
int p 6 + 2 * j + 1 1 
Scalar 0 255 0 } } imshow Results _ frontal 
result _ frontal / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / frontal face 
detection designed for video surveillance / 68 landmark detection / 
/ it can detect faces with bad illumination . / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / The input image must be a gray 
one single channel / / DO NOT RELEASE pResults pResults 
= facedetect _ frontal _ surveillance pBuffer unsigned char * 
gray . ptr 0 gray . cols gray . rows 
int gray . step 1.2 f 2 48 0 doLandmark 
printf % d faces detected . \ n pResults * 
pResults 0 Mat result _ frontal _ surveillance = image 
. clone / / print the detection results for int 
i = 0 i pResults * pResults 0 i + 
+ { short * p = short * pResults + 
1 + 142 * i int x = p 0 
int y = p 1 int w = p 2 
int h = p 3 int neighbors = p 4 
int angle = p 5 printf face _ rect = 
% d % d % d % d neighbors = 
% d angle = % d \ n x y 
w h neighbors angle rectangle result _ frontal _ surveillance 
Rect x y w h Scalar 0 255 0 2 
if doLandmark { for int j = 0 j 68 
j + + circle result _ frontal _ surveillance Point 
int p 6 + 2 * j int p 6 
+ 2 * j + 1 1 Scalar 0 255 
0 } } imshow Results _ frontal _ surveillance result 
_ frontal _ surveillance / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / multiview 
face detection / 68 landmark detection / / it can 
detect side view faces but slower than facedetect _ frontal 
. / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / The input image must be 
a gray one single channel / / DO NOT RELEASE 
pResults pResults = facedetect _ multiview pBuffer unsigned char * 
gray . ptr 0 gray . cols gray . rows 
int gray . step 1.2 f 2 48 0 doLandmark 
printf % d faces detected . \ n pResults * 
pResults 0 Mat result _ multiview = image . clone 
/ / print the detection results for int i = 
0 i pResults * pResults 0 i + + { 
short * p = short * pResults + 1 + 
142 * i int x = p 0 int y 
= p 1 int w = p 2 int h 
= p 3 int neighbors = p 4 int angle 
= p 5 printf face _ rect = % d 
% d % d % d neighbors = % d 
angle = % d \ n x y w h 
neighbors angle rectangle result _ multiview Rect x y w 
h Scalar 0 255 0 2 if doLandmark { for 
int j = 0 j 68 j + + circle 
result _ multiview Point int p 6 + 2 * 
j int p 6 + 2 * j + 1 
1 Scalar 0 255 0 } } imshow Results _ 
multiview result _ multiview / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / reinforced 
multiview face detection / 68 landmark detection / / it 
can detect side view faces better but slower than facedetect 
_ multiview . / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / The input image 
must be a gray one single channel / / DO 
NOT RELEASE pResults pResults = facedetect _ multiview _ reinforce 
pBuffer unsigned char * gray . ptr 0 gray . 
cols gray . rows int gray . step 1.2 f 
3 48 0 doLandmark printf % d faces detected . 
\ n pResults * pResults 0 Mat result _ multiview 
_ reinforce = image . clone / / print the 
detection results for int i = 0 i pResults * 
pResults 0 i + + { short * p = 
short * pResults + 1 + 142 * i int 
x = p 0 int y = p 1 int 
w = p 2 int h = p 3 int 
neighbors = p 4 int angle = p 5 printf 
face _ rect = % d % d % d 
% d neighbors = % d angle = % d 
\ n x y w h neighbors angle rectangle result 
_ multiview _ reinforce Rect x y w h Scalar 
0 255 0 2 if doLandmark { for int j 
= 0 j 68 j + + circle result _ 
multiview _ reinforce Point int p 6 + 2 * 
j int p 6 + 2 * j + 1 
1 Scalar 0 255 0 } } imshow Results _ 
multiview _ reinforce result _ multiview _ reinforce waitKey 100 
/ / release the buffer free pBuffer return 0 } 
View Codecamera 测试 / * The MIT License MIT Copyright 
c 2015 2017 Shiqi Yu shiqi . yu @ gmail 
. com Permission is hereby granted free of charge to 
any person obtaining a copy of this software and associated 
documentation files the Software to deal in the Software without 
restriction including without limitation the rights to use copy modify 
merge publish distribute sublicense and / or sell copies of 
the Software and to permit persons to whom the Software 
is furnished to do so subject to the following conditions 
The above copyright notice and this permission notice shall be 
included in all copies or substantial portions of the Software 
. THE SOFTWARE IS PROVIDED AS IS WITHOUT WARRANTY OF 
ANY KIND EXPRESS OR IMPLIED INCLUDING BUT NOT LIMITED TO 
THE WARRANTIES OF MERCHANTABILITY FITNESS FOR A PARTICULAR PURPOSE AND 
NONINFRINGEMENT . IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM DAMAGES OR OTHER LIABILITY 
WHETHER IN AN ACTION OF CONTRACT TORT OR OTHERWISE ARISING 
FROM OUT OF OR IN CONNECTION WITH THE SOFTWARE OR 
THE USE OR OTHER DEALINGS IN THE SOFTWARE . * 
/ # include stdio . h # include opencv2 / 
opencv . hpp # include facedetect dll . h / 
/ # pragma comment lib libfacedetect . lib # pragma 
comment lib libfacedetect x64 . lib / / define the 
buffer size . Do not change the size # define 
DETECT _ BUFFER _ SIZE 0x20000 using namespace cv / 
/ int main int argc char * argv int main 
{ cv VideoCapture capture capture . open 0 if capture 
. isOpened { std cout video capture failed . . 
. std endl return 0 } cv Mat image cv 
namedWindow video test CV _ WINDOW _ NORMAL while true 
{ image . release capture image cv Mat gray cv 
cvtColor image gray CV _ BGR2GRAY int * pResults = 
NULL / / pBuffer is used in the detection functions 
. / / If you call functions in multiple threads 
please create one buffer for each thread unsigned char * 
pBuffer = unsigned char * malloc DETECT _ BUFFER _ 
SIZE if pBuffer { fprintf stderr Can not alloc buffer 
. \ n return 1 } int doLandmark = 1 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / frontal face detection / 68 
landmark detection / / it s fast but cannot detect 
side view faces / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / The input image 
must be a gray one single channel / / DO 
NOT RELEASE pResults pResults = facedetect _ frontal pBuffer unsigned 
char * gray . ptr 0 gray . cols gray 
. rows int gray . step 1.2 f 2 48 
0 doLandmark printf % d faces detected . \ n 
pResults * pResults 0 Mat result _ frontal = image 
. clone / / print the detection results for int 
i = 0 i pResults * pResults 0 i + 
+ { short * p = short * pResults + 
1 + 142 * i int x = p 0 
int y = p 1 int w = p 2 
int h = p 3 int neighbors = p 4 
int angle = p 5 printf face _ rect = 
% d % d % d % d neighbors = 
% d angle = % d \ n x y 
w h neighbors angle rectangle result _ frontal Rect x 
y w h Scalar 0 255 0 2 if doLandmark 
{ for int j = 0 j 68 j + 
+ circle result _ frontal Point int p 6 + 
2 * j int p 6 + 2 * j 
+ 1 1 Scalar 0 255 0 } } imshow 
video test result _ frontal / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
frontal face detection designed for video surveillance / 68 landmark 
detection / / it can detect faces with bad illumination 
. / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / The input image must be 
a gray one single channel / / DO NOT RELEASE 
pResults pResults = facedetect _ frontal _ surveillance pBuffer unsigned 
char * gray . ptr 0 gray . cols gray 
. rows int gray . step 1.2 f 2 48 
0 doLandmark printf % d faces detected . \ n 
pResults * pResults 0 Mat result _ frontal _ surveillance 
= image . clone / / print the detection results 
for int i = 0 i pResults * pResults 0 
i + + { short * p = short * 
pResults + 1 + 142 * i int x = 
p 0 int y = p 1 int w = 
p 2 int h = p 3 int neighbors = 
p 4 int angle = p 5 printf face _ 
rect = % d % d % d % d 
neighbors = % d angle = % d \ n 
x y w h neighbors angle rectangle result _ frontal 
_ surveillance Rect x y w h Scalar 0 255 
0 2 if doLandmark { for int j = 0 
j 68 j + + circle result _ frontal _ 
surveillance Point int p 6 + 2 * j int 
p 6 + 2 * j + 1 1 Scalar 
0 255 0 } } imshow video test result _ 
frontal _ surveillance / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / multiview face 
detection / 68 landmark detection / / it can detect 
side view faces but slower than facedetect _ frontal . 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / The input image must be a 
gray one single channel / / DO NOT RELEASE pResults 
pResults = facedetect _ multiview pBuffer unsigned char * gray 
. ptr 0 gray . cols gray . rows int 
gray . step 1.2 f 2 48 0 doLandmark printf 
% d faces detected . \ n pResults * pResults 
0 Mat result _ multiview = image . clone / 
/ print the detection results for int i = 0 
i pResults * pResults 0 i + + { short 
* p = short * pResults + 1 + 142 
* i int x = p 0 int y = 
p 1 int w = p 2 int h = 
p 3 int neighbors = p 4 int angle = 
p 5 printf face _ rect = % d % 
d % d % d neighbors = % d angle 
= % d \ n x y w h neighbors 
angle rectangle result _ multiview Rect x y w h 
Scalar 0 255 0 2 if doLandmark { for int 
j = 0 j 68 j + + circle result 
_ multiview Point int p 6 + 2 * j 
int p 6 + 2 * j + 1 1 
Scalar 0 255 0 } } imshow video test result 
_ multiview / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / reinforced multiview face 
detection / 68 landmark detection / / it can detect 
side view faces better but slower than facedetect _ multiview 
. / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / / / / / / 
/ / / / / The input image must be 
a gray one single channel / / DO NOT RELEASE 
pResults pResults = facedetect _ multiview _ reinforce pBuffer unsigned 
char * gray . ptr 0 gray . cols gray 
. rows int gray . step 1.2 f 3 48 
0 doLandmark printf % d faces detected . \ n 
pResults * pResults 0 Mat result _ multiview _ reinforce 
= image . clone / / print the detection results 
for int i = 0 i pResults * pResults 0 
i + + { short * p = short * 
pResults + 1 + 142 * i int x = 
p 0 int y = p 1 int w = 
p 2 int h = p 3 int neighbors = 
p 4 int angle = p 5 printf face _ 
rect = % d % d % d % d 
neighbors = % d angle = % d \ n 
x y w h neighbors angle rectangle result _ multiview 
_ reinforce Rect x y w h Scalar 0 255 
0 2 if doLandmark { for int j = 0 
j 68 j + + circle result _ multiview _ 
reinforce Point int p 6 + 2 * j int 
p 6 + 2 * j + 1 1 Scalar 
0 255 0 } } imshow video test result _ 
multiview _ reinforce waitKey 100 / / release the buffer 
free pBuffer } return 0 } View Code 其中 的 
neighbours 的 含义 是 int min _ neighbors / / 
how many neighbors each candidate rectangle should have to retain 
it 注意 工程 记得 添加 头文件 参考 1 . github 
2 . 如何 使用 libfacedetect 3 . 人脸 检测 算法 
4 . CSDN 大神 介绍 5 . 如何将 人脸 检测 
的 速度 做到 极致 完 