不同色彩空间的转换当前，在计算机视觉中有三种常用的色彩空间：灰度、BGR以及HSV1.灰度色彩空间是通过去除彩色信息来将其转换为灰阶，灰度色彩空间对中间处理特别有效，比如人脸检测2.BGR,即蓝绿红色彩空间，每一个像素点都由一个三元组来表示3.HSV,H(Hue)是色调，S(Saturation)是饱和度，V(value)表示黑暗的程度(或光谱另一端的明亮程度)傅里叶变换Numpy里有快速傅里叶变换（FFT）的包，它包含了fft2()函数，该函数可以计算一副图像的离散傅里叶变换(DFT)。下面通过傅里叶变换来介绍图像的幅度谱。图像的幅度谱是另一种图像，幅度谱图像呈现了原始图像在变化方面的一种表示：把一幅图像中最明亮的像素放到图像中央，然后逐渐变暗，在边缘上的像素最暗。这样可以发现图像中有多少亮的像素和暗的像素，以及他们分布的百分比。高通滤波器高通滤波器是检测图像的某个区域，然后根据像素与周围像素的亮度差来提升该像素的亮度的滤波器以如下的核kernel为例：[[0,-0.25,0],[-0.25,1,-0.25],[0,-0.25,0]]核是指一组权重的集合，他会应用在源图像的一个区域，并由此生成目标图像的一个像素。在计算完中央像素与周围邻近像素的亮度的差值之和以后，如果亮度变化很大，中央像素的亮度会增加，反之则不会。高通和低通滤波器都有一个称为半径的属性，它决定了多大面积的邻近像素参与滤波运算。这些滤波器中的所有值加起来为0import cv2 import numpy as np from scipy import ndimage kernel_3X3=np.array([[-1,-1,-1],[-1,8,-1],[-1,-1,-1]]) kernel_5X5=np.array([[-1,-1,-1,-1,-1],[-1,1,2,1,-1],[-1,2,4,2,-1],[-1,1,2,1,-1],[-1,-1,-1,-1,-1]]) img=cv2.imread("1.jpg",0) k3=ndimage.convolve(img,kernel_3X3)#卷积 k5=ndimage.convolve(img,kernel_5X5)#卷积 blurred=cv2.GaussianBlur(img,(11,11),0) g_hpf=img-blurred #两种高通滤波的效果 cv2.imshow("3x3",k3) cv2.imshow("5x5",k5) #通过对图像应用低通滤波器之后，与原始图像计算差值 cv2.imshow("g_hpf",g_hpf) cv2.waitKey() cv2.destroyAllWindows()低通滤波器低通滤波器（LPF）则是在像素与周围像素的亮度的亮度差值小于一个特定值时，平滑该像素的亮度。它主要用于去噪和模糊化。比如说，高斯模糊是最常用的模糊滤波器（平滑滤波器）之一，它是一个消弱高频信号强度的低通滤波器。边缘检测边缘在认类视觉和计算机视觉中均起着重要的作用OpenCV提供了许多边缘检测滤波函数，包括Laplacian()、Sobel()以及Scharr()。这些滤波函数都会将非边缘区域转换为黑色，将边缘区域转为白色或其他饱和的颜色。但是这些函数都很容易将噪声错误地识别为边缘。缓解这个问题的方法是在找到边缘之前对图像进行模糊处理。OpenCV也提供了许多模糊滤波函数，包括blur()（简单的算术平均)、medianBlur()以及GaussianBlur()。边缘检测滤波函数和模糊滤波函数的参数有很多，但总会有一个ksize参数，它是一个奇数，表示滤波核的宽和高（以像素为单位）。这里使用medianBlur()作为模糊函数，它对去除数字化的视频噪声非常有效，特别是去除彩色图像的噪声；使用Laplacian()作为边缘检测函数，他会产生明显的边缘线条，灰度图像更是如此。在使用medianBlur()函数之后，将要使用Laplacian()函数之前，需要将图像从BRG色彩空间转换为灰色色彩空间。在得到Laplacian()函数的结果之后，需要将其转换成黑色边缘和白色背景的图像。然后将其归一化（使其像素值在0-1之间），并乘以源图像以便能将边缘变黑用定制内核做卷积OpenCV预定义的许多滤波器（滤波函数）都会使用核。其实核是一组权重，它决定如何通过邻近像素点来计算新的像素点。核也称为卷积矩阵，它对一个区域的像素做调和（mix up）或卷积运算。通常基于核的滤波器（滤波函数）被称为卷积滤波器（滤波函数）。OpenCV提供了一个非常通用的filter2D()函数，它运用由用户指定的任意核或卷积矩阵。cv.filter2D(src,-1,kernel,dst)第二个参数指定了目标图像每个通道的位深度，如果为负值，则表示目标图像和源图像有同样的位深度。对于彩色图像来说，filter2D()会对每个通道都用同样的核。如果要对每个通道使用不同的核，就必须用split()函数和merge()函数Canny边缘检测Canny边缘检测算法非常复杂，但也很有趣：它有5个步骤，即使用高斯滤波器对图像及逆行去噪、计算梯度、在边缘上使用非最大抑制（NMS）、在检测到的边缘上使用双阈值去除假阳性，最后还会分析所有的边缘及其之间的连接，以保留真正的边缘并消除不明显的边缘。import cv2 import numpy as np img=cv2.imread("1.jpg",0) c=cv2.Canny(img,200,300) cv2.imshow("canny",c) cv2.waitKey() cv2.destroyAllWindows()轮廓检测在计算机视觉中，轮廓检测是另一个比较重要的任务，不单是用来检测图像或者视频帧中物体的轮廓，而且还有其他操作与轮廓检测有关。这些操作有：计算多边形边界、形状逼近和计算感兴趣区域。这是与图像数据交互时的简单操作，因为Numpy中的矩形区域可以使用数组切片（slice）来定义。import cv2 import numpy as np img=np.zeros((200,200),dtype=np.uint8) img[50:150,50:150]=255 ret,thresh=cv2.threshold(img,127,255,0) image,contours,hierarchy=cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE) color=cv2.cvtColor(img,cv2.COLOR_GRAY2BGR) img=cv2.drawContours(color,contours,-1,(0,255,0),2) cv2.imshow("contours",color) cv2.waitKey() cv2.destroyAllWindows()这段代码首先创建了一个200X200大小的黑色空白图像，接着在图像的中央放置一个白色方块，这里用到了np数组在切片上赋值的功能。接下来对图像进行二值化操作，然后调用了findContours()函数。该函数有三个参数：输入图像，层次类型和轮廓逼近方法。它有几个方面特别有趣：1.这个函数会修改输入图像，因此建议使用原始图像的一份拷贝2.由函数返回的层次树相当重要：cv2.RETR_TREE参数会得到图像中轮廓的整体层次结构，以此来建立轮廓之间的“关系”。如果只想得到最外面的轮廓，可使用cv2.RETR_EXTERNAL。这对消除包含在其他轮廓中的轮廓很有用findContours()函数有三个返回值：修改后的图像、图像的轮廓以及他们的层次。使用轮廓来画出图像的彩色版本，并显示出来。