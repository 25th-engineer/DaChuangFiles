我 是 一名 初学者 如果 你 发现 文中 有错误 请 
留言 告诉 我 谢谢 图像 的 模糊 和 平滑 是 
同一 个 层面 的 意思 平滑 的 过程 就是 一个 
模糊 的 过程 而 图像 的 去 噪 可以 通过 
图像 的 模糊 平滑 来 实现 图像去噪 还有 其他 的 
方法 那么 怎么 才能 对 一幅 图像 进行 模糊 平滑 
呢 图像 的 模糊 平滑 是 对 图像 矩阵 进行 
平均 的 过程 相比 于 图像 锐化 微分 过程 图像 
平滑 处理 是 一个 积分 的 过程 图像 平滑 过程 
可以 通过 原 图像 和 一个 积分算子 进行 卷积 来 
实现 下面/f 介绍/v 两种/m 积分算子/n 全1/nr 算子/n 最简单/i 的/uj 积分算子/n 
就是/d 全1/nr 算子/n 利用/n 全1/nr 算子/n 可以/c 对/p 图像/n 进行/v 
模糊/a 平滑/a 操作/v 有 一定 的 去 噪 能力 下面 
是 python 实例 import numpy as np from PIL import 
Image import matplotlib . pyplot as plt import matplotlib . 
cm as cm suanzi = np . ones 3 3 
# 创建 全1/nr 算子 # 打开 图像 并 转化 成 
灰度 图像 image = Image . open pika . jpg 
. convert L image _ array = np . array 
image # 原 图像 与 全1/nr 算子 进行 卷积 image2 
= signal . convolve2d image _ array suanzi mode = 
same # 将 结果 灰度 值 转化 到 0 255 
image2 = image2 / float image2 . max * 255 
# 显示 图像 plt . subplot 2 1 1 plt 
. imshow image _ array cmap = cm . gray 
plt . axis off plt . subplot 2 1 2 
plt . imshow image2 cmap = cm . gray plt 
. axis off plt . show 运行 结果 如 下图 
为了 看到 效果 图像 经过 人工 局部 放大 上 图为 
原 图像 下图 为 经过 模糊 处理 图像 比较 两幅 
图 可以 看出 全1/nr 算子/n 有/v 一定/d 的/uj 模糊/a 平滑/a 
效果/n 高斯/nr 算子/n 利用/n 高斯/nr 算子/n 进行/v 模糊/a 处理/v 就/d 
是/v 我们/r 常/d 听到/v 的/uj 高斯/nr 模糊/a 标准差 为 σ 
的 高斯分布 如 下式 我们 可以 通过 numpy 模块 的 
fromfunction 方法来 生成 高斯 算子 import numpy as np # 
乘以 100 是 为了 使 算子 中的 数 便于 观察 
# sigma 指定 高斯 算子 的 标准差 def func x 
y sigma = 1 return 100 * 1 / 2 
* np . pi * sigma * np . exp 
x 2 * * 2 + y 2 * * 
2 / 2.0 * sigma * * 2 # 生成 
标准差 都2的/nr 5 * 5 高斯 算子 a = np 
. fromfunction func 5 5 sigma = 2 print a 
# 结果 2.92749158 4.25947511 4.82661763 4.25947511 2.92749158 4.25947511 6.19749972 7.02268722 
6.19749972 4.25947511 4.82661763 7.02268722 7.95774715 7.02268722 4.82661763 4.25947511 6.19749972 7.02268722 
6.19749972 4.25947511 2.92749158 4.25947511 4.82661763 4.25947511 2.92749158 对 上面 的 
5 * 5 高斯 算子 每个 元素 进行 四舍五入 可以 
得到 下面 矩阵 看到 有些 地方 直接 用 上面 的 
矩阵 对 图像 进行 高斯 模糊 实际上 是 运用 的 
是 标准差 为 2 的 高斯 近似 算子 利用 高斯 
算子 对 图像 进行 模糊 程序 如下 import numpy as 
np from PIL import Image import matplotlib . pyplot as 
plt import matplotlib . cm as cm import scipy . 
signal as signal # 生成 高斯 算子 的 函数 def 
func x y sigma = 1 return 100 * 1 
/ 2 * np . pi * sigma * np 
. exp x 2 * * 2 + y 2 
* * 2 / 2.0 * sigma * * 2 
# 生成 标准差 为 2 的 5 * 5 高斯 
算子 suanzi = np . fromfunction func 5 5 sigma 
= 2 # 打开 图像 并 转化 成 灰度 图像 
image = Image . open pika . jpg . convert 
L image _ array = np . array image # 
图像 与 高斯 算子 进行 卷积 image2 = signal . 
convolve2d image _ array suanzi mode = same # 结果 
转化 到 0 255 image2 = image2 / float image2 
. max * 255 # 显示 图像 plt . subplot 
2 1 1 plt . imshow image _ array cmap 
= cm . gray plt . axis off plt . 
subplot 2 1 2 plt . imshow image2 cmap = 
cm . gray plt . axis off plt . show 
运行 结果 如 下图 为了 看到 效果 图像 经过 人工 
局部 放大 上 图为 原 图像 下图/v 为/p 经过/p 高斯/nr 
模糊/a 处理/v 图像/n 对比/v 高斯/nr 算子/n 和全1/nr 算子/n 可以 看出 
高斯 算子 的 模糊 想过 似乎 更好 而且 我们 可以 
通过 更改 高斯 算子 的 标准差 和 维数 来 调整 
模糊 效果 一般来说 高斯 算子 标准差 越大 维数 越大 图像 
越 模糊 参考 列表 1 . python 计算机 视觉 编程 
2 . 度娘 感谢 那些 热爱 分享 知识 的 朋友 
我 是 一名 初学者 如果 你 发现 文中 有错误 请 
留言 告诉 我 谢谢 图像 的 模糊 和 平滑 是 
同一 个 层面 的 意思 平滑 的 过程 就是 一个 
模糊 的 过程 而 图像 的 去 噪 可以 通过 
图像 的 模糊 平滑 来 实现 图像去噪 还有 其他 的 
方法 那么 怎么 才能 对 一幅 图像 进行 模糊 平滑 
呢 图像 的 模糊 平滑 是 对 图像 矩阵 进行 
平均 的 过程 相比 于 图像 锐化 微分 过程 图像 
平滑 处理 是 一个 积分 的 过程 图像 平滑 过程 
可以 通过 原 图像 和 一个 积分算子 进行 卷积 来 
实现 下面/f 介绍/v 两种/m 积分算子/n 全1/nr 算子/n 最简单/i 的/uj 积分算子/n 
就是/d 全1/nr 算子/n 利用/n 全1/nr 算子/n 可以/c 对/p 图像/n 进行/v 
模糊/a 平滑/a 操作/v 有 一定 的 去 噪 能力 下面 
是 python 实例 import numpy as np from PIL import 
Image import matplotlib . pyplot as plt import matplotlib . 
cm as cm suanzi = np . ones 3 3 
# 创建 全1/nr 算子 # 打开 图像 并 转化 成 
灰度 图像 image = Image . open pika . jpg 
. convert L image _ array = np . array 
image # 原 图像 与 全1/nr 算子 进行 卷积 image2 
= signal . convolve2d image _ array suanzi mode = 
same # 将 结果 灰度 值 转化 到 0 255 
image2 = image2 / float image2 . max * 255 
# 显示 图像 plt . subplot 2 1 1 plt 
. imshow image _ array cmap = cm . gray 
plt . axis off plt . subplot 2 1 2 
plt . imshow image2 cmap = cm . gray plt 
. axis off plt . show 运行 结果 如 下图 
为了 看到 效果 图像 经过 人工 局部 放大 上 图为 
原 图像 下图 为 经过 模糊 处理 图像 比较 两幅 
图 可以 看出 全1/nr 算子/n 有/v 一定/d 的/uj 模糊/a 平滑/a 
效果/n 高斯/nr 算子/n 利用/n 高斯/nr 算子/n 进行/v 模糊/a 处理/v 就/d 
是/v 我们/r 常/d 听到/v 的/uj 高斯/nr 模糊/a 标准差 为 σ 
的 高斯分布 如 下式 我们 可以 通过 numpy 模块 的 
fromfunction 方法来 生成 高斯 算子 import numpy as np # 
乘以 100 是 为了 使 算子 中的 数 便于 观察 
# sigma 指定 高斯 算子 的 标准差 def func x 
y sigma = 1 return 100 * 1 / 2 
* np . pi * sigma * np . exp 
x 2 * * 2 + y 2 * * 
2 / 2.0 * sigma * * 2 # 生成 
标准差 都2的/nr 5 * 5 高斯 算子 a = np 
. fromfunction func 5 5 sigma = 2 print a 
# 结果 2.92749158 4.25947511 4.82661763 4.25947511 2.92749158 4.25947511 6.19749972 7.02268722 
6.19749972 4.25947511 4.82661763 7.02268722 7.95774715 7.02268722 4.82661763 4.25947511 6.19749972 7.02268722 
6.19749972 4.25947511 2.92749158 4.25947511 4.82661763 4.25947511 2.92749158 对 上面 的 
5 * 5 高斯 算子 每个 元素 进行 四舍五入 可以 
得到 下面 矩阵 看到 有些 地方 直接 用 上面 的 
矩阵 对 图像 进行 高斯 模糊 实际上 是 运用 的 
是 标准差 为 2 的 高斯 近似 算子 利用 高斯 
算子 对 图像 进行 模糊 程序 如下 import numpy as 
np from PIL import Image import matplotlib . pyplot as 
plt import matplotlib . cm as cm import scipy . 
signal as signal # 生成 高斯 算子 的 函数 def 
func x y sigma = 1 return 100 * 1 
/ 2 * np . pi * sigma * np 
. exp x 2 * * 2 + y 2 
* * 2 / 2.0 * sigma * * 2 
# 生成 标准差 为 2 的 5 * 5 高斯 
算子 suanzi = np . fromfunction func 5 5 sigma 
= 2 # 打开 图像 并 转化 成 灰度 图像 
image = Image . open pika . jpg . convert 
L image _ array = np . array image # 
图像 与 高斯 算子 进行 卷积 image2 = signal . 
convolve2d image _ array suanzi mode = same # 结果 
转化 到 0 255 image2 = image2 / float image2 
. max * 255 # 显示 图像 plt . subplot 
2 1 1 plt . imshow image _ array cmap 
= cm . gray plt . axis off plt . 
subplot 2 1 2 plt . imshow image2 cmap = 
cm . gray plt . axis off plt . show 
运行 结果 如 下图 为了 看到 效果 图像 经过 人工 
局部 放大 上 图为 原 图像 下图/v 为/p 经过/p 高斯/nr 
模糊/a 处理/v 图像/n 对比/v 高斯/nr 算子/n 和全1/nr 算子/n 可以 看出 
高斯 算子 的 模糊 想过 似乎 更好 而且 我们 可以 
通过 更改 高斯 算子 的 标准差 和 维数 来 调整 
模糊 效果 一般来说 高斯 算子 标准差 越大 维数 越大 图像 
越 模糊 参考 列表 1 . python 计算机 视觉 编程 
2 . 度娘 感谢 那些 热爱 分享 知识 的 朋友 
我 是 一名 初学者 如果 你 发现 文中 有错误 请 
留言 告诉 我 谢谢 图像 的 模糊 和 平滑 是 
同一 个 层面 的 意思 平滑 的 过程 就是 一个 
模糊 的 过程 而 图像 的 去 噪 可以 通过 
图像 的 模糊 平滑 来 实现 图像去噪 还有 其他 的 
方法 那么 怎么 才能 对 一幅 图像 进行 模糊 平滑 
呢 图像 的 模糊 平滑 是 对 图像 矩阵 进行 
平均 的 过程 相比 于 图像 锐化 微分 过程 图像 
平滑 处理 是 一个 积分 的 过程 图像 平滑 过程 
可以 通过 原 图像 和 一个 积分算子 进行 卷积 来 
实现 下面/f 介绍/v 两种/m 积分算子/n 全1/nr 算子/n 最简单/i 的/uj 积分算子/n 
就是/d 全1/nr 算子/n 利用/n 全1/nr 算子/n 可以/c 对/p 图像/n 进行/v 
模糊/a 平滑/a 操作/v 有 一定 的 去 噪 能力 下面 
是 python 实例 import numpy as np from PIL import 
Image import matplotlib . pyplot as plt import matplotlib . 
cm as cm suanzi = np . ones 3 3 
# 创建 全1/nr 算子 # 打开 图像 并 转化 成 
灰度 图像 image = Image . open pika . jpg 
. convert L image _ array = np . array 
image # 原 图像 与 全1/nr 算子 进行 卷积 image2 
= signal . convolve2d image _ array suanzi mode = 
same # 将 结果 灰度 值 转化 到 0 255 
image2 = image2 / float image2 . max * 255 
# 显示 图像 plt . subplot 2 1 1 plt 
. imshow image _ array cmap = cm . gray 
plt . axis off plt . subplot 2 1 2 
plt . imshow image2 cmap = cm . gray plt 
. axis off plt . show 运行 结果 如 下图 
为了 看到 效果 图像 经过 人工 局部 放大 上 图为 
原 图像 下图 为 经过 模糊 处理 图像 比较 两幅 
图 可以 看出 全1/nr 算子/n 有/v 一定/d 的/uj 模糊/a 平滑/a 
效果/n 高斯/nr 算子/n 利用/n 高斯/nr 算子/n 进行/v 模糊/a 处理/v 就/d 
是/v 我们/r 常/d 听到/v 的/uj 高斯/nr 模糊/a 标准差 为 σ 
的 高斯分布 如 下式 我们 可以 通过 numpy 模块 的 
fromfunction 方法来 生成 高斯 算子 import numpy as np # 
乘以 100 是 为了 使 算子 中的 数 便于 观察 
# sigma 指定 高斯 算子 的 标准差 def func x 
y sigma = 1 return 100 * 1 / 2 
* np . pi * sigma * np . exp 
x 2 * * 2 + y 2 * * 
2 / 2.0 * sigma * * 2 # 生成 
标准差 都2的/nr 5 * 5 高斯 算子 a = np 
. fromfunction func 5 5 sigma = 2 print a 
# 结果 2.92749158 4.25947511 4.82661763 4.25947511 2.92749158 4.25947511 6.19749972 7.02268722 
6.19749972 4.25947511 4.82661763 7.02268722 7.95774715 7.02268722 4.82661763 4.25947511 6.19749972 7.02268722 
6.19749972 4.25947511 2.92749158 4.25947511 4.82661763 4.25947511 2.92749158 对 上面 的 
5 * 5 高斯 算子 每个 元素 进行 四舍五入 可以 
得到 下面 矩阵 看到 有些 地方 直接 用 上面 的 
矩阵 对 图像 进行 高斯 模糊 实际上 是 运用 的 
是 标准差 为 2 的 高斯 近似 算子 利用 高斯 
算子 对 图像 进行 模糊 程序 如下 import numpy as 
np from PIL import Image import matplotlib . pyplot as 
plt import matplotlib . cm as cm import scipy . 
signal as signal # 生成 高斯 算子 的 函数 def 
func x y sigma = 1 return 100 * 1 
/ 2 * np . pi * sigma * np 
. exp x 2 * * 2 + y 2 
* * 2 / 2.0 * sigma * * 2 
# 生成 标准差 为 2 的 5 * 5 高斯 
算子 suanzi = np . fromfunction func 5 5 sigma 
= 2 # 打开 图像 并 转化 成 灰度 图像 
image = Image . open pika . jpg . convert 
L image _ array = np . array image # 
图像 与 高斯 算子 进行 卷积 image2 = signal . 
convolve2d image _ array suanzi mode = same # 结果 
转化 到 0 255 image2 = image2 / float image2 
. max * 255 # 显示 图像 plt . subplot 
2 1 1 plt . imshow image _ array cmap 
= cm . gray plt . axis off plt . 
subplot 2 1 2 plt . imshow image2 cmap = 
cm . gray plt . axis off plt . show 
运行 结果 如 下图 为了 看到 效果 图像 经过 人工 
局部 放大 上 图为 原 图像 下图/v 为/p 经过/p 高斯/nr 
模糊/a 处理/v 图像/n 对比/v 高斯/nr 算子/n 和全1/nr 算子/n 可以 看出 
高斯 算子 的 模糊 想过 似乎 更好 而且 我们 可以 
通过 更改 高斯 算子 的 标准差 和 维数 来 调整 
模糊 效果 一般来说 高斯 算子 标准差 越大 维数 越大 图像 
越 模糊 参考 列表 1 . python 计算机 视觉 编程 
2 . 度娘 感谢 那些 热爱 分享 知识 的 朋友 
