计算机 视觉 形态学 滤波 标签 空格 分隔 图像处理 信号处理 版权 
声明 本文 为 博主 原创 文章 转载 请 注明 出处 
http / / blog . csdn . net / lg1259156776 
/ 说明 本文 主要 想 弄清楚 形态学 滤波 在 图象处理 
和 信号 处理 中 的 应用 图像 处理 中 非常 
直观 的 通过 腐蚀 膨胀 获得 开闭 运算 的 效果 
而在 数据 实时 滤波 中 形态学 滤波 也 是 可以 
使用 的 形态学 滤波 基本知识 原理 在 特殊 领域 运算 
形式 结构 元素 Sturcture Element 在 每个 像素 位置 上 
与 二 值 图像 对应 的 区域 进行 特定 的 
逻辑运算 运算 结构 是 输出 图像 的 相应 像素 运算 
效果 取决于 结构 元素 大小 内容 以及 逻辑运算 性质 膨胀 
腐蚀 开 闭 运算 是 数学 形态学 最 基本 的 
变换 结构 元素 简单 地 定义 为 像素 的 结构 
形状 以及 一个 原点 又 称为 锚 点 使用 形态学 
滤波 涉及 对 图像 的 每个 像素 应用 这个 结构 
元素 当 结构 元素 的 原点 与 给定 的 像素 
对齐 时 它 与 图像 相交 部分 定义 了 一组 
进行 形态学 运算 的 像素 原则上 结构 元素 可以 是 
任何 形状 但 通常 使用 简单 的 形状 比如 方形 
圆形 和 菱形 而 原点 位于 中心 位置 基于 效率 
的 考虑 腐蚀 和 膨胀 两个 滤波 操作 也 运算 
在 每个 像素 周围 像素 集 合上 邻域 这 是由 
结构 元素 定义 的 当 应用 到 一个 给定 的 
像素 时 结构 元素 的 锚 点 与 该 像素 
的 位置 对齐 而 所有 与 他 相交 的 像素 
都被 包括 在 当前 像素 集合 中 腐蚀 替换 当前 
像素 为 像素 集合 中 找到 的 最小 的 像素 
值 而 膨胀 则 替换 为 像素 集合 中 找到 
的 最大 像素 值 当然 对于 二 值 图像 每个 
像素 只能 被 替换 为 白色 像素 或 黑色 像素 
这 一段 的 论述 可以 参考 Opencv 计算机 视觉 编程 
手册 对于 腐蚀 和 膨胀 的 差别 可以 通过 想象 
腐蚀 呢 如果 给定 像素 的 结构 元素 触碰 到 
背景 那么 该 像素 被 设置 为 背景 而在 膨胀 
的 情况 下 如果 触碰 到 前景 该 像素 被 
设置 为 前景 所以 很 明显 腐蚀 操作 后 物体 
的 尺寸 会 减小 而 膨胀 操作 后 物体 的 
尺寸 会 增大 同时 内部 的 一些 洞 被 填满 
事实上 腐蚀 一副 图像 两次 就 像是 让 结构 元素 
对 自己 进行 膨胀 后 再去 腐蚀 同 一幅 图像 
反过来 对 膨胀 也是 合适 的 有 下面 两种 说法 
对 图像 的 腐蚀 操作 等于 对 图像 负片 的 
膨胀 操作 的 负片 对 图像 的 膨胀 操作 等于 
对 图像 负片 的 腐蚀 操作 的 负片 实际上 说 
的 是 对 目标 进行 的 腐蚀 等效于 对 背景 
进行 的 膨胀 反之亦然 腐蚀 的 最简单 的 应用 是从 
图中 消除 不 相关 的 细节 而 膨胀 的 最简单 
的 应用 是 将 裂缝 桥 接起来 开运 算是 先 
腐蚀 再膨胀 开 运算 一般 断开 狭窄 的 间断 和 
消除 细 的 突出 物 而 闭 操作 通常 消弥 
狭窄 的 间断 和长细/nr 的 鸿沟 消除 小 的 孔洞 
并 填充 轮廓线 中的 断裂 开 运算 与 闭 运算 
的 结合 使用 能使 作用 对象 的 轮廓 变得 光滑 
开运 算是 先 腐蚀 再膨胀 而 闭 运 算是 先 
膨胀 再 腐蚀 在 检验 闭 滤波器 的 结果 时 
可以 看到 白色 前景 物体 中的 小洞 被 填充 该 
滤波器 同时 连接 多 个 相邻 物体 基本上 无法 完全 
包含结构 元素 的 洞洞 或者 缝隙 都 将被 滤波器 移除 
反过来 开 滤波器 则是 移 除掉 场景 中 比较 小 
的 物体 因为 它 门 无法 完全 包含结构 元素 这些 
滤波器 通常 在 物体 检测 中 应用 闭 滤波器 将 
误 分割为 碎片 的 物体 重新 连接起来 而 开 滤波器 
则 去 除掉 图像 噪声 点 引起 的 小 像素 
块 Blob 因此 在 视频 序列 中 使用 他们 很有帮助 
如果 测试 的 二 值 图像 相继 使用 闭 开 
操作 获得 图像 将 只显示 场景 中 的 主要 物体 
如果 优先 处理 噪点 也 可以 先 进行 开 运算 
再 进行 闭 运算 但是 有 可能 去 除掉 一些 
分散 的 物体 需要 注意 的 是 对于 对于 一幅 
图像 多次 使用 相同 的 开 运算 或者 闭 运算 
是 没有 效果 的 因为 在 第一 次 闭 开 
运算 填充 图像 中的 洞 洞后 再次 应用 相同 的 
滤波 不会 对 图像 产生 任何 变化 用 数学 的 
术语 讲 这些 运 算是 等 幂 的 使用 形态学 
滤波 对 图像 进行 边缘 及 角 点 检测 形态学 
滤波 可以 用于 检测 图像 中 指定 的 特征 一种 
比较 形象 的 方法 是 将 灰度 图像 看做 是 
等高线 比如 分水岭 图像 分割 算法 亮 的 区域 代表 
山峰 而 暗 的 区域 代表 山谷 图像 的 边沿 
就 对应 于 峭壁 如果 腐蚀 一幅 图像 会 导致 
山谷 被 扩展 而 峭壁 减少 了 相反 的 如果 
膨胀 一幅 图像 峭壁 则会 增加 但是 这 两种 情况 
下 中间 的 部分 大片 的 谷底 和 高原 基本 
保持 不变 在 上述 理解 的 基础 上 如果 我们 
对 图像 的 腐蚀 和 膨胀 的 结果 做 差 
就能 提取 图像 的 边界 因为 边界 区域 二者 完全 
不同 实际上 我们 也 可以 用 腐蚀 或者 膨胀 的 
结果 与 源 图像 做 差得 出 类似 结果 但 
提取 的 边界 会 比较 细 可以 看出 结构 元 
越大 边界 越粗/nr 在 OpenCV 中 将 形态学 操作 函数 
morphologyEx 的 第 4个 参数 设为 MORPH _ GRADIENT 就能 
完成 上述 工作 利用 形态学 操作 获取 角 点 稍微 
有 一些 复杂 它 试 用了 四种 不同 的 结构 
元素 基本 方法 是 对 一幅 图像 先 腐蚀 在 
膨胀 但是 这 两次 操作 使用 的 结构 元却/nr 不同 
这些 结构 元的/nr 选取 使得 直线 保持 不变 但是 由于 
他们 各自 作用 的 效果 角 点 处 的 边沿 
被 影响 了 我们 结合 一幅 图 来 说明 第 
一幅 图 是 原图 在被 十字形 元素 膨胀 后 方块 
的 边缘 被 扩张 而 由于 十字形 元素 没有 击中 
角 点 此处 不受影响 中间 的 方块 描述 了 这个 
结果 膨胀 后的/nr 图像 接着 被 菱形 元素 腐蚀 这次 
运算 将 大多数 的 边缘 恢复 到 原始 位置 但 
之前 没有 膨胀 过 的 角 点 被 向内 推动 
之后 得到 了 左边 的 方块 可以 看到 他 缺少 
明显 的 角 点 同样 的 处理 过程 通过 X 
形 与 方形 元素 得到 重复 这 两个 元素 结构 
是 先前 元素 的 旋转 版本 捕获 的 将 是 
45 ° 旋转 后的角/nr 点 最后 对 两次 过程 的 
结果 做 差值 提取 角 点 特征 代码 可以 参考 
参考 文献 3 . 形态学 滤波 之 图象处理 一般 腐蚀 
操 作对 二 值 图 进行 处理 腐蚀 操作 如 
下图 中心 位置 的 像素点 是否 与 周围 领域 的 
像素 点 颜色 一样 即 是否 是 白色 点 即 
值 是否 为 255 若 一致 则 保留 不 一致 
则 该点 变为 黑色 值 即为 0 opencv 中的 腐蚀 
操作 CVAPI void cvErode const CvArr * src CvArr * 
dst IplConvKernel * element CV _ DEFAULT NULL int iterations 
CV _ DEFAULT 1 前 两个 参数 比较 熟悉 第三个 
参数 是 用于 传递 模板 的 信息 默认 是 NULL 
即为 3 * 3 的 模板 第四个 参数 是 迭代 
的 次数 即 该 腐蚀 操作 做 几次 opencv 中的 
膨胀 操作 其实 就是 腐蚀 的 反 操作 CVAPI void 
cvDilate const CvArr * src CvArr * dst IplConvKernel * 
element CV _ DEFAULT NULL int iterations CV _ DEFAULT 
1 测试代码 # include stdafx . h # include cv 
. h # include highgui . h int main { 
IplImage * img = cvLoadImage C / fu . jpg 
/ / 读取 图片 cvNamedWindow Example1 CV _ WINDOW _ 
AUTOSIZE cvNamedWindow Example2 CV _ WINDOW _ AUTOSIZE cvNamedWindow Example3 
CV _ WINDOW _ AUTOSIZE cvShowImage Example1 img / / 
在 Example1 显示 图片 / / cvCopy img temp IplImage 
* temp = cvCreateImage / / 创建 一个 size 为 
image 三 通道 8位 的 彩色 图 cvGetSize img IPL 
_ DEPTH _ 8U 3 cvErode img temp 0 1 
/ / 腐蚀 cvShowImage Example2 temp cvDilate img temp 0 
1 / / 膨胀 cvShowImage Example3 temp cvWaitKey 0 / 
/ 暂停 用于 显示 图片 cvReleaseImage & img / / 
释放 img 所 指向 的 内存空间 并且 cvDestroyWindow Example1 cvDestroyWindow 
Example2 cvDestroyWindow Example3 return 0 } 以上 都是 在 模板 
3 * 3 的 情况 下 处理 的 要 是 
我们 期望 使用 自己 定义 的 模板 时候 就 需要 
自己 做 模板 CVAPI IplConvKernel * c v C r 
e a t e t r u c t u 
r i n g E l e m e n 
t E x int cols int rows int anchor _ 
x int anchor _ y int shape int * values 
CV _ DEFAULT NULL 前 两个 参数 是 定义 模板 
的 大小 后 两个 参数 是 参考点 的 坐标 比如 
默认 3 * 3 模板 的 参考点 坐标 是 2 
* 2 第五个 参数 是 模板 的 类型 可以 是 
矩形 十字形 椭圆形 甚至 是 用户 自己 定义 形状 最后 
一个 参数 是 在 使用 自 自定义 形状 的 时候 
通过 value 传递 模板 的 形状 模板 的 类型 CVAPI 
void c v R e l e a s e 
t r u c t u r i n g 
E l e m e n t IplConvKernel * * 
element / / 释放 模板 所 占用 的 内存 自定义 
5 * 5 参考点 3 3 的 矩形 模板 的 
测试代码 # include stdafx . h # include cv . 
h # include highgui . h int main { IplImage 
* img = cvLoadImage C / fu . jpg / 
/ 读取 图片 cvNamedWindow Example1 CV _ WINDOW _ AUTOSIZE 
cvNamedWindow Example2 CV _ WINDOW _ AUTOSIZE cvNamedWindow Example3 CV 
_ WINDOW _ AUTOSIZE cvShowImage Example1 img / / 在 
Example1 显示 图片 / / cvCopy img temp IplImage * 
temp = cvCreateImage / / 创建 一个 size 为 image 
三 通道 8位 的 彩色 图 cvGetSize img IPL _ 
DEPTH _ 8U 3 IplConvKernel * myModel myModel = c 
v C r e a t e t r u 
c t u r i n g E l e 
m e n t E x / / 自定义 5 
* 5 参考点 3 3 的 矩形 模板 5 5 
2 2 CV _ SHAPE _ RECT cvErode img temp 
myModel 1 cvShowImage Example2 temp cvDilate img temp myModel 1 
cvShowImage Example3 temp cvWaitKey 0 / / 暂停 用于 显示 
图片 c v R e l e a s e 
t r u c t u r i n g 
E l e m e n t & myModel cvReleaseImage 
& img / / 释放 img 所 指向 的 内存空间 
并且 cvDestroyWindow Example1 cvDestroyWindow Example2 cvDestroyWindow Example3 return 0 } 
效果图 形态学 滤波 之 信号处理 数学 形态学 的 方法 可以 
理解 为 一个 具有 一定 直径 的 小球 滚过 一段 
特定 的 路径 各种 信号 可以 看作 是 路径 上 
的 小坑 由于 所有 的 噪声 都有 个 共同 特征 
一一 高频 低峰 它们 构成 非常复杂 由 各种 混合 在 
眼 电信号 中的 其他 成份 或 眼球 快速 微小 空间 
大小 不 超过 1 的 运动 导致 这些 小坑 的 
径 长 明显 小于 小球 直径 因此 小球 球心 的 
滚动 轨迹 不 会受 噪声 的 干扰 一一 小球 球心 
滚动 轨迹 即 可以 看成 数学 形态学 处理 后的/nr 信号 
本 系统 中 用到 的 数学 形态学 算子 包括 腐蚀 
运算 膨胀 运算 开 操作 闭 操作 腐蚀 的 最简单 
的 应用 是从 图中 消除 不 相关 的 细节 而 
膨胀 的 最简单 的 应用 是 将 裂缝 桥 接起来 
开运 算是 先 腐蚀 再膨胀 开 运算 一般 断开 狭窄 
的 间断 和 消除 细 的 突出 物 而 闭 
操作 通常 消弥 狭窄 的 间断 和长细/nr 的 鸿沟 消除 
小 的 孔洞 并 填充 轮廓线 中的 断裂 开 运算 
与 闭 运算 的 结合 使用 能使 作用 对象 的 
轮廓 变得 光滑 # include stdio . h # include 
fcntl . h / / # include sys / types 
. h / / # include sys / stats . 
h # include time . h # define N 5 
/ / 结构 元素 大小 设置 根据 滤除 波形 一个 
周期 中 点个 数来 定 例如 采样率 250 滤除 50hz 
/ / 因为 50hz 一个 周期 中有 5个 点 所以 
N 设为 5 float x 3 * N + 2 
= { 0.0 } void openoperate float input float dilation 
/ / 开 运算 先 腐蚀 再膨胀 { int i 
k t float tmp t = 2 * N + 
3 float erosion 2 * N + 3 for k 
= 0 k t k + + { tmp = 
input k for i = k + 1 i k 
+ N i + + { if tmp input i 
tmp = input i } erosion k = tmp } 
t = t 3 for k = 0 k t 
k + + { tmp = erosion k for i 
= k + 1 i k + N i + 
+ { if tmp erosion i tmp = erosion i 
} dilation k = tmp } } float closeoperate float 
input / / 闭 运算 先 膨胀 再 腐蚀 { 
int i k t float tmp t = N * 
2 1 float dilation N for k = 0 k 
N k + + { tmp = input k for 
i = k + 1 i k + N i 
+ + { if tmp input i tmp = input 
i } dilation k = tmp } tmp = dilation 
0 for k = 1 k N k + + 
{ if tmp dilation k tmp = dilation k } 
return tmp } int main { clock _ t start 
end double duration FILE * fd * m _ fd 
float buffer float filter _ data float openresult 2 * 
N 1 m _ fd = fopen D / data 
. txt r + if m _ fd = = 
NULL { perror open error return 1 } fd = 
fopen D / data1 . txt w + if fd 
= = NULL { perror open error return 1 } 
start = clock while fscanf m _ fd % f 
& buffer = EOF { x 3 * N + 
1 = buffer openoperate x openresult filter _ data = 
closeoperate openresult fprintf fd % f filter _ data for 
int y = 0 y 3 * N + 1 
y + + x y = x y + 1 
} end = clock duration = double end start / 
CLOCKS _ PER _ SEC printf % f seconds \ 
n duration fclose fd fclose m _ fd return 0 
} 结果 如下 图 所示 对 有 干扰 原始 眼 
电 数据 进行 形态学 滤波 处理 其中 结构 元素 17个 
窗 宽 5 . 有图/nr 可以 看到 形态学 对于 尖峰 
的 滤波 效果 特别 明显 图二 将 形态学 滤波 算法 
加入 Qt 中 对眼 电 进行 实时 滤波 处理 效果 
如图 引 这 部分 内容 主要 来自 参考文献 2 总结 
以前 认为 形态学 滤波 只在 图像 处理 中 有所 应用 
现在 看 了 参考 文献 2 才 发觉 自己 实在 
有点 固步自封 对 知识 的 来龙去脉 掌握 的 不够 清楚 
一言以蔽之 囫囵吞枣 并不 清楚 思考 方向 而 只 掌握 具体 
的 技巧 细节 不 注重 顶层 设计 所以 才会 有此 
感慨 在 进行 数据 处理 中 常常 用到 的 滤波 
方法 有 中值 滤波 均值 滤波 FIR IIR 卡尔曼滤波 自适应 
滤波 等 而 很多 知识 都是 相符 相通 的 切不可 
死 学 死记 参考文献 1 . http / / blog 
. csdn . net / thefutureisour / article / details 
/ 75748192 . http / / m . blog . 
csdn . net / blog / gylltq / 337993473 . 
OpenCV 2 计算机 视觉 编程 手册 2015 11 28 学习 
笔记 张朋 艺 计算机 视觉 形态学 滤波 标签 空格 分隔 图像处理 信号处理 版权 
声明 本文 为 博主 原创 文章 转载 请 注明 出处 
http / / blog . csdn . net / lg1259156776 
/ 说明 本文 主要 想 弄清楚 形态学 滤波 在 图象处理 
和 信号 处理 中 的 应用 图像 处理 中 非常 
直观 的 通过 腐蚀 膨胀 获得 开闭 运算 的 效果 
而在 数据 实时 滤波 中 形态学 滤波 也 是 可以 
使用 的 形态学 滤波 基本知识 原理 在 特殊 领域 运算 
形式 结构 元素 Sturcture Element 在 每个 像素 位置 上 
与 二 值 图像 对应 的 区域 进行 特定 的 
逻辑运算 运算 结构 是 输出 图像 的 相应 像素 运算 
效果 取决于 结构 元素 大小 内容 以及 逻辑运算 性质 膨胀 
腐蚀 开 闭 运算 是 数学 形态学 最 基本 的 
变换 结构 元素 简单 地 定义 为 像素 的 结构 
形状 以及 一个 原点 又 称为 锚 点 使用 形态学 
滤波 涉及 对 图像 的 每个 像素 应用 这个 结构 
元素 当 结构 元素 的 原点 与 给定 的 像素 
对齐 时 它 与 图像 相交 部分 定义 了 一组 
进行 形态学 运算 的 像素 原则上 结构 元素 可以 是 
任何 形状 但 通常 使用 简单 的 形状 比如 方形 
圆形 和 菱形 而 原点 位于 中心 位置 基于 效率 
的 考虑 腐蚀 和 膨胀 两个 滤波 操作 也 运算 
在 每个 像素 周围 像素 集 合上 邻域 这 是由 
结构 元素 定义 的 当 应用 到 一个 给定 的 
像素 时 结构 元素 的 锚 点 与 该 像素 
的 位置 对齐 而 所有 与 他 相交 的 像素 
都被 包括 在 当前 像素 集合 中 腐蚀 替换 当前 
像素 为 像素 集合 中 找到 的 最小 的 像素 
值 而 膨胀 则 替换 为 像素 集合 中 找到 
的 最大 像素 值 当然 对于 二 值 图像 每个 
像素 只能 被 替换 为 白色 像素 或 黑色 像素 
这 一段 的 论述 可以 参考 Opencv 计算机 视觉 编程 
手册 对于 腐蚀 和 膨胀 的 差别 可以 通过 想象 
腐蚀 呢 如果 给定 像素 的 结构 元素 触碰 到 
背景 那么 该 像素 被 设置 为 背景 而在 膨胀 
的 情况 下 如果 触碰 到 前景 该 像素 被 
设置 为 前景 所以 很 明显 腐蚀 操作 后 物体 
的 尺寸 会 减小 而 膨胀 操作 后 物体 的 
尺寸 会 增大 同时 内部 的 一些 洞 被 填满 
事实上 腐蚀 一副 图像 两次 就 像是 让 结构 元素 
对 自己 进行 膨胀 后 再去 腐蚀 同 一幅 图像 
反过来 对 膨胀 也是 合适 的 有 下面 两种 说法 
对 图像 的 腐蚀 操作 等于 对 图像 负片 的 
膨胀 操作 的 负片 对 图像 的 膨胀 操作 等于 
对 图像 负片 的 腐蚀 操作 的 负片 实际上 说 
的 是 对 目标 进行 的 腐蚀 等效于 对 背景 
进行 的 膨胀 反之亦然 腐蚀 的 最简单 的 应用 是从 
图中 消除 不 相关 的 细节 而 膨胀 的 最简单 
的 应用 是 将 裂缝 桥 接起来 开运 算是 先 
腐蚀 再膨胀 开 运算 一般 断开 狭窄 的 间断 和 
消除 细 的 突出 物 而 闭 操作 通常 消弥 
狭窄 的 间断 和长细/nr 的 鸿沟 消除 小 的 孔洞 
并 填充 轮廓线 中的 断裂 开 运算 与 闭 运算 
的 结合 使用 能使 作用 对象 的 轮廓 变得 光滑 
开运 算是 先 腐蚀 再膨胀 而 闭 运 算是 先 
膨胀 再 腐蚀 在 检验 闭 滤波器 的 结果 时 
可以 看到 白色 前景 物体 中的 小洞 被 填充 该 
滤波器 同时 连接 多 个 相邻 物体 基本上 无法 完全 
包含结构 元素 的 洞洞 或者 缝隙 都 将被 滤波器 移除 
反过来 开 滤波器 则是 移 除掉 场景 中 比较 小 
的 物体 因为 它 门 无法 完全 包含结构 元素 这些 
滤波器 通常 在 物体 检测 中 应用 闭 滤波器 将 
误 分割为 碎片 的 物体 重新 连接起来 而 开 滤波器 
则 去 除掉 图像 噪声 点 引起 的 小 像素 
块 Blob 因此 在 视频 序列 中 使用 他们 很有帮助 
如果 测试 的 二 值 图像 相继 使用 闭 开 
操作 获得 图像 将 只显示 场景 中 的 主要 物体 
如果 优先 处理 噪点 也 可以 先 进行 开 运算 
再 进行 闭 运算 但是 有 可能 去 除掉 一些 
分散 的 物体 需要 注意 的 是 对于 对于 一幅 
图像 多次 使用 相同 的 开 运算 或者 闭 运算 
是 没有 效果 的 因为 在 第一 次 闭 开 
运算 填充 图像 中的 洞 洞后 再次 应用 相同 的 
滤波 不会 对 图像 产生 任何 变化 用 数学 的 
术语 讲 这些 运 算是 等 幂 的 使用 形态学 
滤波 对 图像 进行 边缘 及 角 点 检测 形态学 
滤波 可以 用于 检测 图像 中 指定 的 特征 一种 
比较 形象 的 方法 是 将 灰度 图像 看做 是 
等高线 比如 分水岭 图像 分割 算法 亮 的 区域 代表 
山峰 而 暗 的 区域 代表 山谷 图像 的 边沿 
就 对应 于 峭壁 如果 腐蚀 一幅 图像 会 导致 
山谷 被 扩展 而 峭壁 减少 了 相反 的 如果 
膨胀 一幅 图像 峭壁 则会 增加 但是 这 两种 情况 
下 中间 的 部分 大片 的 谷底 和 高原 基本 
保持 不变 在 上述 理解 的 基础 上 如果 我们 
对 图像 的 腐蚀 和 膨胀 的 结果 做 差 
就能 提取 图像 的 边界 因为 边界 区域 二者 完全 
不同 实际上 我们 也 可以 用 腐蚀 或者 膨胀 的 
结果 与 源 图像 做 差得 出 类似 结果 但 
提取 的 边界 会 比较 细 可以 看出 结构 元 
越大 边界 越粗/nr 在 OpenCV 中 将 形态学 操作 函数 
morphologyEx 的 第 4个 参数 设为 MORPH _ GRADIENT 就能 
完成 上述 工作 利用 形态学 操作 获取 角 点 稍微 
有 一些 复杂 它 试 用了 四种 不同 的 结构 
元素 基本 方法 是 对 一幅 图像 先 腐蚀 在 
膨胀 但是 这 两次 操作 使用 的 结构 元却/nr 不同 
这些 结构 元的/nr 选取 使得 直线 保持 不变 但是 由于 
他们 各自 作用 的 效果 角 点 处 的 边沿 
被 影响 了 我们 结合 一幅 图 来 说明 第 
一幅 图 是 原图 在被 十字形 元素 膨胀 后 方块 
的 边缘 被 扩张 而 由于 十字形 元素 没有 击中 
角 点 此处 不受影响 中间 的 方块 描述 了 这个 
结果 膨胀 后的/nr 图像 接着 被 菱形 元素 腐蚀 这次 
运算 将 大多数 的 边缘 恢复 到 原始 位置 但 
之前 没有 膨胀 过 的 角 点 被 向内 推动 
之后 得到 了 左边 的 方块 可以 看到 他 缺少 
明显 的 角 点 同样 的 处理 过程 通过 X 
形 与 方形 元素 得到 重复 这 两个 元素 结构 
是 先前 元素 的 旋转 版本 捕获 的 将 是 
45 ° 旋转 后的角/nr 点 最后 对 两次 过程 的 
结果 做 差值 提取 角 点 特征 代码 可以 参考 
参考 文献 3 . 形态学 滤波 之 图象处理 一般 腐蚀 
操 作对 二 值 图 进行 处理 腐蚀 操作 如 
下图 中心 位置 的 像素点 是否 与 周围 领域 的 
像素 点 颜色 一样 即 是否 是 白色 点 即 
值 是否 为 255 若 一致 则 保留 不 一致 
则 该点 变为 黑色 值 即为 0 opencv 中的 腐蚀 
操作 CVAPI void cvErode const CvArr * src CvArr * 
dst IplConvKernel * element CV _ DEFAULT NULL int iterations 
CV _ DEFAULT 1 前 两个 参数 比较 熟悉 第三个 
参数 是 用于 传递 模板 的 信息 默认 是 NULL 
即为 3 * 3 的 模板 第四个 参数 是 迭代 
的 次数 即 该 腐蚀 操作 做 几次 opencv 中的 
膨胀 操作 其实 就是 腐蚀 的 反 操作 CVAPI void 
cvDilate const CvArr * src CvArr * dst IplConvKernel * 
element CV _ DEFAULT NULL int iterations CV _ DEFAULT 
1 测试代码 # include stdafx . h # include cv 
. h # include highgui . h int main { 
IplImage * img = cvLoadImage C / fu . jpg 
/ / 读取 图片 cvNamedWindow Example1 CV _ WINDOW _ 
AUTOSIZE cvNamedWindow Example2 CV _ WINDOW _ AUTOSIZE cvNamedWindow Example3 
CV _ WINDOW _ AUTOSIZE cvShowImage Example1 img / / 
在 Example1 显示 图片 / / cvCopy img temp IplImage 
* temp = cvCreateImage / / 创建 一个 size 为 
image 三 通道 8位 的 彩色 图 cvGetSize img IPL 
_ DEPTH _ 8U 3 cvErode img temp 0 1 
/ / 腐蚀 cvShowImage Example2 temp cvDilate img temp 0 
1 / / 膨胀 cvShowImage Example3 temp cvWaitKey 0 / 
/ 暂停 用于 显示 图片 cvReleaseImage & img / / 
释放 img 所 指向 的 内存空间 并且 cvDestroyWindow Example1 cvDestroyWindow 
Example2 cvDestroyWindow Example3 return 0 } 以上 都是 在 模板 
3 * 3 的 情况 下 处理 的 要 是 
我们 期望 使用 自己 定义 的 模板 时候 就 需要 
自己 做 模板 CVAPI IplConvKernel * c v C r 
e a t e t r u c t u 
r i n g E l e m e n 
t E x int cols int rows int anchor _ 
x int anchor _ y int shape int * values 
CV _ DEFAULT NULL 前 两个 参数 是 定义 模板 
的 大小 后 两个 参数 是 参考点 的 坐标 比如 
默认 3 * 3 模板 的 参考点 坐标 是 2 
* 2 第五个 参数 是 模板 的 类型 可以 是 
矩形 十字形 椭圆形 甚至 是 用户 自己 定义 形状 最后 
一个 参数 是 在 使用 自 自定义 形状 的 时候 
通过 value 传递 模板 的 形状 模板 的 类型 CVAPI 
void c v R e l e a s e 
t r u c t u r i n g 
E l e m e n t IplConvKernel * * 
element / / 释放 模板 所 占用 的 内存 自定义 
5 * 5 参考点 3 3 的 矩形 模板 的 
测试代码 # include stdafx . h # include cv . 
h # include highgui . h int main { IplImage 
* img = cvLoadImage C / fu . jpg / 
/ 读取 图片 cvNamedWindow Example1 CV _ WINDOW _ AUTOSIZE 
cvNamedWindow Example2 CV _ WINDOW _ AUTOSIZE cvNamedWindow Example3 CV 
_ WINDOW _ AUTOSIZE cvShowImage Example1 img / / 在 
Example1 显示 图片 / / cvCopy img temp IplImage * 
temp = cvCreateImage / / 创建 一个 size 为 image 
三 通道 8位 的 彩色 图 cvGetSize img IPL _ 
DEPTH _ 8U 3 IplConvKernel * myModel myModel = c 
v C r e a t e t r u 
c t u r i n g E l e 
m e n t E x / / 自定义 5 
* 5 参考点 3 3 的 矩形 模板 5 5 
2 2 CV _ SHAPE _ RECT cvErode img temp 
myModel 1 cvShowImage Example2 temp cvDilate img temp myModel 1 
cvShowImage Example3 temp cvWaitKey 0 / / 暂停 用于 显示 
图片 c v R e l e a s e 
t r u c t u r i n g 
E l e m e n t & myModel cvReleaseImage 
& img / / 释放 img 所 指向 的 内存空间 
并且 cvDestroyWindow Example1 cvDestroyWindow Example2 cvDestroyWindow Example3 return 0 } 
效果图 形态学 滤波 之 信号处理 数学 形态学 的 方法 可以 
理解 为 一个 具有 一定 直径 的 小球 滚过 一段 
特定 的 路径 各种 信号 可以 看作 是 路径 上 
的 小坑 由于 所有 的 噪声 都有 个 共同 特征 
一一 高频 低峰 它们 构成 非常复杂 由 各种 混合 在 
眼 电信号 中的 其他 成份 或 眼球 快速 微小 空间 
大小 不 超过 1 的 运动 导致 这些 小坑 的 
径 长 明显 小于 小球 直径 因此 小球 球心 的 
滚动 轨迹 不 会受 噪声 的 干扰 一一 小球 球心 
滚动 轨迹 即 可以 看成 数学 形态学 处理 后的/nr 信号 
本 系统 中 用到 的 数学 形态学 算子 包括 腐蚀 
运算 膨胀 运算 开 操作 闭 操作 腐蚀 的 最简单 
的 应用 是从 图中 消除 不 相关 的 细节 而 
膨胀 的 最简单 的 应用 是 将 裂缝 桥 接起来 
开运 算是 先 腐蚀 再膨胀 开 运算 一般 断开 狭窄 
的 间断 和 消除 细 的 突出 物 而 闭 
操作 通常 消弥 狭窄 的 间断 和长细/nr 的 鸿沟 消除 
小 的 孔洞 并 填充 轮廓线 中的 断裂 开 运算 
与 闭 运算 的 结合 使用 能使 作用 对象 的 
轮廓 变得 光滑 # include stdio . h # include 
fcntl . h / / # include sys / types 
. h / / # include sys / stats . 
h # include time . h # define N 5 
/ / 结构 元素 大小 设置 根据 滤除 波形 一个 
周期 中 点个 数来 定 例如 采样率 250 滤除 50hz 
/ / 因为 50hz 一个 周期 中有 5个 点 所以 
N 设为 5 float x 3 * N + 2 
= { 0.0 } void openoperate float input float dilation 
/ / 开 运算 先 腐蚀 再膨胀 { int i 
k t float tmp t = 2 * N + 
3 float erosion 2 * N + 3 for k 
= 0 k t k + + { tmp = 
input k for i = k + 1 i k 
+ N i + + { if tmp input i 
tmp = input i } erosion k = tmp } 
t = t 3 for k = 0 k t 
k + + { tmp = erosion k for i 
= k + 1 i k + N i + 
+ { if tmp erosion i tmp = erosion i 
} dilation k = tmp } } float closeoperate float 
input / / 闭 运算 先 膨胀 再 腐蚀 { 
int i k t float tmp t = N * 
2 1 float dilation N for k = 0 k 
N k + + { tmp = input k for 
i = k + 1 i k + N i 
+ + { if tmp input i tmp = input 
i } dilation k = tmp } tmp = dilation 
0 for k = 1 k N k + + 
{ if tmp dilation k tmp = dilation k } 
return tmp } int main { clock _ t start 
end double duration FILE * fd * m _ fd 
float buffer float filter _ data float openresult 2 * 
N 1 m _ fd = fopen D / data 
. txt r + if m _ fd = = 
NULL { perror open error return 1 } fd = 
fopen D / data1 . txt w + if fd 
= = NULL { perror open error return 1 } 
start = clock while fscanf m _ fd % f 
& buffer = EOF { x 3 * N + 
1 = buffer openoperate x openresult filter _ data = 
closeoperate openresult fprintf fd % f filter _ data for 
int y = 0 y 3 * N + 1 
y + + x y = x y + 1 
} end = clock duration = double end start / 
CLOCKS _ PER _ SEC printf % f seconds \ 
n duration fclose fd fclose m _ fd return 0 
} 结果 如下 图 所示 对 有 干扰 原始 眼 
电 数据 进行 形态学 滤波 处理 其中 结构 元素 17个 
窗 宽 5 . 有图/nr 可以 看到 形态学 对于 尖峰 
的 滤波 效果 特别 明显 图二 将 形态学 滤波 算法 
加入 Qt 中 对眼 电 进行 实时 滤波 处理 效果 
如图 引 这 部分 内容 主要 来自 参考文献 2 总结 
以前 认为 形态学 滤波 只在 图像 处理 中 有所 应用 
现在 看 了 参考 文献 2 才 发觉 自己 实在 
有点 固步自封 对 知识 的 来龙去脉 掌握 的 不够 清楚 
一言以蔽之 囫囵吞枣 并不 清楚 思考 方向 而 只 掌握 具体 
的 技巧 细节 不 注重 顶层 设计 所以 才会 有此 
感慨 在 进行 数据 处理 中 常常 用到 的 滤波 
方法 有 中值 滤波 均值 滤波 FIR IIR 卡尔曼滤波 自适应 
滤波 等 而 很多 知识 都是 相符 相通 的 切不可 
死 学 死记 参考文献 1 . http / / blog 
. csdn . net / thefutureisour / article / details 
/ 75748192 . http / / m . blog . 
csdn . net / blog / gylltq / 337993473 . 
OpenCV 2 计算机 视觉 编程 手册 2015 11 28 学习 
笔记 张朋 艺 计算机 视觉 形态学 滤波 标签 空格 分隔 图像处理 信号处理 版权 
声明 本文 为 博主 原创 文章 转载 请 注明 出处 
http / / blog . csdn . net / lg1259156776 
/ 说明 本文 主要 想 弄清楚 形态学 滤波 在 图象处理 
和 信号 处理 中 的 应用 图像 处理 中 非常 
直观 的 通过 腐蚀 膨胀 获得 开闭 运算 的 效果 
而在 数据 实时 滤波 中 形态学 滤波 也 是 可以 
使用 的 形态学 滤波 基本知识 原理 在 特殊 领域 运算 
形式 结构 元素 Sturcture Element 在 每个 像素 位置 上 
与 二 值 图像 对应 的 区域 进行 特定 的 
逻辑运算 运算 结构 是 输出 图像 的 相应 像素 运算 
效果 取决于 结构 元素 大小 内容 以及 逻辑运算 性质 膨胀 
腐蚀 开 闭 运算 是 数学 形态学 最 基本 的 
变换 结构 元素 简单 地 定义 为 像素 的 结构 
形状 以及 一个 原点 又 称为 锚 点 使用 形态学 
滤波 涉及 对 图像 的 每个 像素 应用 这个 结构 
元素 当 结构 元素 的 原点 与 给定 的 像素 
对齐 时 它 与 图像 相交 部分 定义 了 一组 
进行 形态学 运算 的 像素 原则上 结构 元素 可以 是 
任何 形状 但 通常 使用 简单 的 形状 比如 方形 
圆形 和 菱形 而 原点 位于 中心 位置 基于 效率 
的 考虑 腐蚀 和 膨胀 两个 滤波 操作 也 运算 
在 每个 像素 周围 像素 集 合上 邻域 这 是由 
结构 元素 定义 的 当 应用 到 一个 给定 的 
像素 时 结构 元素 的 锚 点 与 该 像素 
的 位置 对齐 而 所有 与 他 相交 的 像素 
都被 包括 在 当前 像素 集合 中 腐蚀 替换 当前 
像素 为 像素 集合 中 找到 的 最小 的 像素 
值 而 膨胀 则 替换 为 像素 集合 中 找到 
的 最大 像素 值 当然 对于 二 值 图像 每个 
像素 只能 被 替换 为 白色 像素 或 黑色 像素 
这 一段 的 论述 可以 参考 Opencv 计算机 视觉 编程 
手册 对于 腐蚀 和 膨胀 的 差别 可以 通过 想象 
腐蚀 呢 如果 给定 像素 的 结构 元素 触碰 到 
背景 那么 该 像素 被 设置 为 背景 而在 膨胀 
的 情况 下 如果 触碰 到 前景 该 像素 被 
设置 为 前景 所以 很 明显 腐蚀 操作 后 物体 
的 尺寸 会 减小 而 膨胀 操作 后 物体 的 
尺寸 会 增大 同时 内部 的 一些 洞 被 填满 
事实上 腐蚀 一副 图像 两次 就 像是 让 结构 元素 
对 自己 进行 膨胀 后 再去 腐蚀 同 一幅 图像 
反过来 对 膨胀 也是 合适 的 有 下面 两种 说法 
对 图像 的 腐蚀 操作 等于 对 图像 负片 的 
膨胀 操作 的 负片 对 图像 的 膨胀 操作 等于 
对 图像 负片 的 腐蚀 操作 的 负片 实际上 说 
的 是 对 目标 进行 的 腐蚀 等效于 对 背景 
进行 的 膨胀 反之亦然 腐蚀 的 最简单 的 应用 是从 
图中 消除 不 相关 的 细节 而 膨胀 的 最简单 
的 应用 是 将 裂缝 桥 接起来 开运 算是 先 
腐蚀 再膨胀 开 运算 一般 断开 狭窄 的 间断 和 
消除 细 的 突出 物 而 闭 操作 通常 消弥 
狭窄 的 间断 和长细/nr 的 鸿沟 消除 小 的 孔洞 
并 填充 轮廓线 中的 断裂 开 运算 与 闭 运算 
的 结合 使用 能使 作用 对象 的 轮廓 变得 光滑 
开运 算是 先 腐蚀 再膨胀 而 闭 运 算是 先 
膨胀 再 腐蚀 在 检验 闭 滤波器 的 结果 时 
可以 看到 白色 前景 物体 中的 小洞 被 填充 该 
滤波器 同时 连接 多 个 相邻 物体 基本上 无法 完全 
包含结构 元素 的 洞洞 或者 缝隙 都 将被 滤波器 移除 
反过来 开 滤波器 则是 移 除掉 场景 中 比较 小 
的 物体 因为 它 门 无法 完全 包含结构 元素 这些 
滤波器 通常 在 物体 检测 中 应用 闭 滤波器 将 
误 分割为 碎片 的 物体 重新 连接起来 而 开 滤波器 
则 去 除掉 图像 噪声 点 引起 的 小 像素 
块 Blob 因此 在 视频 序列 中 使用 他们 很有帮助 
如果 测试 的 二 值 图像 相继 使用 闭 开 
操作 获得 图像 将 只显示 场景 中 的 主要 物体 
如果 优先 处理 噪点 也 可以 先 进行 开 运算 
再 进行 闭 运算 但是 有 可能 去 除掉 一些 
分散 的 物体 需要 注意 的 是 对于 对于 一幅 
图像 多次 使用 相同 的 开 运算 或者 闭 运算 
是 没有 效果 的 因为 在 第一 次 闭 开 
运算 填充 图像 中的 洞 洞后 再次 应用 相同 的 
滤波 不会 对 图像 产生 任何 变化 用 数学 的 
术语 讲 这些 运 算是 等 幂 的 使用 形态学 
滤波 对 图像 进行 边缘 及 角 点 检测 形态学 
滤波 可以 用于 检测 图像 中 指定 的 特征 一种 
比较 形象 的 方法 是 将 灰度 图像 看做 是 
等高线 比如 分水岭 图像 分割 算法 亮 的 区域 代表 
山峰 而 暗 的 区域 代表 山谷 图像 的 边沿 
就 对应 于 峭壁 如果 腐蚀 一幅 图像 会 导致 
山谷 被 扩展 而 峭壁 减少 了 相反 的 如果 
膨胀 一幅 图像 峭壁 则会 增加 但是 这 两种 情况 
下 中间 的 部分 大片 的 谷底 和 高原 基本 
保持 不变 在 上述 理解 的 基础 上 如果 我们 
对 图像 的 腐蚀 和 膨胀 的 结果 做 差 
就能 提取 图像 的 边界 因为 边界 区域 二者 完全 
不同 实际上 我们 也 可以 用 腐蚀 或者 膨胀 的 
结果 与 源 图像 做 差得 出 类似 结果 但 
提取 的 边界 会 比较 细 可以 看出 结构 元 
越大 边界 越粗/nr 在 OpenCV 中 将 形态学 操作 函数 
morphologyEx 的 第 4个 参数 设为 MORPH _ GRADIENT 就能 
完成 上述 工作 利用 形态学 操作 获取 角 点 稍微 
有 一些 复杂 它 试 用了 四种 不同 的 结构 
元素 基本 方法 是 对 一幅 图像 先 腐蚀 在 
膨胀 但是 这 两次 操作 使用 的 结构 元却/nr 不同 
这些 结构 元的/nr 选取 使得 直线 保持 不变 但是 由于 
他们 各自 作用 的 效果 角 点 处 的 边沿 
被 影响 了 我们 结合 一幅 图 来 说明 第 
一幅 图 是 原图 在被 十字形 元素 膨胀 后 方块 
的 边缘 被 扩张 而 由于 十字形 元素 没有 击中 
角 点 此处 不受影响 中间 的 方块 描述 了 这个 
结果 膨胀 后的/nr 图像 接着 被 菱形 元素 腐蚀 这次 
运算 将 大多数 的 边缘 恢复 到 原始 位置 但 
之前 没有 膨胀 过 的 角 点 被 向内 推动 
之后 得到 了 左边 的 方块 可以 看到 他 缺少 
明显 的 角 点 同样 的 处理 过程 通过 X 
形 与 方形 元素 得到 重复 这 两个 元素 结构 
是 先前 元素 的 旋转 版本 捕获 的 将 是 
45 ° 旋转 后的角/nr 点 最后 对 两次 过程 的 
结果 做 差值 提取 角 点 特征 代码 可以 参考 
参考 文献 3 . 形态学 滤波 之 图象处理 一般 腐蚀 
操 作对 二 值 图 进行 处理 腐蚀 操作 如 
下图 中心 位置 的 像素点 是否 与 周围 领域 的 
像素 点 颜色 一样 即 是否 是 白色 点 即 
值 是否 为 255 若 一致 则 保留 不 一致 
则 该点 变为 黑色 值 即为 0 opencv 中的 腐蚀 
操作 CVAPI void cvErode const CvArr * src CvArr * 
dst IplConvKernel * element CV _ DEFAULT NULL int iterations 
CV _ DEFAULT 1 前 两个 参数 比较 熟悉 第三个 
参数 是 用于 传递 模板 的 信息 默认 是 NULL 
即为 3 * 3 的 模板 第四个 参数 是 迭代 
的 次数 即 该 腐蚀 操作 做 几次 opencv 中的 
膨胀 操作 其实 就是 腐蚀 的 反 操作 CVAPI void 
cvDilate const CvArr * src CvArr * dst IplConvKernel * 
element CV _ DEFAULT NULL int iterations CV _ DEFAULT 
1 测试代码 # include stdafx . h # include cv 
. h # include highgui . h int main { 
IplImage * img = cvLoadImage C / fu . jpg 
/ / 读取 图片 cvNamedWindow Example1 CV _ WINDOW _ 
AUTOSIZE cvNamedWindow Example2 CV _ WINDOW _ AUTOSIZE cvNamedWindow Example3 
CV _ WINDOW _ AUTOSIZE cvShowImage Example1 img / / 
在 Example1 显示 图片 / / cvCopy img temp IplImage 
* temp = cvCreateImage / / 创建 一个 size 为 
image 三 通道 8位 的 彩色 图 cvGetSize img IPL 
_ DEPTH _ 8U 3 cvErode img temp 0 1 
/ / 腐蚀 cvShowImage Example2 temp cvDilate img temp 0 
1 / / 膨胀 cvShowImage Example3 temp cvWaitKey 0 / 
/ 暂停 用于 显示 图片 cvReleaseImage & img / / 
释放 img 所 指向 的 内存空间 并且 cvDestroyWindow Example1 cvDestroyWindow 
Example2 cvDestroyWindow Example3 return 0 } 以上 都是 在 模板 
3 * 3 的 情况 下 处理 的 要 是 
我们 期望 使用 自己 定义 的 模板 时候 就 需要 
自己 做 模板 CVAPI IplConvKernel * c v C r 
e a t e t r u c t u 
r i n g E l e m e n 
t E x int cols int rows int anchor _ 
x int anchor _ y int shape int * values 
CV _ DEFAULT NULL 前 两个 参数 是 定义 模板 
的 大小 后 两个 参数 是 参考点 的 坐标 比如 
默认 3 * 3 模板 的 参考点 坐标 是 2 
* 2 第五个 参数 是 模板 的 类型 可以 是 
矩形 十字形 椭圆形 甚至 是 用户 自己 定义 形状 最后 
一个 参数 是 在 使用 自 自定义 形状 的 时候 
通过 value 传递 模板 的 形状 模板 的 类型 CVAPI 
void c v R e l e a s e 
t r u c t u r i n g 
E l e m e n t IplConvKernel * * 
element / / 释放 模板 所 占用 的 内存 自定义 
5 * 5 参考点 3 3 的 矩形 模板 的 
测试代码 # include stdafx . h # include cv . 
h # include highgui . h int main { IplImage 
* img = cvLoadImage C / fu . jpg / 
/ 读取 图片 cvNamedWindow Example1 CV _ WINDOW _ AUTOSIZE 
cvNamedWindow Example2 CV _ WINDOW _ AUTOSIZE cvNamedWindow Example3 CV 
_ WINDOW _ AUTOSIZE cvShowImage Example1 img / / 在 
Example1 显示 图片 / / cvCopy img temp IplImage * 
temp = cvCreateImage / / 创建 一个 size 为 image 
三 通道 8位 的 彩色 图 cvGetSize img IPL _ 
DEPTH _ 8U 3 IplConvKernel * myModel myModel = c 
v C r e a t e t r u 
c t u r i n g E l e 
m e n t E x / / 自定义 5 
* 5 参考点 3 3 的 矩形 模板 5 5 
2 2 CV _ SHAPE _ RECT cvErode img temp 
myModel 1 cvShowImage Example2 temp cvDilate img temp myModel 1 
cvShowImage Example3 temp cvWaitKey 0 / / 暂停 用于 显示 
图片 c v R e l e a s e 
t r u c t u r i n g 
E l e m e n t & myModel cvReleaseImage 
& img / / 释放 img 所 指向 的 内存空间 
并且 cvDestroyWindow Example1 cvDestroyWindow Example2 cvDestroyWindow Example3 return 0 } 
效果图 形态学 滤波 之 信号处理 数学 形态学 的 方法 可以 
理解 为 一个 具有 一定 直径 的 小球 滚过 一段 
特定 的 路径 各种 信号 可以 看作 是 路径 上 
的 小坑 由于 所有 的 噪声 都有 个 共同 特征 
一一 高频 低峰 它们 构成 非常复杂 由 各种 混合 在 
眼 电信号 中的 其他 成份 或 眼球 快速 微小 空间 
大小 不 超过 1 的 运动 导致 这些 小坑 的 
径 长 明显 小于 小球 直径 因此 小球 球心 的 
滚动 轨迹 不 会受 噪声 的 干扰 一一 小球 球心 
滚动 轨迹 即 可以 看成 数学 形态学 处理 后的/nr 信号 
本 系统 中 用到 的 数学 形态学 算子 包括 腐蚀 
运算 膨胀 运算 开 操作 闭 操作 腐蚀 的 最简单 
的 应用 是从 图中 消除 不 相关 的 细节 而 
膨胀 的 最简单 的 应用 是 将 裂缝 桥 接起来 
开运 算是 先 腐蚀 再膨胀 开 运算 一般 断开 狭窄 
的 间断 和 消除 细 的 突出 物 而 闭 
操作 通常 消弥 狭窄 的 间断 和长细/nr 的 鸿沟 消除 
小 的 孔洞 并 填充 轮廓线 中的 断裂 开 运算 
与 闭 运算 的 结合 使用 能使 作用 对象 的 
轮廓 变得 光滑 # include stdio . h # include 
fcntl . h / / # include sys / types 
. h / / # include sys / stats . 
h # include time . h # define N 5 
/ / 结构 元素 大小 设置 根据 滤除 波形 一个 
周期 中 点个 数来 定 例如 采样率 250 滤除 50hz 
/ / 因为 50hz 一个 周期 中有 5个 点 所以 
N 设为 5 float x 3 * N + 2 
= { 0.0 } void openoperate float input float dilation 
/ / 开 运算 先 腐蚀 再膨胀 { int i 
k t float tmp t = 2 * N + 
3 float erosion 2 * N + 3 for k 
= 0 k t k + + { tmp = 
input k for i = k + 1 i k 
+ N i + + { if tmp input i 
tmp = input i } erosion k = tmp } 
t = t 3 for k = 0 k t 
k + + { tmp = erosion k for i 
= k + 1 i k + N i + 
+ { if tmp erosion i tmp = erosion i 
} dilation k = tmp } } float closeoperate float 
input / / 闭 运算 先 膨胀 再 腐蚀 { 
int i k t float tmp t = N * 
2 1 float dilation N for k = 0 k 
N k + + { tmp = input k for 
i = k + 1 i k + N i 
+ + { if tmp input i tmp = input 
i } dilation k = tmp } tmp = dilation 
0 for k = 1 k N k + + 
{ if tmp dilation k tmp = dilation k } 
return tmp } int main { clock _ t start 
end double duration FILE * fd * m _ fd 
float buffer float filter _ data float openresult 2 * 
N 1 m _ fd = fopen D / data 
. txt r + if m _ fd = = 
NULL { perror open error return 1 } fd = 
fopen D / data1 . txt w + if fd 
= = NULL { perror open error return 1 } 
start = clock while fscanf m _ fd % f 
& buffer = EOF { x 3 * N + 
1 = buffer openoperate x openresult filter _ data = 
closeoperate openresult fprintf fd % f filter _ data for 
int y = 0 y 3 * N + 1 
y + + x y = x y + 1 
} end = clock duration = double end start / 
CLOCKS _ PER _ SEC printf % f seconds \ 
n duration fclose fd fclose m _ fd return 0 
} 结果 如下 图 所示 对 有 干扰 原始 眼 
电 数据 进行 形态学 滤波 处理 其中 结构 元素 17个 
窗 宽 5 . 有图/nr 可以 看到 形态学 对于 尖峰 
的 滤波 效果 特别 明显 图二 将 形态学 滤波 算法 
加入 Qt 中 对眼 电 进行 实时 滤波 处理 效果 
如图 引 这 部分 内容 主要 来自 参考文献 2 总结 
以前 认为 形态学 滤波 只在 图像 处理 中 有所 应用 
现在 看 了 参考 文献 2 才 发觉 自己 实在 
有点 固步自封 对 知识 的 来龙去脉 掌握 的 不够 清楚 
一言以蔽之 囫囵吞枣 并不 清楚 思考 方向 而 只 掌握 具体 
的 技巧 细节 不 注重 顶层 设计 所以 才会 有此 
感慨 在 进行 数据 处理 中 常常 用到 的 滤波 
方法 有 中值 滤波 均值 滤波 FIR IIR 卡尔曼滤波 自适应 
滤波 等 而 很多 知识 都是 相符 相通 的 切不可 
死 学 死记 参考文献 1 . http / / blog 
. csdn . net / thefutureisour / article / details 
/ 75748192 . http / / m . blog . 
csdn . net / blog / gylltq / 337993473 . 
OpenCV 2 计算机 视觉 编程 手册 2015 11 28 学习 
笔记 张朋 艺 