1 . 图像 与 原始 字节 之间 的 转换 从 
概念 上 讲 一个 字 节能 表示 0 到 255 
的 整数 目前 对于 多 有的 实时 图像 应用 而言 
虽然 有 其他 的 表示 形式 但 一个 像素 通常 
由 每个 通道 的 一个 字节 表示 一个 OpenCV 图像 
是 . array 类型 的 二维 或 三维 数组 8位 
的 灰度 图像 是 一个 含有 字节 值 的 二维 
数组 一个 24位 的 BGR 图像 是 一个 三维 数组 
它 也 包含 了 字节 值 可使用 表达式 访问 这些 
值 如 image 0 0 或 image 0 0 0 
第一 个 值 代表 像素 的 y 坐标 啊 或 
行 0 表示 顶部 第二个 值 是 像素 的 x 
坐标 或 列 0 表示 最 左边 第三个 值 如果 
可用 的话 表示 颜色通道 如 对于 一个 左上角 有 白色 
像素 的 8位 灰度 图像 而言 image 0 0 的 
值 为 255 . 对于 一个 左上角 有 蓝色 像素 
的 24位 BGR 图像 而言 image 0 0 是 255 
0 0 可以 用 另外 一个 表示 如 image 0 
0 或 image 0 0 = 128 还 可表示 成 
image . item 0 0 或 image . setitem 0 
0 128 对 于单 像素 操作 第二种 表示 方式 更 
有效 若 一幅 图像 的 每个 通道 为 8位 则可 
将其 显示 转换 为 标准 的 一维 Python bytearray 格式 
byteArray =   bytearray image 反之 bytearray 含有 恰当 顺序 
的 字节 可以 通过 显示 转换 和 重构 得到 numpy 
. array 形式 的 图像 garyImage = numpy . array 
garyByteArray   . reshape height width bgrImage = numpy . 
array bgrByteArray   . reshape height width 3 下面 介绍 
将 含有 随机 字节 的 bytearray 转换 为 灰度 图像 
和 BGR 图像 import cv2 import numpy as np import 
os # 创建 一个 120000个 随机 字节 的 数组 randomByteArray 
= bytearray os . urandom 120000 # os . urandom 
n 返回 n 个 随机 byte 值 的 string 作为 
加密 使用 flatNumpyArray = np . array randomByteArray # 将 
数组 转换 为 400 x 300 的 灰度 图像 garyImage 
= flatNumpyArray . reshape 300 400 cv2 . imwrite randomGary 
. png garyImage # 将 数组 转换 为 400 x 
300 的 彩色图像 bgrImage = flatNumpyArray . reshape 100 400 
3 cv2 . imwrite randomColor . png bgrImage 运行 该 
程序 将会 在 程序 所在 目录 中 生成 两张 灰度 
图像 如下 所示 尺寸 分别为 400 x 100 400 x 
400 使用 Python 标准 的 os . urandom 函数 可 
随机 生成 原始 字节 随后 会把 该 字节 转换 为 
NumPy 数组 需要 注意 的 是 诸如 numpy . random 
. randint 0 256 120000 . reshape 400 300 语句 
也能 直接 并且 更 高效 地 随机 生成 NumPy 数组 
使用 os . urandom 函数 的 原因 是 该 语句 
有助于 展示 原始 字节 的 转换 2 . 使用 numpy 
. array 访问 图像 数据 加载 OpenCV 图像 最简单 的 
方式 是 使用 imread 函数 该 函数 会 返回 一幅 
图像 这幅 图像 是 一个 数组 根据 imread 函数 输入 
参数 的 不同 该 图像 可能 是 二维 数组 也 
可能 是 三维 数组 y . array 结构 针对 数组 
操作 有 很好 的 优化 它 允许 某些 块 bulk 
操作 这些 操作 在 通常 的 Python 中 不可 用 
这些 特定 的 . array 操 作在 OpenCV 的 图像 
处理 中 会很 方便 利用 numpy . array 函 数来 
转换 数组 比 用 普通 的 Python 数组 转换 要 
快得多 import cv2 import numpy as np img = cv2 
. imread flower . jpg img 0 0 = 255 
255 255 cv2 . imshow my image img cv2 . 
waitKey 在 图像 左上方 会 出现 一个 白点 假设 想要 
改变 一个 特定 像素 的 蓝色 值 numpy . array 
提供 了 item 方法 该 函数 有 3个 参数 x 
或 左 位置 y 或 顶部 位置 以及 x y 
位置 的 数组 索引 注意 在 BGR 图像 中 某一 
位置 的 数据 是 按 B G R 的 顺序 
保存 的 三元 数组 该 函数 能 返回 索引 函数 
的 值 另 一个 方法 是 通过 itemset 函数 可 
设置 指定 像素 在 指定 通道 的 值 itemset 有 
两个 参数 一个 三元组 x y 和 索引 和要/nr 设定 
的 值 如下 例子 将 坐标 150 120 的 当前 
蓝色 值 127 变为 255import cv2 import numpy as np 
img = cv2 . imread flower . jpg print img 
. item 150 120 0 # 打印 当前 坐标 点 
的 蓝色 值 img . itemset 150 120 0 255 
print img . item 150 120 0 建议 使用 内置 
的 滤波器 和 方法 来 处理 整个 图像 上述 方法 
只 适合 于 处理 特定 的 小区域 下面 介绍 操作 
通道 将 指定 通道 B G R 的 所有 值 
置 为 0 . 注 通过 循环 来 处理 Python 
数组 的 效率 非常 低 应该 尽量 避免 这样 的 
操作 使用 数组 索引 可以 高效 地 操作 像素 像素 
操作 是 一个 高 代价 的 低效 操作 特别 是 
在 视频 数据 处理 时 会 发现 要 等 很久 
才能 得到 结果 可用 索引 indexing 来 解决 该 问题 
以下 代码 可将 图像 所有 的 G 绿色 值 设为 
0import cv2 import numpy as np img = cv2 . 
imread flower . jpg img 1 = 0 cv2 . 
imshow my image img cv2 . waitKey 运行 结果 为 
通过 NumPy 数组 的 索引 访问 原始 像素 还可 设定 
感兴趣 区域 Region Of Interest ROI 一旦 设定 了 该 
区域 就 可以 执行 许多 操作 例如 将该 区域 与 
变量 绑定 然后 设定 第二 个 区域 并将 第一 个 
区域 的 值 分配 给 第二 个 区域 将 图像 
的 一部分 拷贝到 该 图像 的 另一个 位置 import cv2 
import numpy as np img = cv2 . imread flower 
. jpg roi = img 0 100 0 100 img 
100 200 100 200 = roi # 此处 需 考虑 
所用 图像 的 尺寸 不能超过 并 确保 两个 区域 的 
大小 一样 cv2 . imshow my image img cv2 . 
waitKey 运行 结果 为 此外 还 可使用 numpy . array 
来 获得 图像 其他 属性 shape NumPy 返回 包含 宽度 
高度 和 通道 数 如果 图像 是 彩色 的 数组 
这在 调试 图像 类型 时很/nr 有用 如果 图像 是 单色 
或 灰度 的 将不 包含 通道 值 size 该 属性 
是 指 图像 像素 的 大小 datatype 该 属性 会 
得到 图像 的 数据类型 通常 为 一个 无符号 整数 类型 
的 变量 和该/nr 类型 占 的 位数 比如 unit8 类型 
import cv2 import numpy as np img = cv2 . 
imread flower . jpg print img . shape print img 
. size print img . dtype 运行 结果 为 220 
252 3 166320uint83 . 视频 文件 的 读 / 写 
OpenCV 提供 了 VideoCapture 类 和 VideoWriter 类 来 支持 
各种 格式 的 视频 文件 支持 的 格式 类型 会 
因 系统 的 不同 而 变化 但 应该 都 支持 
AVI 格式 在 到达 视频文件 末尾 之前 VideoCapture 类 可通过 
read 函数 来 获取 新的 帧 每 帧 都是 一幅 
基于 BGR 格式 的 图像 可将 一幅 图像 传递 给 
VideoWriter 类 的 write 函数 该 函数 会将 这幅 图像 
加到 VideoWriter 类 所 指向 的 文件 中 如下 示例 
读取 AVI 文件 的 帧 并 采用 YUV 颜色 编码 
将其 写入 另 一帧 中 import cv2 videoCapture = cv2 
. VideoCapture myvideo . avi fps = videoCapture . get 
cv2 . CAP _ PROP _ FPS size = int 
videoCapture . get cv2 . CAP _ PROP _ FRAME 
_ WIDTH int videoCapture . get cv2 . CAP _ 
PROP _ FRAME _ HEIGHT videoWriter = cv2 . VideoWriter 
MyOutputVid . avi cv2 . VideoWriter _ fourcc I 4 
2 0 fps size success frame = videoCapture . read 
while success # 循环 直到 所有 帧 结束 videoWriter . 
write frame success frame = videoCapture . read 要 特别 
注意 必须 要 为 VideoWriter 类 的 构造函数 指定 视频 
文件名 这个 文件名 对应 的 文件 若 存在 会被 覆盖 
也 必须 指定 视频 编解码器 编解码器 的 可用性 根据 系统 
不同 而 不同 下面 是 一些 常用 选项 cv2 . 
VideoWriter _ force I 4 2 0 该 选项 是 
一个 未 压缩 的 YUV 颜色 编码 是 4 2 
0 色度 子 采样 这种 编码 有 很好 的 兼容性 
但 会 产生 较 大文件 文件 扩展 名为 . avi 
cv2 . VideoWriter _ force P I M 1 该 
选项 是 MPEG 1 编码 类型 文件 扩展 名为 . 
avi cv2 . VideoWriter _ force X V I D 
该 选项 是 MPEG 4 编码 类型 如果 希望 得到 
的 视频 大小 为 平均值 推荐 使用 此 选项 文件 
扩展 名为 . avi cv2 . VideoWriter _ force T 
H E O 该 选项 是 Ogg Vorbis 文件 扩展名 
应为 . ogv cv2 . VideoWriter _ force F L 
V 1 该 选项 是 一个 Flash 视频 文件 扩展名 
应为 . flv 帧速率 和帧/nr 大小 也 必须 要 指定 
因为 需要 从 另一个 视频文件 复制 视频 帧 这些 属性 
可以 通过 VideoCapture 类 的 get 函数 得到 4 . 
捕获 摄像头 的 帧 VideoCapture 类 可以 获得 摄像头 的 
帧 流 但对 摄像头 而言 通常 不是 用 视频 的 
文件 名 来 构造 VideoCapture 类 而是 需要 传递 摄像头 
的 设备 索引 device index 下面 的 例子 会 捕获 
摄像头 10秒 的 视频 信息 并 将其 写入 一个 AVI 
文件 中 import cv2 cameraCapture = cv2 . VideoCapture 0 
fps = 30 size = int cameraCapture . get cv2 
. CAP _ PROP _ FRAME _ WIDTH int cameraCapture 
. get cv2 . CAP _ PROP _ FRAME _ 
HEIGHT videoWriter = cv2 . VideoWriter MyOutputVid . avi cv2 
. VideoWriter _ fourcc I 4 2 0 fps size 
success frame = cameraCapture . read n u m F 
r a m e s R e m a i 
n i n g = 10 * fps 1 while 
success and n u m F r a m e 
s R e m a i n i n g 
0 videoWriter . write frame success frame = cameraCapture . 
read n u m F r a m e s 
R e m a i n i n g = 
1 cameraCapture . release 然而 VideoCapture 类 的 get 方法 
不能 反悔 摄像头 帧速率 的 准确 值 它 总是 返回 
0 为了 针对 摄像头 创建 合适 的 VideoWriter 类 要么 
对 帧速率 做出 假设 要么 使用 计时器 来 测量 摄像头 
的 数量 和 顺序 由 系统 决定 但 OpenCV 没有 
提供 任何 查询 摄像头 数量 和 属性 的 方法 如果 
使用 无效 索引 构造 了 VideoCapture 类 就 不会 得到 
帧 VideoCapture 的 read 函数 会 返回 false None 为了 
不让 read 函数 从 没有 正确 打开 的 VideoCapture 类 
中 获取 数据 可在 执行 该 函数 之后 使用 VideoCapture 
. isOpened 方法 做一个 判断 该 方法 返回 一个 Boolean 
值 当 需要 同步 一组 摄像头 或 一个多头 摄像头 例如 
立体 摄像头 或 Kinect 时 read 方法 就 不再 适合 
了 可用 grab 和 retrive 方法 代替 它 对于 一组 
摄像头 可以 使用 以下 代码 success0 = cameraCapture0 . grab 
success1 = cameraCapture1 . grab if success0 and success1 frame0 
= cameraCapture0 . retrive frame1 = cameraCapture1 . retrive 5 
. 在 窗口 显示图 像用 imshow 函数 实现 显示 图像 
的 操作 imshow 函数 有 两个 参数 显示 图像 的 
帧 名字 以及 要 显示 的 图像 本身 import cv2 
import numpy as np img = cv2 . imread flower 
. jpg cv2 . imshow my image img cv2 . 
waitKey cv2 . d e s t r o y 
A l l W i n d o w s 
# 释放 由 OpenCV 创建 的 所有 窗口 6 . 
在 窗口 显示 摄像头 帧 OpenCV 的 namedWindow imshow 和 
DestoryWindow 函数 允许 指定 窗口 名 来 创建 显示 和 
销毁 destroy 窗口 此外 任何 窗口 都 可以 通过 waitKey 
函数 来 获取 键盘输入 通过 setMouseCallback 函数 来 获取 鼠标 
输入 以下 代码 可 实时 显示 摄像头 帧 import cv2 
clicked = False def onMouse event x y flags param 
global clicked if event = = cv2 . EVENT _ 
LBUTTONUP clicked = True cameraCapture = cv2 . VideoCapture 0 
cv2 . namedWindow MyWindow cv2 . setMouseCallback MyWindow onMouse print 
showing camera feed . Click window or press any key 
to stop . success frame = cameraCapture . read while 
success and cv2 . waitKey 1 = = 1 and 
not clicked cv2 . imshow MyWindow frame success frame = 
cameraCapture . read cv2 . destroyWindow MyWindow cameraCapture . release 
waitKey 的 参数 为 等待 键盘 触发 的 时间 单位 
为 毫秒 其 返回值 为 1 表示 没有 键 被 
按下 或 ASCII 码 另外 Python 提供 了 一个 标准 
函数 ord 该 函数 可以 将 字符 转换 为 ASCII 
码 注 在 一些 系统 中 waitKey 的 返回值 可能 
比 ASCII 码 的 值 更大 在 Linux 系统 中 
如果 OpenCV 使用 GTK 作为 后 端的 GUI 库 就 
会 出现 bug 在 所有 系统 中 可以 通过 读取 
返回值 的 最后 一个 字节 来 保证 肢体 去 ASCII 
码 代码 为 keycode = cv2 . waitkey 1 if 
keycode = 1 keycode & = 0xff   OpenCV 的 
窗口 函数 和 waitKey 函数 相互依赖 OpenCV 的 窗口 只有在 
调用 waitKey 函数 时 才会 更新 waitKey 函数 只有 在 
OpenCV 窗口 成为 活动 窗口 时 才能 捕获 输入 信息 
鼠标 回调函数 setMouseCallback 有 5个 参数 param 是 可选 参数 
它 是 setMouseCallback 函数 的 第三 个 参数 默认 情况 
下 该 参数 是 0 . 回调 时间 参数 可以 
取 如下 的 值 它们 分别 对应 不同 的 鼠标 
事件 cv2 . EVENT _ MOUSEMOVE 该 事件 对应 鼠标 
移动 cv2 . EVENT _ LBUTTONDOWN 该 事件 对应 鼠标 
左键 按下 cv2 . EVENT _ RBUTTONDOWN 该 事件 对应 
鼠标 右键 按下 cv2 . EVENT _ MBUTTONDOWN 该 事件 
对应 鼠标 中间 键 按下 cv2 . EVENT _ LBUTTONUP 
该 事件 对应 鼠标 左键 松开 cv2 . EVENT _ 
RBUTTONUP 该 事件 对应 鼠标 右键 松开 cv2 . EVENT 
_ MBUTTONUP 该 事件 对应 鼠标 中间 键 松开 cv2 
. EVENT _ LBUTTONDBLCLK 该 事件 对应 双击鼠标 左键 cv2 
. EVENT _ RBUTTONDBLCLK 该 事件 对应 双击鼠标 右键 cv2 
. EVENT _ MBUTTONDBLCLK 该 事件 随 影 双击鼠标 中间 
键 鼠标 回调 的 标志 参数 可能 是 以下 事件 
的 按 位 组合 cv2 . EVENT _ FLAG _ 
LBUTTON 该 事件 对 应按 下 鼠标 左键 cv2 . 
EVENT _ FLAG _ RBUTTON 该 事件 对 应按 下 
鼠标 右键 cv2 . EVENT _ FLAG _ MBUTTON 该 
事件 对 应按 下 鼠标 中间 键 cv2 . EVENT 
_ FLAG _ CTRLKEY 该 事件 对应 按下 Ctrl 键 
cv2 . EVENT _ FLAG _ SHIFTKEY 该 事件 对应 
按下 Shift 键 cv2 . EVENT _ FLAG _ ALTKEY 
该 事件 对应 按下 Alt 键 1 . 图像 与 原始 字节 之间 的 转换 从 
概念 上 讲 一个 字 节能 表示 0 到 255 
的 整数 目前 对于 多 有的 实时 图像 应用 而言 
虽然 有 其他 的 表示 形式 但 一个 像素 通常 
由 每个 通道 的 一个 字节 表示 一个 OpenCV 图像 
是 . array 类型 的 二维 或 三维 数组 8位 
的 灰度 图像 是 一个 含有 字节 值 的 二维 
数组 一个 24位 的 BGR 图像 是 一个 三维 数组 
它 也 包含 了 字节 值 可使用 表达式 访问 这些 
值 如 image 0 0 或 image 0 0 0 
第一 个 值 代表 像素 的 y 坐标 啊 或 
行 0 表示 顶部 第二个 值 是 像素 的 x 
坐标 或 列 0 表示 最 左边 第三个 值 如果 
可用 的话 表示 颜色通道 如 对于 一个 左上角 有 白色 
像素 的 8位 灰度 图像 而言 image 0 0 的 
值 为 255 . 对于 一个 左上角 有 蓝色 像素 
的 24位 BGR 图像 而言 image 0 0 是 255 
0 0 可以 用 另外 一个 表示 如 image 0 
0 或 image 0 0 = 128 还 可表示 成 
image . item 0 0 或 image . setitem 0 
0 128 对 于单 像素 操作 第二种 表示 方式 更 
有效 若 一幅 图像 的 每个 通道 为 8位 则可 
将其 显示 转换 为 标准 的 一维 Python bytearray 格式 
byteArray =   bytearray image 反之 bytearray 含有 恰当 顺序 
的 字节 可以 通过 显示 转换 和 重构 得到 numpy 
. array 形式 的 图像 garyImage = numpy . array 
garyByteArray   . reshape height width bgrImage = numpy . 
array bgrByteArray   . reshape height width 3 下面 介绍 
将 含有 随机 字节 的 bytearray 转换 为 灰度 图像 
和 BGR 图像 import cv2 import numpy as np import 
os # 创建 一个 120000个 随机 字节 的 数组 randomByteArray 
= bytearray os . urandom 120000 # os . urandom 
n 返回 n 个 随机 byte 值 的 string 作为 
加密 使用 flatNumpyArray = np . array randomByteArray # 将 
数组 转换 为 400 x 300 的 灰度 图像 garyImage 
= flatNumpyArray . reshape 300 400 cv2 . imwrite randomGary 
. png garyImage # 将 数组 转换 为 400 x 
300 的 彩色图像 bgrImage = flatNumpyArray . reshape 100 400 
3 cv2 . imwrite randomColor . png bgrImage 运行 该 
程序 将会 在 程序 所在 目录 中 生成 两张 灰度 
图像 如下 所示 尺寸 分别为 400 x 100 400 x 
400 使用 Python 标准 的 os . urandom 函数 可 
随机 生成 原始 字节 随后 会把 该 字节 转换 为 
NumPy 数组 需要 注意 的 是 诸如 numpy . random 
. randint 0 256 120000 . reshape 400 300 语句 
也能 直接 并且 更 高效 地 随机 生成 NumPy 数组 
使用 os . urandom 函数 的 原因 是 该 语句 
有助于 展示 原始 字节 的 转换 2 . 使用 numpy 
. array 访问 图像 数据 加载 OpenCV 图像 最简单 的 
方式 是 使用 imread 函数 该 函数 会 返回 一幅 
图像 这幅 图像 是 一个 数组 根据 imread 函数 输入 
参数 的 不同 该 图像 可能 是 二维 数组 也 
可能 是 三维 数组 y . array 结构 针对 数组 
操作 有 很好 的 优化 它 允许 某些 块 bulk 
操作 这些 操作 在 通常 的 Python 中 不可 用 
这些 特定 的 . array 操 作在 OpenCV 的 图像 
处理 中 会很 方便 利用 numpy . array 函 数来 
转换 数组 比 用 普通 的 Python 数组 转换 要 
快得多 import cv2 import numpy as np img = cv2 
. imread flower . jpg img 0 0 = 255 
255 255 cv2 . imshow my image img cv2 . 
waitKey 在 图像 左上方 会 出现 一个 白点 假设 想要 
改变 一个 特定 像素 的 蓝色 值 numpy . array 
提供 了 item 方法 该 函数 有 3个 参数 x 
或 左 位置 y 或 顶部 位置 以及 x y 
位置 的 数组 索引 注意 在 BGR 图像 中 某一 
位置 的 数据 是 按 B G R 的 顺序 
保存 的 三元 数组 该 函数 能 返回 索引 函数 
的 值 另 一个 方法 是 通过 itemset 函数 可 
设置 指定 像素 在 指定 通道 的 值 itemset 有 
两个 参数 一个 三元组 x y 和 索引 和要/nr 设定 
的 值 如下 例子 将 坐标 150 120 的 当前 
蓝色 值 127 变为 255import cv2 import numpy as np 
img = cv2 . imread flower . jpg print img 
. item 150 120 0 # 打印 当前 坐标 点 
的 蓝色 值 img . itemset 150 120 0 255 
print img . item 150 120 0 建议 使用 内置 
的 滤波器 和 方法 来 处理 整个 图像 上述 方法 
只 适合 于 处理 特定 的 小区域 下面 介绍 操作 
通道 将 指定 通道 B G R 的 所有 值 
置 为 0 . 注 通过 循环 来 处理 Python 
数组 的 效率 非常 低 应该 尽量 避免 这样 的 
操作 使用 数组 索引 可以 高效 地 操作 像素 像素 
操作 是 一个 高 代价 的 低效 操作 特别 是 
在 视频 数据 处理 时 会 发现 要 等 很久 
才能 得到 结果 可用 索引 indexing 来 解决 该 问题 
以下 代码 可将 图像 所有 的 G 绿色 值 设为 
0import cv2 import numpy as np img = cv2 . 
imread flower . jpg img 1 = 0 cv2 . 
imshow my image img cv2 . waitKey 运行 结果 为 
通过 NumPy 数组 的 索引 访问 原始 像素 还可 设定 
感兴趣 区域 Region Of Interest ROI 一旦 设定 了 该 
区域 就 可以 执行 许多 操作 例如 将该 区域 与 
变量 绑定 然后 设定 第二 个 区域 并将 第一 个 
区域 的 值 分配 给 第二 个 区域 将 图像 
的 一部分 拷贝到 该 图像 的 另一个 位置 import cv2 
import numpy as np img = cv2 . imread flower 
. jpg roi = img 0 100 0 100 img 
100 200 100 200 = roi # 此处 需 考虑 
所用 图像 的 尺寸 不能超过 并 确保 两个 区域 的 
大小 一样 cv2 . imshow my image img cv2 . 
waitKey 运行 结果 为 此外 还 可使用 numpy . array 
来 获得 图像 其他 属性 shape NumPy 返回 包含 宽度 
高度 和 通道 数 如果 图像 是 彩色 的 数组 
这在 调试 图像 类型 时很/nr 有用 如果 图像 是 单色 
或 灰度 的 将不 包含 通道 值 size 该 属性 
是 指 图像 像素 的 大小 datatype 该 属性 会 
得到 图像 的 数据类型 通常 为 一个 无符号 整数 类型 
的 变量 和该/nr 类型 占 的 位数 比如 unit8 类型 
import cv2 import numpy as np img = cv2 . 
imread flower . jpg print img . shape print img 
. size print img . dtype 运行 结果 为 220 
252 3 166320uint83 . 视频 文件 的 读 / 写 
OpenCV 提供 了 VideoCapture 类 和 VideoWriter 类 来 支持 
各种 格式 的 视频 文件 支持 的 格式 类型 会 
因 系统 的 不同 而 变化 但 应该 都 支持 
AVI 格式 在 到达 视频文件 末尾 之前 VideoCapture 类 可通过 
read 函数 来 获取 新的 帧 每 帧 都是 一幅 
基于 BGR 格式 的 图像 可将 一幅 图像 传递 给 
VideoWriter 类 的 write 函数 该 函数 会将 这幅 图像 
加到 VideoWriter 类 所 指向 的 文件 中 如下 示例 
读取 AVI 文件 的 帧 并 采用 YUV 颜色 编码 
将其 写入 另 一帧 中 import cv2 videoCapture = cv2 
. VideoCapture myvideo . avi fps = videoCapture . get 
cv2 . CAP _ PROP _ FPS size = int 
videoCapture . get cv2 . CAP _ PROP _ FRAME 
_ WIDTH int videoCapture . get cv2 . CAP _ 
PROP _ FRAME _ HEIGHT videoWriter = cv2 . VideoWriter 
MyOutputVid . avi cv2 . VideoWriter _ fourcc I 4 
2 0 fps size success frame = videoCapture . read 
while success # 循环 直到 所有 帧 结束 videoWriter . 
write frame success frame = videoCapture . read 要 特别 
注意 必须 要 为 VideoWriter 类 的 构造函数 指定 视频 
文件名 这个 文件名 对应 的 文件 若 存在 会被 覆盖 
也 必须 指定 视频 编解码器 编解码器 的 可用性 根据 系统 
不同 而 不同 下面 是 一些 常用 选项 cv2 . 
VideoWriter _ force I 4 2 0 该 选项 是 
一个 未 压缩 的 YUV 颜色 编码 是 4 2 
0 色度 子 采样 这种 编码 有 很好 的 兼容性 
但 会 产生 较 大文件 文件 扩展 名为 . avi 
cv2 . VideoWriter _ force P I M 1 该 
选项 是 MPEG 1 编码 类型 文件 扩展 名为 . 
avi cv2 . VideoWriter _ force X V I D 
该 选项 是 MPEG 4 编码 类型 如果 希望 得到 
的 视频 大小 为 平均值 推荐 使用 此 选项 文件 
扩展 名为 . avi cv2 . VideoWriter _ force T 
H E O 该 选项 是 Ogg Vorbis 文件 扩展名 
应为 . ogv cv2 . VideoWriter _ force F L 
V 1 该 选项 是 一个 Flash 视频 文件 扩展名 
应为 . flv 帧速率 和帧/nr 大小 也 必须 要 指定 
因为 需要 从 另一个 视频文件 复制 视频 帧 这些 属性 
可以 通过 VideoCapture 类 的 get 函数 得到 4 . 
捕获 摄像头 的 帧 VideoCapture 类 可以 获得 摄像头 的 
帧 流 但对 摄像头 而言 通常 不是 用 视频 的 
文件 名 来 构造 VideoCapture 类 而是 需要 传递 摄像头 
的 设备 索引 device index 下面 的 例子 会 捕获 
摄像头 10秒 的 视频 信息 并 将其 写入 一个 AVI 
文件 中 import cv2 cameraCapture = cv2 . VideoCapture 0 
fps = 30 size = int cameraCapture . get cv2 
. CAP _ PROP _ FRAME _ WIDTH int cameraCapture 
. get cv2 . CAP _ PROP _ FRAME _ 
HEIGHT videoWriter = cv2 . VideoWriter MyOutputVid . avi cv2 
. VideoWriter _ fourcc I 4 2 0 fps size 
success frame = cameraCapture . read n u m F 
r a m e s R e m a i 
n i n g = 10 * fps 1 while 
success and n u m F r a m e 
s R e m a i n i n g 
0 videoWriter . write frame success frame = cameraCapture . 
read n u m F r a m e s 
R e m a i n i n g = 
1 cameraCapture . release 然而 VideoCapture 类 的 get 方法 
不能 反悔 摄像头 帧速率 的 准确 值 它 总是 返回 
0 为了 针对 摄像头 创建 合适 的 VideoWriter 类 要么 
对 帧速率 做出 假设 要么 使用 计时器 来 测量 摄像头 
的 数量 和 顺序 由 系统 决定 但 OpenCV 没有 
提供 任何 查询 摄像头 数量 和 属性 的 方法 如果 
使用 无效 索引 构造 了 VideoCapture 类 就 不会 得到 
帧 VideoCapture 的 read 函数 会 返回 false None 为了 
不让 read 函数 从 没有 正确 打开 的 VideoCapture 类 
中 获取 数据 可在 执行 该 函数 之后 使用 VideoCapture 
. isOpened 方法 做一个 判断 该 方法 返回 一个 Boolean 
值 当 需要 同步 一组 摄像头 或 一个多头 摄像头 例如 
立体 摄像头 或 Kinect 时 read 方法 就 不再 适合 
了 可用 grab 和 retrive 方法 代替 它 对于 一组 
摄像头 可以 使用 以下 代码 success0 = cameraCapture0 . grab 
success1 = cameraCapture1 . grab if success0 and success1 frame0 
= cameraCapture0 . retrive frame1 = cameraCapture1 . retrive 5 
. 在 窗口 显示图 像用 imshow 函数 实现 显示 图像 
的 操作 imshow 函数 有 两个 参数 显示 图像 的 
帧 名字 以及 要 显示 的 图像 本身 import cv2 
import numpy as np img = cv2 . imread flower 
. jpg cv2 . imshow my image img cv2 . 
waitKey cv2 . d e s t r o y 
A l l W i n d o w s 
# 释放 由 OpenCV 创建 的 所有 窗口 6 . 
在 窗口 显示 摄像头 帧 OpenCV 的 namedWindow imshow 和 
DestoryWindow 函数 允许 指定 窗口 名 来 创建 显示 和 
销毁 destroy 窗口 此外 任何 窗口 都 可以 通过 waitKey 
函数 来 获取 键盘输入 通过 setMouseCallback 函数 来 获取 鼠标 
输入 以下 代码 可 实时 显示 摄像头 帧 import cv2 
clicked = False def onMouse event x y flags param 
global clicked if event = = cv2 . EVENT _ 
LBUTTONUP clicked = True cameraCapture = cv2 . VideoCapture 0 
cv2 . namedWindow MyWindow cv2 . setMouseCallback MyWindow onMouse print 
showing camera feed . Click window or press any key 
to stop . success frame = cameraCapture . read while 
success and cv2 . waitKey 1 = = 1 and 
not clicked cv2 . imshow MyWindow frame success frame = 
cameraCapture . read cv2 . destroyWindow MyWindow cameraCapture . release 
waitKey 的 参数 为 等待 键盘 触发 的 时间 单位 
为 毫秒 其 返回值 为 1 表示 没有 键 被 
按下 或 ASCII 码 另外 Python 提供 了 一个 标准 
函数 ord 该 函数 可以 将 字符 转换 为 ASCII 
码 注 在 一些 系统 中 waitKey 的 返回值 可能 
比 ASCII 码 的 值 更大 在 Linux 系统 中 
如果 OpenCV 使用 GTK 作为 后 端的 GUI 库 就 
会 出现 bug 在 所有 系统 中 可以 通过 读取 
返回值 的 最后 一个 字节 来 保证 肢体 去 ASCII 
码 代码 为 keycode = cv2 . waitkey 1 if 
keycode = 1 keycode & = 0xff   OpenCV 的 
窗口 函数 和 waitKey 函数 相互依赖 OpenCV 的 窗口 只有在 
调用 waitKey 函数 时 才会 更新 waitKey 函数 只有 在 
OpenCV 窗口 成为 活动 窗口 时 才能 捕获 输入 信息 
鼠标 回调函数 setMouseCallback 有 5个 参数 param 是 可选 参数 
它 是 setMouseCallback 函数 的 第三 个 参数 默认 情况 
下 该 参数 是 0 . 回调 时间 参数 可以 
取 如下 的 值 它们 分别 对应 不同 的 鼠标 
事件 cv2 . EVENT _ MOUSEMOVE 该 事件 对应 鼠标 
移动 cv2 . EVENT _ LBUTTONDOWN 该 事件 对应 鼠标 
左键 按下 cv2 . EVENT _ RBUTTONDOWN 该 事件 对应 
鼠标 右键 按下 cv2 . EVENT _ MBUTTONDOWN 该 事件 
对应 鼠标 中间 键 按下 cv2 . EVENT _ LBUTTONUP 
该 事件 对应 鼠标 左键 松开 cv2 . EVENT _ 
RBUTTONUP 该 事件 对应 鼠标 右键 松开 cv2 . EVENT 
_ MBUTTONUP 该 事件 对应 鼠标 中间 键 松开 cv2 
. EVENT _ LBUTTONDBLCLK 该 事件 对应 双击鼠标 左键 cv2 
. EVENT _ RBUTTONDBLCLK 该 事件 对应 双击鼠标 右键 cv2 
. EVENT _ MBUTTONDBLCLK 该 事件 随 影 双击鼠标 中间 
键 鼠标 回调 的 标志 参数 可能 是 以下 事件 
的 按 位 组合 cv2 . EVENT _ FLAG _ 
LBUTTON 该 事件 对 应按 下 鼠标 左键 cv2 . 
EVENT _ FLAG _ RBUTTON 该 事件 对 应按 下 
鼠标 右键 cv2 . EVENT _ FLAG _ MBUTTON 该 
事件 对 应按 下 鼠标 中间 键 cv2 . EVENT 
_ FLAG _ CTRLKEY 该 事件 对应 按下 Ctrl 键 
cv2 . EVENT _ FLAG _ SHIFTKEY 该 事件 对应 
按下 Shift 键 cv2 . EVENT _ FLAG _ ALTKEY 
该 事件 对应 按下 Alt 键 1 . 图像 与 原始 字节 之间 的 转换 从 
概念 上 讲 一个 字 节能 表示 0 到 255 
的 整数 目前 对于 多 有的 实时 图像 应用 而言 
虽然 有 其他 的 表示 形式 但 一个 像素 通常 
由 每个 通道 的 一个 字节 表示 一个 OpenCV 图像 
是 . array 类型 的 二维 或 三维 数组 8位 
的 灰度 图像 是 一个 含有 字节 值 的 二维 
数组 一个 24位 的 BGR 图像 是 一个 三维 数组 
它 也 包含 了 字节 值 可使用 表达式 访问 这些 
值 如 image 0 0 或 image 0 0 0 
第一 个 值 代表 像素 的 y 坐标 啊 或 
行 0 表示 顶部 第二个 值 是 像素 的 x 
坐标 或 列 0 表示 最 左边 第三个 值 如果 
可用 的话 表示 颜色通道 如 对于 一个 左上角 有 白色 
像素 的 8位 灰度 图像 而言 image 0 0 的 
值 为 255 . 对于 一个 左上角 有 蓝色 像素 
的 24位 BGR 图像 而言 image 0 0 是 255 
0 0 可以 用 另外 一个 表示 如 image 0 
0 或 image 0 0 = 128 还 可表示 成 
image . item 0 0 或 image . setitem 0 
0 128 对 于单 像素 操作 第二种 表示 方式 更 
有效 若 一幅 图像 的 每个 通道 为 8位 则可 
将其 显示 转换 为 标准 的 一维 Python bytearray 格式 
byteArray =   bytearray image 反之 bytearray 含有 恰当 顺序 
的 字节 可以 通过 显示 转换 和 重构 得到 numpy 
. array 形式 的 图像 garyImage = numpy . array 
garyByteArray   . reshape height width bgrImage = numpy . 
array bgrByteArray   . reshape height width 3 下面 介绍 
将 含有 随机 字节 的 bytearray 转换 为 灰度 图像 
和 BGR 图像 import cv2 import numpy as np import 
os # 创建 一个 120000个 随机 字节 的 数组 randomByteArray 
= bytearray os . urandom 120000 # os . urandom 
n 返回 n 个 随机 byte 值 的 string 作为 
加密 使用 flatNumpyArray = np . array randomByteArray # 将 
数组 转换 为 400 x 300 的 灰度 图像 garyImage 
= flatNumpyArray . reshape 300 400 cv2 . imwrite randomGary 
. png garyImage # 将 数组 转换 为 400 x 
300 的 彩色图像 bgrImage = flatNumpyArray . reshape 100 400 
3 cv2 . imwrite randomColor . png bgrImage 运行 该 
程序 将会 在 程序 所在 目录 中 生成 两张 灰度 
图像 如下 所示 尺寸 分别为 400 x 100 400 x 
400 使用 Python 标准 的 os . urandom 函数 可 
随机 生成 原始 字节 随后 会把 该 字节 转换 为 
NumPy 数组 需要 注意 的 是 诸如 numpy . random 
. randint 0 256 120000 . reshape 400 300 语句 
也能 直接 并且 更 高效 地 随机 生成 NumPy 数组 
使用 os . urandom 函数 的 原因 是 该 语句 
有助于 展示 原始 字节 的 转换 2 . 使用 numpy 
. array 访问 图像 数据 加载 OpenCV 图像 最简单 的 
方式 是 使用 imread 函数 该 函数 会 返回 一幅 
图像 这幅 图像 是 一个 数组 根据 imread 函数 输入 
参数 的 不同 该 图像 可能 是 二维 数组 也 
可能 是 三维 数组 y . array 结构 针对 数组 
操作 有 很好 的 优化 它 允许 某些 块 bulk 
操作 这些 操作 在 通常 的 Python 中 不可 用 
这些 特定 的 . array 操 作在 OpenCV 的 图像 
处理 中 会很 方便 利用 numpy . array 函 数来 
转换 数组 比 用 普通 的 Python 数组 转换 要 
快得多 import cv2 import numpy as np img = cv2 
. imread flower . jpg img 0 0 = 255 
255 255 cv2 . imshow my image img cv2 . 
waitKey 在 图像 左上方 会 出现 一个 白点 假设 想要 
改变 一个 特定 像素 的 蓝色 值 numpy . array 
提供 了 item 方法 该 函数 有 3个 参数 x 
或 左 位置 y 或 顶部 位置 以及 x y 
位置 的 数组 索引 注意 在 BGR 图像 中 某一 
位置 的 数据 是 按 B G R 的 顺序 
保存 的 三元 数组 该 函数 能 返回 索引 函数 
的 值 另 一个 方法 是 通过 itemset 函数 可 
设置 指定 像素 在 指定 通道 的 值 itemset 有 
两个 参数 一个 三元组 x y 和 索引 和要/nr 设定 
的 值 如下 例子 将 坐标 150 120 的 当前 
蓝色 值 127 变为 255import cv2 import numpy as np 
img = cv2 . imread flower . jpg print img 
. item 150 120 0 # 打印 当前 坐标 点 
的 蓝色 值 img . itemset 150 120 0 255 
print img . item 150 120 0 建议 使用 内置 
的 滤波器 和 方法 来 处理 整个 图像 上述 方法 
只 适合 于 处理 特定 的 小区域 下面 介绍 操作 
通道 将 指定 通道 B G R 的 所有 值 
置 为 0 . 注 通过 循环 来 处理 Python 
数组 的 效率 非常 低 应该 尽量 避免 这样 的 
操作 使用 数组 索引 可以 高效 地 操作 像素 像素 
操作 是 一个 高 代价 的 低效 操作 特别 是 
在 视频 数据 处理 时 会 发现 要 等 很久 
才能 得到 结果 可用 索引 indexing 来 解决 该 问题 
以下 代码 可将 图像 所有 的 G 绿色 值 设为 
0import cv2 import numpy as np img = cv2 . 
imread flower . jpg img 1 = 0 cv2 . 
imshow my image img cv2 . waitKey 运行 结果 为 
通过 NumPy 数组 的 索引 访问 原始 像素 还可 设定 
感兴趣 区域 Region Of Interest ROI 一旦 设定 了 该 
区域 就 可以 执行 许多 操作 例如 将该 区域 与 
变量 绑定 然后 设定 第二 个 区域 并将 第一 个 
区域 的 值 分配 给 第二 个 区域 将 图像 
的 一部分 拷贝到 该 图像 的 另一个 位置 import cv2 
import numpy as np img = cv2 . imread flower 
. jpg roi = img 0 100 0 100 img 
100 200 100 200 = roi # 此处 需 考虑 
所用 图像 的 尺寸 不能超过 并 确保 两个 区域 的 
大小 一样 cv2 . imshow my image img cv2 . 
waitKey 运行 结果 为 此外 还 可使用 numpy . array 
来 获得 图像 其他 属性 shape NumPy 返回 包含 宽度 
高度 和 通道 数 如果 图像 是 彩色 的 数组 
这在 调试 图像 类型 时很/nr 有用 如果 图像 是 单色 
或 灰度 的 将不 包含 通道 值 size 该 属性 
是 指 图像 像素 的 大小 datatype 该 属性 会 
得到 图像 的 数据类型 通常 为 一个 无符号 整数 类型 
的 变量 和该/nr 类型 占 的 位数 比如 unit8 类型 
import cv2 import numpy as np img = cv2 . 
imread flower . jpg print img . shape print img 
. size print img . dtype 运行 结果 为 220 
252 3 166320uint83 . 视频 文件 的 读 / 写 
OpenCV 提供 了 VideoCapture 类 和 VideoWriter 类 来 支持 
各种 格式 的 视频 文件 支持 的 格式 类型 会 
因 系统 的 不同 而 变化 但 应该 都 支持 
AVI 格式 在 到达 视频文件 末尾 之前 VideoCapture 类 可通过 
read 函数 来 获取 新的 帧 每 帧 都是 一幅 
基于 BGR 格式 的 图像 可将 一幅 图像 传递 给 
VideoWriter 类 的 write 函数 该 函数 会将 这幅 图像 
加到 VideoWriter 类 所 指向 的 文件 中 如下 示例 
读取 AVI 文件 的 帧 并 采用 YUV 颜色 编码 
将其 写入 另 一帧 中 import cv2 videoCapture = cv2 
. VideoCapture myvideo . avi fps = videoCapture . get 
cv2 . CAP _ PROP _ FPS size = int 
videoCapture . get cv2 . CAP _ PROP _ FRAME 
_ WIDTH int videoCapture . get cv2 . CAP _ 
PROP _ FRAME _ HEIGHT videoWriter = cv2 . VideoWriter 
MyOutputVid . avi cv2 . VideoWriter _ fourcc I 4 
2 0 fps size success frame = videoCapture . read 
while success # 循环 直到 所有 帧 结束 videoWriter . 
write frame success frame = videoCapture . read 要 特别 
注意 必须 要 为 VideoWriter 类 的 构造函数 指定 视频 
文件名 这个 文件名 对应 的 文件 若 存在 会被 覆盖 
也 必须 指定 视频 编解码器 编解码器 的 可用性 根据 系统 
不同 而 不同 下面 是 一些 常用 选项 cv2 . 
VideoWriter _ force I 4 2 0 该 选项 是 
一个 未 压缩 的 YUV 颜色 编码 是 4 2 
0 色度 子 采样 这种 编码 有 很好 的 兼容性 
但 会 产生 较 大文件 文件 扩展 名为 . avi 
cv2 . VideoWriter _ force P I M 1 该 
选项 是 MPEG 1 编码 类型 文件 扩展 名为 . 
avi cv2 . VideoWriter _ force X V I D 
该 选项 是 MPEG 4 编码 类型 如果 希望 得到 
的 视频 大小 为 平均值 推荐 使用 此 选项 文件 
扩展 名为 . avi cv2 . VideoWriter _ force T 
H E O 该 选项 是 Ogg Vorbis 文件 扩展名 
应为 . ogv cv2 . VideoWriter _ force F L 
V 1 该 选项 是 一个 Flash 视频 文件 扩展名 
应为 . flv 帧速率 和帧/nr 大小 也 必须 要 指定 
因为 需要 从 另一个 视频文件 复制 视频 帧 这些 属性 
可以 通过 VideoCapture 类 的 get 函数 得到 4 . 
捕获 摄像头 的 帧 VideoCapture 类 可以 获得 摄像头 的 
帧 流 但对 摄像头 而言 通常 不是 用 视频 的 
文件 名 来 构造 VideoCapture 类 而是 需要 传递 摄像头 
的 设备 索引 device index 下面 的 例子 会 捕获 
摄像头 10秒 的 视频 信息 并 将其 写入 一个 AVI 
文件 中 import cv2 cameraCapture = cv2 . VideoCapture 0 
fps = 30 size = int cameraCapture . get cv2 
. CAP _ PROP _ FRAME _ WIDTH int cameraCapture 
. get cv2 . CAP _ PROP _ FRAME _ 
HEIGHT videoWriter = cv2 . VideoWriter MyOutputVid . avi cv2 
. VideoWriter _ fourcc I 4 2 0 fps size 
success frame = cameraCapture . read n u m F 
r a m e s R e m a i 
n i n g = 10 * fps 1 while 
success and n u m F r a m e 
s R e m a i n i n g 
0 videoWriter . write frame success frame = cameraCapture . 
read n u m F r a m e s 
R e m a i n i n g = 
1 cameraCapture . release 然而 VideoCapture 类 的 get 方法 
不能 反悔 摄像头 帧速率 的 准确 值 它 总是 返回 
0 为了 针对 摄像头 创建 合适 的 VideoWriter 类 要么 
对 帧速率 做出 假设 要么 使用 计时器 来 测量 摄像头 
的 数量 和 顺序 由 系统 决定 但 OpenCV 没有 
提供 任何 查询 摄像头 数量 和 属性 的 方法 如果 
使用 无效 索引 构造 了 VideoCapture 类 就 不会 得到 
帧 VideoCapture 的 read 函数 会 返回 false None 为了 
不让 read 函数 从 没有 正确 打开 的 VideoCapture 类 
中 获取 数据 可在 执行 该 函数 之后 使用 VideoCapture 
. isOpened 方法 做一个 判断 该 方法 返回 一个 Boolean 
值 当 需要 同步 一组 摄像头 或 一个多头 摄像头 例如 
立体 摄像头 或 Kinect 时 read 方法 就 不再 适合 
了 可用 grab 和 retrive 方法 代替 它 对于 一组 
摄像头 可以 使用 以下 代码 success0 = cameraCapture0 . grab 
success1 = cameraCapture1 . grab if success0 and success1 frame0 
= cameraCapture0 . retrive frame1 = cameraCapture1 . retrive 5 
. 在 窗口 显示图 像用 imshow 函数 实现 显示 图像 
的 操作 imshow 函数 有 两个 参数 显示 图像 的 
帧 名字 以及 要 显示 的 图像 本身 import cv2 
import numpy as np img = cv2 . imread flower 
. jpg cv2 . imshow my image img cv2 . 
waitKey cv2 . d e s t r o y 
A l l W i n d o w s 
# 释放 由 OpenCV 创建 的 所有 窗口 6 . 
在 窗口 显示 摄像头 帧 OpenCV 的 namedWindow imshow 和 
DestoryWindow 函数 允许 指定 窗口 名 来 创建 显示 和 
销毁 destroy 窗口 此外 任何 窗口 都 可以 通过 waitKey 
函数 来 获取 键盘输入 通过 setMouseCallback 函数 来 获取 鼠标 
输入 以下 代码 可 实时 显示 摄像头 帧 import cv2 
clicked = False def onMouse event x y flags param 
global clicked if event = = cv2 . EVENT _ 
LBUTTONUP clicked = True cameraCapture = cv2 . VideoCapture 0 
cv2 . namedWindow MyWindow cv2 . setMouseCallback MyWindow onMouse print 
showing camera feed . Click window or press any key 
to stop . success frame = cameraCapture . read while 
success and cv2 . waitKey 1 = = 1 and 
not clicked cv2 . imshow MyWindow frame success frame = 
cameraCapture . read cv2 . destroyWindow MyWindow cameraCapture . release 
waitKey 的 参数 为 等待 键盘 触发 的 时间 单位 
为 毫秒 其 返回值 为 1 表示 没有 键 被 
按下 或 ASCII 码 另外 Python 提供 了 一个 标准 
函数 ord 该 函数 可以 将 字符 转换 为 ASCII 
码 注 在 一些 系统 中 waitKey 的 返回值 可能 
比 ASCII 码 的 值 更大 在 Linux 系统 中 
如果 OpenCV 使用 GTK 作为 后 端的 GUI 库 就 
会 出现 bug 在 所有 系统 中 可以 通过 读取 
返回值 的 最后 一个 字节 来 保证 肢体 去 ASCII 
码 代码 为 keycode = cv2 . waitkey 1 if 
keycode = 1 keycode & = 0xff   OpenCV 的 
窗口 函数 和 waitKey 函数 相互依赖 OpenCV 的 窗口 只有在 
调用 waitKey 函数 时 才会 更新 waitKey 函数 只有 在 
OpenCV 窗口 成为 活动 窗口 时 才能 捕获 输入 信息 
鼠标 回调函数 setMouseCallback 有 5个 参数 param 是 可选 参数 
它 是 setMouseCallback 函数 的 第三 个 参数 默认 情况 
下 该 参数 是 0 . 回调 时间 参数 可以 
取 如下 的 值 它们 分别 对应 不同 的 鼠标 
事件 cv2 . EVENT _ MOUSEMOVE 该 事件 对应 鼠标 
移动 cv2 . EVENT _ LBUTTONDOWN 该 事件 对应 鼠标 
左键 按下 cv2 . EVENT _ RBUTTONDOWN 该 事件 对应 
鼠标 右键 按下 cv2 . EVENT _ MBUTTONDOWN 该 事件 
对应 鼠标 中间 键 按下 cv2 . EVENT _ LBUTTONUP 
该 事件 对应 鼠标 左键 松开 cv2 . EVENT _ 
RBUTTONUP 该 事件 对应 鼠标 右键 松开 cv2 . EVENT 
_ MBUTTONUP 该 事件 对应 鼠标 中间 键 松开 cv2 
. EVENT _ LBUTTONDBLCLK 该 事件 对应 双击鼠标 左键 cv2 
. EVENT _ RBUTTONDBLCLK 该 事件 对应 双击鼠标 右键 cv2 
. EVENT _ MBUTTONDBLCLK 该 事件 随 影 双击鼠标 中间 
键 鼠标 回调 的 标志 参数 可能 是 以下 事件 
的 按 位 组合 cv2 . EVENT _ FLAG _ 
LBUTTON 该 事件 对 应按 下 鼠标 左键 cv2 . 
EVENT _ FLAG _ RBUTTON 该 事件 对 应按 下 
鼠标 右键 cv2 . EVENT _ FLAG _ MBUTTON 该 
事件 对 应按 下 鼠标 中间 键 cv2 . EVENT 
_ FLAG _ CTRLKEY 该 事件 对应 按下 Ctrl 键 
cv2 . EVENT _ FLAG _ SHIFTKEY 该 事件 对应 
按下 Shift 键 cv2 . EVENT _ FLAG _ ALTKEY 
该 事件 对应 按下 Alt 键 