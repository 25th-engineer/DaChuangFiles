1 . Canny 边缘 检测 OpenCV 提供 了 Canny 函数 
来 识别 边缘 Canny 边缘 检测 算法 有 5个 步骤 
使用 高斯 滤波器 对 图像 进行 去 噪 计算 梯度 
在 边缘 上 使用 非 最大 抑制 NMS 在 检测 
到 的 边缘 上 使用 双 阈值 去除 假 阳性 
false positive 最后 还 会 分析 所有 的 边缘 及其 
之间 的 连接 以 保留 真正 的 边缘 并 消除 
不 明显 的 边缘 import cv2 import numpy as np 
img = cv2 . imread flower . jpg cv2 . 
imwrite canny . jpg cv2 . Canny img 200 300 
cv2 . imshow image img cv2 . imshow canny cv2 
. imread canny . jpg cv2 . waitKey cv2 . 
d e s t r o y A l l 
W i n d o w s 运行 结果 为 
2 . 轮廓 检测 在 计算机 视觉 中 轮廓 检测 
不 仅用 来 检测 图像 或者 视频 帧 中 物体 
的 轮廓 而且 还有 其他 操作 与 轮廓 检测 有关 
如 计算 多边形 边界 形状 逼近 和 计算 感兴趣 区域 
这是 与 图像 数据 交互 时的/nr 简单 操作 因为 NumPy 
中的 矩形 区域 可以 使用 数组 切片 slice 来 定义 
在 物体 检测 包括 人脸 和 物体 跟踪 时会 大量 
使用 import cv2import numpy as npimg = np . zeros 
200 200 dtype = np . uint8 # 创建 一个 
200x200 大小 的 黑色 空白 图像 img 50 150 50 
150 = 255 # 在 图像 的 中央 放置 一个 
白色 方块 ret thresh = cv2 . threshold img 127 
255 0 # 对 图像 进行 二 值 化 操作 
image contours hierarchy = cv2 . findContours thresh cv2 . 
RETR _ TREE cv2 . CHAIN _ APPROX _ SIMPLE 
# 寻找 轮廓 color = cv2 . cvtColor img cv2 
. COLOR _ GRAY2BGR # 颜色 空间 转换 img = 
cv2 . drawContours color contours 1 0 255 0 2 
# 画出 轮廓 1 表示 所有 轮廓 画笔 颜色 为 
0 255 0 即 Green 粗细 为 3cv2 . imshow 
contours color cv2 . waitKey cv2 . d e s 
t r o y A l l W i n 
d o w s findContours 函数 有 三个 参数 输入 
图像 层次 类型 和 轮廓 逼近 方法 这个 函数 会 
修改 输入 图像 因此 建议 使用 原始 图像 的 一份 
拷贝 如 通过 img . copy 来 作为 输入 图像 
由 函数 返回 的 层次 树 相当 重要 cv2 . 
RETR _ TREE 参数 会 得到 图像 中 轮廓 的 
整体 层次结构 以此 来 建立 轮廓 之间 的 关系 如果 
只 想得到 最 外面 的 轮廓 可使用 cv2 . RETR 
_ EXTERNAL 这对 消除 包含 在 其他 轮廓 中的 轮廓 
很 有用 如在 大多数 情形 下 不 需要 检测 一个 
目标 包含 在 另一个 与之 相同 的 目标 里面 findContours 
函数 有 三个 返回值 修改后 的 图像 图像 的 轮廓 
以及 它们 的 层次 使用 轮廓 来 画出 图像 的 
彩色 版本 即把 轮廓 画成 绿色 并 显示 出来 cv2 
. threshold 简单 阈值 这个 函数 有 四个 参数 第一 
个 原 图像 第二 个 进行 分类 的 阈值 第三个 
是 高于 低于 阈值 时 赋予 的 新 值 第四个 
是 一个 方法 选择 参数 常用 的 有 cv2 . 
THRESH _ BINARY 黑 白二 值 cv2 . THRESH _ 
BINARY _ INV 黑 白二 值 反转 cv2 . THRESH 
_ TRUNC 得到 的 图像 为多 像素 值 cv2 . 
THRESH _ TOZEROcv2 . THRESH _ TOZERO _ INV 该 
函数 有 两个 返回值 第一 个 retVal 得到 的 阈值 
在后面 一个 方法 中会 用到 第二 个 就是 阈值 化 
后的/nr 图像 cvCvtColor . . . 是 Opencv 里 的 
颜色 空间 转换 函数 可以 实现 RGB 颜色 向 HSV 
HSI 等 颜色 空间 的 转换 也 可以 转 换为 
灰度 图像 参数 CV _ RGB2GRAY 是 RGB 到 gray 
参数 CV _ GRAY2RGB 是 gray 到 RGB . 处理 
结果 是 彩色 的 则 转 灰色 就是 了 运行 
结果 为 3 . 边界 框 最小 矩形 区域 和 
最小 闭 圆 的 轮廓 可用 OpenCV 的 cv2 . 
findContours 函数 找到 不规则 的 歪斜 的 以及 旋转 的 
形状 现实 的 应用 会 对 目标 的 边界 框 
最小 矩形 面积 最小 闭 圆 特别 感兴趣 3.1 绘制 
矩形 函数 cv2 . rectangle img 380 0 511 111 
255 0 0 3 需要 确定 的 就是 矩形 的 
两个 点 左上角 与 右下角 颜色 线 的 类型 不 
设置 就 默认 import cv2 import numpy as np from 
matplotlib import pyplot as plt img = np . zeros 
512 512 3 np . uint8 # 生成 一个 空 
彩色图像 cv2 . rectangle img 20 20 411 411 55 
255 155 5 plt . imshow img brg plt . 
show import cv2 import numpy as np img = cv2 
. pyrDown cv2 . imread hammer . jpg cv2 . 
IMREAD _ UNCHANGED ret thresh = cv2 . threshold cv2 
. cvtColor img . copy cv2 . COLOR _ BGR2GRAY 
127 255 cv2 . THRESH _ BINARY image contours hier 
= cv2 . findContours thresh cv2 . RETR _ EXTERNAL 
cv2 . CHAIN _ APPROX _ SIMPLE for c in 
contours # find bounding box coordinates # 现 计算 出 
一个 简单 的 边界 框 x y w h = 
cv2 . boundingRect c # 将 轮廓 信息 转换成 x 
y 坐标 并 加上 矩形 的 高度 和 宽度 cv2 
. rectangle img x y x + w y + 
h 0 255 0 2 # 画出 矩形 # find 
minimum area # 计算 包围 目标 的 最小 矩形 区域 
rect = cv2 . minAreaRect c # calculate coordinate of 
the minimum area rectangle box = cv2 . boxPoints rect 
# normalize coordinates to integers box = np . int0 
box # 注 OpenCV/w 没有/v 函数/n 能/v 直接/ad 从/p 轮廓/n 
信息/n 中/f 计算出/i 最小/a 矩形/n 顶点/n 的/uj 坐标/v 所以 需要 
计算出 最小 矩形 区域 # 然后 计算 这个 矩形 的 
顶点 由于 计算 出来 的 顶点 坐标 是 浮点 型 
但是 所得 像素 的 坐标值 是 整数 不能 获取 像素 
的 一部分 # 所以 需要 做 一个 转换 # draw 
contours cv2 . drawContours img box 0 0 0 255 
3 # 画出 该 矩形 # calculate center and radius 
of minimum enclosing circle x y radius = cv2 . 
m i n E n c l o s i 
n g C i r c l e c # 
会 返回 一个 二 元组 第一 个 元素 为 圆心 
的 坐标 组成 的 元组 第二 个 元素 为 圆 
的 半径 值 # cast to integers center = int 
x int y radius = int radius # draw the 
circle img = cv2 . circle img center radius 0 
255 0 2 cv2 . drawContours img contours 1 255 
0 0 1 cv2 . imshow contours img cv2 . 
waitKey cv2 . d e s t r o y 
A l l W i n d o w s 
运行 结果 为 在 导入 模块 后 加载 图像 然后 
在 源 图像 的 灰度 图像 上 执行 一个 二 
值 化 操作 这样 做 之后 可 在 这个 灰度 
图像 上 执行 所有 计算 轮廓 的 操作 但在 源 
图像 上 可 利用 色彩 信息 来 画 这些 轮廓 
cv2 . drawContours img box 0 0 0 255 3 
首先 该 函数 与 所有 绘图 函数 一样 它 会 
修改 源 图像 其次 该 函数 的 第二 个 参数 
接收 一个 保存着 轮廓 的 数组 从而 可以 在 一次 
操作 中 绘制 一 系列 的 轮廓 因此 如果 只有 
一组 点来 表示 多边形 轮廓 就 需要 把 这组 点 
放到 一个 数 组里 该 函数 的 第三 个 参数 
是 要 绘制 的 轮廓 数组 的 索引 1 表示 
绘制 所有 的 轮廓 否则 只会 绘制 轮廓 数 组里 
指定 的 轮廓 大多数 绘图 函数 把 绘图 的 颜色 
和 密度 thickness 放在 最后 两个 参 数里 函数 介绍 
cv2 . imread 读入 图片 共 两个 参数 第一 个 
参数 为要 读入 的 图片 文件名 第二个 参数 为 如何 
读取 图片 包括 cv2 . IMREAD _ COLOR 读入 一副 
彩色图片 cv2 . IMREAD _ GRAYSCALE 以 灰度 模式 读入 
图片 cv2 . IMREAD _ UNCHANGED 读入 一幅 图片 并 
包括 其 alpha 通道 cv2 . imread flower . jpg 
0 表示 已 灰度 模式 读入 cv2 . imshow 创建 
一个 窗口 显示 图片 共 两个 参数 第一 个 参数 
表示 窗口 名字 可以 创建 多个 窗口 中 但是 每个 
窗口 不能 重名 第二个 参数 是 读入 的 图片 cv2 
. waitKey 键盘 绑定 函数 共 一个 参数 表示 等待 
毫 秒数 将 等待 特定 的 几 毫秒 看 键盘 
是否 有 输入 返回值 为 ASCII 值 如果 其 参数 
为 0 则 表示 无限期 的 等待 键盘输入 cv2 . 
d e s t r o y A l l 
W i n d o w s 删除 建立 的 
全部 窗口 cv2 . destroyWindows 删除 指定 的 窗口 cv2 
. imwrite 保存 图片 共 两个 参数 第一个 为 保存 
文件名 第二个 为 读入 图片 Opencv 中 可以 通过 函数 
cv2 . pyrDown 和 cv2 . pyrUp 来 构建 金字塔 
函数 cv2 . pyrDown 是/v 从/p 一个/m 高/a 分辨率/n 图像/n 
变成/v 低分辨率/n 图像/n 的/uj cv2 . pyrDown 函数 接受 3个 
参数 tmp 当前 图像 初始 化为 原 图像 src dst 
目的 图像 显示 图像 为 输入 图像 的 一半 Size 
tmp . cols / 2 tmp . rows / 2 
目的 图像 大小 既然 我们 是 向下 采样 4 . 
凸 轮廓 与 Douglas Peucker 算法 大多数 处理 轮廓 的 
时候 物体 的 形状 包括 凸 形状 都是 变化 多样 
的 凸 形状 内部 的 任意 两点 之间 的 连线 
都在 该 形状 里面 cv2 . approxPloyDP 是 一个 OpenCV 
函数 它 用来 计算 近似 的 多边形 框 该 函数 
有 三个 参数 第一 个 参数 为 轮廓 第二个 参数 
为 ε 值 它 表示 源 轮廓 与 近似 多边形 
的 最大 差值 这个 值 越小 近似 多边形 与 源 
轮廓 越 接近 第三个 参数 为 布尔 标记 它 表示 
这个 多边形 是否 闭合 ε 值 对 获取 有用 的 
轮廓 非常重要 是 为所 得到 的 近似 多边形 周长 与 
源 轮廓 周长 之间 的 最大 差值 这个 差值 越小 
近似 多边形 与 源 轮廓 就越 相似 可 通过 OpenCV 
的 cv2 . arcLength 函数 来 得到 轮廓 的 周长 
信息 epsilon = 0.01 * cv2 . arcLength cnt True 
approx = cv2 . approxPolyDP cnt epsilon True 可 通过 
OpenCV 来 有效 地 计算 一个 近似 多边形 多边形 周长 
与 源 轮廓 周长 之比 就为 ε 为了 计算 凸 
形状 需要用 OpenCV 的 cv2 . convexHull 函数 来 获取 
处理 过 的 轮廓 信息 代码 为 hull = cv2 
. convexHull cnt 5 . 直线/n 和圆/nr 检测/vn Hough/w 变换/v 
是/v 直线/n 和/c 形状/n 检测/vn 背后/f 的/uj 理论/n 基础/n 5.1 
绘制 直线 函数 为 cv2 . line img Point pt1 
Point pt2 color thickness = 1 line _ type = 
8 shift = 0 有值的/nr 代表/n 有/v 默认值/l 不用 给 
也行 可以 看到 这个 函数 主要 接受 参数 为 两个 
点 的 坐标 线 的 颜色 彩色图像 的话 颜色 就 
是 一个 1 * 3 的 数组 import cv2 import 
numpy as np from matplotlib import pyplot as plt img 
= np . zeros 512 512 np . uint8 # 
生成 一个 空 灰度 图像 cv2 . line img 0 
0 511 511 255 5 plt . imshow img gray 
plt . show import cv2 import numpy as np from 
matplotlib import pyplot as plt img = np . zeros 
512 512 3 np . uint8 # 生成 一个 空 
彩色图像 cv2 . line img 0 0 511 511 0 
255 0 5 plt . imshow img brg plt . 
show 5.2 直线 检测 直线 检测 可通过 HoughLines 和 HoughLinesP 
函数 来 完成 它们 仅有 的 差别 是 第一 个 
函数 使用 标准 的 Hough 变换 第二个 函数 使用 概率 
Hough 变换 HoughLinesP 函数 之所以 成为 概率 版本 的 Hough 
变换 是因为 它 只 通过 分析 点 的 子集 并 
估计 这些 点 都 属于 一条 直线 的 概率 这是 
标准 Hough 变换 的 优化 版本 该 函数 的 计算 
代价 会 少 一些 执行 会 变得 更快 import cv2 
import numpy as np img = cv2 . imread lines 
. jpg gray = cv2 . cvtColor img cv2 . 
COLOR _ BGR2GRAY edges = cv2 . Canny gray 50 
120 minLineLength = 20 maxLineGap = 5 lines = cv2 
. HoughLinesP edges 1 np . pi / 180 100 
minLineLength maxLineGap for x1 y1 x2 y2 in lines 0 
cv2 . line img x1 y1 x2 y2 0 255 
0 2 cv2 . imshow edges edges cv2 . imshow 
lines img cv2 . waitKey cv2 . d e s 
t r o y A l l W i n 
d o w s HoughLines 函数 会 接收 一个 由 
Canny 边缘 检测 滤波器 处理 过 的 单通道 二 值 
图像 不一定 需要 Canny 滤波器 但是 一个 经过 去 噪 
并 只有 边缘 的 图像 当作 Hough 变换 的 输入 
会 很不错 HoughLinesP 的 参数 需要 处理 的 参数 线段 
的 几何 表示 rho 和 theta 一般 分别 取 1 
和 np . pi / 180 阈值 低于 该 阈值 
的 直线 会被 忽略 Hough 变换 可以 理解 为 投票箱 
和 投票数 之间 的 关系 每一个 投票箱 代表 一个 直线 
投票数 达到 阈值 的 直线 会被 保留 其他 的 会被 
删除 minLineLength 和 maxLineGap5 . 3 绘制 圆 绘制 圆形 
只 需要 确定 圆心 与 半径 函数   cv2 . 
circle img 380 0 63 255 0 0 3 import 
cv2 import numpy as np from matplotlib import pyplot as 
plt img = np . zeros 512 512 3 np 
. uint8 # 生成 一个 空 彩色图像 cv2 . circle 
img 100 100 50 55 255 155 5 plt . 
imshow img brg plt . show 5.4 圆 检测 OpenCV 
的 HoughCircles 函数 可 用来 检测 圆 它 与 使用 
HoughLines 函数 类似 像用 来 决定 删除 或 保留 直线 
的 两个 参数 minLineLength 和 maxLineGap 一样 HoughCircles/w 有/v 一个/m 
圆/n 心间/n 的/uj 最小/a 距离/n 和圆的/nr 最小/a 及/c 最大/a 半径/n 
import cv2 import numpy as np planets = cv2 . 
imread planet _ glow . jpg gray _ img = 
cv2 . cvtColor planets cv2 . COLOR _ BGR2GRAY img 
= cv2 . medianBlur gray _ img 5 cimg = 
cv2 . cvtColor img cv2 . COLOR _ GRAY2BGR circles 
= cv2 . HoughCircles img cv2 . HOUGH _ GRADIENT 
1 120 param1 = 100 param2 = 30 minRadius = 
0 maxRadius = 0 circles = np . uint16 np 
. around circles for i in circles 0 # draw 
the outer circle cv2 . circle planets i 0 i 
1 i 2 0 255 0 2 # draw the 
center of the circle cv2 . circle planets i 0 
i 1 2 0 0 255 3 cv2 . imwrite 
planets _ circles . jpg planets cv2 . imshow HoughCircles 
planets cv2 . waitKey cv2 . d e s t 
r o y A l l W i n d 
o w s 运行 结果 为 5.5 绘制 椭圆 椭圆 
涉及到 长轴 短 轴 椭圆 圆心 旋转 角度 等 import 
cv2 import numpy as np from matplotlib import pyplot as 
plt img = np . zeros 512 512 3 np 
. uint8 # 生成 一个 空 彩色图像 cv2 . ellipse 
img 256 256 150 100 0 0 180 250 1 
# 注意 最后 一个 参数 1 表示 对 图像 进行 
填充 默认 是 不 填充 的 如果 去掉 只有 椭圆 
轮廓 了 plt . imshow img brg plt . show 
6 . 检测 其他 形状 Hough 变换 能 检测 的 
形状 仅限于 圆 前面 提到 过 检测 任何 形状 的 
方法 特别 是 用 approxPloyDP 函数 来 检测 该 函数 
提供 多边形 的 近似 所以 如果 你 的 图像 有 
多边形 再结合 cv2 . findContours 函数 和 cv2 . approxPloyDP 
函数 就能 相当 准确 地 检测 出来 1 . Canny 边缘 检测 OpenCV 提供 了 Canny 函数 
来 识别 边缘 Canny 边缘 检测 算法 有 5个 步骤 
使用 高斯 滤波器 对 图像 进行 去 噪 计算 梯度 
在 边缘 上 使用 非 最大 抑制 NMS 在 检测 
到 的 边缘 上 使用 双 阈值 去除 假 阳性 
false positive 最后 还 会 分析 所有 的 边缘 及其 
之间 的 连接 以 保留 真正 的 边缘 并 消除 
不 明显 的 边缘 import cv2 import numpy as np 
img = cv2 . imread flower . jpg cv2 . 
imwrite canny . jpg cv2 . Canny img 200 300 
cv2 . imshow image img cv2 . imshow canny cv2 
. imread canny . jpg cv2 . waitKey cv2 . 
d e s t r o y A l l 
W i n d o w s 运行 结果 为 
2 . 轮廓 检测 在 计算机 视觉 中 轮廓 检测 
不 仅用 来 检测 图像 或者 视频 帧 中 物体 
的 轮廓 而且 还有 其他 操作 与 轮廓 检测 有关 
如 计算 多边形 边界 形状 逼近 和 计算 感兴趣 区域 
这是 与 图像 数据 交互 时的/nr 简单 操作 因为 NumPy 
中的 矩形 区域 可以 使用 数组 切片 slice 来 定义 
在 物体 检测 包括 人脸 和 物体 跟踪 时会 大量 
使用 import cv2import numpy as npimg = np . zeros 
200 200 dtype = np . uint8 # 创建 一个 
200x200 大小 的 黑色 空白 图像 img 50 150 50 
150 = 255 # 在 图像 的 中央 放置 一个 
白色 方块 ret thresh = cv2 . threshold img 127 
255 0 # 对 图像 进行 二 值 化 操作 
image contours hierarchy = cv2 . findContours thresh cv2 . 
RETR _ TREE cv2 . CHAIN _ APPROX _ SIMPLE 
# 寻找 轮廓 color = cv2 . cvtColor img cv2 
. COLOR _ GRAY2BGR # 颜色 空间 转换 img = 
cv2 . drawContours color contours 1 0 255 0 2 
# 画出 轮廓 1 表示 所有 轮廓 画笔 颜色 为 
0 255 0 即 Green 粗细 为 3cv2 . imshow 
contours color cv2 . waitKey cv2 . d e s 
t r o y A l l W i n 
d o w s findContours 函数 有 三个 参数 输入 
图像 层次 类型 和 轮廓 逼近 方法 这个 函数 会 
修改 输入 图像 因此 建议 使用 原始 图像 的 一份 
拷贝 如 通过 img . copy 来 作为 输入 图像 
由 函数 返回 的 层次 树 相当 重要 cv2 . 
RETR _ TREE 参数 会 得到 图像 中 轮廓 的 
整体 层次结构 以此 来 建立 轮廓 之间 的 关系 如果 
只 想得到 最 外面 的 轮廓 可使用 cv2 . RETR 
_ EXTERNAL 这对 消除 包含 在 其他 轮廓 中的 轮廓 
很 有用 如在 大多数 情形 下 不 需要 检测 一个 
目标 包含 在 另一个 与之 相同 的 目标 里面 findContours 
函数 有 三个 返回值 修改后 的 图像 图像 的 轮廓 
以及 它们 的 层次 使用 轮廓 来 画出 图像 的 
彩色 版本 即把 轮廓 画成 绿色 并 显示 出来 cv2 
. threshold 简单 阈值 这个 函数 有 四个 参数 第一 
个 原 图像 第二 个 进行 分类 的 阈值 第三个 
是 高于 低于 阈值 时 赋予 的 新 值 第四个 
是 一个 方法 选择 参数 常用 的 有 cv2 . 
THRESH _ BINARY 黑 白二 值 cv2 . THRESH _ 
BINARY _ INV 黑 白二 值 反转 cv2 . THRESH 
_ TRUNC 得到 的 图像 为多 像素 值 cv2 . 
THRESH _ TOZEROcv2 . THRESH _ TOZERO _ INV 该 
函数 有 两个 返回值 第一 个 retVal 得到 的 阈值 
在后面 一个 方法 中会 用到 第二 个 就是 阈值 化 
后的/nr 图像 cvCvtColor . . . 是 Opencv 里 的 
颜色 空间 转换 函数 可以 实现 RGB 颜色 向 HSV 
HSI 等 颜色 空间 的 转换 也 可以 转 换为 
灰度 图像 参数 CV _ RGB2GRAY 是 RGB 到 gray 
参数 CV _ GRAY2RGB 是 gray 到 RGB . 处理 
结果 是 彩色 的 则 转 灰色 就是 了 运行 
结果 为 3 . 边界 框 最小 矩形 区域 和 
最小 闭 圆 的 轮廓 可用 OpenCV 的 cv2 . 
findContours 函数 找到 不规则 的 歪斜 的 以及 旋转 的 
形状 现实 的 应用 会 对 目标 的 边界 框 
最小 矩形 面积 最小 闭 圆 特别 感兴趣 3.1 绘制 
矩形 函数 cv2 . rectangle img 380 0 511 111 
255 0 0 3 需要 确定 的 就是 矩形 的 
两个 点 左上角 与 右下角 颜色 线 的 类型 不 
设置 就 默认 import cv2 import numpy as np from 
matplotlib import pyplot as plt img = np . zeros 
512 512 3 np . uint8 # 生成 一个 空 
彩色图像 cv2 . rectangle img 20 20 411 411 55 
255 155 5 plt . imshow img brg plt . 
show import cv2 import numpy as np img = cv2 
. pyrDown cv2 . imread hammer . jpg cv2 . 
IMREAD _ UNCHANGED ret thresh = cv2 . threshold cv2 
. cvtColor img . copy cv2 . COLOR _ BGR2GRAY 
127 255 cv2 . THRESH _ BINARY image contours hier 
= cv2 . findContours thresh cv2 . RETR _ EXTERNAL 
cv2 . CHAIN _ APPROX _ SIMPLE for c in 
contours # find bounding box coordinates # 现 计算 出 
一个 简单 的 边界 框 x y w h = 
cv2 . boundingRect c # 将 轮廓 信息 转换成 x 
y 坐标 并 加上 矩形 的 高度 和 宽度 cv2 
. rectangle img x y x + w y + 
h 0 255 0 2 # 画出 矩形 # find 
minimum area # 计算 包围 目标 的 最小 矩形 区域 
rect = cv2 . minAreaRect c # calculate coordinate of 
the minimum area rectangle box = cv2 . boxPoints rect 
# normalize coordinates to integers box = np . int0 
box # 注 OpenCV/w 没有/v 函数/n 能/v 直接/ad 从/p 轮廓/n 
信息/n 中/f 计算出/i 最小/a 矩形/n 顶点/n 的/uj 坐标/v 所以 需要 
计算出 最小 矩形 区域 # 然后 计算 这个 矩形 的 
顶点 由于 计算 出来 的 顶点 坐标 是 浮点 型 
但是 所得 像素 的 坐标值 是 整数 不能 获取 像素 
的 一部分 # 所以 需要 做 一个 转换 # draw 
contours cv2 . drawContours img box 0 0 0 255 
3 # 画出 该 矩形 # calculate center and radius 
of minimum enclosing circle x y radius = cv2 . 
m i n E n c l o s i 
n g C i r c l e c # 
会 返回 一个 二 元组 第一 个 元素 为 圆心 
的 坐标 组成 的 元组 第二 个 元素 为 圆 
的 半径 值 # cast to integers center = int 
x int y radius = int radius # draw the 
circle img = cv2 . circle img center radius 0 
255 0 2 cv2 . drawContours img contours 1 255 
0 0 1 cv2 . imshow contours img cv2 . 
waitKey cv2 . d e s t r o y 
A l l W i n d o w s 
运行 结果 为 在 导入 模块 后 加载 图像 然后 
在 源 图像 的 灰度 图像 上 执行 一个 二 
值 化 操作 这样 做 之后 可 在 这个 灰度 
图像 上 执行 所有 计算 轮廓 的 操作 但在 源 
图像 上 可 利用 色彩 信息 来 画 这些 轮廓 
cv2 . drawContours img box 0 0 0 255 3 
首先 该 函数 与 所有 绘图 函数 一样 它 会 
修改 源 图像 其次 该 函数 的 第二 个 参数 
接收 一个 保存着 轮廓 的 数组 从而 可以 在 一次 
操作 中 绘制 一 系列 的 轮廓 因此 如果 只有 
一组 点来 表示 多边形 轮廓 就 需要 把 这组 点 
放到 一个 数 组里 该 函数 的 第三 个 参数 
是 要 绘制 的 轮廓 数组 的 索引 1 表示 
绘制 所有 的 轮廓 否则 只会 绘制 轮廓 数 组里 
指定 的 轮廓 大多数 绘图 函数 把 绘图 的 颜色 
和 密度 thickness 放在 最后 两个 参 数里 函数 介绍 
cv2 . imread 读入 图片 共 两个 参数 第一 个 
参数 为要 读入 的 图片 文件名 第二个 参数 为 如何 
读取 图片 包括 cv2 . IMREAD _ COLOR 读入 一副 
彩色图片 cv2 . IMREAD _ GRAYSCALE 以 灰度 模式 读入 
图片 cv2 . IMREAD _ UNCHANGED 读入 一幅 图片 并 
包括 其 alpha 通道 cv2 . imread flower . jpg 
0 表示 已 灰度 模式 读入 cv2 . imshow 创建 
一个 窗口 显示 图片 共 两个 参数 第一 个 参数 
表示 窗口 名字 可以 创建 多个 窗口 中 但是 每个 
窗口 不能 重名 第二个 参数 是 读入 的 图片 cv2 
. waitKey 键盘 绑定 函数 共 一个 参数 表示 等待 
毫 秒数 将 等待 特定 的 几 毫秒 看 键盘 
是否 有 输入 返回值 为 ASCII 值 如果 其 参数 
为 0 则 表示 无限期 的 等待 键盘输入 cv2 . 
d e s t r o y A l l 
W i n d o w s 删除 建立 的 
全部 窗口 cv2 . destroyWindows 删除 指定 的 窗口 cv2 
. imwrite 保存 图片 共 两个 参数 第一个 为 保存 
文件名 第二个 为 读入 图片 Opencv 中 可以 通过 函数 
cv2 . pyrDown 和 cv2 . pyrUp 来 构建 金字塔 
函数 cv2 . pyrDown 是/v 从/p 一个/m 高/a 分辨率/n 图像/n 
变成/v 低分辨率/n 图像/n 的/uj cv2 . pyrDown 函数 接受 3个 
参数 tmp 当前 图像 初始 化为 原 图像 src dst 
目的 图像 显示 图像 为 输入 图像 的 一半 Size 
tmp . cols / 2 tmp . rows / 2 
目的 图像 大小 既然 我们 是 向下 采样 4 . 
凸 轮廓 与 Douglas Peucker 算法 大多数 处理 轮廓 的 
时候 物体 的 形状 包括 凸 形状 都是 变化 多样 
的 凸 形状 内部 的 任意 两点 之间 的 连线 
都在 该 形状 里面 cv2 . approxPloyDP 是 一个 OpenCV 
函数 它 用来 计算 近似 的 多边形 框 该 函数 
有 三个 参数 第一 个 参数 为 轮廓 第二个 参数 
为 ε 值 它 表示 源 轮廓 与 近似 多边形 
的 最大 差值 这个 值 越小 近似 多边形 与 源 
轮廓 越 接近 第三个 参数 为 布尔 标记 它 表示 
这个 多边形 是否 闭合 ε 值 对 获取 有用 的 
轮廓 非常重要 是 为所 得到 的 近似 多边形 周长 与 
源 轮廓 周长 之间 的 最大 差值 这个 差值 越小 
近似 多边形 与 源 轮廓 就越 相似 可 通过 OpenCV 
的 cv2 . arcLength 函数 来 得到 轮廓 的 周长 
信息 epsilon = 0.01 * cv2 . arcLength cnt True 
approx = cv2 . approxPolyDP cnt epsilon True 可 通过 
OpenCV 来 有效 地 计算 一个 近似 多边形 多边形 周长 
与 源 轮廓 周长 之比 就为 ε 为了 计算 凸 
形状 需要用 OpenCV 的 cv2 . convexHull 函数 来 获取 
处理 过 的 轮廓 信息 代码 为 hull = cv2 
. convexHull cnt 5 . 直线/n 和圆/nr 检测/vn Hough/w 变换/v 
是/v 直线/n 和/c 形状/n 检测/vn 背后/f 的/uj 理论/n 基础/n 5.1 
绘制 直线 函数 为 cv2 . line img Point pt1 
Point pt2 color thickness = 1 line _ type = 
8 shift = 0 有值的/nr 代表/n 有/v 默认值/l 不用 给 
也行 可以 看到 这个 函数 主要 接受 参数 为 两个 
点 的 坐标 线 的 颜色 彩色图像 的话 颜色 就 
是 一个 1 * 3 的 数组 import cv2 import 
numpy as np from matplotlib import pyplot as plt img 
= np . zeros 512 512 np . uint8 # 
生成 一个 空 灰度 图像 cv2 . line img 0 
0 511 511 255 5 plt . imshow img gray 
plt . show import cv2 import numpy as np from 
matplotlib import pyplot as plt img = np . zeros 
512 512 3 np . uint8 # 生成 一个 空 
彩色图像 cv2 . line img 0 0 511 511 0 
255 0 5 plt . imshow img brg plt . 
show 5.2 直线 检测 直线 检测 可通过 HoughLines 和 HoughLinesP 
函数 来 完成 它们 仅有 的 差别 是 第一 个 
函数 使用 标准 的 Hough 变换 第二个 函数 使用 概率 
Hough 变换 HoughLinesP 函数 之所以 成为 概率 版本 的 Hough 
变换 是因为 它 只 通过 分析 点 的 子集 并 
估计 这些 点 都 属于 一条 直线 的 概率 这是 
标准 Hough 变换 的 优化 版本 该 函数 的 计算 
代价 会 少 一些 执行 会 变得 更快 import cv2 
import numpy as np img = cv2 . imread lines 
. jpg gray = cv2 . cvtColor img cv2 . 
COLOR _ BGR2GRAY edges = cv2 . Canny gray 50 
120 minLineLength = 20 maxLineGap = 5 lines = cv2 
. HoughLinesP edges 1 np . pi / 180 100 
minLineLength maxLineGap for x1 y1 x2 y2 in lines 0 
cv2 . line img x1 y1 x2 y2 0 255 
0 2 cv2 . imshow edges edges cv2 . imshow 
lines img cv2 . waitKey cv2 . d e s 
t r o y A l l W i n 
d o w s HoughLines 函数 会 接收 一个 由 
Canny 边缘 检测 滤波器 处理 过 的 单通道 二 值 
图像 不一定 需要 Canny 滤波器 但是 一个 经过 去 噪 
并 只有 边缘 的 图像 当作 Hough 变换 的 输入 
会 很不错 HoughLinesP 的 参数 需要 处理 的 参数 线段 
的 几何 表示 rho 和 theta 一般 分别 取 1 
和 np . pi / 180 阈值 低于 该 阈值 
的 直线 会被 忽略 Hough 变换 可以 理解 为 投票箱 
和 投票数 之间 的 关系 每一个 投票箱 代表 一个 直线 
投票数 达到 阈值 的 直线 会被 保留 其他 的 会被 
删除 minLineLength 和 maxLineGap5 . 3 绘制 圆 绘制 圆形 
只 需要 确定 圆心 与 半径 函数   cv2 . 
circle img 380 0 63 255 0 0 3 import 
cv2 import numpy as np from matplotlib import pyplot as 
plt img = np . zeros 512 512 3 np 
. uint8 # 生成 一个 空 彩色图像 cv2 . circle 
img 100 100 50 55 255 155 5 plt . 
imshow img brg plt . show 5.4 圆 检测 OpenCV 
的 HoughCircles 函数 可 用来 检测 圆 它 与 使用 
HoughLines 函数 类似 像用 来 决定 删除 或 保留 直线 
的 两个 参数 minLineLength 和 maxLineGap 一样 HoughCircles/w 有/v 一个/m 
圆/n 心间/n 的/uj 最小/a 距离/n 和圆的/nr 最小/a 及/c 最大/a 半径/n 
import cv2 import numpy as np planets = cv2 . 
imread planet _ glow . jpg gray _ img = 
cv2 . cvtColor planets cv2 . COLOR _ BGR2GRAY img 
= cv2 . medianBlur gray _ img 5 cimg = 
cv2 . cvtColor img cv2 . COLOR _ GRAY2BGR circles 
= cv2 . HoughCircles img cv2 . HOUGH _ GRADIENT 
1 120 param1 = 100 param2 = 30 minRadius = 
0 maxRadius = 0 circles = np . uint16 np 
. around circles for i in circles 0 # draw 
the outer circle cv2 . circle planets i 0 i 
1 i 2 0 255 0 2 # draw the 
center of the circle cv2 . circle planets i 0 
i 1 2 0 0 255 3 cv2 . imwrite 
planets _ circles . jpg planets cv2 . imshow HoughCircles 
planets cv2 . waitKey cv2 . d e s t 
r o y A l l W i n d 
o w s 运行 结果 为 5.5 绘制 椭圆 椭圆 
涉及到 长轴 短 轴 椭圆 圆心 旋转 角度 等 import 
cv2 import numpy as np from matplotlib import pyplot as 
plt img = np . zeros 512 512 3 np 
. uint8 # 生成 一个 空 彩色图像 cv2 . ellipse 
img 256 256 150 100 0 0 180 250 1 
# 注意 最后 一个 参数 1 表示 对 图像 进行 
填充 默认 是 不 填充 的 如果 去掉 只有 椭圆 
轮廓 了 plt . imshow img brg plt . show 
6 . 检测 其他 形状 Hough 变换 能 检测 的 
形状 仅限于 圆 前面 提到 过 检测 任何 形状 的 
方法 特别 是 用 approxPloyDP 函数 来 检测 该 函数 
提供 多边形 的 近似 所以 如果 你 的 图像 有 
多边形 再结合 cv2 . findContours 函数 和 cv2 . approxPloyDP 
函数 就能 相当 准确 地 检测 出来 1 . Canny 边缘 检测 OpenCV 提供 了 Canny 函数 
来 识别 边缘 Canny 边缘 检测 算法 有 5个 步骤 
使用 高斯 滤波器 对 图像 进行 去 噪 计算 梯度 
在 边缘 上 使用 非 最大 抑制 NMS 在 检测 
到 的 边缘 上 使用 双 阈值 去除 假 阳性 
false positive 最后 还 会 分析 所有 的 边缘 及其 
之间 的 连接 以 保留 真正 的 边缘 并 消除 
不 明显 的 边缘 import cv2 import numpy as np 
img = cv2 . imread flower . jpg cv2 . 
imwrite canny . jpg cv2 . Canny img 200 300 
cv2 . imshow image img cv2 . imshow canny cv2 
. imread canny . jpg cv2 . waitKey cv2 . 
d e s t r o y A l l 
W i n d o w s 运行 结果 为 
2 . 轮廓 检测 在 计算机 视觉 中 轮廓 检测 
不 仅用 来 检测 图像 或者 视频 帧 中 物体 
的 轮廓 而且 还有 其他 操作 与 轮廓 检测 有关 
如 计算 多边形 边界 形状 逼近 和 计算 感兴趣 区域 
这是 与 图像 数据 交互 时的/nr 简单 操作 因为 NumPy 
中的 矩形 区域 可以 使用 数组 切片 slice 来 定义 
在 物体 检测 包括 人脸 和 物体 跟踪 时会 大量 
使用 import cv2import numpy as npimg = np . zeros 
200 200 dtype = np . uint8 # 创建 一个 
200x200 大小 的 黑色 空白 图像 img 50 150 50 
150 = 255 # 在 图像 的 中央 放置 一个 
白色 方块 ret thresh = cv2 . threshold img 127 
255 0 # 对 图像 进行 二 值 化 操作 
image contours hierarchy = cv2 . findContours thresh cv2 . 
RETR _ TREE cv2 . CHAIN _ APPROX _ SIMPLE 
# 寻找 轮廓 color = cv2 . cvtColor img cv2 
. COLOR _ GRAY2BGR # 颜色 空间 转换 img = 
cv2 . drawContours color contours 1 0 255 0 2 
# 画出 轮廓 1 表示 所有 轮廓 画笔 颜色 为 
0 255 0 即 Green 粗细 为 3cv2 . imshow 
contours color cv2 . waitKey cv2 . d e s 
t r o y A l l W i n 
d o w s findContours 函数 有 三个 参数 输入 
图像 层次 类型 和 轮廓 逼近 方法 这个 函数 会 
修改 输入 图像 因此 建议 使用 原始 图像 的 一份 
拷贝 如 通过 img . copy 来 作为 输入 图像 
由 函数 返回 的 层次 树 相当 重要 cv2 . 
RETR _ TREE 参数 会 得到 图像 中 轮廓 的 
整体 层次结构 以此 来 建立 轮廓 之间 的 关系 如果 
只 想得到 最 外面 的 轮廓 可使用 cv2 . RETR 
_ EXTERNAL 这对 消除 包含 在 其他 轮廓 中的 轮廓 
很 有用 如在 大多数 情形 下 不 需要 检测 一个 
目标 包含 在 另一个 与之 相同 的 目标 里面 findContours 
函数 有 三个 返回值 修改后 的 图像 图像 的 轮廓 
以及 它们 的 层次 使用 轮廓 来 画出 图像 的 
彩色 版本 即把 轮廓 画成 绿色 并 显示 出来 cv2 
. threshold 简单 阈值 这个 函数 有 四个 参数 第一 
个 原 图像 第二 个 进行 分类 的 阈值 第三个 
是 高于 低于 阈值 时 赋予 的 新 值 第四个 
是 一个 方法 选择 参数 常用 的 有 cv2 . 
THRESH _ BINARY 黑 白二 值 cv2 . THRESH _ 
BINARY _ INV 黑 白二 值 反转 cv2 . THRESH 
_ TRUNC 得到 的 图像 为多 像素 值 cv2 . 
THRESH _ TOZEROcv2 . THRESH _ TOZERO _ INV 该 
函数 有 两个 返回值 第一 个 retVal 得到 的 阈值 
在后面 一个 方法 中会 用到 第二 个 就是 阈值 化 
后的/nr 图像 cvCvtColor . . . 是 Opencv 里 的 
颜色 空间 转换 函数 可以 实现 RGB 颜色 向 HSV 
HSI 等 颜色 空间 的 转换 也 可以 转 换为 
灰度 图像 参数 CV _ RGB2GRAY 是 RGB 到 gray 
参数 CV _ GRAY2RGB 是 gray 到 RGB . 处理 
结果 是 彩色 的 则 转 灰色 就是 了 运行 
结果 为 3 . 边界 框 最小 矩形 区域 和 
最小 闭 圆 的 轮廓 可用 OpenCV 的 cv2 . 
findContours 函数 找到 不规则 的 歪斜 的 以及 旋转 的 
形状 现实 的 应用 会 对 目标 的 边界 框 
最小 矩形 面积 最小 闭 圆 特别 感兴趣 3.1 绘制 
矩形 函数 cv2 . rectangle img 380 0 511 111 
255 0 0 3 需要 确定 的 就是 矩形 的 
两个 点 左上角 与 右下角 颜色 线 的 类型 不 
设置 就 默认 import cv2 import numpy as np from 
matplotlib import pyplot as plt img = np . zeros 
512 512 3 np . uint8 # 生成 一个 空 
彩色图像 cv2 . rectangle img 20 20 411 411 55 
255 155 5 plt . imshow img brg plt . 
show import cv2 import numpy as np img = cv2 
. pyrDown cv2 . imread hammer . jpg cv2 . 
IMREAD _ UNCHANGED ret thresh = cv2 . threshold cv2 
. cvtColor img . copy cv2 . COLOR _ BGR2GRAY 
127 255 cv2 . THRESH _ BINARY image contours hier 
= cv2 . findContours thresh cv2 . RETR _ EXTERNAL 
cv2 . CHAIN _ APPROX _ SIMPLE for c in 
contours # find bounding box coordinates # 现 计算 出 
一个 简单 的 边界 框 x y w h = 
cv2 . boundingRect c # 将 轮廓 信息 转换成 x 
y 坐标 并 加上 矩形 的 高度 和 宽度 cv2 
. rectangle img x y x + w y + 
h 0 255 0 2 # 画出 矩形 # find 
minimum area # 计算 包围 目标 的 最小 矩形 区域 
rect = cv2 . minAreaRect c # calculate coordinate of 
the minimum area rectangle box = cv2 . boxPoints rect 
# normalize coordinates to integers box = np . int0 
box # 注 OpenCV/w 没有/v 函数/n 能/v 直接/ad 从/p 轮廓/n 
信息/n 中/f 计算出/i 最小/a 矩形/n 顶点/n 的/uj 坐标/v 所以 需要 
计算出 最小 矩形 区域 # 然后 计算 这个 矩形 的 
顶点 由于 计算 出来 的 顶点 坐标 是 浮点 型 
但是 所得 像素 的 坐标值 是 整数 不能 获取 像素 
的 一部分 # 所以 需要 做 一个 转换 # draw 
contours cv2 . drawContours img box 0 0 0 255 
3 # 画出 该 矩形 # calculate center and radius 
of minimum enclosing circle x y radius = cv2 . 
m i n E n c l o s i 
n g C i r c l e c # 
会 返回 一个 二 元组 第一 个 元素 为 圆心 
的 坐标 组成 的 元组 第二 个 元素 为 圆 
的 半径 值 # cast to integers center = int 
x int y radius = int radius # draw the 
circle img = cv2 . circle img center radius 0 
255 0 2 cv2 . drawContours img contours 1 255 
0 0 1 cv2 . imshow contours img cv2 . 
waitKey cv2 . d e s t r o y 
A l l W i n d o w s 
运行 结果 为 在 导入 模块 后 加载 图像 然后 
在 源 图像 的 灰度 图像 上 执行 一个 二 
值 化 操作 这样 做 之后 可 在 这个 灰度 
图像 上 执行 所有 计算 轮廓 的 操作 但在 源 
图像 上 可 利用 色彩 信息 来 画 这些 轮廓 
cv2 . drawContours img box 0 0 0 255 3 
首先 该 函数 与 所有 绘图 函数 一样 它 会 
修改 源 图像 其次 该 函数 的 第二 个 参数 
接收 一个 保存着 轮廓 的 数组 从而 可以 在 一次 
操作 中 绘制 一 系列 的 轮廓 因此 如果 只有 
一组 点来 表示 多边形 轮廓 就 需要 把 这组 点 
放到 一个 数 组里 该 函数 的 第三 个 参数 
是 要 绘制 的 轮廓 数组 的 索引 1 表示 
绘制 所有 的 轮廓 否则 只会 绘制 轮廓 数 组里 
指定 的 轮廓 大多数 绘图 函数 把 绘图 的 颜色 
和 密度 thickness 放在 最后 两个 参 数里 函数 介绍 
cv2 . imread 读入 图片 共 两个 参数 第一 个 
参数 为要 读入 的 图片 文件名 第二个 参数 为 如何 
读取 图片 包括 cv2 . IMREAD _ COLOR 读入 一副 
彩色图片 cv2 . IMREAD _ GRAYSCALE 以 灰度 模式 读入 
图片 cv2 . IMREAD _ UNCHANGED 读入 一幅 图片 并 
包括 其 alpha 通道 cv2 . imread flower . jpg 
0 表示 已 灰度 模式 读入 cv2 . imshow 创建 
一个 窗口 显示 图片 共 两个 参数 第一 个 参数 
表示 窗口 名字 可以 创建 多个 窗口 中 但是 每个 
窗口 不能 重名 第二个 参数 是 读入 的 图片 cv2 
. waitKey 键盘 绑定 函数 共 一个 参数 表示 等待 
毫 秒数 将 等待 特定 的 几 毫秒 看 键盘 
是否 有 输入 返回值 为 ASCII 值 如果 其 参数 
为 0 则 表示 无限期 的 等待 键盘输入 cv2 . 
d e s t r o y A l l 
W i n d o w s 删除 建立 的 
全部 窗口 cv2 . destroyWindows 删除 指定 的 窗口 cv2 
. imwrite 保存 图片 共 两个 参数 第一个 为 保存 
文件名 第二个 为 读入 图片 Opencv 中 可以 通过 函数 
cv2 . pyrDown 和 cv2 . pyrUp 来 构建 金字塔 
函数 cv2 . pyrDown 是/v 从/p 一个/m 高/a 分辨率/n 图像/n 
变成/v 低分辨率/n 图像/n 的/uj cv2 . pyrDown 函数 接受 3个 
参数 tmp 当前 图像 初始 化为 原 图像 src dst 
目的 图像 显示 图像 为 输入 图像 的 一半 Size 
tmp . cols / 2 tmp . rows / 2 
目的 图像 大小 既然 我们 是 向下 采样 4 . 
凸 轮廓 与 Douglas Peucker 算法 大多数 处理 轮廓 的 
时候 物体 的 形状 包括 凸 形状 都是 变化 多样 
的 凸 形状 内部 的 任意 两点 之间 的 连线 
都在 该 形状 里面 cv2 . approxPloyDP 是 一个 OpenCV 
函数 它 用来 计算 近似 的 多边形 框 该 函数 
有 三个 参数 第一 个 参数 为 轮廓 第二个 参数 
为 ε 值 它 表示 源 轮廓 与 近似 多边形 
的 最大 差值 这个 值 越小 近似 多边形 与 源 
轮廓 越 接近 第三个 参数 为 布尔 标记 它 表示 
这个 多边形 是否 闭合 ε 值 对 获取 有用 的 
轮廓 非常重要 是 为所 得到 的 近似 多边形 周长 与 
源 轮廓 周长 之间 的 最大 差值 这个 差值 越小 
近似 多边形 与 源 轮廓 就越 相似 可 通过 OpenCV 
的 cv2 . arcLength 函数 来 得到 轮廓 的 周长 
信息 epsilon = 0.01 * cv2 . arcLength cnt True 
approx = cv2 . approxPolyDP cnt epsilon True 可 通过 
OpenCV 来 有效 地 计算 一个 近似 多边形 多边形 周长 
与 源 轮廓 周长 之比 就为 ε 为了 计算 凸 
形状 需要用 OpenCV 的 cv2 . convexHull 函数 来 获取 
处理 过 的 轮廓 信息 代码 为 hull = cv2 
. convexHull cnt 5 . 直线/n 和圆/nr 检测/vn Hough/w 变换/v 
是/v 直线/n 和/c 形状/n 检测/vn 背后/f 的/uj 理论/n 基础/n 5.1 
绘制 直线 函数 为 cv2 . line img Point pt1 
Point pt2 color thickness = 1 line _ type = 
8 shift = 0 有值的/nr 代表/n 有/v 默认值/l 不用 给 
也行 可以 看到 这个 函数 主要 接受 参数 为 两个 
点 的 坐标 线 的 颜色 彩色图像 的话 颜色 就 
是 一个 1 * 3 的 数组 import cv2 import 
numpy as np from matplotlib import pyplot as plt img 
= np . zeros 512 512 np . uint8 # 
生成 一个 空 灰度 图像 cv2 . line img 0 
0 511 511 255 5 plt . imshow img gray 
plt . show import cv2 import numpy as np from 
matplotlib import pyplot as plt img = np . zeros 
512 512 3 np . uint8 # 生成 一个 空 
彩色图像 cv2 . line img 0 0 511 511 0 
255 0 5 plt . imshow img brg plt . 
show 5.2 直线 检测 直线 检测 可通过 HoughLines 和 HoughLinesP 
函数 来 完成 它们 仅有 的 差别 是 第一 个 
函数 使用 标准 的 Hough 变换 第二个 函数 使用 概率 
Hough 变换 HoughLinesP 函数 之所以 成为 概率 版本 的 Hough 
变换 是因为 它 只 通过 分析 点 的 子集 并 
估计 这些 点 都 属于 一条 直线 的 概率 这是 
标准 Hough 变换 的 优化 版本 该 函数 的 计算 
代价 会 少 一些 执行 会 变得 更快 import cv2 
import numpy as np img = cv2 . imread lines 
. jpg gray = cv2 . cvtColor img cv2 . 
COLOR _ BGR2GRAY edges = cv2 . Canny gray 50 
120 minLineLength = 20 maxLineGap = 5 lines = cv2 
. HoughLinesP edges 1 np . pi / 180 100 
minLineLength maxLineGap for x1 y1 x2 y2 in lines 0 
cv2 . line img x1 y1 x2 y2 0 255 
0 2 cv2 . imshow edges edges cv2 . imshow 
lines img cv2 . waitKey cv2 . d e s 
t r o y A l l W i n 
d o w s HoughLines 函数 会 接收 一个 由 
Canny 边缘 检测 滤波器 处理 过 的 单通道 二 值 
图像 不一定 需要 Canny 滤波器 但是 一个 经过 去 噪 
并 只有 边缘 的 图像 当作 Hough 变换 的 输入 
会 很不错 HoughLinesP 的 参数 需要 处理 的 参数 线段 
的 几何 表示 rho 和 theta 一般 分别 取 1 
和 np . pi / 180 阈值 低于 该 阈值 
的 直线 会被 忽略 Hough 变换 可以 理解 为 投票箱 
和 投票数 之间 的 关系 每一个 投票箱 代表 一个 直线 
投票数 达到 阈值 的 直线 会被 保留 其他 的 会被 
删除 minLineLength 和 maxLineGap5 . 3 绘制 圆 绘制 圆形 
只 需要 确定 圆心 与 半径 函数   cv2 . 
circle img 380 0 63 255 0 0 3 import 
cv2 import numpy as np from matplotlib import pyplot as 
plt img = np . zeros 512 512 3 np 
. uint8 # 生成 一个 空 彩色图像 cv2 . circle 
img 100 100 50 55 255 155 5 plt . 
imshow img brg plt . show 5.4 圆 检测 OpenCV 
的 HoughCircles 函数 可 用来 检测 圆 它 与 使用 
HoughLines 函数 类似 像用 来 决定 删除 或 保留 直线 
的 两个 参数 minLineLength 和 maxLineGap 一样 HoughCircles/w 有/v 一个/m 
圆/n 心间/n 的/uj 最小/a 距离/n 和圆的/nr 最小/a 及/c 最大/a 半径/n 
import cv2 import numpy as np planets = cv2 . 
imread planet _ glow . jpg gray _ img = 
cv2 . cvtColor planets cv2 . COLOR _ BGR2GRAY img 
= cv2 . medianBlur gray _ img 5 cimg = 
cv2 . cvtColor img cv2 . COLOR _ GRAY2BGR circles 
= cv2 . HoughCircles img cv2 . HOUGH _ GRADIENT 
1 120 param1 = 100 param2 = 30 minRadius = 
0 maxRadius = 0 circles = np . uint16 np 
. around circles for i in circles 0 # draw 
the outer circle cv2 . circle planets i 0 i 
1 i 2 0 255 0 2 # draw the 
center of the circle cv2 . circle planets i 0 
i 1 2 0 0 255 3 cv2 . imwrite 
planets _ circles . jpg planets cv2 . imshow HoughCircles 
planets cv2 . waitKey cv2 . d e s t 
r o y A l l W i n d 
o w s 运行 结果 为 5.5 绘制 椭圆 椭圆 
涉及到 长轴 短 轴 椭圆 圆心 旋转 角度 等 import 
cv2 import numpy as np from matplotlib import pyplot as 
plt img = np . zeros 512 512 3 np 
. uint8 # 生成 一个 空 彩色图像 cv2 . ellipse 
img 256 256 150 100 0 0 180 250 1 
# 注意 最后 一个 参数 1 表示 对 图像 进行 
填充 默认 是 不 填充 的 如果 去掉 只有 椭圆 
轮廓 了 plt . imshow img brg plt . show 
6 . 检测 其他 形状 Hough 变换 能 检测 的 
形状 仅限于 圆 前面 提到 过 检测 任何 形状 的 
方法 特别 是 用 approxPloyDP 函数 来 检测 该 函数 
提供 多边形 的 近似 所以 如果 你 的 图像 有 
多边形 再结合 cv2 . findContours 函数 和 cv2 . approxPloyDP 
函数 就能 相当 准确 地 检测 出来 