我 是 一名 初学者 如果 你 发现 文中 有错误 请 
留言 告诉 我 谢谢 如果 需要 检测 到 图像 里面 
的 边缘 首先 我们 需要 知道 边缘 处 具有 什么 
特征 对于 一幅 灰度 图像 来说 边缘 两边 的 灰度 
值 肯定 不 相同 这样 我们 才能 分辨出 哪里 是 
边缘 哪里 不是 因此 如果 我们 需要 检测 一个 灰度 
图像 的 边缘 我们 需要 找出 哪里 的 灰度 变化 
最大 显然 灰度 变化 越大 对比度 越强 边缘 就越 明显 
那么 问题 来了 我们 怎么 知道 哪里 灰度 变化 大 
哪里 灰度 变化 小 呢 导数 梯度 边缘 信息 在 
数学 中 与 变化 率 有关 的 就是 导数 如果 
灰度 图像 的 像素 是 连续 的 实际 不是 那么 
我们 可以 分别 原 图像 G 对 x 方向 和y/nr 
方向 求 导数 获得 x 方向 的 导数 图像 Gx 
和y/nr 方向 的 导数 图像 Gy Gx/w 和/c Gy/w 分别/d 
隐含/v 了/ul x/w 和y/nr 方向/n 的/uj 灰度/n 变化/vn 信息/n 也就 
隐含 了 边缘 信息 如果 要 在 同一 图像 上 
包含 两个 方向 的 边缘 信息 我们 可以 用 到 
梯度 梯度 是 一个 向量 原 图像 的 梯度 向量 
Gxy 为 Gx Gy 梯度 向量 的 大小 和 方向 
可以 用 下面 两个 式子 计算 角度 值 好像 需要 
根据 向量 所在 象限 不同 适当 + pi 或者 pi 
梯度 向量 大小 就 包含 了 x 方向 和y/nr 方向 
的 边缘 信息 图像 导数 实际上 图像 矩阵 是 离散 
的 连续函数 求 变化率 用 的 是 导数 而 离散 
函数 求 变化率 用 的 是 差分 差分 的 概念 
很容易 理解 就是 用 相邻 两 个数 的 差 来 
表示 变化率 下面 公式 是 向后 差分 x 方向 的 
差分 Gx n y = G n y G n 
1 y y 方向 的 差分 Gy x n = 
G x n G x n 1 实际 计算 图像 
导数 时 我们 是 通过 原 图像 和 一个 算子 
进行 卷积 来 完成 的 这种 方法 是 求 图像 
的 近似 导数 最 简单 的 求 图像 导数 的 
算子 是 Prewitt 算子 x 方向 的 Prewitt 算子 为 
y 方向 的 Prewitt 算子 为 原 图像 和 一个 
算子 进行 卷积 的 大概 过程 如下 如果 图像 矩阵 
中 一块 区域 为 那么 x 5处 的 x 方向 
的 导数 是 将 x 方向 算子 的 中心 和 
x5 重合 然后 对应 元素 相乘 再 求和 即 x 
5处 的 x 方向 导数 为 x3 + x6 + 
x9 x1 x4 x 7对 矩阵 中 所有 元素 进行 
上述 计算 就是 卷积 的 过程 因此 利用 原 图像 
和x/nr 方向 Prewitt 算子 进行 卷积 就 可以 得到 图像 
的 x 方向 导数 矩阵 Gx 利用 原 图像 和y/nr 
方向 Prewitt 算子 进行 卷积 就 可以 得到 图像 的 
y 方向 导数 矩阵 Gy 利用 公式 就 可以 得到 
图像 的 梯度 矩阵 Gxy 这个 矩阵 包含 图像 x 
方向 和y/nr 方向 的 边缘 信息 Python 实现 卷积 及 
Prewitt 算子 的 边缘 检测 首先 我们 把 图像 卷积 
函数 封装 在 一个 名为 imconv 的 函数 中   
实际上 scipy 库 中的 signal 模块 含有 一个二维 卷积 的 
方法 convolve2d   import numpy as np from PIL import 
Image def imconv image _ array suanzi 计算 卷积 参数 
image _ array 原 灰度 图像 矩阵 suanzi 算子 返回 
原 图像 与 算子 卷积 后的/nr 结果 矩阵 image = 
image _ array . copy # 原 图像 矩阵 的 
深 拷贝 dim1 dim2 = image . shape # 对 
每个 元素 与 算子 进行 乘积 再 求和 忽略 最 
外圈 边框 像素 for i in range 1 dim1 1 
for j in range 1 dim2 1 image i j 
= image _ array i 1 i + 2 j 
1 j + 2 * suanzi . sum # 由于 
卷积 后 灰度 值 不 一定 在 0 255 之间 
统一 化成 0 255 image = image * 255.0 / 
image . max # 返回 结果 矩阵 return image 然后 
我们 利用 Prewitt 算子 计算 x 方向 导数 矩阵 Gx 
y 方向 导数 矩阵 Gy 和 梯度 矩阵 Gxy import 
numpy as np import matplotlib . pyplot as plt # 
x 方向 的 Prewitt 算子 suanzi _ x = np 
. array 1 0 1 1 0 1 1 0 
1 # y 方向 的 Prewitt 算子 suanzi _ y 
= np . array 1 1 1 0 0 0 
1 1 1 # 打开 图像 并 转化 成 灰度 
图像 image = Image . open pika . jpg . 
convert L # 转化成 图像 矩阵 image _ array = 
np . array image # 得到 x 方向 矩阵 image 
_ x = imconv image _ array suanzi _ x 
# 得到 y 方向 矩阵 image _ y = imconv 
image _ array suanzi _ y # 得到 梯度 矩阵 
image _ xy = np . sqrt image _ x 
* * 2 + image _ y * * 2 
# 梯度 矩阵 统一 到 0 255 image _ xy 
= 255.0 / image _ xy . max * image 
_ xy # 绘出 图像 plt . subplot 2 2 
1 plt . imshow image _ array cmap = cm 
. gray plt . axis off plt . subplot 2 
2 2 plt . imshow image _ x cmap = 
cm . gray plt . axis off plt . subplot 
2 2 3 plt . imshow image _ y cmap 
= cm . gray plt . axis off plt . 
subplot 2 2 4 plt . imshow image _ xy 
cmap = cm . gray plt . axis off plt 
. show Prewitt 算子 的 结果 如下 图 所示 上方 
左 图为 原 图像 右 图为 x 方向 导数 图像 
下方 左 图为 y 方向 导数 图像 右 图为 梯度 
图像 从 图中 可以 看出 Prewitt 算子 虽然能 检测 出 
图像 边缘 但是 检测 结果 较为 粗糙 还带 有 大量 
的 噪声 近似 导数 的 Sobel 算子 Sobel 算子 与 
Prewitt 比较 类似 但是 它 比 Prewitt 算子 要好 一些 
x 方向 的 Sobel 算子 为 y 方向 的 Sobel 
算子 为 python 代码 只 需要 将 上面 代码 中的 
Prewitt 算子 改成 Sobel 算子 即可 # x 方向 的 
Sobel 算子 suanzi _ x = np . array 1 
0 1 2 0 2 1 0 1 # y 
方向 的 Sobel 算子 suanzi _ y = np . 
array 1 2 1 0 0 0 1 2 1 
Sobel 算子   的 结果 如下 图 所示 上方 左 
图为 原 图像 右 图为 x 方向 导数 图像 下方 
左 图为 y 方向 导数 图像 右 图为 梯度 图像 
从 图中 看出 比较 Prewitt 算子 和 Sobel 算子 Sobel 
算子 稍微 减少 了 一点 噪声 但 噪声 还是 比 
较多 的 近似 二阶 导数 的 Laplace 算子 Laplace 算子 
是 一个 二阶 导数 的 算子 它/r 实际上/d 是/v 一个/m 
x/w 方向/n 二阶/n 导数/n 和y/nr 方向/n 二阶/n 导数/n 的/uj 和的/nr 
近似/a 求导/v 算子/n 实际上 Laplace 算子 是 通过 Sobel 算子 
推导 出来 的 Laplace 算子 为 Laplace 还有 一种 扩展 
算子 为 为了 不再 重复 造 轮子 这次 我们 运用 
scipy 库 中 signal 模块 的 convolve 方法 来 计算 
图像 卷积 convolve 的 第一 个 参数 是 原 图像 
矩阵 第二个 参数 为 卷积 算子 然后 指定 关键字 参数 
mode = same 输出 矩阵 大 小和 原 图像 矩阵 
相同 import numpy as np from PIL import Image import 
matplotlib . pyplot as plt import matplotlib . cm as 
cm import scipy . signal as signal # 导入 sicpy 
的 signal 模块 # Laplace 算子 suanzi1 = np . 
array 0 1 0 1 4 1 0 1 0 
# Laplace 扩展 算子 suanzi2 = np . array 1 
1 1 1 8 1 1 1 1 # 打开 
图像 并 转化 成 灰度 图像 image = Image . 
open pika . jpg . convert L image _ array 
= np . array image # 利用 signal 的 convolve 
计算 卷积 image _ suanzi1 = signal . convolve2d image 
_ array suanzi1 mode = same image _ suanzi2 = 
signal . convolve2d image _ array suanzi2 mode = same 
# 将 卷积 结果 转化成 0 ~ 255 image _ 
suanzi1 = image _ suanzi1 / float image _ suanzi1 
. max * 255 image _ suanzi2 = image _ 
suanzi2 / float image _ suanzi2 . max * 255 
# 为了 使 看清 边缘 检测 结果 将 大于 灰度 
平均值 的 灰度 变成 255 白色 image _ suanzi1 image 
_ suanzi1 image _ suanzi1 . mean = 255 image 
_ suanzi2 image _ suanzi2 image _ suanzi2 . mean 
= 255 # 显示 图像 plt . subplot 2 1 
1 plt . imshow image _ array cmap = cm 
. gray plt . axis off plt . subplot 2 
2 3 plt . imshow image _ suanzi1 cmap = 
cm . gray plt . axis off plt . subplot 
2 2 4 plt . imshow image _ suanzi2 cmap 
= cm . gray plt . axis off plt . 
show 结果 如 下图 其中 上方 为 原 图像 下方 
左边 为 Laplace 算子 结果 右边 为 Laplace 扩展 算子 
结果 从 结果 可以 看出 laplace 算子 似乎 比 前面 
两个 算子 prewitt 算子 和 Sobel 算子 要好 一些 噪声 
减少 了 但 还是 比较 多 而 Laplace 扩展 算子 
的 结果 看上去 比 Laplace 的 结果 少 一些 噪声 
降噪 后 进行 边缘 检测 为了 获得 更好 的 边缘 
检测 效果 可以 先 对 图像 进行 模糊 平滑 处理 
目的 是 去除 图像 中 的 高频 噪声 python 程序 
如下 首先 用 标准差 为 5 的 5 * 5 
高斯 算子 对 图像 进行 平滑 处理 然后 利用 Laplace 
的 扩展 算子 对 图像 进行 边缘 检测 import numpy 
as np from PIL import Image import matplotlib . pyplot 
as plt import matplotlib . cm as cm import scipy 
. signal as signal # 生成 高斯 算子 的 函数 
def func x y sigma = 1 return 100 * 
1 / 2 * np . pi * sigma * 
np . exp x 2 * * 2 + y 
2 * * 2 / 2.0 * sigma * * 
2 # 生成 标准差 为 5 的 5 * 5 
高斯 算子 suanzi1 = np . fromfunction func 5 5 
sigma = 5 # Laplace 扩展 算子 suanzi2 = np 
. array 1 1 1 1 8 1 1 1 
1 # 打开 图像 并 转化 成 灰度 图像 image 
= Image . open pika . jpg . convert L 
image _ array = np . array image # 利用 
生成 的 高斯 算子 与 原 图像 进行 卷积 对 
图像 进行 平滑 处理 image _ blur = signal . 
convolve2d image _ array suanzi1 mode = same # 对 
平滑 后的/nr 图像 进行 边缘 检测 image2 = signal . 
convolve2d image _ blur suanzi2 mode = same # 结果 
转化 到 0 255 image2 = image2 / float image2 
. max * 255 # 将 大于 灰度 平均值 的 
灰度 值 变成 255 白色 便于 观察 边缘 image2 image2 
image2 . mean = 255 # 显示 图像 plt . 
subplot 2 1 1 plt . imshow image _ array 
cmap = cm . gray plt . axis off plt 
. subplot 2 1 2 plt . imshow image2 cmap 
= cm . gray plt . axis off plt . 
show 结果 如 下图 从 图中 可以 看出 经过 降噪 
处理 后 边缘 效果 较为 明显 参考 列表 1 . 
python 计算机 视觉 编程 2 . 网络 感谢 百度 感觉 
网络 上 分享 知识 的 网友 实际上 一些 现成 的 
Python 库 已经 对 边缘 检测 过程 进行 了 封装 
效果 和 效率 更为 出色 文中 以 自己 的 python 
代码 进行 边缘 检测 实际上/d 是/v 想/v 对/p 实际/n 过程/n 
有/v 更好/d 的/uj 认识/v 和/c 了解/v 我 是 一名 初学者 如果 你 发现 文中 有错误 请 
留言 告诉 我 谢谢 如果 需要 检测 到 图像 里面 
的 边缘 首先 我们 需要 知道 边缘 处 具有 什么 
特征 对于 一幅 灰度 图像 来说 边缘 两边 的 灰度 
值 肯定 不 相同 这样 我们 才能 分辨出 哪里 是 
边缘 哪里 不是 因此 如果 我们 需要 检测 一个 灰度 
图像 的 边缘 我们 需要 找出 哪里 的 灰度 变化 
最大 显然 灰度 变化 越大 对比度 越强 边缘 就越 明显 
那么 问题 来了 我们 怎么 知道 哪里 灰度 变化 大 
哪里 灰度 变化 小 呢 导数 梯度 边缘 信息 在 
数学 中 与 变化 率 有关 的 就是 导数 如果 
灰度 图像 的 像素 是 连续 的 实际 不是 那么 
我们 可以 分别 原 图像 G 对 x 方向 和y/nr 
方向 求 导数 获得 x 方向 的 导数 图像 Gx 
和y/nr 方向 的 导数 图像 Gy Gx/w 和/c Gy/w 分别/d 
隐含/v 了/ul x/w 和y/nr 方向/n 的/uj 灰度/n 变化/vn 信息/n 也就 
隐含 了 边缘 信息 如果 要 在 同一 图像 上 
包含 两个 方向 的 边缘 信息 我们 可以 用 到 
梯度 梯度 是 一个 向量 原 图像 的 梯度 向量 
Gxy 为 Gx Gy 梯度 向量 的 大小 和 方向 
可以 用 下面 两个 式子 计算 角度 值 好像 需要 
根据 向量 所在 象限 不同 适当 + pi 或者 pi 
梯度 向量 大小 就 包含 了 x 方向 和y/nr 方向 
的 边缘 信息 图像 导数 实际上 图像 矩阵 是 离散 
的 连续函数 求 变化率 用 的 是 导数 而 离散 
函数 求 变化率 用 的 是 差分 差分 的 概念 
很容易 理解 就是 用 相邻 两 个数 的 差 来 
表示 变化率 下面 公式 是 向后 差分 x 方向 的 
差分 Gx n y = G n y G n 
1 y y 方向 的 差分 Gy x n = 
G x n G x n 1 实际 计算 图像 
导数 时 我们 是 通过 原 图像 和 一个 算子 
进行 卷积 来 完成 的 这种 方法 是 求 图像 
的 近似 导数 最 简单 的 求 图像 导数 的 
算子 是 Prewitt 算子 x 方向 的 Prewitt 算子 为 
y 方向 的 Prewitt 算子 为 原 图像 和 一个 
算子 进行 卷积 的 大概 过程 如下 如果 图像 矩阵 
中 一块 区域 为 那么 x 5处 的 x 方向 
的 导数 是 将 x 方向 算子 的 中心 和 
x5 重合 然后 对应 元素 相乘 再 求和 即 x 
5处 的 x 方向 导数 为 x3 + x6 + 
x9 x1 x4 x 7对 矩阵 中 所有 元素 进行 
上述 计算 就是 卷积 的 过程 因此 利用 原 图像 
和x/nr 方向 Prewitt 算子 进行 卷积 就 可以 得到 图像 
的 x 方向 导数 矩阵 Gx 利用 原 图像 和y/nr 
方向 Prewitt 算子 进行 卷积 就 可以 得到 图像 的 
y 方向 导数 矩阵 Gy 利用 公式 就 可以 得到 
图像 的 梯度 矩阵 Gxy 这个 矩阵 包含 图像 x 
方向 和y/nr 方向 的 边缘 信息 Python 实现 卷积 及 
Prewitt 算子 的 边缘 检测 首先 我们 把 图像 卷积 
函数 封装 在 一个 名为 imconv 的 函数 中   
实际上 scipy 库 中的 signal 模块 含有 一个二维 卷积 的 
方法 convolve2d   import numpy as np from PIL import 
Image def imconv image _ array suanzi 计算 卷积 参数 
image _ array 原 灰度 图像 矩阵 suanzi 算子 返回 
原 图像 与 算子 卷积 后的/nr 结果 矩阵 image = 
image _ array . copy # 原 图像 矩阵 的 
深 拷贝 dim1 dim2 = image . shape # 对 
每个 元素 与 算子 进行 乘积 再 求和 忽略 最 
外圈 边框 像素 for i in range 1 dim1 1 
for j in range 1 dim2 1 image i j 
= image _ array i 1 i + 2 j 
1 j + 2 * suanzi . sum # 由于 
卷积 后 灰度 值 不 一定 在 0 255 之间 
统一 化成 0 255 image = image * 255.0 / 
image . max # 返回 结果 矩阵 return image 然后 
我们 利用 Prewitt 算子 计算 x 方向 导数 矩阵 Gx 
y 方向 导数 矩阵 Gy 和 梯度 矩阵 Gxy import 
numpy as np import matplotlib . pyplot as plt # 
x 方向 的 Prewitt 算子 suanzi _ x = np 
. array 1 0 1 1 0 1 1 0 
1 # y 方向 的 Prewitt 算子 suanzi _ y 
= np . array 1 1 1 0 0 0 
1 1 1 # 打开 图像 并 转化 成 灰度 
图像 image = Image . open pika . jpg . 
convert L # 转化成 图像 矩阵 image _ array = 
np . array image # 得到 x 方向 矩阵 image 
_ x = imconv image _ array suanzi _ x 
# 得到 y 方向 矩阵 image _ y = imconv 
image _ array suanzi _ y # 得到 梯度 矩阵 
image _ xy = np . sqrt image _ x 
* * 2 + image _ y * * 2 
# 梯度 矩阵 统一 到 0 255 image _ xy 
= 255.0 / image _ xy . max * image 
_ xy # 绘出 图像 plt . subplot 2 2 
1 plt . imshow image _ array cmap = cm 
. gray plt . axis off plt . subplot 2 
2 2 plt . imshow image _ x cmap = 
cm . gray plt . axis off plt . subplot 
2 2 3 plt . imshow image _ y cmap 
= cm . gray plt . axis off plt . 
subplot 2 2 4 plt . imshow image _ xy 
cmap = cm . gray plt . axis off plt 
. show Prewitt 算子 的 结果 如下 图 所示 上方 
左 图为 原 图像 右 图为 x 方向 导数 图像 
下方 左 图为 y 方向 导数 图像 右 图为 梯度 
图像 从 图中 可以 看出 Prewitt 算子 虽然能 检测 出 
图像 边缘 但是 检测 结果 较为 粗糙 还带 有 大量 
的 噪声 近似 导数 的 Sobel 算子 Sobel 算子 与 
Prewitt 比较 类似 但是 它 比 Prewitt 算子 要好 一些 
x 方向 的 Sobel 算子 为 y 方向 的 Sobel 
算子 为 python 代码 只 需要 将 上面 代码 中的 
Prewitt 算子 改成 Sobel 算子 即可 # x 方向 的 
Sobel 算子 suanzi _ x = np . array 1 
0 1 2 0 2 1 0 1 # y 
方向 的 Sobel 算子 suanzi _ y = np . 
array 1 2 1 0 0 0 1 2 1 
Sobel 算子   的 结果 如下 图 所示 上方 左 
图为 原 图像 右 图为 x 方向 导数 图像 下方 
左 图为 y 方向 导数 图像 右 图为 梯度 图像 
从 图中 看出 比较 Prewitt 算子 和 Sobel 算子 Sobel 
算子 稍微 减少 了 一点 噪声 但 噪声 还是 比 
较多 的 近似 二阶 导数 的 Laplace 算子 Laplace 算子 
是 一个 二阶 导数 的 算子 它/r 实际上/d 是/v 一个/m 
x/w 方向/n 二阶/n 导数/n 和y/nr 方向/n 二阶/n 导数/n 的/uj 和的/nr 
近似/a 求导/v 算子/n 实际上 Laplace 算子 是 通过 Sobel 算子 
推导 出来 的 Laplace 算子 为 Laplace 还有 一种 扩展 
算子 为 为了 不再 重复 造 轮子 这次 我们 运用 
scipy 库 中 signal 模块 的 convolve 方法 来 计算 
图像 卷积 convolve 的 第一 个 参数 是 原 图像 
矩阵 第二个 参数 为 卷积 算子 然后 指定 关键字 参数 
mode = same 输出 矩阵 大 小和 原 图像 矩阵 
相同 import numpy as np from PIL import Image import 
matplotlib . pyplot as plt import matplotlib . cm as 
cm import scipy . signal as signal # 导入 sicpy 
的 signal 模块 # Laplace 算子 suanzi1 = np . 
array 0 1 0 1 4 1 0 1 0 
# Laplace 扩展 算子 suanzi2 = np . array 1 
1 1 1 8 1 1 1 1 # 打开 
图像 并 转化 成 灰度 图像 image = Image . 
open pika . jpg . convert L image _ array 
= np . array image # 利用 signal 的 convolve 
计算 卷积 image _ suanzi1 = signal . convolve2d image 
_ array suanzi1 mode = same image _ suanzi2 = 
signal . convolve2d image _ array suanzi2 mode = same 
# 将 卷积 结果 转化成 0 ~ 255 image _ 
suanzi1 = image _ suanzi1 / float image _ suanzi1 
. max * 255 image _ suanzi2 = image _ 
suanzi2 / float image _ suanzi2 . max * 255 
# 为了 使 看清 边缘 检测 结果 将 大于 灰度 
平均值 的 灰度 变成 255 白色 image _ suanzi1 image 
_ suanzi1 image _ suanzi1 . mean = 255 image 
_ suanzi2 image _ suanzi2 image _ suanzi2 . mean 
= 255 # 显示 图像 plt . subplot 2 1 
1 plt . imshow image _ array cmap = cm 
. gray plt . axis off plt . subplot 2 
2 3 plt . imshow image _ suanzi1 cmap = 
cm . gray plt . axis off plt . subplot 
2 2 4 plt . imshow image _ suanzi2 cmap 
= cm . gray plt . axis off plt . 
show 结果 如 下图 其中 上方 为 原 图像 下方 
左边 为 Laplace 算子 结果 右边 为 Laplace 扩展 算子 
结果 从 结果 可以 看出 laplace 算子 似乎 比 前面 
两个 算子 prewitt 算子 和 Sobel 算子 要好 一些 噪声 
减少 了 但 还是 比较 多 而 Laplace 扩展 算子 
的 结果 看上去 比 Laplace 的 结果 少 一些 噪声 
降噪 后 进行 边缘 检测 为了 获得 更好 的 边缘 
检测 效果 可以 先 对 图像 进行 模糊 平滑 处理 
目的 是 去除 图像 中 的 高频 噪声 python 程序 
如下 首先 用 标准差 为 5 的 5 * 5 
高斯 算子 对 图像 进行 平滑 处理 然后 利用 Laplace 
的 扩展 算子 对 图像 进行 边缘 检测 import numpy 
as np from PIL import Image import matplotlib . pyplot 
as plt import matplotlib . cm as cm import scipy 
. signal as signal # 生成 高斯 算子 的 函数 
def func x y sigma = 1 return 100 * 
1 / 2 * np . pi * sigma * 
np . exp x 2 * * 2 + y 
2 * * 2 / 2.0 * sigma * * 
2 # 生成 标准差 为 5 的 5 * 5 
高斯 算子 suanzi1 = np . fromfunction func 5 5 
sigma = 5 # Laplace 扩展 算子 suanzi2 = np 
. array 1 1 1 1 8 1 1 1 
1 # 打开 图像 并 转化 成 灰度 图像 image 
= Image . open pika . jpg . convert L 
image _ array = np . array image # 利用 
生成 的 高斯 算子 与 原 图像 进行 卷积 对 
图像 进行 平滑 处理 image _ blur = signal . 
convolve2d image _ array suanzi1 mode = same # 对 
平滑 后的/nr 图像 进行 边缘 检测 image2 = signal . 
convolve2d image _ blur suanzi2 mode = same # 结果 
转化 到 0 255 image2 = image2 / float image2 
. max * 255 # 将 大于 灰度 平均值 的 
灰度 值 变成 255 白色 便于 观察 边缘 image2 image2 
image2 . mean = 255 # 显示 图像 plt . 
subplot 2 1 1 plt . imshow image _ array 
cmap = cm . gray plt . axis off plt 
. subplot 2 1 2 plt . imshow image2 cmap 
= cm . gray plt . axis off plt . 
show 结果 如 下图 从 图中 可以 看出 经过 降噪 
处理 后 边缘 效果 较为 明显 参考 列表 1 . 
python 计算机 视觉 编程 2 . 网络 感谢 百度 感觉 
网络 上 分享 知识 的 网友 实际上 一些 现成 的 
Python 库 已经 对 边缘 检测 过程 进行 了 封装 
效果 和 效率 更为 出色 文中 以 自己 的 python 
代码 进行 边缘 检测 实际上/d 是/v 想/v 对/p 实际/n 过程/n 
有/v 更好/d 的/uj 认识/v 和/c 了解/v 我 是 一名 初学者 如果 你 发现 文中 有错误 请 
留言 告诉 我 谢谢 如果 需要 检测 到 图像 里面 
的 边缘 首先 我们 需要 知道 边缘 处 具有 什么 
特征 对于 一幅 灰度 图像 来说 边缘 两边 的 灰度 
值 肯定 不 相同 这样 我们 才能 分辨出 哪里 是 
边缘 哪里 不是 因此 如果 我们 需要 检测 一个 灰度 
图像 的 边缘 我们 需要 找出 哪里 的 灰度 变化 
最大 显然 灰度 变化 越大 对比度 越强 边缘 就越 明显 
那么 问题 来了 我们 怎么 知道 哪里 灰度 变化 大 
哪里 灰度 变化 小 呢 导数 梯度 边缘 信息 在 
数学 中 与 变化 率 有关 的 就是 导数 如果 
灰度 图像 的 像素 是 连续 的 实际 不是 那么 
我们 可以 分别 原 图像 G 对 x 方向 和y/nr 
方向 求 导数 获得 x 方向 的 导数 图像 Gx 
和y/nr 方向 的 导数 图像 Gy Gx/w 和/c Gy/w 分别/d 
隐含/v 了/ul x/w 和y/nr 方向/n 的/uj 灰度/n 变化/vn 信息/n 也就 
隐含 了 边缘 信息 如果 要 在 同一 图像 上 
包含 两个 方向 的 边缘 信息 我们 可以 用 到 
梯度 梯度 是 一个 向量 原 图像 的 梯度 向量 
Gxy 为 Gx Gy 梯度 向量 的 大小 和 方向 
可以 用 下面 两个 式子 计算 角度 值 好像 需要 
根据 向量 所在 象限 不同 适当 + pi 或者 pi 
梯度 向量 大小 就 包含 了 x 方向 和y/nr 方向 
的 边缘 信息 图像 导数 实际上 图像 矩阵 是 离散 
的 连续函数 求 变化率 用 的 是 导数 而 离散 
函数 求 变化率 用 的 是 差分 差分 的 概念 
很容易 理解 就是 用 相邻 两 个数 的 差 来 
表示 变化率 下面 公式 是 向后 差分 x 方向 的 
差分 Gx n y = G n y G n 
1 y y 方向 的 差分 Gy x n = 
G x n G x n 1 实际 计算 图像 
导数 时 我们 是 通过 原 图像 和 一个 算子 
进行 卷积 来 完成 的 这种 方法 是 求 图像 
的 近似 导数 最 简单 的 求 图像 导数 的 
算子 是 Prewitt 算子 x 方向 的 Prewitt 算子 为 
y 方向 的 Prewitt 算子 为 原 图像 和 一个 
算子 进行 卷积 的 大概 过程 如下 如果 图像 矩阵 
中 一块 区域 为 那么 x 5处 的 x 方向 
的 导数 是 将 x 方向 算子 的 中心 和 
x5 重合 然后 对应 元素 相乘 再 求和 即 x 
5处 的 x 方向 导数 为 x3 + x6 + 
x9 x1 x4 x 7对 矩阵 中 所有 元素 进行 
上述 计算 就是 卷积 的 过程 因此 利用 原 图像 
和x/nr 方向 Prewitt 算子 进行 卷积 就 可以 得到 图像 
的 x 方向 导数 矩阵 Gx 利用 原 图像 和y/nr 
方向 Prewitt 算子 进行 卷积 就 可以 得到 图像 的 
y 方向 导数 矩阵 Gy 利用 公式 就 可以 得到 
图像 的 梯度 矩阵 Gxy 这个 矩阵 包含 图像 x 
方向 和y/nr 方向 的 边缘 信息 Python 实现 卷积 及 
Prewitt 算子 的 边缘 检测 首先 我们 把 图像 卷积 
函数 封装 在 一个 名为 imconv 的 函数 中   
实际上 scipy 库 中的 signal 模块 含有 一个二维 卷积 的 
方法 convolve2d   import numpy as np from PIL import 
Image def imconv image _ array suanzi 计算 卷积 参数 
image _ array 原 灰度 图像 矩阵 suanzi 算子 返回 
原 图像 与 算子 卷积 后的/nr 结果 矩阵 image = 
image _ array . copy # 原 图像 矩阵 的 
深 拷贝 dim1 dim2 = image . shape # 对 
每个 元素 与 算子 进行 乘积 再 求和 忽略 最 
外圈 边框 像素 for i in range 1 dim1 1 
for j in range 1 dim2 1 image i j 
= image _ array i 1 i + 2 j 
1 j + 2 * suanzi . sum # 由于 
卷积 后 灰度 值 不 一定 在 0 255 之间 
统一 化成 0 255 image = image * 255.0 / 
image . max # 返回 结果 矩阵 return image 然后 
我们 利用 Prewitt 算子 计算 x 方向 导数 矩阵 Gx 
y 方向 导数 矩阵 Gy 和 梯度 矩阵 Gxy import 
numpy as np import matplotlib . pyplot as plt # 
x 方向 的 Prewitt 算子 suanzi _ x = np 
. array 1 0 1 1 0 1 1 0 
1 # y 方向 的 Prewitt 算子 suanzi _ y 
= np . array 1 1 1 0 0 0 
1 1 1 # 打开 图像 并 转化 成 灰度 
图像 image = Image . open pika . jpg . 
convert L # 转化成 图像 矩阵 image _ array = 
np . array image # 得到 x 方向 矩阵 image 
_ x = imconv image _ array suanzi _ x 
# 得到 y 方向 矩阵 image _ y = imconv 
image _ array suanzi _ y # 得到 梯度 矩阵 
image _ xy = np . sqrt image _ x 
* * 2 + image _ y * * 2 
# 梯度 矩阵 统一 到 0 255 image _ xy 
= 255.0 / image _ xy . max * image 
_ xy # 绘出 图像 plt . subplot 2 2 
1 plt . imshow image _ array cmap = cm 
. gray plt . axis off plt . subplot 2 
2 2 plt . imshow image _ x cmap = 
cm . gray plt . axis off plt . subplot 
2 2 3 plt . imshow image _ y cmap 
= cm . gray plt . axis off plt . 
subplot 2 2 4 plt . imshow image _ xy 
cmap = cm . gray plt . axis off plt 
. show Prewitt 算子 的 结果 如下 图 所示 上方 
左 图为 原 图像 右 图为 x 方向 导数 图像 
下方 左 图为 y 方向 导数 图像 右 图为 梯度 
图像 从 图中 可以 看出 Prewitt 算子 虽然能 检测 出 
图像 边缘 但是 检测 结果 较为 粗糙 还带 有 大量 
的 噪声 近似 导数 的 Sobel 算子 Sobel 算子 与 
Prewitt 比较 类似 但是 它 比 Prewitt 算子 要好 一些 
x 方向 的 Sobel 算子 为 y 方向 的 Sobel 
算子 为 python 代码 只 需要 将 上面 代码 中的 
Prewitt 算子 改成 Sobel 算子 即可 # x 方向 的 
Sobel 算子 suanzi _ x = np . array 1 
0 1 2 0 2 1 0 1 # y 
方向 的 Sobel 算子 suanzi _ y = np . 
array 1 2 1 0 0 0 1 2 1 
Sobel 算子   的 结果 如下 图 所示 上方 左 
图为 原 图像 右 图为 x 方向 导数 图像 下方 
左 图为 y 方向 导数 图像 右 图为 梯度 图像 
从 图中 看出 比较 Prewitt 算子 和 Sobel 算子 Sobel 
算子 稍微 减少 了 一点 噪声 但 噪声 还是 比 
较多 的 近似 二阶 导数 的 Laplace 算子 Laplace 算子 
是 一个 二阶 导数 的 算子 它/r 实际上/d 是/v 一个/m 
x/w 方向/n 二阶/n 导数/n 和y/nr 方向/n 二阶/n 导数/n 的/uj 和的/nr 
近似/a 求导/v 算子/n 实际上 Laplace 算子 是 通过 Sobel 算子 
推导 出来 的 Laplace 算子 为 Laplace 还有 一种 扩展 
算子 为 为了 不再 重复 造 轮子 这次 我们 运用 
scipy 库 中 signal 模块 的 convolve 方法 来 计算 
图像 卷积 convolve 的 第一 个 参数 是 原 图像 
矩阵 第二个 参数 为 卷积 算子 然后 指定 关键字 参数 
mode = same 输出 矩阵 大 小和 原 图像 矩阵 
相同 import numpy as np from PIL import Image import 
matplotlib . pyplot as plt import matplotlib . cm as 
cm import scipy . signal as signal # 导入 sicpy 
的 signal 模块 # Laplace 算子 suanzi1 = np . 
array 0 1 0 1 4 1 0 1 0 
# Laplace 扩展 算子 suanzi2 = np . array 1 
1 1 1 8 1 1 1 1 # 打开 
图像 并 转化 成 灰度 图像 image = Image . 
open pika . jpg . convert L image _ array 
= np . array image # 利用 signal 的 convolve 
计算 卷积 image _ suanzi1 = signal . convolve2d image 
_ array suanzi1 mode = same image _ suanzi2 = 
signal . convolve2d image _ array suanzi2 mode = same 
# 将 卷积 结果 转化成 0 ~ 255 image _ 
suanzi1 = image _ suanzi1 / float image _ suanzi1 
. max * 255 image _ suanzi2 = image _ 
suanzi2 / float image _ suanzi2 . max * 255 
# 为了 使 看清 边缘 检测 结果 将 大于 灰度 
平均值 的 灰度 变成 255 白色 image _ suanzi1 image 
_ suanzi1 image _ suanzi1 . mean = 255 image 
_ suanzi2 image _ suanzi2 image _ suanzi2 . mean 
= 255 # 显示 图像 plt . subplot 2 1 
1 plt . imshow image _ array cmap = cm 
. gray plt . axis off plt . subplot 2 
2 3 plt . imshow image _ suanzi1 cmap = 
cm . gray plt . axis off plt . subplot 
2 2 4 plt . imshow image _ suanzi2 cmap 
= cm . gray plt . axis off plt . 
show 结果 如 下图 其中 上方 为 原 图像 下方 
左边 为 Laplace 算子 结果 右边 为 Laplace 扩展 算子 
结果 从 结果 可以 看出 laplace 算子 似乎 比 前面 
两个 算子 prewitt 算子 和 Sobel 算子 要好 一些 噪声 
减少 了 但 还是 比较 多 而 Laplace 扩展 算子 
的 结果 看上去 比 Laplace 的 结果 少 一些 噪声 
降噪 后 进行 边缘 检测 为了 获得 更好 的 边缘 
检测 效果 可以 先 对 图像 进行 模糊 平滑 处理 
目的 是 去除 图像 中 的 高频 噪声 python 程序 
如下 首先 用 标准差 为 5 的 5 * 5 
高斯 算子 对 图像 进行 平滑 处理 然后 利用 Laplace 
的 扩展 算子 对 图像 进行 边缘 检测 import numpy 
as np from PIL import Image import matplotlib . pyplot 
as plt import matplotlib . cm as cm import scipy 
. signal as signal # 生成 高斯 算子 的 函数 
def func x y sigma = 1 return 100 * 
1 / 2 * np . pi * sigma * 
np . exp x 2 * * 2 + y 
2 * * 2 / 2.0 * sigma * * 
2 # 生成 标准差 为 5 的 5 * 5 
高斯 算子 suanzi1 = np . fromfunction func 5 5 
sigma = 5 # Laplace 扩展 算子 suanzi2 = np 
. array 1 1 1 1 8 1 1 1 
1 # 打开 图像 并 转化 成 灰度 图像 image 
= Image . open pika . jpg . convert L 
image _ array = np . array image # 利用 
生成 的 高斯 算子 与 原 图像 进行 卷积 对 
图像 进行 平滑 处理 image _ blur = signal . 
convolve2d image _ array suanzi1 mode = same # 对 
平滑 后的/nr 图像 进行 边缘 检测 image2 = signal . 
convolve2d image _ blur suanzi2 mode = same # 结果 
转化 到 0 255 image2 = image2 / float image2 
. max * 255 # 将 大于 灰度 平均值 的 
灰度 值 变成 255 白色 便于 观察 边缘 image2 image2 
image2 . mean = 255 # 显示 图像 plt . 
subplot 2 1 1 plt . imshow image _ array 
cmap = cm . gray plt . axis off plt 
. subplot 2 1 2 plt . imshow image2 cmap 
= cm . gray plt . axis off plt . 
show 结果 如 下图 从 图中 可以 看出 经过 降噪 
处理 后 边缘 效果 较为 明显 参考 列表 1 . 
python 计算机 视觉 编程 2 . 网络 感谢 百度 感觉 
网络 上 分享 知识 的 网友 实际上 一些 现成 的 
Python 库 已经 对 边缘 检测 过程 进行 了 封装 
效果 和 效率 更为 出色 文中 以 自己 的 python 
代码 进行 边缘 检测 实际上/d 是/v 想/v 对/p 实际/n 过程/n 
有/v 更好/d 的/uj 认识/v 和/c 了解/v 