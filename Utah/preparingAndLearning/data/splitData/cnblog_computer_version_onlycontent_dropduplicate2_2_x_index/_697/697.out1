资料 来源 人工智能 前沿 讲习 表格 资料 来源 hoya012 的 
G i t h u b D e t e 
c t o r V O C 0 7 mAP 
@ IoU = 0.5 VOC12 mAP @ IoU = 0.5 
COCO mAP @ IoU = 0.5 0.95 Published InR CNN58 
. 5 CVPR 14SPP Net59 . 2 ECCV 14MR CNN78 
. 2 07 + 12 73.9 07 + 12 ICCV 
15Fast R CNN70 . 0 07 + 12 68.4 07 
+ + 12 19 . 7ICCV 15Faster R CNN73 . 
2 07 + 12 70.4 07 + + 12 21 
. 9NIPS 15YOLO v 166.4 07 + 12 57.9 07 
+ + 12 CVPR 16G CNN66 . 866.4 07 + 
12 CVPR 16AZNet70 . 4 22 . 3CVPR 16ION80 . 
177.933 . 1CVPR 16HyperNet76 . 3 07 + 12 71.4 
07 + + 12 CVPR 16OHEM78 . 9 07 + 
12 76.3 07 + + 12 22 . 4CVPR 16MPN 
33 . 2BMVC 16SSD76 . 8 07 + 12 74.9 
07 + + 12 31 . 2ECCV 16GBDNet77 . 2 
07 + 12 27 . 0ECCV 16CPF76 . 4 07 
+ 12 72.6 07 + + 12 ECCV 16R FCN79 
. 5 07 + 12 77.6 07 + + 12 
29 . 9NIPS 16DeepID Net69 . 0 PAMI 16NoC71 . 
6 07 + 12 68.8 07 + 12 27 . 
2TPAMI 16DSSD81 . 5 07 + 12 80.0 07 + 
+ 12 33 . 2arXiv 17TDM 37 . 3CVPR 17FPN 
36 . 2CVPR 17YOLO v 278.6 07 + 12 73.4 
07 + + 12 CVPR 17RON77 . 6 07 + 
12 75.4 07 + + 12 27 . 4CVPR 17DeNet77 
. 1 07 + 12 73.9 07 + + 12 
33 . 8ICCV 17CoupleNet82 . 7 07 + 12 80.4 
07 + + 12 34 . 4ICCV 17RetinaNet 39 . 
1ICCV 17DSOD77 . 7 07 + 12 76.3 07 + 
+ 12 ICCV 17SMN70 . 0 ICCV 17Light Head R 
CNN 41 . 5arXiv 17YOLO v3 33 . 0arXiv 18SIN76 
. 0 07 + 12 73.1 07 + + 12 
23 . 2CVPR 18STDN80 . 9 07 + 12 CVPR 
18RefineDet83 . 8 07 + 12 83.5 07 + + 
12 41 . 8CVPR 18SNIP 45 . 7CVPR 18Relation Network 
32 . 5CVPR 18Cascade R CNN 42 . 8CVPR 18MLKP80 
. 6 07 + 12 77.2 07 + + 12 
28 . 6CVPR 18Fitness NMS 41 . 8CVPR 18RFBNet82 . 
2 07 + 12 ECCV 18CornerNet 42 . 1ECCV 18PFPNet84 
. 1 07 + 12 83.7 07 + + 12 
39 . 4ECCV 18Pelee70 . 9 07 + 12 NIPS 
18HKRM78 . 8 07 + 12 37 . 8NIPS 18M2Det 
44 . 2AAAI 19R DAD81 . 2 07 + + 
12 82.0 07 + + 12 43 . 1AAAI 19 
一 One Stage 和 Two Stage 物体 检测 算法 大致 
分为 两类 一步法 检测器 和二/nr 步法 检测器 一步法 检测器 在 
原图 上 铺设 一系列 锚 点 框 anchor 利用 一个 
全 卷积 网络 对 这些 锚 点 框 进行 一次 
分类 和 一次 回归 得到 检测 结果 二 步法 检测器 
在 原图 上 铺设 一系列 锚 点 框 anchor 利用 
一个 网络 对 这些 锚 点 框 进行 两次 分类 
和 两次 回归 得到 检测 结果 相对于 一步法 检测器 二 
步法 检测器 多 了 一个 步骤 如果 这 两类 方法 
在 相同 的 条件 下 如 相同 的 输入 相同 
的 anchor 设置 相同 的 机器 等 一步法 一般 胜在 
高效率 因为 它 没有 耗时 的 第二 步 而 二 
步法 的 精度 要 更高 一些 现在 各 个 检测 
库 上 排名 靠前 的 算法 基本 都是 二 步法 
比较 出名 的 一步法 检测器 有 YOLO SSD RetinaNet CornerNet 
其中 SSD 是 一步法 检测器 的 集大成 者 后续/v 大/a 
部分/n 的/uj 一步法/l 工作/vn 都是/nr 基于/p 它/r 的/uj 比较/d 出名/v 
的/uj 二/m 步法/n 检测器/n 有/v Faster/w R CNN R FCN 
FPN Cascade R CNN SNIP 其中 Faster R CNN 是 
奠基 性 工作 基本 所有 的 检测 算法 的 都是 
在 它 的 基础上 改进 的 包括 一步法 SSDTwo Stage 
的 精度 优势 二 阶段 的 分类 二 步法 的 
第一 步在/nr 分类 时 正负 样本 是 极不 平衡 的 
导致 分类器 训练 比较 困难 这 也是 一步法 效果 不如 
二 步法 的 原因 之一 也是 focal loss 的 motivation 
而 第二 步在/nr 分类 时 由于 第一步 滤掉 了 绝大部分 
的 负 样本 送给 第二步 分类 的 proposal 中 正负 
样本 比例 已经 比较 平衡 了 所以 第二步 分类 中 
不存在 正负 样本 极度 不 平衡 的 问题 即 二步 
法 可以 在 很大 程度 上 缓和 正负 样本 极度 
不 平衡 的 分类 问题 二 阶段 的 回归 二 
步法 中 第一步 会 先 对 初始 候选框 进行 校正 
然后 把 校 正过 的 候选框 送给 第二步 作为 第二 
步 校正 的 初始 候选框 再让 第二步 进一步 校正 二 
阶段 的 特征 在 二 步法 中 第一步 和 第二 
步法 除了 共享 的 特征 外 他们/r 都有/nr 自己/r 独有/v 
的/uj 特征/n 专注 于 自身 的 任务 具体来说 这 两个 
步骤 独有 的 特征 分别 处理 着 不同 难度 的 
任务 如 第一步 中的 特征 专注 于 处理 二 分类 
任务 区分 前景 和 背景 和 粗略 的 回归 问题 
第二步 的 特征 专注/v 于/p 处理/v 多/m 分类/n 任务/n 和/c 
精确/a 的/uj 回归/v 问题/n 特征/n 校准/n 在 二 步法 中 
有 一个 很 重要 的 RoIPooling 扣 特征 的 操作 
它 把 候选 区域 对应 的 特征 抠出来 达到 了 
特征 校准 的 目的 而 一步法 中 特征 是 对 
不齐 的 二 One Stage 目标 检测 1 One Stage 
目标 检测 Pipeline2 One Stage 目标 检测 模型 改进 方向 
网络设计 主干网络 anchors 设置 方案 检测 框 回归 方式 损失 
函数 PPT 原文 如下 3 网络设计 改进 作者 使用 SSD 
系列 网络 的 发展 展示 了 One Stage 网络 主干 
发展 的 脉络 DSSD 和 FSSD 我 在 学校 的 
组 会上 做过 讲解 不过 没有 整理 成文 这里 不 
做 过多 讲解 以后 再提 SSDDSSDFSSD4 anchors 生成 方案 改进 
YOLOv1SSDYOLOv2 v3RefineDet 这个 网络 本文 后面 会 介绍 这里 不多 
赘述 5 回归 目标 设计 YOLOYOLO 用 不相 重叠 的 
网格 划分 区域 而 选取 的 anchor 为 真实 框 
中心点 所在 的 网格 作 为 回归 的 起始 框 
去 匹配 检测 目标 即 一个 anchor 对应 一个 targetSSDSSD 
的 网格 多 且 相互 重叠 其 匹配 策略 也 
略 复杂 每一个 anchor 网格 都 有一个 自己 的 class 
都 要去 匹配 一个 真实 框 在 贡献 loss 的 
时候 真实 框 仅 和 IOU 大于 阈值 的 anchor 
相匹配 参见 TensorFlow SSD 源码 学习 _ 其二 基于 VGG 
的 SSD 网络 前 向 架构 TensorFlow SSD 源码 学习 
_ 其 七 损失 函数 CornetNetECCV 2018 的 文章 不 
采用 anchor 修正 的 方法 做 物体 检测 而是 将 
ground truth 的 左上 和 右下 两个 角 点视 为 
关键 点 用 热 图 来 定位 实际 设计 很 
复杂 其 损失 函数 设计 也 值得一看 特殊 的 网络 
一定会 有 特殊 的 损失 函数 相匹配 除了 原文 外 
推荐 个 博客 辅助 理解 CornetNet 算法 理解 6 损失 
函数 OHEMOHEM 是 Fast RCNN 的 改进 适合于 batch size 
images 较少 但 每张 image 的 examples 很多 的 情况 
针对 困难 object 进行 提取 思想 概括 如下 In OHEM 
each example is scored by its loss non maximum suppression 
nms is then applied and a minibatch is constructed with 
the highest loss examples . 实际应用 流程 将 Fast RCNN 
分成 两个 components ConvNet 和 RoINet .   ConvNet 为 
共享 的 底层 卷积 层 RoINet 为 RoI Pooling 后的层/nr 
包括 全 连接 层 2 对于 每张 输入 图像 经前向/nr 
传播/vn 用 ConvNet 获得 feature maps 这里 为 RoI Pooling 
层 的 输入 3 将 事先 计 算好 的 proposals 
经 RoI Pooling 层 投影 到 feature maps 上 获取 
固定 的 特征 输出 作为 全 连接 层 的 输入 
需要 注意 的 是 论 文说 为了 减少 显存 以及 
后向 传播 的 时间 这里 的 RoINet 是 有 两个 
的 它们 共享 权重 RoINet1 是 只读 只 进行 forward 
RoINet2 进行 forward 和 backward a   将 原图 的 
所有 props 扔到 RoINet1 上图 a 部分 计算 它们 的 
loss 这里 有 两个 loss cls 和 det b 根据 
loss 从高 到 低 排序 以及 利用 NMS 来 选出 
前 K 个 props K 由 论文 里 的 N 
和B/nr 参数 决定 为什么 要 用 NMS 显然 对于 那些 
高度 overlap 的 props 经 RoI 的 投 影后 其 
在 feature maps 上 的 位置 和 大小 是 差不多 
一样 的 容易 导致 loss double counting 问题 c 将 
选出 的 K 个 props 可以 理解 成 hard examples 
扔到 RoINet2 上图 b 部分 这时 的 RoINet2 和 Fast 
RCNN 的 RoINet 一样 计算 K 个 props 的 loss 
并 回传 梯度 / 残差 给 ConvNet 来 更新 整个 
网络 Focal lossRetinaNet 提出 的 致力 于 解决 正负 样本 
不 均衡 的 新型 损失 函数 出发点 希望 one stage 
detector 可以 达到 two stage detector 的 准确率 同时 不 
影响 原有 的 速度 问题 假设 作者 认为 one stage 
detector 的 准确率 不如 two stage detector 的 原因 是 
样本 的 类别 不均衡 相关 工作 作者 认为 OHEM 算法 
虽然 增加 了 错 分类 样本 的 权重 但 是 
完全 忽略 了 容易 分类 的 样本 focal loss 在 
标准 交叉 熵 损失 基础 上 修改 得到 的 这个 
函数 可以 通过 减少 易 分类 样本 的 权重 使得/v 
模型/n 在/p 训练/vn 时更/nr 专注/v 于难/nr 分类/n 的/uj 样本/n 原/n 
交叉/n 熵/g Focal loss 改进 gamma 0 使得 减少 易 
分类 样本 的 损失 使得 更 关注 于 困难 的 
错分 的 样本 添加 正负 样本 加入 平衡 因子 alpha 
用来 平衡 正负 样本 本身 的 比例 不均 三 Two 
Stage 目标 检测 1 Two Stage 目标 检测 Pipeline2 Two 
Stage 目标 检测 模型 改进 方向 生成 ProposalsROI 特征 获取 
ROI 算法 设计 加速 检测 后 处理 回归 框 PPT 
原文 如下 3 生成 ProposalsR CNN 使用 某些 算法 生成 
推荐 框 这些 推荐 区直 接在 原 图上 crop 生成 
Proposals 然后 非 极大值 抑制 合并 这些 Proposals 的 分类 
回归 结果 作者 使用 聚 类 描述 这个 合并 过程 
Faster R CNN 这个 讲 滥 了 直接 用 anchors 
经过 第一次 分类 回归 得到 的 推荐 框 crop 原图 
经过 特征提取 网 生成 的 特征 图 结果 作为 Proposals 
进行 分类 回归 FPN 总体 来看 和 Faster R CNN 
类似 不过 crop 的 目标 不再 是 原图 经过 网络 
生成 的 一张 特征 图 而是 在 特征 金字塔 上 
寻找 某一 层 作为 crop 目标 Cascade R CNN 这篇 
是 CVPR 2018 的 文章 核心 是 Cascade roi wise 
subnet 用于 更好 的 利用 IOU 进行 回归 结果 的 
修正 简单 解释一下 下图 经过 conv 出来 的 特征 要 
经过 align pool 才能 进入 subnet 这里 采用 了 联 
级 的 方式 操作 B0 是 二 分类 生成 的 
框 选取 一 系列 IOU 阈值 { 0.5 0.6 0.7 
} B1 是 B0 在 conv 输出 特征 上 crop 
出来 子 区域 经过 H1 回归 的 结果 B2 则是 
B1 在 conv 输出 阈值 逐渐 严格 回归 效果 更好 
R FCN 生成 K * K * C + 1 
张 特征 K 为 ROI 输出 尺寸 在 K * 
K 组 中 每 一组 只取 对应 输出 位置 的 
Pool 结果 重新排列 整理 得到 我们 想要 的 特征 计算机 
视觉 R FCN4 设计 ROI 算法 ROI Pooling ROI Align 
PSROI Pool PRROI Pool5 两 步法 准确率 提升 6 模型 
后处理 NMS 非 极大值 抑制 Soft NMSdef cpu _ soft 
_ nms np . ndarray float ndim = 2 boxes 
float sigma = 0.5 float Nt = 0.3 float threshold 
= 0.001 unsigned int method = 0 cdef unsigned int 
N = boxes . shape 0 cdef float iw ih 
box _ area cdef float ua cdef int pos = 
0 cdef float maxscore = 0 cdef int maxpos = 
0 cdef float x1 x2 y1 y2 tx1 tx2 ty1 
ty2 ts area weight ov for i in range N 
maxscore = boxes i 4 maxpos = i tx1 = 
boxes i 0 ty1 = boxes i 1 tx2 = 
boxes i 2 ty2 = boxes i 3 ts = 
boxes i 4 pos = i + 1 # get 
max box while pos N if maxscore boxes pos 4 
maxscore = boxes pos 4 maxpos = pos pos = 
pos + 1 # add max box as a detection 
boxes i 0 = boxes maxpos 0 boxes i 1 
= boxes maxpos 1 boxes i 2 = boxes maxpos 
2 boxes i 3 = boxes maxpos 3 boxes i 
4 = boxes maxpos 4 # swap ith box with 
position of max box boxes maxpos 0 = tx1 boxes 
maxpos 1 = ty1 boxes maxpos 2 = tx2 boxes 
maxpos 3 = ty2 boxes maxpos 4 = ts tx1 
= boxes i 0 ty1 = boxes i 1 tx2 
= boxes i 2 ty2 = boxes i 3 ts 
= boxes i 4 pos = i + 1 # 
NMS iterations note that N changes if detection boxes fall 
below threshold while pos N x1 = boxes pos 0 
y1 = boxes pos 1 x2 = boxes pos 2 
y2 = boxes pos 3 s = boxes pos 4 
area = x2 x1 + 1 * y2 y1 + 
1 iw = min tx2 x2 max tx1 x1 + 
1 if iw 0 ih = min ty2 y2 max 
ty1 y1 + 1 if ih 0 ua = float 
tx2 tx1 + 1 * ty2 ty1 + 1 + 
area iw * ih ov = iw * ih / 
ua # iou between max box and detection box if 
method = = 1 # linear if ov Nt weight 
= 1 ov else weight = 1 elif method = 
= 2 # gaussian weight = np . exp ov 
* ov / sigma else # original NMS if ov 
Nt weight = 0 else weight = 1 boxes pos 
4 = weight * boxes pos 4 # if box 
score falls below threshold discard the box by swapping with 
last box # update N if boxes pos 4 threshold 
boxes pos 0 = boxes N 1 0 boxes pos 
1 = boxes N 1 1 boxes pos 2 = 
boxes N 1 2 boxes pos 3 = boxes N 
1 3 boxes pos 4 = boxes N 1 4 
N = N 1 pos = pos 1 pos = 
pos + 1 keep = i for i in range 
N return keepIOU Guided NMS 资料 来源 人工智能 前沿 讲习 表格 资料 来源 hoya012 的 
G i t h u b D e t e 
c t o r V O C 0 7 mAP 
@ IoU = 0.5 VOC12 mAP @ IoU = 0.5 
COCO mAP @ IoU = 0.5 0.95 Published InR CNN58 
. 5 CVPR 14SPP Net59 . 2 ECCV 14MR CNN78 
. 2 07 + 12 73.9 07 + 12 ICCV 
15Fast R CNN70 . 0 07 + 12 68.4 07 
+ + 12 19 . 7ICCV 15Faster R CNN73 . 
2 07 + 12 70.4 07 + + 12 21 
. 9NIPS 15YOLO v 166.4 07 + 12 57.9 07 
+ + 12 CVPR 16G CNN66 . 866.4 07 + 
12 CVPR 16AZNet70 . 4 22 . 3CVPR 16ION80 . 
177.933 . 1CVPR 16HyperNet76 . 3 07 + 12 71.4 
07 + + 12 CVPR 16OHEM78 . 9 07 + 
12 76.3 07 + + 12 22 . 4CVPR 16MPN 
33 . 2BMVC 16SSD76 . 8 07 + 12 74.9 
07 + + 12 31 . 2ECCV 16GBDNet77 . 2 
07 + 12 27 . 0ECCV 16CPF76 . 4 07 
+ 12 72.6 07 + + 12 ECCV 16R FCN79 
. 5 07 + 12 77.6 07 + + 12 
29 . 9NIPS 16DeepID Net69 . 0 PAMI 16NoC71 . 
6 07 + 12 68.8 07 + 12 27 . 
2TPAMI 16DSSD81 . 5 07 + 12 80.0 07 + 
+ 12 33 . 2arXiv 17TDM 37 . 3CVPR 17FPN 
36 . 2CVPR 17YOLO v 278.6 07 + 12 73.4 
07 + + 12 CVPR 17RON77 . 6 07 + 
12 75.4 07 + + 12 27 . 4CVPR 17DeNet77 
. 1 07 + 12 73.9 07 + + 12 
33 . 8ICCV 17CoupleNet82 . 7 07 + 12 80.4 
07 + + 12 34 . 4ICCV 17RetinaNet 39 . 
1ICCV 17DSOD77 . 7 07 + 12 76.3 07 + 
+ 12 ICCV 17SMN70 . 0 ICCV 17Light Head R 
CNN 41 . 5arXiv 17YOLO v3 33 . 0arXiv 18SIN76 
. 0 07 + 12 73.1 07 + + 12 
23 . 2CVPR 18STDN80 . 9 07 + 12 CVPR 
18RefineDet83 . 8 07 + 12 83.5 07 + + 
12 41 . 8CVPR 18SNIP 45 . 7CVPR 18Relation Network 
32 . 5CVPR 18Cascade R CNN 42 . 8CVPR 18MLKP80 
. 6 07 + 12 77.2 07 + + 12 
28 . 6CVPR 18Fitness NMS 41 . 8CVPR 18RFBNet82 . 
2 07 + 12 ECCV 18CornerNet 42 . 1ECCV 18PFPNet84 
. 1 07 + 12 83.7 07 + + 12 
39 . 4ECCV 18Pelee70 . 9 07 + 12 NIPS 
18HKRM78 . 8 07 + 12 37 . 8NIPS 18M2Det 
44 . 2AAAI 19R DAD81 . 2 07 + + 
12 82.0 07 + + 12 43 . 1AAAI 19 
一 One Stage 和 Two Stage 物体 检测 算法 大致 
分为 两类 一步法 检测器 和二/nr 步法 检测器 一步法 检测器 在 
原图 上 铺设 一系列 锚 点 框 anchor 利用 一个 
全 卷积 网络 对 这些 锚 点 框 进行 一次 
分类 和 一次 回归 得到 检测 结果 二 步法 检测器 
在 原图 上 铺设 一系列 锚 点 框 anchor 利用 
一个 网络 对 这些 锚 点 框 进行 两次 分类 
和 两次 回归 得到 检测 结果 相对于 一步法 检测器 二 
步法 检测器 多 了 一个 步骤 如果 这 两类 方法 
在 相同 的 条件 下 如 相同 的 输入 相同 
的 anchor 设置 相同 的 机器 等 一步法 一般 胜在 
高效率 因为 它 没有 耗时 的 第二 步 而 二 
步法 的 精度 要 更高 一些 现在 各 个 检测 
库 上 排名 靠前 的 算法 基本 都是 二 步法 
比较 出名 的 一步法 检测器 有 YOLO SSD RetinaNet CornerNet 
其中 SSD 是 一步法 检测器 的 集大成 者 后续/v 大/a 
部分/n 的/uj 一步法/l 工作/vn 都是/nr 基于/p 它/r 的/uj 比较/d 出名/v 
的/uj 二/m 步法/n 检测器/n 有/v Faster/w R CNN R FCN 
FPN Cascade R CNN SNIP 其中 Faster R CNN 是 
奠基 性 工作 基本 所有 的 检测 算法 的 都是 
在 它 的 基础上 改进 的 包括 一步法 SSDTwo Stage 
的 精度 优势 二 阶段 的 分类 二 步法 的 
第一 步在/nr 分类 时 正负 样本 是 极不 平衡 的 
导致 分类器 训练 比较 困难 这 也是 一步法 效果 不如 
二 步法 的 原因 之一 也是 focal loss 的 motivation 
而 第二 步在/nr 分类 时 由于 第一步 滤掉 了 绝大部分 
的 负 样本 送给 第二步 分类 的 proposal 中 正负 
样本 比例 已经 比较 平衡 了 所以 第二步 分类 中 
不存在 正负 样本 极度 不 平衡 的 问题 即 二步 
法 可以 在 很大 程度 上 缓和 正负 样本 极度 
不 平衡 的 分类 问题 二 阶段 的 回归 二 
步法 中 第一步 会 先 对 初始 候选框 进行 校正 
然后 把 校 正过 的 候选框 送给 第二步 作为 第二 
步 校正 的 初始 候选框 再让 第二步 进一步 校正 二 
阶段 的 特征 在 二 步法 中 第一步 和 第二 
步法 除了 共享 的 特征 外 他们/r 都有/nr 自己/r 独有/v 
的/uj 特征/n 专注 于 自身 的 任务 具体来说 这 两个 
步骤 独有 的 特征 分别 处理 着 不同 难度 的 
任务 如 第一步 中的 特征 专注 于 处理 二 分类 
任务 区分 前景 和 背景 和 粗略 的 回归 问题 
第二步 的 特征 专注/v 于/p 处理/v 多/m 分类/n 任务/n 和/c 
精确/a 的/uj 回归/v 问题/n 特征/n 校准/n 在 二 步法 中 
有 一个 很 重要 的 RoIPooling 扣 特征 的 操作 
它 把 候选 区域 对应 的 特征 抠出来 达到 了 
特征 校准 的 目的 而 一步法 中 特征 是 对 
不齐 的 二 One Stage 目标 检测 1 One Stage 
目标 检测 Pipeline2 One Stage 目标 检测 模型 改进 方向 
网络设计 主干网络 anchors 设置 方案 检测 框 回归 方式 损失 
函数 PPT 原文 如下 3 网络设计 改进 作者 使用 SSD 
系列 网络 的 发展 展示 了 One Stage 网络 主干 
发展 的 脉络 DSSD 和 FSSD 我 在 学校 的 
组 会上 做过 讲解 不过 没有 整理 成文 这里 不 
做 过多 讲解 以后 再提 SSDDSSDFSSD4 anchors 生成 方案 改进 
YOLOv1SSDYOLOv2 v3RefineDet 这个 网络 本文 后面 会 介绍 这里 不多 
赘述 5 回归 目标 设计 YOLOYOLO 用 不相 重叠 的 
网格 划分 区域 而 选取 的 anchor 为 真实 框 
中心点 所在 的 网格 作 为 回归 的 起始 框 
去 匹配 检测 目标 即 一个 anchor 对应 一个 targetSSDSSD 
的 网格 多 且 相互 重叠 其 匹配 策略 也 
略 复杂 每一个 anchor 网格 都 有一个 自己 的 class 
都 要去 匹配 一个 真实 框 在 贡献 loss 的 
时候 真实 框 仅 和 IOU 大于 阈值 的 anchor 
相匹配 参见 TensorFlow SSD 源码 学习 _ 其二 基于 VGG 
的 SSD 网络 前 向 架构 TensorFlow SSD 源码 学习 
_ 其 七 损失 函数 CornetNetECCV 2018 的 文章 不 
采用 anchor 修正 的 方法 做 物体 检测 而是 将 
ground truth 的 左上 和 右下 两个 角 点视 为 
关键 点 用 热 图 来 定位 实际 设计 很 
复杂 其 损失 函数 设计 也 值得一看 特殊 的 网络 
一定会 有 特殊 的 损失 函数 相匹配 除了 原文 外 
推荐 个 博客 辅助 理解 CornetNet 算法 理解 6 损失 
函数 OHEMOHEM 是 Fast RCNN 的 改进 适合于 batch size 
images 较少 但 每张 image 的 examples 很多 的 情况 
针对 困难 object 进行 提取 思想 概括 如下 In OHEM 
each example is scored by its loss non maximum suppression 
nms is then applied and a minibatch is constructed with 
the highest loss examples . 实际应用 流程 将 Fast RCNN 
分成 两个 components ConvNet 和 RoINet .   ConvNet 为 
共享 的 底层 卷积 层 RoINet 为 RoI Pooling 后的层/nr 
包括 全 连接 层 2 对于 每张 输入 图像 经前向/nr 
传播/vn 用 ConvNet 获得 feature maps 这里 为 RoI Pooling 
层 的 输入 3 将 事先 计 算好 的 proposals 
经 RoI Pooling 层 投影 到 feature maps 上 获取 
固定 的 特征 输出 作为 全 连接 层 的 输入 
需要 注意 的 是 论 文说 为了 减少 显存 以及 
后向 传播 的 时间 这里 的 RoINet 是 有 两个 
的 它们 共享 权重 RoINet1 是 只读 只 进行 forward 
RoINet2 进行 forward 和 backward a   将 原图 的 
所有 props 扔到 RoINet1 上图 a 部分 计算 它们 的 
loss 这里 有 两个 loss cls 和 det b 根据 
loss 从高 到 低 排序 以及 利用 NMS 来 选出 
前 K 个 props K 由 论文 里 的 N 
和B/nr 参数 决定 为什么 要 用 NMS 显然 对于 那些 
高度 overlap 的 props 经 RoI 的 投 影后 其 
在 feature maps 上 的 位置 和 大小 是 差不多 
一样 的 容易 导致 loss double counting 问题 c 将 
选出 的 K 个 props 可以 理解 成 hard examples 
扔到 RoINet2 上图 b 部分 这时 的 RoINet2 和 Fast 
RCNN 的 RoINet 一样 计算 K 个 props 的 loss 
并 回传 梯度 / 残差 给 ConvNet 来 更新 整个 
网络 Focal lossRetinaNet 提出 的 致力 于 解决 正负 样本 
不 均衡 的 新型 损失 函数 出发点 希望 one stage 
detector 可以 达到 two stage detector 的 准确率 同时 不 
影响 原有 的 速度 问题 假设 作者 认为 one stage 
detector 的 准确率 不如 two stage detector 的 原因 是 
样本 的 类别 不均衡 相关 工作 作者 认为 OHEM 算法 
虽然 增加 了 错 分类 样本 的 权重 但 是 
完全 忽略 了 容易 分类 的 样本 focal loss 在 
标准 交叉 熵 损失 基础 上 修改 得到 的 这个 
函数 可以 通过 减少 易 分类 样本 的 权重 使得/v 
模型/n 在/p 训练/vn 时更/nr 专注/v 于难/nr 分类/n 的/uj 样本/n 原/n 
交叉/n 熵/g Focal loss 改进 gamma 0 使得 减少 易 
分类 样本 的 损失 使得 更 关注 于 困难 的 
错分 的 样本 添加 正负 样本 加入 平衡 因子 alpha 
用来 平衡 正负 样本 本身 的 比例 不均 三 Two 
Stage 目标 检测 1 Two Stage 目标 检测 Pipeline2 Two 
Stage 目标 检测 模型 改进 方向 生成 ProposalsROI 特征 获取 
ROI 算法 设计 加速 检测 后 处理 回归 框 PPT 
原文 如下 3 生成 ProposalsR CNN 使用 某些 算法 生成 
推荐 框 这些 推荐 区直 接在 原 图上 crop 生成 
Proposals 然后 非 极大值 抑制 合并 这些 Proposals 的 分类 
回归 结果 作者 使用 聚 类 描述 这个 合并 过程 
Faster R CNN 这个 讲 滥 了 直接 用 anchors 
经过 第一次 分类 回归 得到 的 推荐 框 crop 原图 
经过 特征提取 网 生成 的 特征 图 结果 作为 Proposals 
进行 分类 回归 FPN 总体 来看 和 Faster R CNN 
类似 不过 crop 的 目标 不再 是 原图 经过 网络 
生成 的 一张 特征 图 而是 在 特征 金字塔 上 
寻找 某一 层 作为 crop 目标 Cascade R CNN 这篇 
是 CVPR 2018 的 文章 核心 是 Cascade roi wise 
subnet 用于 更好 的 利用 IOU 进行 回归 结果 的 
修正 简单 解释一下 下图 经过 conv 出来 的 特征 要 
经过 align pool 才能 进入 subnet 这里 采用 了 联 
级 的 方式 操作 B0 是 二 分类 生成 的 
框 选取 一 系列 IOU 阈值 { 0.5 0.6 0.7 
} B1 是 B0 在 conv 输出 特征 上 crop 
出来 子 区域 经过 H1 回归 的 结果 B2 则是 
B1 在 conv 输出 阈值 逐渐 严格 回归 效果 更好 
R FCN 生成 K * K * C + 1 
张 特征 K 为 ROI 输出 尺寸 在 K * 
K 组 中 每 一组 只取 对应 输出 位置 的 
Pool 结果 重新排列 整理 得到 我们 想要 的 特征 计算机 
视觉 R FCN4 设计 ROI 算法 ROI Pooling ROI Align 
PSROI Pool PRROI Pool5 两 步法 准确率 提升 6 模型 
后处理 NMS 非 极大值 抑制 Soft NMSdef cpu _ soft 
_ nms np . ndarray float ndim = 2 boxes 
float sigma = 0.5 float Nt = 0.3 float threshold 
= 0.001 unsigned int method = 0 cdef unsigned int 
N = boxes . shape 0 cdef float iw ih 
box _ area cdef float ua cdef int pos = 
0 cdef float maxscore = 0 cdef int maxpos = 
0 cdef float x1 x2 y1 y2 tx1 tx2 ty1 
ty2 ts area weight ov for i in range N 
maxscore = boxes i 4 maxpos = i tx1 = 
boxes i 0 ty1 = boxes i 1 tx2 = 
boxes i 2 ty2 = boxes i 3 ts = 
boxes i 4 pos = i + 1 # get 
max box while pos N if maxscore boxes pos 4 
maxscore = boxes pos 4 maxpos = pos pos = 
pos + 1 # add max box as a detection 
boxes i 0 = boxes maxpos 0 boxes i 1 
= boxes maxpos 1 boxes i 2 = boxes maxpos 
2 boxes i 3 = boxes maxpos 3 boxes i 
4 = boxes maxpos 4 # swap ith box with 
position of max box boxes maxpos 0 = tx1 boxes 
maxpos 1 = ty1 boxes maxpos 2 = tx2 boxes 
maxpos 3 = ty2 boxes maxpos 4 = ts tx1 
= boxes i 0 ty1 = boxes i 1 tx2 
= boxes i 2 ty2 = boxes i 3 ts 
= boxes i 4 pos = i + 1 # 
NMS iterations note that N changes if detection boxes fall 
below threshold while pos N x1 = boxes pos 0 
y1 = boxes pos 1 x2 = boxes pos 2 
y2 = boxes pos 3 s = boxes pos 4 
area = x2 x1 + 1 * y2 y1 + 
1 iw = min tx2 x2 max tx1 x1 + 
1 if iw 0 ih = min ty2 y2 max 
ty1 y1 + 1 if ih 0 ua = float 
tx2 tx1 + 1 * ty2 ty1 + 1 + 
area iw * ih ov = iw * ih / 
ua # iou between max box and detection box if 
method = = 1 # linear if ov Nt weight 
= 1 ov else weight = 1 elif method = 
= 2 # gaussian weight = np . exp ov 
* ov / sigma else # original NMS if ov 
Nt weight = 0 else weight = 1 boxes pos 
4 = weight * boxes pos 4 # if box 
score falls below threshold discard the box by swapping with 
last box # update N if boxes pos 4 threshold 
boxes pos 0 = boxes N 1 0 boxes pos 
1 = boxes N 1 1 boxes pos 2 = 
boxes N 1 2 boxes pos 3 = boxes N 
1 3 boxes pos 4 = boxes N 1 4 
N = N 1 pos = pos 1 pos = 
pos + 1 keep = i for i in range 
N return keepIOU Guided NMS 资料 来源 人工智能 前沿 讲习 表格 资料 来源 hoya012 的 
G i t h u b D e t e 
c t o r V O C 0 7 mAP 
@ IoU = 0.5 VOC12 mAP @ IoU = 0.5 
COCO mAP @ IoU = 0.5 0.95 Published InR CNN58 
. 5 CVPR 14SPP Net59 . 2 ECCV 14MR CNN78 
. 2 07 + 12 73.9 07 + 12 ICCV 
15Fast R CNN70 . 0 07 + 12 68.4 07 
+ + 12 19 . 7ICCV 15Faster R CNN73 . 
2 07 + 12 70.4 07 + + 12 21 
. 9NIPS 15YOLO v 166.4 07 + 12 57.9 07 
+ + 12 CVPR 16G CNN66 . 866.4 07 + 
12 CVPR 16AZNet70 . 4 22 . 3CVPR 16ION80 . 
177.933 . 1CVPR 16HyperNet76 . 3 07 + 12 71.4 
07 + + 12 CVPR 16OHEM78 . 9 07 + 
12 76.3 07 + + 12 22 . 4CVPR 16MPN 
33 . 2BMVC 16SSD76 . 8 07 + 12 74.9 
07 + + 12 31 . 2ECCV 16GBDNet77 . 2 
07 + 12 27 . 0ECCV 16CPF76 . 4 07 
+ 12 72.6 07 + + 12 ECCV 16R FCN79 
. 5 07 + 12 77.6 07 + + 12 
29 . 9NIPS 16DeepID Net69 . 0 PAMI 16NoC71 . 
6 07 + 12 68.8 07 + 12 27 . 
2TPAMI 16DSSD81 . 5 07 + 12 80.0 07 + 
+ 12 33 . 2arXiv 17TDM 37 . 3CVPR 17FPN 
36 . 2CVPR 17YOLO v 278.6 07 + 12 73.4 
07 + + 12 CVPR 17RON77 . 6 07 + 
12 75.4 07 + + 12 27 . 4CVPR 17DeNet77 
. 1 07 + 12 73.9 07 + + 12 
33 . 8ICCV 17CoupleNet82 . 7 07 + 12 80.4 
07 + + 12 34 . 4ICCV 17RetinaNet 39 . 
1ICCV 17DSOD77 . 7 07 + 12 76.3 07 + 
+ 12 ICCV 17SMN70 . 0 ICCV 17Light Head R 
CNN 41 . 5arXiv 17YOLO v3 33 . 0arXiv 18SIN76 
. 0 07 + 12 73.1 07 + + 12 
23 . 2CVPR 18STDN80 . 9 07 + 12 CVPR 
18RefineDet83 . 8 07 + 12 83.5 07 + + 
12 41 . 8CVPR 18SNIP 45 . 7CVPR 18Relation Network 
32 . 5CVPR 18Cascade R CNN 42 . 8CVPR 18MLKP80 
. 6 07 + 12 77.2 07 + + 12 
28 . 6CVPR 18Fitness NMS 41 . 8CVPR 18RFBNet82 . 
2 07 + 12 ECCV 18CornerNet 42 . 1ECCV 18PFPNet84 
. 1 07 + 12 83.7 07 + + 12 
39 . 4ECCV 18Pelee70 . 9 07 + 12 NIPS 
18HKRM78 . 8 07 + 12 37 . 8NIPS 18M2Det 
44 . 2AAAI 19R DAD81 . 2 07 + + 
12 82.0 07 + + 12 43 . 1AAAI 19 
一 One Stage 和 Two Stage 物体 检测 算法 大致 
分为 两类 一步法 检测器 和二/nr 步法 检测器 一步法 检测器 在 
原图 上 铺设 一系列 锚 点 框 anchor 利用 一个 
全 卷积 网络 对 这些 锚 点 框 进行 一次 
分类 和 一次 回归 得到 检测 结果 二 步法 检测器 
在 原图 上 铺设 一系列 锚 点 框 anchor 利用 
一个 网络 对 这些 锚 点 框 进行 两次 分类 
和 两次 回归 得到 检测 结果 相对于 一步法 检测器 二 
步法 检测器 多 了 一个 步骤 如果 这 两类 方法 
在 相同 的 条件 下 如 相同 的 输入 相同 
的 anchor 设置 相同 的 机器 等 一步法 一般 胜在 
高效率 因为 它 没有 耗时 的 第二 步 而 二 
步法 的 精度 要 更高 一些 现在 各 个 检测 
库 上 排名 靠前 的 算法 基本 都是 二 步法 
比较 出名 的 一步法 检测器 有 YOLO SSD RetinaNet CornerNet 
其中 SSD 是 一步法 检测器 的 集大成 者 后续/v 大/a 
部分/n 的/uj 一步法/l 工作/vn 都是/nr 基于/p 它/r 的/uj 比较/d 出名/v 
的/uj 二/m 步法/n 检测器/n 有/v Faster/w R CNN R FCN 
FPN Cascade R CNN SNIP 其中 Faster R CNN 是 
奠基 性 工作 基本 所有 的 检测 算法 的 都是 
在 它 的 基础上 改进 的 包括 一步法 SSDTwo Stage 
的 精度 优势 二 阶段 的 分类 二 步法 的 
第一 步在/nr 分类 时 正负 样本 是 极不 平衡 的 
导致 分类器 训练 比较 困难 这 也是 一步法 效果 不如 
二 步法 的 原因 之一 也是 focal loss 的 motivation 
而 第二 步在/nr 分类 时 由于 第一步 滤掉 了 绝大部分 
的 负 样本 送给 第二步 分类 的 proposal 中 正负 
样本 比例 已经 比较 平衡 了 所以 第二步 分类 中 
不存在 正负 样本 极度 不 平衡 的 问题 即 二步 
法 可以 在 很大 程度 上 缓和 正负 样本 极度 
不 平衡 的 分类 问题 二 阶段 的 回归 二 
步法 中 第一步 会 先 对 初始 候选框 进行 校正 
然后 把 校 正过 的 候选框 送给 第二步 作为 第二 
步 校正 的 初始 候选框 再让 第二步 进一步 校正 二 
阶段 的 特征 在 二 步法 中 第一步 和 第二 
步法 除了 共享 的 特征 外 他们/r 都有/nr 自己/r 独有/v 
的/uj 特征/n 专注 于 自身 的 任务 具体来说 这 两个 
步骤 独有 的 特征 分别 处理 着 不同 难度 的 
任务 如 第一步 中的 特征 专注 于 处理 二 分类 
任务 区分 前景 和 背景 和 粗略 的 回归 问题 
第二步 的 特征 专注/v 于/p 处理/v 多/m 分类/n 任务/n 和/c 
精确/a 的/uj 回归/v 问题/n 特征/n 校准/n 在 二 步法 中 
有 一个 很 重要 的 RoIPooling 扣 特征 的 操作 
它 把 候选 区域 对应 的 特征 抠出来 达到 了 
特征 校准 的 目的 而 一步法 中 特征 是 对 
不齐 的 二 One Stage 目标 检测 1 One Stage 
目标 检测 Pipeline2 One Stage 目标 检测 模型 改进 方向 
网络设计 主干网络 anchors 设置 方案 检测 框 回归 方式 损失 
函数 PPT 原文 如下 3 网络设计 改进 作者 使用 SSD 
系列 网络 的 发展 展示 了 One Stage 网络 主干 
发展 的 脉络 DSSD 和 FSSD 我 在 学校 的 
组 会上 做过 讲解 不过 没有 整理 成文 这里 不 
做 过多 讲解 以后 再提 SSDDSSDFSSD4 anchors 生成 方案 改进 
YOLOv1SSDYOLOv2 v3RefineDet 这个 网络 本文 后面 会 介绍 这里 不多 
赘述 5 回归 目标 设计 YOLOYOLO 用 不相 重叠 的 
网格 划分 区域 而 选取 的 anchor 为 真实 框 
中心点 所在 的 网格 作 为 回归 的 起始 框 
去 匹配 检测 目标 即 一个 anchor 对应 一个 targetSSDSSD 
的 网格 多 且 相互 重叠 其 匹配 策略 也 
略 复杂 每一个 anchor 网格 都 有一个 自己 的 class 
都 要去 匹配 一个 真实 框 在 贡献 loss 的 
时候 真实 框 仅 和 IOU 大于 阈值 的 anchor 
相匹配 参见 TensorFlow SSD 源码 学习 _ 其二 基于 VGG 
的 SSD 网络 前 向 架构 TensorFlow SSD 源码 学习 
_ 其 七 损失 函数 CornetNetECCV 2018 的 文章 不 
采用 anchor 修正 的 方法 做 物体 检测 而是 将 
ground truth 的 左上 和 右下 两个 角 点视 为 
关键 点 用 热 图 来 定位 实际 设计 很 
复杂 其 损失 函数 设计 也 值得一看 特殊 的 网络 
一定会 有 特殊 的 损失 函数 相匹配 除了 原文 外 
推荐 个 博客 辅助 理解 CornetNet 算法 理解 6 损失 
函数 OHEMOHEM 是 Fast RCNN 的 改进 适合于 batch size 
images 较少 但 每张 image 的 examples 很多 的 情况 
针对 困难 object 进行 提取 思想 概括 如下 In OHEM 
each example is scored by its loss non maximum suppression 
nms is then applied and a minibatch is constructed with 
the highest loss examples . 实际应用 流程 将 Fast RCNN 
分成 两个 components ConvNet 和 RoINet .   ConvNet 为 
共享 的 底层 卷积 层 RoINet 为 RoI Pooling 后的层/nr 
包括 全 连接 层 2 对于 每张 输入 图像 经前向/nr 
传播/vn 用 ConvNet 获得 feature maps 这里 为 RoI Pooling 
层 的 输入 3 将 事先 计 算好 的 proposals 
经 RoI Pooling 层 投影 到 feature maps 上 获取 
固定 的 特征 输出 作为 全 连接 层 的 输入 
需要 注意 的 是 论 文说 为了 减少 显存 以及 
后向 传播 的 时间 这里 的 RoINet 是 有 两个 
的 它们 共享 权重 RoINet1 是 只读 只 进行 forward 
RoINet2 进行 forward 和 backward a   将 原图 的 
所有 props 扔到 RoINet1 上图 a 部分 计算 它们 的 
loss 这里 有 两个 loss cls 和 det b 根据 
loss 从高 到 低 排序 以及 利用 NMS 来 选出 
前 K 个 props K 由 论文 里 的 N 
和B/nr 参数 决定 为什么 要 用 NMS 显然 对于 那些 
高度 overlap 的 props 经 RoI 的 投 影后 其 
在 feature maps 上 的 位置 和 大小 是 差不多 
一样 的 容易 导致 loss double counting 问题 c 将 
选出 的 K 个 props 可以 理解 成 hard examples 
扔到 RoINet2 上图 b 部分 这时 的 RoINet2 和 Fast 
RCNN 的 RoINet 一样 计算 K 个 props 的 loss 
并 回传 梯度 / 残差 给 ConvNet 来 更新 整个 
网络 Focal lossRetinaNet 提出 的 致力 于 解决 正负 样本 
不 均衡 的 新型 损失 函数 出发点 希望 one stage 
detector 可以 达到 two stage detector 的 准确率 同时 不 
影响 原有 的 速度 问题 假设 作者 认为 one stage 
detector 的 准确率 不如 two stage detector 的 原因 是 
样本 的 类别 不均衡 相关 工作 作者 认为 OHEM 算法 
虽然 增加 了 错 分类 样本 的 权重 但 是 
完全 忽略 了 容易 分类 的 样本 focal loss 在 
标准 交叉 熵 损失 基础 上 修改 得到 的 这个 
函数 可以 通过 减少 易 分类 样本 的 权重 使得/v 
模型/n 在/p 训练/vn 时更/nr 专注/v 于难/nr 分类/n 的/uj 样本/n 原/n 
交叉/n 熵/g Focal loss 改进 gamma 0 使得 减少 易 
分类 样本 的 损失 使得 更 关注 于 困难 的 
错分 的 样本 添加 正负 样本 加入 平衡 因子 alpha 
用来 平衡 正负 样本 本身 的 比例 不均 三 Two 
Stage 目标 检测 1 Two Stage 目标 检测 Pipeline2 Two 
Stage 目标 检测 模型 改进 方向 生成 ProposalsROI 特征 获取 
ROI 算法 设计 加速 检测 后 处理 回归 框 PPT 
原文 如下 3 生成 ProposalsR CNN 使用 某些 算法 生成 
推荐 框 这些 推荐 区直 接在 原 图上 crop 生成 
Proposals 然后 非 极大值 抑制 合并 这些 Proposals 的 分类 
回归 结果 作者 使用 聚 类 描述 这个 合并 过程 
Faster R CNN 这个 讲 滥 了 直接 用 anchors 
经过 第一次 分类 回归 得到 的 推荐 框 crop 原图 
经过 特征提取 网 生成 的 特征 图 结果 作为 Proposals 
进行 分类 回归 FPN 总体 来看 和 Faster R CNN 
类似 不过 crop 的 目标 不再 是 原图 经过 网络 
生成 的 一张 特征 图 而是 在 特征 金字塔 上 
寻找 某一 层 作为 crop 目标 Cascade R CNN 这篇 
是 CVPR 2018 的 文章 核心 是 Cascade roi wise 
subnet 用于 更好 的 利用 IOU 进行 回归 结果 的 
修正 简单 解释一下 下图 经过 conv 出来 的 特征 要 
经过 align pool 才能 进入 subnet 这里 采用 了 联 
级 的 方式 操作 B0 是 二 分类 生成 的 
框 选取 一 系列 IOU 阈值 { 0.5 0.6 0.7 
} B1 是 B0 在 conv 输出 特征 上 crop 
出来 子 区域 经过 H1 回归 的 结果 B2 则是 
B1 在 conv 输出 阈值 逐渐 严格 回归 效果 更好 
R FCN 生成 K * K * C + 1 
张 特征 K 为 ROI 输出 尺寸 在 K * 
K 组 中 每 一组 只取 对应 输出 位置 的 
Pool 结果 重新排列 整理 得到 我们 想要 的 特征 计算机 
视觉 R FCN4 设计 ROI 算法 ROI Pooling ROI Align 
PSROI Pool PRROI Pool5 两 步法 准确率 提升 6 模型 
后处理 NMS 非 极大值 抑制 Soft NMSdef cpu _ soft 
_ nms np . ndarray float ndim = 2 boxes 
float sigma = 0.5 float Nt = 0.3 float threshold 
= 0.001 unsigned int method = 0 cdef unsigned int 
N = boxes . shape 0 cdef float iw ih 
box _ area cdef float ua cdef int pos = 
0 cdef float maxscore = 0 cdef int maxpos = 
0 cdef float x1 x2 y1 y2 tx1 tx2 ty1 
ty2 ts area weight ov for i in range N 
maxscore = boxes i 4 maxpos = i tx1 = 
boxes i 0 ty1 = boxes i 1 tx2 = 
boxes i 2 ty2 = boxes i 3 ts = 
boxes i 4 pos = i + 1 # get 
max box while pos N if maxscore boxes pos 4 
maxscore = boxes pos 4 maxpos = pos pos = 
pos + 1 # add max box as a detection 
boxes i 0 = boxes maxpos 0 boxes i 1 
= boxes maxpos 1 boxes i 2 = boxes maxpos 
2 boxes i 3 = boxes maxpos 3 boxes i 
4 = boxes maxpos 4 # swap ith box with 
position of max box boxes maxpos 0 = tx1 boxes 
maxpos 1 = ty1 boxes maxpos 2 = tx2 boxes 
maxpos 3 = ty2 boxes maxpos 4 = ts tx1 
= boxes i 0 ty1 = boxes i 1 tx2 
= boxes i 2 ty2 = boxes i 3 ts 
= boxes i 4 pos = i + 1 # 
NMS iterations note that N changes if detection boxes fall 
below threshold while pos N x1 = boxes pos 0 
y1 = boxes pos 1 x2 = boxes pos 2 
y2 = boxes pos 3 s = boxes pos 4 
area = x2 x1 + 1 * y2 y1 + 
1 iw = min tx2 x2 max tx1 x1 + 
1 if iw 0 ih = min ty2 y2 max 
ty1 y1 + 1 if ih 0 ua = float 
tx2 tx1 + 1 * ty2 ty1 + 1 + 
area iw * ih ov = iw * ih / 
ua # iou between max box and detection box if 
method = = 1 # linear if ov Nt weight 
= 1 ov else weight = 1 elif method = 
= 2 # gaussian weight = np . exp ov 
* ov / sigma else # original NMS if ov 
Nt weight = 0 else weight = 1 boxes pos 
4 = weight * boxes pos 4 # if box 
score falls below threshold discard the box by swapping with 
last box # update N if boxes pos 4 threshold 
boxes pos 0 = boxes N 1 0 boxes pos 
1 = boxes N 1 1 boxes pos 2 = 
boxes N 1 2 boxes pos 3 = boxes N 
1 3 boxes pos 4 = boxes N 1 4 
N = N 1 pos = pos 1 pos = 
pos + 1 keep = i for i in range 
N return keepIOU Guided NMS 