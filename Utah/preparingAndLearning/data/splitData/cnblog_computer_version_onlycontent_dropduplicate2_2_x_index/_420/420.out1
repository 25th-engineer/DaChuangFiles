图像 的 几何变换 主要 包括 平移 扩大 与 缩小 旋转 
仿射 透视 等等 图像 变换 是 建立 在 矩阵 运算 
基础上 的 通过 矩阵 运算 可以 很快 的 找到 对应 
关系 1 . 图像 的 平移 图像 的 平移 沿着 
x 方向 tx 距离 y 方向 ty 距离 需要 构造 
移动 矩阵 M 通过 numpy 来 产生 这个 矩阵 并 
将其 赋值 给 仿射 函数 cv2 . warpAffine . 仿射 
函数 cv2 . warpAffine 接受 三个 参数 需要 变换 的 
原始 图像 移动 矩阵 M 以及 变换 的 图像 大小 
这个 大小 如果不 和 原始 图像 大小 相同 那么 函数 
会 自动 通过 插值 来 调整 像素 间 的 关系 
import cv2 import numpy as np import matplotlib . pyplot 
as plt img = cv2 . imread flower . jpg 
H = np . float32 1 0 100 0 1 
50 rows cols = img . shape 2 res = 
cv2 . warpAffine img H rows cols # 需要 图像 
变换 矩阵 变换 后的/nr 大小 plt . subplot 121 plt 
. imshow img plt . subplot 122 plt . imshow 
res plt . show 2 . 图像 的 缩放 图像 
的 缩放 有 专门 的 一个 函数 cv2 . resize 
需要 确定 的 是 缩放 比例 另外 一个 就是 在 
缩放 以后 图像 必然 就会 变化 这就 又 涉及 到 
一个 插值 问题 那么 这个 函数 中 缩放 有 几种 
不同 的 插值 interpolation 方法 在 缩小 时 推荐 cv2 
. INTER _ ARER 扩大 是 推荐 cv2 . INTER 
_ CUBIC 和 cv2 . INTER _ LINEAR 默认 都是 
cv2 . INTER _ LINEARimport cv2 import matplotlib . pyplot 
as plt img = cv2 . imread flower . jpg 
# 插值 interpolation # None 本 应该 是 放 图像 
大小 的 位置 的 后面 设置 了 缩放 比例 所有 
就 不要 了 res1 = cv2 . resize img None 
fx = 2 fy = 2 interpolation = cv2 . 
INTER _ CUBIC # 直接 规定 缩放 大小 这个 时候 
就 不需要 缩放 因子 height width = img . shape 
2 res2 = cv2 . resize img 2 * width 
2 * height interpolation = cv2 . INTER _ CUBIC 
plt . subplot 131 plt . imshow img plt . 
subplot 132 plt . imshow res1 plt . subplot 133 
plt . imshow res2 plt . show 3 . 图像 
的 旋转 图像 旋转 需 构造 旋转 矩阵 opencv 提供 
了 一个 函数   cv2 . g e t R 
o t a t i o n M a t 
r i x 2 D 这个 函数 需要 三个 参数 
旋转 中心 旋转 角度 旋转 后 图像 的 缩放 比例 
import cv2 import matplotlib . pyplot as plt img = 
cv2 . imread flower . jpg rows cols = img 
. shape 2 # 第一 个 参数 旋转 中心 第二个 
参数 旋转 角度 第三个 参数 缩放 比例 M = cv2 
. g e t R o t a t i 
o n M a t r i x 2 D 
cols / 2 rows / 2 45 1 # 第三 
个 参数 变换 后的/nr 图像 大小 res = cv2 . 
warpAffine img M rows cols plt . subplot 121 plt 
. imshow img plt . subplot 122 plt . imshow 
res plt . show 4 . 图像 的 仿射 图像 
的 旋转 加上 拉升 就是 图像 仿射变换 仿射 变化 也 
需要 一个 变换 矩阵 M opencv 提供 了 根据 变换 
前后 三个点 的 对应 关系 来 自动 求解 M 这个 
函数 是 M = cv2 . g e t A 
f f i n e T r a n s 
f o r m pos1 pos2 其中 两个 位置 就是 
变换 前后 的 对应 位置 关系 输出 的 就是 仿射 
矩阵 M 然后 再 使用 函数 cv2 . warpAffine import 
cv2 import numpy as np import matplotlib . pyplot as 
plt img = cv2 . imread flower . jpg rows 
cols = img . shape 2 pts1 = np . 
float32 50 50 200 50 50 200 pts2 = np 
. float32 10 100 200 50 100 250 M = 
cv2 . g e t A f f i n 
e T r a n s f o r m 
pts1 pts2 # 第三 个 参数 变换 后的/nr 图像 大小 
res = cv2 . warpAffine img M rows cols plt 
. subplot 121 plt . imshow img plt . subplot 
122 plt . imshow res plt . show 5 . 
图像 的 透射 透视 需要 的 是 一个 3 * 
3 的 矩阵 opencv 的 函数 是 M = cv2 
. g e t P e r s p e 
c t i v e T r a n s 
f o r m pts1 pts2 其中 pts 需要 变换 
前后 的 4个 点 对应 位置 得到 M 后 再通过 
函数 cv2 . warpPerspective img M 200 200 进行 import 
cv2 import numpy as np import matplotlib . pyplot as 
plt img = cv2 . imread flower . jpg rows 
cols = img . shape 2 pts1 = np . 
float32 56 65 238 52 28 237 239 240 pts2 
= np . float32 0 0 200 0 0 200 
200 200 M = cv2 . g e t P 
e r s p e c t i v e 
T r a n s f o r m pts1 
pts2 res = cv2 . warpPerspective img M 200 200 
plt . subplot 121 plt . imshow img plt . 
subplot 122 plt . imshow res plt . show 图像 的 几何变换 主要 包括 平移 扩大 与 缩小 旋转 
仿射 透视 等等 图像 变换 是 建立 在 矩阵 运算 
基础上 的 通过 矩阵 运算 可以 很快 的 找到 对应 
关系 1 . 图像 的 平移 图像 的 平移 沿着 
x 方向 tx 距离 y 方向 ty 距离 需要 构造 
移动 矩阵 M 通过 numpy 来 产生 这个 矩阵 并 
将其 赋值 给 仿射 函数 cv2 . warpAffine . 仿射 
函数 cv2 . warpAffine 接受 三个 参数 需要 变换 的 
原始 图像 移动 矩阵 M 以及 变换 的 图像 大小 
这个 大小 如果不 和 原始 图像 大小 相同 那么 函数 
会 自动 通过 插值 来 调整 像素 间 的 关系 
import cv2 import numpy as np import matplotlib . pyplot 
as plt img = cv2 . imread flower . jpg 
H = np . float32 1 0 100 0 1 
50 rows cols = img . shape 2 res = 
cv2 . warpAffine img H rows cols # 需要 图像 
变换 矩阵 变换 后的/nr 大小 plt . subplot 121 plt 
. imshow img plt . subplot 122 plt . imshow 
res plt . show 2 . 图像 的 缩放 图像 
的 缩放 有 专门 的 一个 函数 cv2 . resize 
需要 确定 的 是 缩放 比例 另外 一个 就是 在 
缩放 以后 图像 必然 就会 变化 这就 又 涉及 到 
一个 插值 问题 那么 这个 函数 中 缩放 有 几种 
不同 的 插值 interpolation 方法 在 缩小 时 推荐 cv2 
. INTER _ ARER 扩大 是 推荐 cv2 . INTER 
_ CUBIC 和 cv2 . INTER _ LINEAR 默认 都是 
cv2 . INTER _ LINEARimport cv2 import matplotlib . pyplot 
as plt img = cv2 . imread flower . jpg 
# 插值 interpolation # None 本 应该 是 放 图像 
大小 的 位置 的 后面 设置 了 缩放 比例 所有 
就 不要 了 res1 = cv2 . resize img None 
fx = 2 fy = 2 interpolation = cv2 . 
INTER _ CUBIC # 直接 规定 缩放 大小 这个 时候 
就 不需要 缩放 因子 height width = img . shape 
2 res2 = cv2 . resize img 2 * width 
2 * height interpolation = cv2 . INTER _ CUBIC 
plt . subplot 131 plt . imshow img plt . 
subplot 132 plt . imshow res1 plt . subplot 133 
plt . imshow res2 plt . show 3 . 图像 
的 旋转 图像 旋转 需 构造 旋转 矩阵 opencv 提供 
了 一个 函数   cv2 . g e t R 
o t a t i o n M a t 
r i x 2 D 这个 函数 需要 三个 参数 
旋转 中心 旋转 角度 旋转 后 图像 的 缩放 比例 
import cv2 import matplotlib . pyplot as plt img = 
cv2 . imread flower . jpg rows cols = img 
. shape 2 # 第一 个 参数 旋转 中心 第二个 
参数 旋转 角度 第三个 参数 缩放 比例 M = cv2 
. g e t R o t a t i 
o n M a t r i x 2 D 
cols / 2 rows / 2 45 1 # 第三 
个 参数 变换 后的/nr 图像 大小 res = cv2 . 
warpAffine img M rows cols plt . subplot 121 plt 
. imshow img plt . subplot 122 plt . imshow 
res plt . show 4 . 图像 的 仿射 图像 
的 旋转 加上 拉升 就是 图像 仿射变换 仿射 变化 也 
需要 一个 变换 矩阵 M opencv 提供 了 根据 变换 
前后 三个点 的 对应 关系 来 自动 求解 M 这个 
函数 是 M = cv2 . g e t A 
f f i n e T r a n s 
f o r m pos1 pos2 其中 两个 位置 就是 
变换 前后 的 对应 位置 关系 输出 的 就是 仿射 
矩阵 M 然后 再 使用 函数 cv2 . warpAffine import 
cv2 import numpy as np import matplotlib . pyplot as 
plt img = cv2 . imread flower . jpg rows 
cols = img . shape 2 pts1 = np . 
float32 50 50 200 50 50 200 pts2 = np 
. float32 10 100 200 50 100 250 M = 
cv2 . g e t A f f i n 
e T r a n s f o r m 
pts1 pts2 # 第三 个 参数 变换 后的/nr 图像 大小 
res = cv2 . warpAffine img M rows cols plt 
. subplot 121 plt . imshow img plt . subplot 
122 plt . imshow res plt . show 5 . 
图像 的 透射 透视 需要 的 是 一个 3 * 
3 的 矩阵 opencv 的 函数 是 M = cv2 
. g e t P e r s p e 
c t i v e T r a n s 
f o r m pts1 pts2 其中 pts 需要 变换 
前后 的 4个 点 对应 位置 得到 M 后 再通过 
函数 cv2 . warpPerspective img M 200 200 进行 import 
cv2 import numpy as np import matplotlib . pyplot as 
plt img = cv2 . imread flower . jpg rows 
cols = img . shape 2 pts1 = np . 
float32 56 65 238 52 28 237 239 240 pts2 
= np . float32 0 0 200 0 0 200 
200 200 M = cv2 . g e t P 
e r s p e c t i v e 
T r a n s f o r m pts1 
pts2 res = cv2 . warpPerspective img M 200 200 
plt . subplot 121 plt . imshow img plt . 
subplot 122 plt . imshow res plt . show 图像 的 几何变换 主要 包括 平移 扩大 与 缩小 旋转 
仿射 透视 等等 图像 变换 是 建立 在 矩阵 运算 
基础上 的 通过 矩阵 运算 可以 很快 的 找到 对应 
关系 1 . 图像 的 平移 图像 的 平移 沿着 
x 方向 tx 距离 y 方向 ty 距离 需要 构造 
移动 矩阵 M 通过 numpy 来 产生 这个 矩阵 并 
将其 赋值 给 仿射 函数 cv2 . warpAffine . 仿射 
函数 cv2 . warpAffine 接受 三个 参数 需要 变换 的 
原始 图像 移动 矩阵 M 以及 变换 的 图像 大小 
这个 大小 如果不 和 原始 图像 大小 相同 那么 函数 
会 自动 通过 插值 来 调整 像素 间 的 关系 
import cv2 import numpy as np import matplotlib . pyplot 
as plt img = cv2 . imread flower . jpg 
H = np . float32 1 0 100 0 1 
50 rows cols = img . shape 2 res = 
cv2 . warpAffine img H rows cols # 需要 图像 
变换 矩阵 变换 后的/nr 大小 plt . subplot 121 plt 
. imshow img plt . subplot 122 plt . imshow 
res plt . show 2 . 图像 的 缩放 图像 
的 缩放 有 专门 的 一个 函数 cv2 . resize 
需要 确定 的 是 缩放 比例 另外 一个 就是 在 
缩放 以后 图像 必然 就会 变化 这就 又 涉及 到 
一个 插值 问题 那么 这个 函数 中 缩放 有 几种 
不同 的 插值 interpolation 方法 在 缩小 时 推荐 cv2 
. INTER _ ARER 扩大 是 推荐 cv2 . INTER 
_ CUBIC 和 cv2 . INTER _ LINEAR 默认 都是 
cv2 . INTER _ LINEARimport cv2 import matplotlib . pyplot 
as plt img = cv2 . imread flower . jpg 
# 插值 interpolation # None 本 应该 是 放 图像 
大小 的 位置 的 后面 设置 了 缩放 比例 所有 
就 不要 了 res1 = cv2 . resize img None 
fx = 2 fy = 2 interpolation = cv2 . 
INTER _ CUBIC # 直接 规定 缩放 大小 这个 时候 
就 不需要 缩放 因子 height width = img . shape 
2 res2 = cv2 . resize img 2 * width 
2 * height interpolation = cv2 . INTER _ CUBIC 
plt . subplot 131 plt . imshow img plt . 
subplot 132 plt . imshow res1 plt . subplot 133 
plt . imshow res2 plt . show 3 . 图像 
的 旋转 图像 旋转 需 构造 旋转 矩阵 opencv 提供 
了 一个 函数   cv2 . g e t R 
o t a t i o n M a t 
r i x 2 D 这个 函数 需要 三个 参数 
旋转 中心 旋转 角度 旋转 后 图像 的 缩放 比例 
import cv2 import matplotlib . pyplot as plt img = 
cv2 . imread flower . jpg rows cols = img 
. shape 2 # 第一 个 参数 旋转 中心 第二个 
参数 旋转 角度 第三个 参数 缩放 比例 M = cv2 
. g e t R o t a t i 
o n M a t r i x 2 D 
cols / 2 rows / 2 45 1 # 第三 
个 参数 变换 后的/nr 图像 大小 res = cv2 . 
warpAffine img M rows cols plt . subplot 121 plt 
. imshow img plt . subplot 122 plt . imshow 
res plt . show 4 . 图像 的 仿射 图像 
的 旋转 加上 拉升 就是 图像 仿射变换 仿射 变化 也 
需要 一个 变换 矩阵 M opencv 提供 了 根据 变换 
前后 三个点 的 对应 关系 来 自动 求解 M 这个 
函数 是 M = cv2 . g e t A 
f f i n e T r a n s 
f o r m pos1 pos2 其中 两个 位置 就是 
变换 前后 的 对应 位置 关系 输出 的 就是 仿射 
矩阵 M 然后 再 使用 函数 cv2 . warpAffine import 
cv2 import numpy as np import matplotlib . pyplot as 
plt img = cv2 . imread flower . jpg rows 
cols = img . shape 2 pts1 = np . 
float32 50 50 200 50 50 200 pts2 = np 
. float32 10 100 200 50 100 250 M = 
cv2 . g e t A f f i n 
e T r a n s f o r m 
pts1 pts2 # 第三 个 参数 变换 后的/nr 图像 大小 
res = cv2 . warpAffine img M rows cols plt 
. subplot 121 plt . imshow img plt . subplot 
122 plt . imshow res plt . show 5 . 
图像 的 透射 透视 需要 的 是 一个 3 * 
3 的 矩阵 opencv 的 函数 是 M = cv2 
. g e t P e r s p e 
c t i v e T r a n s 
f o r m pts1 pts2 其中 pts 需要 变换 
前后 的 4个 点 对应 位置 得到 M 后 再通过 
函数 cv2 . warpPerspective img M 200 200 进行 import 
cv2 import numpy as np import matplotlib . pyplot as 
plt img = cv2 . imread flower . jpg rows 
cols = img . shape 2 pts1 = np . 
float32 56 65 238 52 28 237 239 240 pts2 
= np . float32 0 0 200 0 0 200 
200 200 M = cv2 . g e t P 
e r s p e c t i v e 
T r a n s f o r m pts1 
pts2 res = cv2 . warpPerspective img M 200 200 
plt . subplot 121 plt . imshow img plt . 
subplot 122 plt . imshow res plt . show 