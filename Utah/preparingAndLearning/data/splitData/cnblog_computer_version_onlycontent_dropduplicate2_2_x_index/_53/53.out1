2D 图像 几何 基元 一般 的 表示 一个 2d 几何 
基元 只用 两 个 维度 比如 x y 就 可以 
表示 了 但是 在 计算机 视觉 研究 中 为了 统一 
对 2d 几何 基元 的 操作 后面 讲到 的 仿射 
透射 变换 一般 会 以 增广 矢量 的 方式 表示 
几何 基元 齐次 坐标 将 原本 n 维 的 坐标 
用 一个 n + 1 维 的 坐标 表示 其 
两个 基本 作用 为 1 . 区分 n 维空间 的 
点 和 向量 一个点 的 第 n + 1 维 
为非 零值 而 向量 的 n + 1 维 为 
02 . 统一 几何 基元 的 旋转 平移 拉伸 投影 
等 操作 只用 一个 矩阵 就 可以 表示 2D 点 
2D 点 的 齐次 坐标 表示 为 其中 仅 在 
尺度 上 不同 的 矢量 被 视为 等同 的 被称作 
为 2D 投影 空间 其次 矢量 可以 通过 除以 最后 
你 一个 元素 来 转换 为非 齐次 矢量 X 即 
其中 是 增广 矢量 如果 最后 w 为 0 则 
称 此点 为 理想 点 或者 无穷远点 它 没有 等同 
的 非 齐次 表达 2D 直线 2D 直线 可以用 齐次 
向量 表示 其 对应 的 直线 方程 为 其 规范化 
表达 为 如果 l = 0 0 1 则 包含 
所有 无穷远点 2D 圆锥曲线 2D 图像 变换 及 示例 利用 
齐次 坐标 我们 可以 把 统一 2D 变换 操作 平移变换 
其中 I 是 2x2 的 单位矩阵 旋转变换 放缩 变换 x 
y 分别 放缩 仿射变换 投影变换 因为 而 仿射变换 是 投影 
变化 的 子集 所有 对 2D 几何 基元 的 操作 
都 以用 一个 3x3 的 Homography 表示 这样一来 对 图像 
的 多次 2D 变换 就 相当于 图像 对 多个 Homography 
矩阵 的 乘积 即 R = H1 * H2 * 
H3 . . . Hn * r 我们 用 Python 
代码 表示 这个 过程 1 import numpy as np 2 
import cv2 as cv 3 from numba import jit 4 
import matplotlib . pyplot as plt 5 from matplotlib . 
font _ manager import FontProperties 6 7 def MoveT tx 
ty lastOp = None np . ndarray 8 op = 
np . array 1 0 tx 0 1 ty 0 
0 1 dtype = np . float32 9 if lastOp 
is not None 10 op = np . dot op 
lastOp 11 return op 12 13 14 def RotateT r 
lastOp = None np . ndarray 15 op = np 
. array np . cos r np . sin r 
0 np . sin r np . cos r 0 
0 0 1 dtype = np . float32 16 if 
lastOp is not None 17 op = np . dot 
op lastOp 18 return op 19 20 21 def ZoomT 
rx ry lastOp = None np . ndarray 22 op 
= np . array rx 0 0 0 ry 0 
0 0 1 dtype = np . float32 23 if 
lastOp is not None 24 op = np . dot 
op lastOp 25 return op 26 27 def Transform imgSrc 
np . ndarray op np . ndarray 28 h w 
= imgSrc . shape 2 29 imgDst = np . 
zeros imgSrc . shape dtype = imgSrc . dtype 30 
for i in range h 31 v1 = np . 
stack np . arange w np . ones w * 
i np . ones w axis = 1 32 v2 
= np . dot v1 op 33 tpx tpy tpz 
= np . hsplit v2 3 34 for iy ix 
iz j in zip tpy tpx tpz range w 35 
py px = int iy / iz int ix / 
iz 36 if 0 = py h and 0 = 
px w 37 imgDst int py int px = imgSrc 
i j 38 39 return imgDst1 if _ _ name 
_ _ = = _ _ main _ _ 2 
font _ set = FontProperties fname = r c \ 
windows \ fonts \ msyh . ttc size = 12 
3 imgSrc = plt . imread E / Users / 
Administrator / pictures / Test / user . jpg 4 
op = np . transpose MoveT 10 30 RotateT np 
. pi / 12 ZoomT 1.1 1.2 5 6 imgDst 
= Transform imgSrc op 7 plt . figure 1 plt 
. imshow imgDst plt . title Resuult fontproperties = font 
_ set 8 plt . show 我们 对 图 进行 
了 如下 操作 1 . 对 y 尺度 放大 1.1倍 
x 尺度 放大 1.2倍 2 . 绕 z 轴 垂直于 
x y 旋转 π / 12 度 3 . x 
方向 移动 30 像素 y 方向 移动 10 像素 fig1 
原图 fig2 仿射变换 结果 可以 看到 这个 结果 并 不是 
很好 在 结果 中 发现 一些 很 明显 的 空洞 
因为 我们 对 图像 进行 了 放大 操作 和 旋转 
操作 在 这 一个 过程 中 结果 图像 的 有一些 
像素 的 值 并 不能 从 仿射变换 中 得出 从而 
形成 空洞 可见 直接 直接 对 图像 进行 正向 变换 
效果 是 不好 的 下面 我们 将 会 看到 利用 
反向 变换 + 插值 的 方法 解决 空洞 的 问题 
利用 透射 变换 来 进行 倾斜 校正 透射 变换 的 
一个 应用 就是 拿来 校正 图像 原理 很 简单 就是 
把 根据 关键点 找到 变换 矩阵 假如 使用 矩阵 并且 
设 h33 = 1 那么 就要 把 剩下 的 8个 
参 数给 解出来 8个 未知数 需要 8个 方程 又 因为 
从 仿射变换 的 对应 关系 可以 列方程 为 也 就是说 
只要 找 8个 点 的 以及 其 两两 对应 关系 
就 可以 找到 透射 变换 的 矩阵 也 就 可以 
对 图像 进行 校正 了 透射 变 换有 放缩 和 
旋转 等 操作 正如 上一 小节 所说 如果 仅 使用 
正向 变换 那么 肯定 会有 空洞 现象 的 发生 如果 
使用 反向 变换 那么 这个 问题 也 就 迎刃而解 了 
我们 要 做 的 就是 扫描 反向 变换 的 位置 
在 这里 我们 可以 采用 原 图像 正向 变换 后 
上下 左右 的 边界 点 确定 扫描 区域 然后 一个 
一个 点 反向 变换 回原 图像 中 并 根据 原 
图像 来 进行 插值 Python 代码 1 # WarpCorrection . 
py 2 3 @ jit 4 def B i l 
i n e a r I n t e r 
p o l a t i o n imgSrc np 
. ndarray h w sx float sy float float 5 
6 对 图片 的 指定 位置 做 双 线性插值 7 
param imgSrc 源 图像 8 param h src 的 高度 
9 param w src 的 宽度 10 param sx x 
位置 11 param sy y 位置 12 return 所 插入 
的 值 13 14 intSx intSy = int sx int 
sy 15 if 0 = intSx w 1 and 0 
= intSy h 1 16 x1 x2 = intSx intSx 
+ 1 17 y1 y2 = intSy intSy + 1 
18 H1 = np . dot np . array x2 
sx sx x1 imgSrc y1 y2 + 1 x1 x2 
+ 1 19 return H1 0 * y2 sy + 
H1 1 * sy y1 20 else 21 return imgSrc 
intSy intSx 22 23 def WarpCorrection imgSrc np . ndarray 
dots tuple np . ndarray 24 assert len dots = 
= 4 25 26 # 四个 点 的 顺序 一定 
要 按照 左上 右上 右下 左下 的 顺时针 顺序 点 
27 d1 d2 d3 d4 = dots 28 x1 x2 
x3 x4 = d1 0 d2 0 d3 0 d4 
0 29 y1 y2 y3 y4 = d1 1 d2 
1 d3 1 d4 1 30 assert x1 x2 31 
assert x4 x3 32 assert y1 y4 33 assert y2 
y3 34 35 objW = np . round np . 
sqrt x1 x2 * * 2 + y1 y2 * 
* 2 36 objH = np . round np . 
sqrt x2 x3 * * 2 + y2 y3 * 
* 2 37 38 # 在 这里 我 简单 地 
设 为把 所 输入 的 四个 点 的 位置 通过 
2D 变换 变换 为 长方形 的 四个 顶点 的 位置 
以 x1 为 起点 39 t1 t2 t3 t4 = 
y1 x1 y1 x1 + objW y1 + objH x1 
+ objW y1 + objH x1 40 41 rx1 rx2 
rx3 rx4 = t1 1 t2 1 t3 1 t4 
1 42 ry1 ry2 ry3 ry4 = t1 0 t2 
0 t3 0 t4 0 43 44 # = = 
= = = = = = = = = = 
= = = = Step 0 根据 8个 点 两两 
对应 关系 找到 Homography 矩阵 = = = = = 
= = = = = = = = = = 
= 45 # 把 8个 约束 写成 方程组 以 矩阵 
的 形式 表达 46 m = np . array 47 
y1 x1 1 0 0 0 ry1 * y1 ry1 
* x1 48 0 0 0 y1 x1 1 rx1 
* y1 rx1 * x1 49 y2 x2 1 0 
0 0 ry2 * y2 ry2 * x2 50 0 
0 0 y2 x2 1 rx2 * y2 rx2 * 
x2 51 y3 x3 1 0 0 0 ry3 * 
y3 ry3 * x3 52 0 0 0 y3 x3 
1 rx3 * y3 rx3 * x3 53 y4 x4 
1 0 0 0 ry4 * y4 ry4 * x4 
54 0 0 0 y4 x4 1 rx4 * y4 
rx4 * x4 55 56 57 vectorSrc = np . 
array ry1 rx1 ry2 rx2 ry3 rx3 ry4 rx4 58 
vectorSrc . shape = 1 8 59 HFlat = np 
. dot np . linalg . inv m np . 
transpose vectorSrc 60 a b c d e f g 
h = HFlat 0 0 HFlat 1 0 HFlat 2 
0 HFlat 3 0 HFlat 4 0 HFlat 5 0 
HFlat 6 0 HFlat 7 0 61 62 H = 
np . array a b c 63 d e f 
64 g h 1 dtype = np . float32 65 
66 # = = = = = = = = 
= = = = = = = = Step 1 
通过 对 原 图像 四个 顶点 进行 正向 投射 变换 
确定 目标 图像 区域 = = = = = = 
= = = = = = = = = = 
67 height width = imgSrc . shape 2 68 m 
a t r i x O r i g i 
n V e r t e x = np . 
array 0 0 1 69 0 width 1 1 70 
height 1 width 1 1 71 height 1 0 1 
72 73 result = np . dot m a t 
r i x O r i g i n V 
e r t e x np . transpose H 74 
minX = int min result 0 1 / result 0 
2 result 1 1 / result 1 2 result 2 
1 / result 2 2 result 3 1 / result 
3 2 75 maxX = int max result 0 1 
/ result 0 2 result 1 1 / result 1 
2 result 2 1 / result 2 2 result 3 
1 / result 3 2 76 minY = int min 
result 0 0 / result 0 2 result 1 0 
/ result 1 2 result 2 0 / result 2 
2 result 3 0 / result 3 2 77 maxY 
= int max result 0 0 / result 0 2 
result 1 0 / result 1 2 result 2 0 
/ result 2 2 result 3 0 / result 3 
2 78 79 # = = = = = = 
= = = = = = = = = = 
Step 2 反向 变换 + 双 二次 插值 校正 图像 
= = = = = = = = = = 
= = = = = = 80 vtr = np 
. empty 0 3 dtype = np . float32 81 
for i in range minY maxY 82 arr1 = np 
. arange minX maxX 83 arr2 = np . ones 
maxX minX 84 vt1 = np . stack arr2 * 
i arr1 arr2 axis = 1 85 vtr = np 
. concatenate vtr vt1 axis = 0 86 87 # 
请注意 因为 传 进去 的 是 规范化 后 Y X 
1 的 值 所以 得到 的 其实 是 y / 
Z x / Z 1 / Z 的 值 88 
vts = np . dot vtr np . linalg . 
inv np . transpose H 89 dstHeight dstWidth = maxY 
minY + 1 maxX minX + 1 90 imgDst = 
np . zeros dstHeight dstWidth imgSrc . shape 2 dtype 
= imgSrc . dtype 91 92 for r s in 
zip vtr vts 93 ry rx = int r 0 
int r 1 94 iy ix = s 2 95 
# 需要 解 y x = iy * g * 
y + h * x + 1 ix * g 
* y + h * x + 1 这个 方程 
96 TH = np . linalg . inv np . 
array iy * g 1 iy * h 97 ix 
* g ix * h 1 98 99 vxy = 
np . dot TH np . array iy ix 100 
sy sx = vxy 0 0 vxy 1 0 101 
102 if 0 = round sy height and 0 = 
round sx width 103 imgDst ry minY rx minX = 
B i l i n e a r I n 
t e r p o l a t i o 
n imgSrc height width sx sy 104 105 return imgDst 
这里 使用 了 双 二次 插值 双 二次 插值 的 
公式 推导 如下 fig3 . 双 二次 插值 公式 推导 
fig4 . 双 二次 插值 图像 解释 上面 右图 所 
展示 的 那样 双 二次 插值 其实 就是 一个 加权平均 
操作 为了/p 和双/nr 二次/m 插值/n 的/uj 效果/n 做/v 对比/v 我 
加了 个 最 邻近 插值 继续 往 程序 里面 加 
点 东西 来 测试 下 实际效果 在 这里 我 使用 
了 OpenCV 的 Highgui 的 包1/nr # * coding utf 
8 * 2 import matplotlib . pyplot as plt 3 
from matplotlib . font _ manager import FontProperties 4 from 
WarpTransform import * 5 from multiprocessing . dummy import Process 
6 7 windowCount = int 0 8 mainWinName = source 
9 10 def WarpImage imgSrc np . ndarray dots tuple 
count None 11 imgBLiner imgNearest = WarpCorrection imgSrc dots 12 
13 winName str = f result BLiner { count } 
14 cv . namedWindow winName 15 cv . imshow winName 
imgBLiner 16 17 winName str = f result nearest { 
count } 18 cv . namedWindow winName 19 cv . 
imshow winName imgNearest 20 21 cv . waitKey 0 22 
cv . destroyWindow winName 23 24 class W a r 
p C o r r e c t i o 
n M g r 25 def _ _ init _ 
_ self imgSrc 26 self . _ _ clickTime = 
0 27 self . _ _ imgSrc = imgSrc . 
copy 28 self . _ _ imgDrawn = imgSrc . 
copy 29 self . _ _ dots = 30 31 
@ property 32 def sourceImage self 33 return self . 
_ _ imgSrc 34 35 @ property 36 def drawnImage 
self 37 return self . _ _ imgDrawn 38 39 
@ drawnImage . setter 40 def drawnImage self newImg 41 
self . _ _ imgDrawn = newImg 42 43 @ 
property 44 def clickTime self 45 return self . _ 
_ clickTime 46 47 @ clickTime . setter 48 def 
clickTime self v 49 self . _ _ clickTime = 
v 50 51 @ property 52 def dots self 53 
return self . _ _ dots 54 55 @ staticmethod 
56 def MouseCallback event x y flags param 57 # 
四个 点 的 顺序 一定 要 按照 左上 右上 右下 
左下 的 顺时针 顺序 点 58 if event = = 
cv . EVENT _ LBUTTONDBLCLK 59 clickTime = param . 
clickTime 60 cv . circle param . drawnImage x y 
8 0 0 255 1 61 param . dots . 
append x y 62 cv . imshow mainWinName param . 
drawnImage 63 64 if clickTime + 1 = = 4 
65 global windowCount 66 p = Process target = WarpImage 
args = param . sourceImage param . dots . copy 
windowCount 67 p . daemon = True 68 p . 
start 69 70 param . drawnImage = param . sourceImage 
. copy 71 cv . imshow mainWinName param . sourceImage 
72 param . dots . clear 73 windowCount + = 
1 74 75 param . clickTime = clickTime + 1 
% 4 76 77 78 if _ _ name _ 
_ = = _ _ main _ _ 79 cv 
. namedWindow mainWinName 80 imgSrc = cv . imread E 
/ Users / Administrator / pictures / Test / skew 
. jpg 81 imgSrc = cv . resize imgSrc int 
imgSrc . shape 1 / 4 int imgSrc . shape 
0 / 4 82 83 mgr = W a r 
p C o r r e c t i o 
n M g r imgSrc 84 cv . setMouseCallback mainWinName 
W a r p C o r r e c 
t i o n M g r . MouseCallback mgr 
85 86 cv . imshow mainWinName imgSrc 87 cv . 
waitKey 0 88 cv . d e s t r 
o y A l l W i n d o 
w s 为了/p 对比/v 最/d 近邻/v 插值/n 和双/nr 二次/m 插值/n 
的/uj 差别/d 我 把 WarpCorrection 改 了 一下 # 请注意 
因为 传 进去 的 是 规范化 后 Y X 1 
的 值 所以 得到 的 其实 是 y / Z 
x / Z 1 / Z 的 值 vts = 
np . dot vtr np . linalg . inv np 
. transpose H dstHeight dstWidth = maxY minY + 1 
maxX minX + 1 imgBLiner = np . zeros dstHeight 
dstWidth imgSrc . shape 2 dtype = imgSrc . dtype 
imgNearest = np . zeros dstHeight dstWidth imgSrc . shape 
2 dtype = imgSrc . dtype for r s in 
zip vtr vts ry rx = int r 0 int 
r 1 iy ix = s 2 # 需要 解 
y x = iy * g * y + h 
* x + 1 ix * g * y + 
h * x + 1 这个 方程 TH = np 
. linalg . inv np . array iy * g 
1 iy * h ix * g ix * h 
1 vxy = np . dot TH np . array 
iy ix sy sx = vxy 0 0 vxy 1 
0 if 0 = round sy height and 0 = 
round sx width imgBLiner ry minY rx minX = B 
i l i n e a r I n t 
e r p o l a t i o n 
imgSrc height width sx sy imgNearest ry minY rx minX 
= imgSrc int round sy int round sx return imgBLiner 
imgNearest 运行 下 程序 来 看下 效果 上面 程序 的 
作用 就是 选中 要 校正 图像 的 四个 角 然后 
校正 PS 实际 运行 可能 会 相当 慢 我 没做 
优化 原图 Fig3 . 最 近邻 插值 边缘 很 粗糙 
看 清华大学出版社 几个字 Fig4 . 双 二次 插值 毛刺 很少 
但是 图像 模糊 了 OpenCV 库 中 WarpPerspective 源代码 其实 
OpenCV 是 带了 仿射变换 和 透射 变换 的 API 的 
先 来看 下 投影变换 的 源码 在 imgwarp . cpp 
部分 关键 代码 Assert 和 IPP 优化 这里 不 展示 
了 1 void cv warpPerspective InputArray _ src OutputArray _ 
dst InputArray _ M0 2 Size dsize int flags int 
borderType const Scalar & borderValue 3 { 4 Mat src 
= _ src . getMat M0 = _ M0 . 
getMat 5 _ dst . create dsize . area = 
= 0 src . size dsize src . type 6 
Mat dst = _ dst . getMat 7 8 if 
dst . data = = src . data 9 src 
= src . clone 10 11 double M 9 12 
Mat matM 3 3 CV _ 64F M 13 int 
interpolation = flags & INTER _ MAX 14 15 / 
/ 插入方法 不支持 INTER _ AREA 用 INTER _ LINEAR 
代替 16 if interpolation = = INTER _ AREA 17 
interpolation = INTER _ LINEAR 18 19 CV _ Assert 
M0 . type = = CV _ 32F | | 
M0 . type = = CV _ 64F & & 
M0 . rows = = 3 & & M0 . 
cols = = 3 20 M0 . convertTo matM matM 
. type 21 22 / / 这里 源码 是 这样 
操作 的 如果 可以 执行 IPP 那么 就 直接 执行 
IPP 指令 加 块 操作 23 / / 如果 没有 
说明 传入 的 变换 矩阵 已经 转置 过了 那么 执行 
一次 矩阵转置 24 if flags & WARP _ INVERSE _ 
MAP 25 invert matM matM 26 27 hal warpPerspectve src 
. type src . data src . step src . 
cols src . rows dst . data dst . step 
dst . cols dst . rows 28 matM . ptr 
double interpolation borderType borderValue . val 29 } 1 namespace 
hal { 2 3 void warpPerspectve int src _ type 
4 const uchar * src _ data size _ t 
src _ step int src _ width int src _ 
height 5 uchar * dst _ data size _ t 
dst _ step int dst _ width int dst _ 
height 6 const double M 9 int interpolation int borderType 
const double borderValue 4 7 { 8 Mat src Size 
src _ width src _ height src _ type const 
_ cast uchar * src _ data src _ step 
9 Mat dst Size dst _ width dst _ height 
src _ type dst _ data dst _ step 10 
11 Range range 0 dst . rows 12 W a 
r p P e r s p e c t 
i v e I n v o k e r 
invoker src dst M interpolation borderType Scalar borderValue 0 borderValue 
1 borderValue 2 borderValue 3 13 14 / / 这里 
是 一个 opencv 执行 并行 处理 的 一个 方法 真正 
执行 处理 的 代码 在 W a r p P 
e r s p e c t i v e 
I n v o k e r 的 函数 对象 
操作符 中 15 parallel _ for _ range invoker dst 
. total / double 1 16 16 } 17 18 
} / / hal 1 class W a r p 
P e r s p e c t i v 
e I n v o k e r 2 public 
ParallelLoopBody 3 { 4 public 5 W a r p 
P e r s p e c t i v 
e I n v o k e r const Mat 
& _ src Mat & _ dst const double * 
_ M int _ interpolation 6 int _ borderType const 
Scalar & _ borderValue 7 ParallelLoopBody src _ src dst 
_ dst M _ M interpolation _ interpolation 8 borderType 
_ borderType borderValue _ borderValue 9 { 10 / / 
注意 M 就是 转置 矩阵 11 } 12 13 virtual 
void operator const Range & range const 14 { 15 
const int BLOCK _ SZ = 32 16 short XY 
BLOCK _ SZ * BLOCK _ SZ * 2 A 
BLOCK _ SZ * BLOCK _ SZ 17 int x 
y x1 y1 width = dst . cols height = 
dst . rows 18 19 int bh0 = std min 
BLOCK _ SZ / 2 height 20 int bw0 = 
std min BLOCK _ SZ * BLOCK _ SZ / 
bh0 width / / 操作 块 的 宽 21 bh0 
= std min BLOCK _ SZ * BLOCK _ SZ 
/ bw0 height / / 操作 块 的 高 22 
23 / / 下面 的 意思 是 如果 支持 SSE4 
指令 那么 就 先 对 转置 矩阵 进行 预处理 下面 
会 继续 用 到 这个 pwarp _ impl _ sse4 
24 # if CV _ TRY _ SSE4 _ 1 
25 Ptr opt _ SSE4 _ 1 W a r 
p P e r s p e c t i 
v e L i n e _ SSE4 pwarp _ 
impl _ sse4 26 if CV _ CPU _ HAS 
_ SUPPORT _ SSE4 _ 1 27 pwarp _ impl 
_ sse4 = opt _ SSE4 _ 1 W a 
r p P e r s p e c t 
i v e L i n e _ SSE4 getImpl 
M 28 # endif 29 30 / / opencv 对 
投射 变换 的 操作 是 基于 块 操作 的 主要 
是 为了 方便 可以 直接 用 SSE4 指令 给 操作 
提速 31 for y = range . start y range 
. end y + = bh0 32 { 33 for 
x = 0 x width x + = bw0 34 
{ 35 int bw = std min bw0 width x 
36 int bh = std min bh0 range . end 
y / / height 37 38 / / _ XY 
是 一个 双 通道 的 Mat 下面 remap 会 用到 
39 Mat _ XY bh bw CV _ 16SC2 XY 
matA 40 Mat dpart dst Rect x y bw bh 
41 42 for y1 = 0 y1 bh y1 + 
+ 43 { 44 short * xy = XY + 
y1 * bw * 2 45 / / 就是 X 
Y W = x y 1 * M ^ T 
的 操作 46 / / 注意 现在 是 分块 操作 
所以 才有 + M 1 * y + y1 这 
一项 47 double X0 = M 0 * x + 
M 1 * y + y1 + M 2 48 
double Y0 = M 3 * x + M 4 
* y + y1 + M 5 49 double W0 
= M 6 * x + M 7 * y 
+ y1 + M 8 50 51 / / 最 
近邻 插值 52 if interpolation = = INTER _ NEAREST 
53 { 54 x1 = 0 55 56 / / 
这里 就是 刚才 上面 所说 的 pwarp _ impl _ 
sse4 所 用到 的 位置 57 # if CV _ 
TRY _ SSE4 _ 1 58 if pwarp _ impl 
_ sse4 59 pwarp _ impl _ sse4 processNN M 
xy X0 Y0 W0 bw 60 else 61 # endif 
62 for x1 bw x1 + + 63 { 64 
/ / 计算 W 65 double W = W0 + 
M 6 * x1 66 W = W 1 . 
/ W 0 67 / / 从 齐次 坐标 变到 
增广 矢量 注意 现在 是 分块 操作 所以 才有 + 
M 0 * x1 这 一项 68 / / 把 
结果 控制在 INT _ MIN INT _ MAX 中 由于 
下 面会 有把 double 转为 int 69 double fX = 
std max double INT _ MIN std min double INT 
_ MAX X0 + M 0 * x1 * W 
70 double fY = std max double INT _ MIN 
std min double INT _ MAX Y0 + M 3 
* x1 * W 71 int X = saturate _ 
cast int fX 72 int Y = saturate _ cast 
int fY 73 74 xy x1 * 2 = saturate 
_ cast short X 75 xy x1 * 2 + 
1 = saturate _ cast short Y 76 } 77 
} 78 / / 其他 插值 方法 79 else 80 
{ 81 short * alpha = A + y1 * 
bw 82 x1 = 0 83 84 / / 原 
理上 同 85 # if CV _ TRY _ SSE4 
_ 1 86 if pwarp _ impl _ sse4 87 
pwarp _ impl _ sse4 process M xy alpha X0 
Y0 W0 bw 88 else 89 # endif 90 for 
x1 bw x1 + + 91 { 92 double W 
= W0 + M 6 * x1 93 / / 
INTER _ TAB _ SIZE 在 我 的 opencv 版本 
就是 32 INTER _ BITS 是 5 94 / / 
下面 的 代码 是 先把 值 扩大 32倍 再 左移 
5位 得到 一个 值 95 W = W INTER _ 
TAB _ SIZE / W 0 96 double fX = 
std max double INT _ MIN std min double INT 
_ MAX X0 + M 0 * x1 * W 
97 double fY = std max double INT _ MIN 
std min double INT _ MAX Y0 + M 3 
* x1 * W 98 int X = saturate _ 
cast int fX 99 int Y = saturate _ cast 
int fY 100 101 xy x1 * 2 = saturate 
_ cast short X INTER _ BITS 102 xy x1 
* 2 + 1 = saturate _ cast short Y 
INTER _ BITS 103 104 / / alpha 是 remap 
里面 所 使用 的 remapBilinear 所要 用到 的 一个 参数 
这里 就不 往下 看了 105 alpha x1 = short Y 
& INTER _ TAB _ SIZE 1 * INTER _ 
TAB _ SIZE + 106 X & INTER _ TAB 
_ SIZE 1 107 } 108 } 109 } 110 
111 if interpolation = = INTER _ NEAREST 112 / 
/ 直接 运行 重 映射 直接 把 源点 映射 到 
目标 位置 的 点 113 remap src dpart _ XY 
Mat interpolation borderType borderValue 114 else 115 { 116 Mat 
_ matA bh bw CV _ 16U A 117 remap 
src dpart _ XY _ matA interpolation borderType borderValue 118 
} 119 } 120 } 121 } 122 123 private 
124 Mat src 125 Mat dst 126 const double * 
M 127 int interpolation borderType 128 Scalar borderValue 129 } 
OpenCV 的 仿射变换 源码 和 投影变换 的 类似 只是 仿射变换 
的 矩阵 M 的 元素 个数 是 6个 参考 http 
/ / www . cnblogs . com / houkai / 
p / 6660272 . htmlhttps / / en . wikipedia 
. org / wiki / Bilinear _ i n t 
e r p o l a t i o n 
h t t p / / www . cnblogs . 
com / tiandsp / archive / 2012/12 / 16/2820916 . 
html 2D 图像 几何 基元 一般 的 表示 一个 2d 几何 
基元 只用 两 个 维度 比如 x y 就 可以 
表示 了 但是 在 计算机 视觉 研究 中 为了 统一 
对 2d 几何 基元 的 操作 后面 讲到 的 仿射 
透射 变换 一般 会 以 增广 矢量 的 方式 表示 
几何 基元 齐次 坐标 将 原本 n 维 的 坐标 
用 一个 n + 1 维 的 坐标 表示 其 
两个 基本 作用 为 1 . 区分 n 维空间 的 
点 和 向量 一个点 的 第 n + 1 维 
为非 零值 而 向量 的 n + 1 维 为 
02 . 统一 几何 基元 的 旋转 平移 拉伸 投影 
等 操作 只用 一个 矩阵 就 可以 表示 2D 点 
2D 点 的 齐次 坐标 表示 为 其中 仅 在 
尺度 上 不同 的 矢量 被 视为 等同 的 被称作 
为 2D 投影 空间 其次 矢量 可以 通过 除以 最后 
你 一个 元素 来 转换 为非 齐次 矢量 X 即 
其中 是 增广 矢量 如果 最后 w 为 0 则 
称 此点 为 理想 点 或者 无穷远点 它 没有 等同 
的 非 齐次 表达 2D 直线 2D 直线 可以用 齐次 
向量 表示 其 对应 的 直线 方程 为 其 规范化 
表达 为 如果 l = 0 0 1 则 包含 
所有 无穷远点 2D 圆锥曲线 2D 图像 变换 及 示例 利用 
齐次 坐标 我们 可以 把 统一 2D 变换 操作 平移变换 
其中 I 是 2x2 的 单位矩阵 旋转变换 放缩 变换 x 
y 分别 放缩 仿射变换 投影变换 因为 而 仿射变换 是 投影 
变化 的 子集 所有 对 2D 几何 基元 的 操作 
都 以用 一个 3x3 的 Homography 表示 这样一来 对 图像 
的 多次 2D 变换 就 相当于 图像 对 多个 Homography 
矩阵 的 乘积 即 R = H1 * H2 * 
H3 . . . Hn * r 我们 用 Python 
代码 表示 这个 过程 1 import numpy as np 2 
import cv2 as cv 3 from numba import jit 4 
import matplotlib . pyplot as plt 5 from matplotlib . 
font _ manager import FontProperties 6 7 def MoveT tx 
ty lastOp = None np . ndarray 8 op = 
np . array 1 0 tx 0 1 ty 0 
0 1 dtype = np . float32 9 if lastOp 
is not None 10 op = np . dot op 
lastOp 11 return op 12 13 14 def RotateT r 
lastOp = None np . ndarray 15 op = np 
. array np . cos r np . sin r 
0 np . sin r np . cos r 0 
0 0 1 dtype = np . float32 16 if 
lastOp is not None 17 op = np . dot 
op lastOp 18 return op 19 20 21 def ZoomT 
rx ry lastOp = None np . ndarray 22 op 
= np . array rx 0 0 0 ry 0 
0 0 1 dtype = np . float32 23 if 
lastOp is not None 24 op = np . dot 
op lastOp 25 return op 26 27 def Transform imgSrc 
np . ndarray op np . ndarray 28 h w 
= imgSrc . shape 2 29 imgDst = np . 
zeros imgSrc . shape dtype = imgSrc . dtype 30 
for i in range h 31 v1 = np . 
stack np . arange w np . ones w * 
i np . ones w axis = 1 32 v2 
= np . dot v1 op 33 tpx tpy tpz 
= np . hsplit v2 3 34 for iy ix 
iz j in zip tpy tpx tpz range w 35 
py px = int iy / iz int ix / 
iz 36 if 0 = py h and 0 = 
px w 37 imgDst int py int px = imgSrc 
i j 38 39 return imgDst1 if _ _ name 
_ _ = = _ _ main _ _ 2 
font _ set = FontProperties fname = r c \ 
windows \ fonts \ msyh . ttc size = 12 
3 imgSrc = plt . imread E / Users / 
Administrator / pictures / Test / user . jpg 4 
op = np . transpose MoveT 10 30 RotateT np 
. pi / 12 ZoomT 1.1 1.2 5 6 imgDst 
= Transform imgSrc op 7 plt . figure 1 plt 
. imshow imgDst plt . title Resuult fontproperties = font 
_ set 8 plt . show 我们 对 图 进行 
了 如下 操作 1 . 对 y 尺度 放大 1.1倍 
x 尺度 放大 1.2倍 2 . 绕 z 轴 垂直于 
x y 旋转 π / 12 度 3 . x 
方向 移动 30 像素 y 方向 移动 10 像素 fig1 
原图 fig2 仿射变换 结果 可以 看到 这个 结果 并 不是 
很好 在 结果 中 发现 一些 很 明显 的 空洞 
因为 我们 对 图像 进行 了 放大 操作 和 旋转 
操作 在 这 一个 过程 中 结果 图像 的 有一些 
像素 的 值 并 不能 从 仿射变换 中 得出 从而 
形成 空洞 可见 直接 直接 对 图像 进行 正向 变换 
效果 是 不好 的 下面 我们 将 会 看到 利用 
反向 变换 + 插值 的 方法 解决 空洞 的 问题 
利用 透射 变换 来 进行 倾斜 校正 透射 变换 的 
一个 应用 就是 拿来 校正 图像 原理 很 简单 就是 
把 根据 关键点 找到 变换 矩阵 假如 使用 矩阵 并且 
设 h33 = 1 那么 就要 把 剩下 的 8个 
参 数给 解出来 8个 未知数 需要 8个 方程 又 因为 
从 仿射变换 的 对应 关系 可以 列方程 为 也 就是说 
只要 找 8个 点 的 以及 其 两两 对应 关系 
就 可以 找到 透射 变换 的 矩阵 也 就 可以 
对 图像 进行 校正 了 透射 变 换有 放缩 和 
旋转 等 操作 正如 上一 小节 所说 如果 仅 使用 
正向 变换 那么 肯定 会有 空洞 现象 的 发生 如果 
使用 反向 变换 那么 这个 问题 也 就 迎刃而解 了 
我们 要 做 的 就是 扫描 反向 变换 的 位置 
在 这里 我们 可以 采用 原 图像 正向 变换 后 
上下 左右 的 边界 点 确定 扫描 区域 然后 一个 
一个 点 反向 变换 回原 图像 中 并 根据 原 
图像 来 进行 插值 Python 代码 1 # WarpCorrection . 
py 2 3 @ jit 4 def B i l 
i n e a r I n t e r 
p o l a t i o n imgSrc np 
. ndarray h w sx float sy float float 5 
6 对 图片 的 指定 位置 做 双 线性插值 7 
param imgSrc 源 图像 8 param h src 的 高度 
9 param w src 的 宽度 10 param sx x 
位置 11 param sy y 位置 12 return 所 插入 
的 值 13 14 intSx intSy = int sx int 
sy 15 if 0 = intSx w 1 and 0 
= intSy h 1 16 x1 x2 = intSx intSx 
+ 1 17 y1 y2 = intSy intSy + 1 
18 H1 = np . dot np . array x2 
sx sx x1 imgSrc y1 y2 + 1 x1 x2 
+ 1 19 return H1 0 * y2 sy + 
H1 1 * sy y1 20 else 21 return imgSrc 
intSy intSx 22 23 def WarpCorrection imgSrc np . ndarray 
dots tuple np . ndarray 24 assert len dots = 
= 4 25 26 # 四个 点 的 顺序 一定 
要 按照 左上 右上 右下 左下 的 顺时针 顺序 点 
27 d1 d2 d3 d4 = dots 28 x1 x2 
x3 x4 = d1 0 d2 0 d3 0 d4 
0 29 y1 y2 y3 y4 = d1 1 d2 
1 d3 1 d4 1 30 assert x1 x2 31 
assert x4 x3 32 assert y1 y4 33 assert y2 
y3 34 35 objW = np . round np . 
sqrt x1 x2 * * 2 + y1 y2 * 
* 2 36 objH = np . round np . 
sqrt x2 x3 * * 2 + y2 y3 * 
* 2 37 38 # 在 这里 我 简单 地 
设 为把 所 输入 的 四个 点 的 位置 通过 
2D 变换 变换 为 长方形 的 四个 顶点 的 位置 
以 x1 为 起点 39 t1 t2 t3 t4 = 
y1 x1 y1 x1 + objW y1 + objH x1 
+ objW y1 + objH x1 40 41 rx1 rx2 
rx3 rx4 = t1 1 t2 1 t3 1 t4 
1 42 ry1 ry2 ry3 ry4 = t1 0 t2 
0 t3 0 t4 0 43 44 # = = 
= = = = = = = = = = 
= = = = Step 0 根据 8个 点 两两 
对应 关系 找到 Homography 矩阵 = = = = = 
= = = = = = = = = = 
= 45 # 把 8个 约束 写成 方程组 以 矩阵 
的 形式 表达 46 m = np . array 47 
y1 x1 1 0 0 0 ry1 * y1 ry1 
* x1 48 0 0 0 y1 x1 1 rx1 
* y1 rx1 * x1 49 y2 x2 1 0 
0 0 ry2 * y2 ry2 * x2 50 0 
0 0 y2 x2 1 rx2 * y2 rx2 * 
x2 51 y3 x3 1 0 0 0 ry3 * 
y3 ry3 * x3 52 0 0 0 y3 x3 
1 rx3 * y3 rx3 * x3 53 y4 x4 
1 0 0 0 ry4 * y4 ry4 * x4 
54 0 0 0 y4 x4 1 rx4 * y4 
rx4 * x4 55 56 57 vectorSrc = np . 
array ry1 rx1 ry2 rx2 ry3 rx3 ry4 rx4 58 
vectorSrc . shape = 1 8 59 HFlat = np 
. dot np . linalg . inv m np . 
transpose vectorSrc 60 a b c d e f g 
h = HFlat 0 0 HFlat 1 0 HFlat 2 
0 HFlat 3 0 HFlat 4 0 HFlat 5 0 
HFlat 6 0 HFlat 7 0 61 62 H = 
np . array a b c 63 d e f 
64 g h 1 dtype = np . float32 65 
66 # = = = = = = = = 
= = = = = = = = Step 1 
通过 对 原 图像 四个 顶点 进行 正向 投射 变换 
确定 目标 图像 区域 = = = = = = 
= = = = = = = = = = 
67 height width = imgSrc . shape 2 68 m 
a t r i x O r i g i 
n V e r t e x = np . 
array 0 0 1 69 0 width 1 1 70 
height 1 width 1 1 71 height 1 0 1 
72 73 result = np . dot m a t 
r i x O r i g i n V 
e r t e x np . transpose H 74 
minX = int min result 0 1 / result 0 
2 result 1 1 / result 1 2 result 2 
1 / result 2 2 result 3 1 / result 
3 2 75 maxX = int max result 0 1 
/ result 0 2 result 1 1 / result 1 
2 result 2 1 / result 2 2 result 3 
1 / result 3 2 76 minY = int min 
result 0 0 / result 0 2 result 1 0 
/ result 1 2 result 2 0 / result 2 
2 result 3 0 / result 3 2 77 maxY 
= int max result 0 0 / result 0 2 
result 1 0 / result 1 2 result 2 0 
/ result 2 2 result 3 0 / result 3 
2 78 79 # = = = = = = 
= = = = = = = = = = 
Step 2 反向 变换 + 双 二次 插值 校正 图像 
= = = = = = = = = = 
= = = = = = 80 vtr = np 
. empty 0 3 dtype = np . float32 81 
for i in range minY maxY 82 arr1 = np 
. arange minX maxX 83 arr2 = np . ones 
maxX minX 84 vt1 = np . stack arr2 * 
i arr1 arr2 axis = 1 85 vtr = np 
. concatenate vtr vt1 axis = 0 86 87 # 
请注意 因为 传 进去 的 是 规范化 后 Y X 
1 的 值 所以 得到 的 其实 是 y / 
Z x / Z 1 / Z 的 值 88 
vts = np . dot vtr np . linalg . 
inv np . transpose H 89 dstHeight dstWidth = maxY 
minY + 1 maxX minX + 1 90 imgDst = 
np . zeros dstHeight dstWidth imgSrc . shape 2 dtype 
= imgSrc . dtype 91 92 for r s in 
zip vtr vts 93 ry rx = int r 0 
int r 1 94 iy ix = s 2 95 
# 需要 解 y x = iy * g * 
y + h * x + 1 ix * g 
* y + h * x + 1 这个 方程 
96 TH = np . linalg . inv np . 
array iy * g 1 iy * h 97 ix 
* g ix * h 1 98 99 vxy = 
np . dot TH np . array iy ix 100 
sy sx = vxy 0 0 vxy 1 0 101 
102 if 0 = round sy height and 0 = 
round sx width 103 imgDst ry minY rx minX = 
B i l i n e a r I n 
t e r p o l a t i o 
n imgSrc height width sx sy 104 105 return imgDst 
这里 使用 了 双 二次 插值 双 二次 插值 的 
公式 推导 如下 fig3 . 双 二次 插值 公式 推导 
fig4 . 双 二次 插值 图像 解释 上面 右图 所 
展示 的 那样 双 二次 插值 其实 就是 一个 加权平均 
操作 为了/p 和双/nr 二次/m 插值/n 的/uj 效果/n 做/v 对比/v 我 
加了 个 最 邻近 插值 继续 往 程序 里面 加 
点 东西 来 测试 下 实际效果 在 这里 我 使用 
了 OpenCV 的 Highgui 的 包1/nr # * coding utf 
8 * 2 import matplotlib . pyplot as plt 3 
from matplotlib . font _ manager import FontProperties 4 from 
WarpTransform import * 5 from multiprocessing . dummy import Process 
6 7 windowCount = int 0 8 mainWinName = source 
9 10 def WarpImage imgSrc np . ndarray dots tuple 
count None 11 imgBLiner imgNearest = WarpCorrection imgSrc dots 12 
13 winName str = f result BLiner { count } 
14 cv . namedWindow winName 15 cv . imshow winName 
imgBLiner 16 17 winName str = f result nearest { 
count } 18 cv . namedWindow winName 19 cv . 
imshow winName imgNearest 20 21 cv . waitKey 0 22 
cv . destroyWindow winName 23 24 class W a r 
p C o r r e c t i o 
n M g r 25 def _ _ init _ 
_ self imgSrc 26 self . _ _ clickTime = 
0 27 self . _ _ imgSrc = imgSrc . 
copy 28 self . _ _ imgDrawn = imgSrc . 
copy 29 self . _ _ dots = 30 31 
@ property 32 def sourceImage self 33 return self . 
_ _ imgSrc 34 35 @ property 36 def drawnImage 
self 37 return self . _ _ imgDrawn 38 39 
@ drawnImage . setter 40 def drawnImage self newImg 41 
self . _ _ imgDrawn = newImg 42 43 @ 
property 44 def clickTime self 45 return self . _ 
_ clickTime 46 47 @ clickTime . setter 48 def 
clickTime self v 49 self . _ _ clickTime = 
v 50 51 @ property 52 def dots self 53 
return self . _ _ dots 54 55 @ staticmethod 
56 def MouseCallback event x y flags param 57 # 
四个 点 的 顺序 一定 要 按照 左上 右上 右下 
左下 的 顺时针 顺序 点 58 if event = = 
cv . EVENT _ LBUTTONDBLCLK 59 clickTime = param . 
clickTime 60 cv . circle param . drawnImage x y 
8 0 0 255 1 61 param . dots . 
append x y 62 cv . imshow mainWinName param . 
drawnImage 63 64 if clickTime + 1 = = 4 
65 global windowCount 66 p = Process target = WarpImage 
args = param . sourceImage param . dots . copy 
windowCount 67 p . daemon = True 68 p . 
start 69 70 param . drawnImage = param . sourceImage 
. copy 71 cv . imshow mainWinName param . sourceImage 
72 param . dots . clear 73 windowCount + = 
1 74 75 param . clickTime = clickTime + 1 
% 4 76 77 78 if _ _ name _ 
_ = = _ _ main _ _ 79 cv 
. namedWindow mainWinName 80 imgSrc = cv . imread E 
/ Users / Administrator / pictures / Test / skew 
. jpg 81 imgSrc = cv . resize imgSrc int 
imgSrc . shape 1 / 4 int imgSrc . shape 
0 / 4 82 83 mgr = W a r 
p C o r r e c t i o 
n M g r imgSrc 84 cv . setMouseCallback mainWinName 
W a r p C o r r e c 
t i o n M g r . MouseCallback mgr 
85 86 cv . imshow mainWinName imgSrc 87 cv . 
waitKey 0 88 cv . d e s t r 
o y A l l W i n d o 
w s 为了/p 对比/v 最/d 近邻/v 插值/n 和双/nr 二次/m 插值/n 
的/uj 差别/d 我 把 WarpCorrection 改 了 一下 # 请注意 
因为 传 进去 的 是 规范化 后 Y X 1 
的 值 所以 得到 的 其实 是 y / Z 
x / Z 1 / Z 的 值 vts = 
np . dot vtr np . linalg . inv np 
. transpose H dstHeight dstWidth = maxY minY + 1 
maxX minX + 1 imgBLiner = np . zeros dstHeight 
dstWidth imgSrc . shape 2 dtype = imgSrc . dtype 
imgNearest = np . zeros dstHeight dstWidth imgSrc . shape 
2 dtype = imgSrc . dtype for r s in 
zip vtr vts ry rx = int r 0 int 
r 1 iy ix = s 2 # 需要 解 
y x = iy * g * y + h 
* x + 1 ix * g * y + 
h * x + 1 这个 方程 TH = np 
. linalg . inv np . array iy * g 
1 iy * h ix * g ix * h 
1 vxy = np . dot TH np . array 
iy ix sy sx = vxy 0 0 vxy 1 
0 if 0 = round sy height and 0 = 
round sx width imgBLiner ry minY rx minX = B 
i l i n e a r I n t 
e r p o l a t i o n 
imgSrc height width sx sy imgNearest ry minY rx minX 
= imgSrc int round sy int round sx return imgBLiner 
imgNearest 运行 下 程序 来 看下 效果 上面 程序 的 
作用 就是 选中 要 校正 图像 的 四个 角 然后 
校正 PS 实际 运行 可能 会 相当 慢 我 没做 
优化 原图 Fig3 . 最 近邻 插值 边缘 很 粗糙 
看 清华大学出版社 几个字 Fig4 . 双 二次 插值 毛刺 很少 
但是 图像 模糊 了 OpenCV 库 中 WarpPerspective 源代码 其实 
OpenCV 是 带了 仿射变换 和 透射 变换 的 API 的 
先 来看 下 投影变换 的 源码 在 imgwarp . cpp 
部分 关键 代码 Assert 和 IPP 优化 这里 不 展示 
了 1 void cv warpPerspective InputArray _ src OutputArray _ 
dst InputArray _ M0 2 Size dsize int flags int 
borderType const Scalar & borderValue 3 { 4 Mat src 
= _ src . getMat M0 = _ M0 . 
getMat 5 _ dst . create dsize . area = 
= 0 src . size dsize src . type 6 
Mat dst = _ dst . getMat 7 8 if 
dst . data = = src . data 9 src 
= src . clone 10 11 double M 9 12 
Mat matM 3 3 CV _ 64F M 13 int 
interpolation = flags & INTER _ MAX 14 15 / 
/ 插入方法 不支持 INTER _ AREA 用 INTER _ LINEAR 
代替 16 if interpolation = = INTER _ AREA 17 
interpolation = INTER _ LINEAR 18 19 CV _ Assert 
M0 . type = = CV _ 32F | | 
M0 . type = = CV _ 64F & & 
M0 . rows = = 3 & & M0 . 
cols = = 3 20 M0 . convertTo matM matM 
. type 21 22 / / 这里 源码 是 这样 
操作 的 如果 可以 执行 IPP 那么 就 直接 执行 
IPP 指令 加 块 操作 23 / / 如果 没有 
说明 传入 的 变换 矩阵 已经 转置 过了 那么 执行 
一次 矩阵转置 24 if flags & WARP _ INVERSE _ 
MAP 25 invert matM matM 26 27 hal warpPerspectve src 
. type src . data src . step src . 
cols src . rows dst . data dst . step 
dst . cols dst . rows 28 matM . ptr 
double interpolation borderType borderValue . val 29 } 1 namespace 
hal { 2 3 void warpPerspectve int src _ type 
4 const uchar * src _ data size _ t 
src _ step int src _ width int src _ 
height 5 uchar * dst _ data size _ t 
dst _ step int dst _ width int dst _ 
height 6 const double M 9 int interpolation int borderType 
const double borderValue 4 7 { 8 Mat src Size 
src _ width src _ height src _ type const 
_ cast uchar * src _ data src _ step 
9 Mat dst Size dst _ width dst _ height 
src _ type dst _ data dst _ step 10 
11 Range range 0 dst . rows 12 W a 
r p P e r s p e c t 
i v e I n v o k e r 
invoker src dst M interpolation borderType Scalar borderValue 0 borderValue 
1 borderValue 2 borderValue 3 13 14 / / 这里 
是 一个 opencv 执行 并行 处理 的 一个 方法 真正 
执行 处理 的 代码 在 W a r p P 
e r s p e c t i v e 
I n v o k e r 的 函数 对象 
操作符 中 15 parallel _ for _ range invoker dst 
. total / double 1 16 16 } 17 18 
} / / hal 1 class W a r p 
P e r s p e c t i v 
e I n v o k e r 2 public 
ParallelLoopBody 3 { 4 public 5 W a r p 
P e r s p e c t i v 
e I n v o k e r const Mat 
& _ src Mat & _ dst const double * 
_ M int _ interpolation 6 int _ borderType const 
Scalar & _ borderValue 7 ParallelLoopBody src _ src dst 
_ dst M _ M interpolation _ interpolation 8 borderType 
_ borderType borderValue _ borderValue 9 { 10 / / 
注意 M 就是 转置 矩阵 11 } 12 13 virtual 
void operator const Range & range const 14 { 15 
const int BLOCK _ SZ = 32 16 short XY 
BLOCK _ SZ * BLOCK _ SZ * 2 A 
BLOCK _ SZ * BLOCK _ SZ 17 int x 
y x1 y1 width = dst . cols height = 
dst . rows 18 19 int bh0 = std min 
BLOCK _ SZ / 2 height 20 int bw0 = 
std min BLOCK _ SZ * BLOCK _ SZ / 
bh0 width / / 操作 块 的 宽 21 bh0 
= std min BLOCK _ SZ * BLOCK _ SZ 
/ bw0 height / / 操作 块 的 高 22 
23 / / 下面 的 意思 是 如果 支持 SSE4 
指令 那么 就 先 对 转置 矩阵 进行 预处理 下面 
会 继续 用 到 这个 pwarp _ impl _ sse4 
24 # if CV _ TRY _ SSE4 _ 1 
25 Ptr opt _ SSE4 _ 1 W a r 
p P e r s p e c t i 
v e L i n e _ SSE4 pwarp _ 
impl _ sse4 26 if CV _ CPU _ HAS 
_ SUPPORT _ SSE4 _ 1 27 pwarp _ impl 
_ sse4 = opt _ SSE4 _ 1 W a 
r p P e r s p e c t 
i v e L i n e _ SSE4 getImpl 
M 28 # endif 29 30 / / opencv 对 
投射 变换 的 操作 是 基于 块 操作 的 主要 
是 为了 方便 可以 直接 用 SSE4 指令 给 操作 
提速 31 for y = range . start y range 
. end y + = bh0 32 { 33 for 
x = 0 x width x + = bw0 34 
{ 35 int bw = std min bw0 width x 
36 int bh = std min bh0 range . end 
y / / height 37 38 / / _ XY 
是 一个 双 通道 的 Mat 下面 remap 会 用到 
39 Mat _ XY bh bw CV _ 16SC2 XY 
matA 40 Mat dpart dst Rect x y bw bh 
41 42 for y1 = 0 y1 bh y1 + 
+ 43 { 44 short * xy = XY + 
y1 * bw * 2 45 / / 就是 X 
Y W = x y 1 * M ^ T 
的 操作 46 / / 注意 现在 是 分块 操作 
所以 才有 + M 1 * y + y1 这 
一项 47 double X0 = M 0 * x + 
M 1 * y + y1 + M 2 48 
double Y0 = M 3 * x + M 4 
* y + y1 + M 5 49 double W0 
= M 6 * x + M 7 * y 
+ y1 + M 8 50 51 / / 最 
近邻 插值 52 if interpolation = = INTER _ NEAREST 
53 { 54 x1 = 0 55 56 / / 
这里 就是 刚才 上面 所说 的 pwarp _ impl _ 
sse4 所 用到 的 位置 57 # if CV _ 
TRY _ SSE4 _ 1 58 if pwarp _ impl 
_ sse4 59 pwarp _ impl _ sse4 processNN M 
xy X0 Y0 W0 bw 60 else 61 # endif 
62 for x1 bw x1 + + 63 { 64 
/ / 计算 W 65 double W = W0 + 
M 6 * x1 66 W = W 1 . 
/ W 0 67 / / 从 齐次 坐标 变到 
增广 矢量 注意 现在 是 分块 操作 所以 才有 + 
M 0 * x1 这 一项 68 / / 把 
结果 控制在 INT _ MIN INT _ MAX 中 由于 
下 面会 有把 double 转为 int 69 double fX = 
std max double INT _ MIN std min double INT 
_ MAX X0 + M 0 * x1 * W 
70 double fY = std max double INT _ MIN 
std min double INT _ MAX Y0 + M 3 
* x1 * W 71 int X = saturate _ 
cast int fX 72 int Y = saturate _ cast 
int fY 73 74 xy x1 * 2 = saturate 
_ cast short X 75 xy x1 * 2 + 
1 = saturate _ cast short Y 76 } 77 
} 78 / / 其他 插值 方法 79 else 80 
{ 81 short * alpha = A + y1 * 
bw 82 x1 = 0 83 84 / / 原 
理上 同 85 # if CV _ TRY _ SSE4 
_ 1 86 if pwarp _ impl _ sse4 87 
pwarp _ impl _ sse4 process M xy alpha X0 
Y0 W0 bw 88 else 89 # endif 90 for 
x1 bw x1 + + 91 { 92 double W 
= W0 + M 6 * x1 93 / / 
INTER _ TAB _ SIZE 在 我 的 opencv 版本 
就是 32 INTER _ BITS 是 5 94 / / 
下面 的 代码 是 先把 值 扩大 32倍 再 左移 
5位 得到 一个 值 95 W = W INTER _ 
TAB _ SIZE / W 0 96 double fX = 
std max double INT _ MIN std min double INT 
_ MAX X0 + M 0 * x1 * W 
97 double fY = std max double INT _ MIN 
std min double INT _ MAX Y0 + M 3 
* x1 * W 98 int X = saturate _ 
cast int fX 99 int Y = saturate _ cast 
int fY 100 101 xy x1 * 2 = saturate 
_ cast short X INTER _ BITS 102 xy x1 
* 2 + 1 = saturate _ cast short Y 
INTER _ BITS 103 104 / / alpha 是 remap 
里面 所 使用 的 remapBilinear 所要 用到 的 一个 参数 
这里 就不 往下 看了 105 alpha x1 = short Y 
& INTER _ TAB _ SIZE 1 * INTER _ 
TAB _ SIZE + 106 X & INTER _ TAB 
_ SIZE 1 107 } 108 } 109 } 110 
111 if interpolation = = INTER _ NEAREST 112 / 
/ 直接 运行 重 映射 直接 把 源点 映射 到 
目标 位置 的 点 113 remap src dpart _ XY 
Mat interpolation borderType borderValue 114 else 115 { 116 Mat 
_ matA bh bw CV _ 16U A 117 remap 
src dpart _ XY _ matA interpolation borderType borderValue 118 
} 119 } 120 } 121 } 122 123 private 
124 Mat src 125 Mat dst 126 const double * 
M 127 int interpolation borderType 128 Scalar borderValue 129 } 
OpenCV 的 仿射变换 源码 和 投影变换 的 类似 只是 仿射变换 
的 矩阵 M 的 元素 个数 是 6个 参考 http 
/ / www . cnblogs . com / houkai / 
p / 6660272 . htmlhttps / / en . wikipedia 
. org / wiki / Bilinear _ i n t 
e r p o l a t i o n 
h t t p / / www . cnblogs . 
com / tiandsp / archive / 2012/12 / 16/2820916 . 
html 2D 图像 几何 基元 一般 的 表示 一个 2d 几何 
基元 只用 两 个 维度 比如 x y 就 可以 
表示 了 但是 在 计算机 视觉 研究 中 为了 统一 
对 2d 几何 基元 的 操作 后面 讲到 的 仿射 
透射 变换 一般 会 以 增广 矢量 的 方式 表示 
几何 基元 齐次 坐标 将 原本 n 维 的 坐标 
用 一个 n + 1 维 的 坐标 表示 其 
两个 基本 作用 为 1 . 区分 n 维空间 的 
点 和 向量 一个点 的 第 n + 1 维 
为非 零值 而 向量 的 n + 1 维 为 
02 . 统一 几何 基元 的 旋转 平移 拉伸 投影 
等 操作 只用 一个 矩阵 就 可以 表示 2D 点 
2D 点 的 齐次 坐标 表示 为 其中 仅 在 
尺度 上 不同 的 矢量 被 视为 等同 的 被称作 
为 2D 投影 空间 其次 矢量 可以 通过 除以 最后 
你 一个 元素 来 转换 为非 齐次 矢量 X 即 
其中 是 增广 矢量 如果 最后 w 为 0 则 
称 此点 为 理想 点 或者 无穷远点 它 没有 等同 
的 非 齐次 表达 2D 直线 2D 直线 可以用 齐次 
向量 表示 其 对应 的 直线 方程 为 其 规范化 
表达 为 如果 l = 0 0 1 则 包含 
所有 无穷远点 2D 圆锥曲线 2D 图像 变换 及 示例 利用 
齐次 坐标 我们 可以 把 统一 2D 变换 操作 平移变换 
其中 I 是 2x2 的 单位矩阵 旋转变换 放缩 变换 x 
y 分别 放缩 仿射变换 投影变换 因为 而 仿射变换 是 投影 
变化 的 子集 所有 对 2D 几何 基元 的 操作 
都 以用 一个 3x3 的 Homography 表示 这样一来 对 图像 
的 多次 2D 变换 就 相当于 图像 对 多个 Homography 
矩阵 的 乘积 即 R = H1 * H2 * 
H3 . . . Hn * r 我们 用 Python 
代码 表示 这个 过程 1 import numpy as np 2 
import cv2 as cv 3 from numba import jit 4 
import matplotlib . pyplot as plt 5 from matplotlib . 
font _ manager import FontProperties 6 7 def MoveT tx 
ty lastOp = None np . ndarray 8 op = 
np . array 1 0 tx 0 1 ty 0 
0 1 dtype = np . float32 9 if lastOp 
is not None 10 op = np . dot op 
lastOp 11 return op 12 13 14 def RotateT r 
lastOp = None np . ndarray 15 op = np 
. array np . cos r np . sin r 
0 np . sin r np . cos r 0 
0 0 1 dtype = np . float32 16 if 
lastOp is not None 17 op = np . dot 
op lastOp 18 return op 19 20 21 def ZoomT 
rx ry lastOp = None np . ndarray 22 op 
= np . array rx 0 0 0 ry 0 
0 0 1 dtype = np . float32 23 if 
lastOp is not None 24 op = np . dot 
op lastOp 25 return op 26 27 def Transform imgSrc 
np . ndarray op np . ndarray 28 h w 
= imgSrc . shape 2 29 imgDst = np . 
zeros imgSrc . shape dtype = imgSrc . dtype 30 
for i in range h 31 v1 = np . 
stack np . arange w np . ones w * 
i np . ones w axis = 1 32 v2 
= np . dot v1 op 33 tpx tpy tpz 
= np . hsplit v2 3 34 for iy ix 
iz j in zip tpy tpx tpz range w 35 
py px = int iy / iz int ix / 
iz 36 if 0 = py h and 0 = 
px w 37 imgDst int py int px = imgSrc 
i j 38 39 return imgDst1 if _ _ name 
_ _ = = _ _ main _ _ 2 
font _ set = FontProperties fname = r c \ 
windows \ fonts \ msyh . ttc size = 12 
3 imgSrc = plt . imread E / Users / 
Administrator / pictures / Test / user . jpg 4 
op = np . transpose MoveT 10 30 RotateT np 
. pi / 12 ZoomT 1.1 1.2 5 6 imgDst 
= Transform imgSrc op 7 plt . figure 1 plt 
. imshow imgDst plt . title Resuult fontproperties = font 
_ set 8 plt . show 我们 对 图 进行 
了 如下 操作 1 . 对 y 尺度 放大 1.1倍 
x 尺度 放大 1.2倍 2 . 绕 z 轴 垂直于 
x y 旋转 π / 12 度 3 . x 
方向 移动 30 像素 y 方向 移动 10 像素 fig1 
原图 fig2 仿射变换 结果 可以 看到 这个 结果 并 不是 
很好 在 结果 中 发现 一些 很 明显 的 空洞 
因为 我们 对 图像 进行 了 放大 操作 和 旋转 
操作 在 这 一个 过程 中 结果 图像 的 有一些 
像素 的 值 并 不能 从 仿射变换 中 得出 从而 
形成 空洞 可见 直接 直接 对 图像 进行 正向 变换 
效果 是 不好 的 下面 我们 将 会 看到 利用 
反向 变换 + 插值 的 方法 解决 空洞 的 问题 
利用 透射 变换 来 进行 倾斜 校正 透射 变换 的 
一个 应用 就是 拿来 校正 图像 原理 很 简单 就是 
把 根据 关键点 找到 变换 矩阵 假如 使用 矩阵 并且 
设 h33 = 1 那么 就要 把 剩下 的 8个 
参 数给 解出来 8个 未知数 需要 8个 方程 又 因为 
从 仿射变换 的 对应 关系 可以 列方程 为 也 就是说 
只要 找 8个 点 的 以及 其 两两 对应 关系 
就 可以 找到 透射 变换 的 矩阵 也 就 可以 
对 图像 进行 校正 了 透射 变 换有 放缩 和 
旋转 等 操作 正如 上一 小节 所说 如果 仅 使用 
正向 变换 那么 肯定 会有 空洞 现象 的 发生 如果 
使用 反向 变换 那么 这个 问题 也 就 迎刃而解 了 
我们 要 做 的 就是 扫描 反向 变换 的 位置 
在 这里 我们 可以 采用 原 图像 正向 变换 后 
上下 左右 的 边界 点 确定 扫描 区域 然后 一个 
一个 点 反向 变换 回原 图像 中 并 根据 原 
图像 来 进行 插值 Python 代码 1 # WarpCorrection . 
py 2 3 @ jit 4 def B i l 
i n e a r I n t e r 
p o l a t i o n imgSrc np 
. ndarray h w sx float sy float float 5 
6 对 图片 的 指定 位置 做 双 线性插值 7 
param imgSrc 源 图像 8 param h src 的 高度 
9 param w src 的 宽度 10 param sx x 
位置 11 param sy y 位置 12 return 所 插入 
的 值 13 14 intSx intSy = int sx int 
sy 15 if 0 = intSx w 1 and 0 
= intSy h 1 16 x1 x2 = intSx intSx 
+ 1 17 y1 y2 = intSy intSy + 1 
18 H1 = np . dot np . array x2 
sx sx x1 imgSrc y1 y2 + 1 x1 x2 
+ 1 19 return H1 0 * y2 sy + 
H1 1 * sy y1 20 else 21 return imgSrc 
intSy intSx 22 23 def WarpCorrection imgSrc np . ndarray 
dots tuple np . ndarray 24 assert len dots = 
= 4 25 26 # 四个 点 的 顺序 一定 
要 按照 左上 右上 右下 左下 的 顺时针 顺序 点 
27 d1 d2 d3 d4 = dots 28 x1 x2 
x3 x4 = d1 0 d2 0 d3 0 d4 
0 29 y1 y2 y3 y4 = d1 1 d2 
1 d3 1 d4 1 30 assert x1 x2 31 
assert x4 x3 32 assert y1 y4 33 assert y2 
y3 34 35 objW = np . round np . 
sqrt x1 x2 * * 2 + y1 y2 * 
* 2 36 objH = np . round np . 
sqrt x2 x3 * * 2 + y2 y3 * 
* 2 37 38 # 在 这里 我 简单 地 
设 为把 所 输入 的 四个 点 的 位置 通过 
2D 变换 变换 为 长方形 的 四个 顶点 的 位置 
以 x1 为 起点 39 t1 t2 t3 t4 = 
y1 x1 y1 x1 + objW y1 + objH x1 
+ objW y1 + objH x1 40 41 rx1 rx2 
rx3 rx4 = t1 1 t2 1 t3 1 t4 
1 42 ry1 ry2 ry3 ry4 = t1 0 t2 
0 t3 0 t4 0 43 44 # = = 
= = = = = = = = = = 
= = = = Step 0 根据 8个 点 两两 
对应 关系 找到 Homography 矩阵 = = = = = 
= = = = = = = = = = 
= 45 # 把 8个 约束 写成 方程组 以 矩阵 
的 形式 表达 46 m = np . array 47 
y1 x1 1 0 0 0 ry1 * y1 ry1 
* x1 48 0 0 0 y1 x1 1 rx1 
* y1 rx1 * x1 49 y2 x2 1 0 
0 0 ry2 * y2 ry2 * x2 50 0 
0 0 y2 x2 1 rx2 * y2 rx2 * 
x2 51 y3 x3 1 0 0 0 ry3 * 
y3 ry3 * x3 52 0 0 0 y3 x3 
1 rx3 * y3 rx3 * x3 53 y4 x4 
1 0 0 0 ry4 * y4 ry4 * x4 
54 0 0 0 y4 x4 1 rx4 * y4 
rx4 * x4 55 56 57 vectorSrc = np . 
array ry1 rx1 ry2 rx2 ry3 rx3 ry4 rx4 58 
vectorSrc . shape = 1 8 59 HFlat = np 
. dot np . linalg . inv m np . 
transpose vectorSrc 60 a b c d e f g 
h = HFlat 0 0 HFlat 1 0 HFlat 2 
0 HFlat 3 0 HFlat 4 0 HFlat 5 0 
HFlat 6 0 HFlat 7 0 61 62 H = 
np . array a b c 63 d e f 
64 g h 1 dtype = np . float32 65 
66 # = = = = = = = = 
= = = = = = = = Step 1 
通过 对 原 图像 四个 顶点 进行 正向 投射 变换 
确定 目标 图像 区域 = = = = = = 
= = = = = = = = = = 
67 height width = imgSrc . shape 2 68 m 
a t r i x O r i g i 
n V e r t e x = np . 
array 0 0 1 69 0 width 1 1 70 
height 1 width 1 1 71 height 1 0 1 
72 73 result = np . dot m a t 
r i x O r i g i n V 
e r t e x np . transpose H 74 
minX = int min result 0 1 / result 0 
2 result 1 1 / result 1 2 result 2 
1 / result 2 2 result 3 1 / result 
3 2 75 maxX = int max result 0 1 
/ result 0 2 result 1 1 / result 1 
2 result 2 1 / result 2 2 result 3 
1 / result 3 2 76 minY = int min 
result 0 0 / result 0 2 result 1 0 
/ result 1 2 result 2 0 / result 2 
2 result 3 0 / result 3 2 77 maxY 
= int max result 0 0 / result 0 2 
result 1 0 / result 1 2 result 2 0 
/ result 2 2 result 3 0 / result 3 
2 78 79 # = = = = = = 
= = = = = = = = = = 
Step 2 反向 变换 + 双 二次 插值 校正 图像 
= = = = = = = = = = 
= = = = = = 80 vtr = np 
. empty 0 3 dtype = np . float32 81 
for i in range minY maxY 82 arr1 = np 
. arange minX maxX 83 arr2 = np . ones 
maxX minX 84 vt1 = np . stack arr2 * 
i arr1 arr2 axis = 1 85 vtr = np 
. concatenate vtr vt1 axis = 0 86 87 # 
请注意 因为 传 进去 的 是 规范化 后 Y X 
1 的 值 所以 得到 的 其实 是 y / 
Z x / Z 1 / Z 的 值 88 
vts = np . dot vtr np . linalg . 
inv np . transpose H 89 dstHeight dstWidth = maxY 
minY + 1 maxX minX + 1 90 imgDst = 
np . zeros dstHeight dstWidth imgSrc . shape 2 dtype 
= imgSrc . dtype 91 92 for r s in 
zip vtr vts 93 ry rx = int r 0 
int r 1 94 iy ix = s 2 95 
# 需要 解 y x = iy * g * 
y + h * x + 1 ix * g 
* y + h * x + 1 这个 方程 
96 TH = np . linalg . inv np . 
array iy * g 1 iy * h 97 ix 
* g ix * h 1 98 99 vxy = 
np . dot TH np . array iy ix 100 
sy sx = vxy 0 0 vxy 1 0 101 
102 if 0 = round sy height and 0 = 
round sx width 103 imgDst ry minY rx minX = 
B i l i n e a r I n 
t e r p o l a t i o 
n imgSrc height width sx sy 104 105 return imgDst 
这里 使用 了 双 二次 插值 双 二次 插值 的 
公式 推导 如下 fig3 . 双 二次 插值 公式 推导 
fig4 . 双 二次 插值 图像 解释 上面 右图 所 
展示 的 那样 双 二次 插值 其实 就是 一个 加权平均 
操作 为了/p 和双/nr 二次/m 插值/n 的/uj 效果/n 做/v 对比/v 我 
加了 个 最 邻近 插值 继续 往 程序 里面 加 
点 东西 来 测试 下 实际效果 在 这里 我 使用 
了 OpenCV 的 Highgui 的 包1/nr # * coding utf 
8 * 2 import matplotlib . pyplot as plt 3 
from matplotlib . font _ manager import FontProperties 4 from 
WarpTransform import * 5 from multiprocessing . dummy import Process 
6 7 windowCount = int 0 8 mainWinName = source 
9 10 def WarpImage imgSrc np . ndarray dots tuple 
count None 11 imgBLiner imgNearest = WarpCorrection imgSrc dots 12 
13 winName str = f result BLiner { count } 
14 cv . namedWindow winName 15 cv . imshow winName 
imgBLiner 16 17 winName str = f result nearest { 
count } 18 cv . namedWindow winName 19 cv . 
imshow winName imgNearest 20 21 cv . waitKey 0 22 
cv . destroyWindow winName 23 24 class W a r 
p C o r r e c t i o 
n M g r 25 def _ _ init _ 
_ self imgSrc 26 self . _ _ clickTime = 
0 27 self . _ _ imgSrc = imgSrc . 
copy 28 self . _ _ imgDrawn = imgSrc . 
copy 29 self . _ _ dots = 30 31 
@ property 32 def sourceImage self 33 return self . 
_ _ imgSrc 34 35 @ property 36 def drawnImage 
self 37 return self . _ _ imgDrawn 38 39 
@ drawnImage . setter 40 def drawnImage self newImg 41 
self . _ _ imgDrawn = newImg 42 43 @ 
property 44 def clickTime self 45 return self . _ 
_ clickTime 46 47 @ clickTime . setter 48 def 
clickTime self v 49 self . _ _ clickTime = 
v 50 51 @ property 52 def dots self 53 
return self . _ _ dots 54 55 @ staticmethod 
56 def MouseCallback event x y flags param 57 # 
四个 点 的 顺序 一定 要 按照 左上 右上 右下 
左下 的 顺时针 顺序 点 58 if event = = 
cv . EVENT _ LBUTTONDBLCLK 59 clickTime = param . 
clickTime 60 cv . circle param . drawnImage x y 
8 0 0 255 1 61 param . dots . 
append x y 62 cv . imshow mainWinName param . 
drawnImage 63 64 if clickTime + 1 = = 4 
65 global windowCount 66 p = Process target = WarpImage 
args = param . sourceImage param . dots . copy 
windowCount 67 p . daemon = True 68 p . 
start 69 70 param . drawnImage = param . sourceImage 
. copy 71 cv . imshow mainWinName param . sourceImage 
72 param . dots . clear 73 windowCount + = 
1 74 75 param . clickTime = clickTime + 1 
% 4 76 77 78 if _ _ name _ 
_ = = _ _ main _ _ 79 cv 
. namedWindow mainWinName 80 imgSrc = cv . imread E 
/ Users / Administrator / pictures / Test / skew 
. jpg 81 imgSrc = cv . resize imgSrc int 
imgSrc . shape 1 / 4 int imgSrc . shape 
0 / 4 82 83 mgr = W a r 
p C o r r e c t i o 
n M g r imgSrc 84 cv . setMouseCallback mainWinName 
W a r p C o r r e c 
t i o n M g r . MouseCallback mgr 
85 86 cv . imshow mainWinName imgSrc 87 cv . 
waitKey 0 88 cv . d e s t r 
o y A l l W i n d o 
w s 为了/p 对比/v 最/d 近邻/v 插值/n 和双/nr 二次/m 插值/n 
的/uj 差别/d 我 把 WarpCorrection 改 了 一下 # 请注意 
因为 传 进去 的 是 规范化 后 Y X 1 
的 值 所以 得到 的 其实 是 y / Z 
x / Z 1 / Z 的 值 vts = 
np . dot vtr np . linalg . inv np 
. transpose H dstHeight dstWidth = maxY minY + 1 
maxX minX + 1 imgBLiner = np . zeros dstHeight 
dstWidth imgSrc . shape 2 dtype = imgSrc . dtype 
imgNearest = np . zeros dstHeight dstWidth imgSrc . shape 
2 dtype = imgSrc . dtype for r s in 
zip vtr vts ry rx = int r 0 int 
r 1 iy ix = s 2 # 需要 解 
y x = iy * g * y + h 
* x + 1 ix * g * y + 
h * x + 1 这个 方程 TH = np 
. linalg . inv np . array iy * g 
1 iy * h ix * g ix * h 
1 vxy = np . dot TH np . array 
iy ix sy sx = vxy 0 0 vxy 1 
0 if 0 = round sy height and 0 = 
round sx width imgBLiner ry minY rx minX = B 
i l i n e a r I n t 
e r p o l a t i o n 
imgSrc height width sx sy imgNearest ry minY rx minX 
= imgSrc int round sy int round sx return imgBLiner 
imgNearest 运行 下 程序 来 看下 效果 上面 程序 的 
作用 就是 选中 要 校正 图像 的 四个 角 然后 
校正 PS 实际 运行 可能 会 相当 慢 我 没做 
优化 原图 Fig3 . 最 近邻 插值 边缘 很 粗糙 
看 清华大学出版社 几个字 Fig4 . 双 二次 插值 毛刺 很少 
但是 图像 模糊 了 OpenCV 库 中 WarpPerspective 源代码 其实 
OpenCV 是 带了 仿射变换 和 透射 变换 的 API 的 
先 来看 下 投影变换 的 源码 在 imgwarp . cpp 
部分 关键 代码 Assert 和 IPP 优化 这里 不 展示 
了 1 void cv warpPerspective InputArray _ src OutputArray _ 
dst InputArray _ M0 2 Size dsize int flags int 
borderType const Scalar & borderValue 3 { 4 Mat src 
= _ src . getMat M0 = _ M0 . 
getMat 5 _ dst . create dsize . area = 
= 0 src . size dsize src . type 6 
Mat dst = _ dst . getMat 7 8 if 
dst . data = = src . data 9 src 
= src . clone 10 11 double M 9 12 
Mat matM 3 3 CV _ 64F M 13 int 
interpolation = flags & INTER _ MAX 14 15 / 
/ 插入方法 不支持 INTER _ AREA 用 INTER _ LINEAR 
代替 16 if interpolation = = INTER _ AREA 17 
interpolation = INTER _ LINEAR 18 19 CV _ Assert 
M0 . type = = CV _ 32F | | 
M0 . type = = CV _ 64F & & 
M0 . rows = = 3 & & M0 . 
cols = = 3 20 M0 . convertTo matM matM 
. type 21 22 / / 这里 源码 是 这样 
操作 的 如果 可以 执行 IPP 那么 就 直接 执行 
IPP 指令 加 块 操作 23 / / 如果 没有 
说明 传入 的 变换 矩阵 已经 转置 过了 那么 执行 
一次 矩阵转置 24 if flags & WARP _ INVERSE _ 
MAP 25 invert matM matM 26 27 hal warpPerspectve src 
. type src . data src . step src . 
cols src . rows dst . data dst . step 
dst . cols dst . rows 28 matM . ptr 
double interpolation borderType borderValue . val 29 } 1 namespace 
hal { 2 3 void warpPerspectve int src _ type 
4 const uchar * src _ data size _ t 
src _ step int src _ width int src _ 
height 5 uchar * dst _ data size _ t 
dst _ step int dst _ width int dst _ 
height 6 const double M 9 int interpolation int borderType 
const double borderValue 4 7 { 8 Mat src Size 
src _ width src _ height src _ type const 
_ cast uchar * src _ data src _ step 
9 Mat dst Size dst _ width dst _ height 
src _ type dst _ data dst _ step 10 
11 Range range 0 dst . rows 12 W a 
r p P e r s p e c t 
i v e I n v o k e r 
invoker src dst M interpolation borderType Scalar borderValue 0 borderValue 
1 borderValue 2 borderValue 3 13 14 / / 这里 
是 一个 opencv 执行 并行 处理 的 一个 方法 真正 
执行 处理 的 代码 在 W a r p P 
e r s p e c t i v e 
I n v o k e r 的 函数 对象 
操作符 中 15 parallel _ for _ range invoker dst 
. total / double 1 16 16 } 17 18 
} / / hal 1 class W a r p 
P e r s p e c t i v 
e I n v o k e r 2 public 
ParallelLoopBody 3 { 4 public 5 W a r p 
P e r s p e c t i v 
e I n v o k e r const Mat 
& _ src Mat & _ dst const double * 
_ M int _ interpolation 6 int _ borderType const 
Scalar & _ borderValue 7 ParallelLoopBody src _ src dst 
_ dst M _ M interpolation _ interpolation 8 borderType 
_ borderType borderValue _ borderValue 9 { 10 / / 
注意 M 就是 转置 矩阵 11 } 12 13 virtual 
void operator const Range & range const 14 { 15 
const int BLOCK _ SZ = 32 16 short XY 
BLOCK _ SZ * BLOCK _ SZ * 2 A 
BLOCK _ SZ * BLOCK _ SZ 17 int x 
y x1 y1 width = dst . cols height = 
dst . rows 18 19 int bh0 = std min 
BLOCK _ SZ / 2 height 20 int bw0 = 
std min BLOCK _ SZ * BLOCK _ SZ / 
bh0 width / / 操作 块 的 宽 21 bh0 
= std min BLOCK _ SZ * BLOCK _ SZ 
/ bw0 height / / 操作 块 的 高 22 
23 / / 下面 的 意思 是 如果 支持 SSE4 
指令 那么 就 先 对 转置 矩阵 进行 预处理 下面 
会 继续 用 到 这个 pwarp _ impl _ sse4 
24 # if CV _ TRY _ SSE4 _ 1 
25 Ptr opt _ SSE4 _ 1 W a r 
p P e r s p e c t i 
v e L i n e _ SSE4 pwarp _ 
impl _ sse4 26 if CV _ CPU _ HAS 
_ SUPPORT _ SSE4 _ 1 27 pwarp _ impl 
_ sse4 = opt _ SSE4 _ 1 W a 
r p P e r s p e c t 
i v e L i n e _ SSE4 getImpl 
M 28 # endif 29 30 / / opencv 对 
投射 变换 的 操作 是 基于 块 操作 的 主要 
是 为了 方便 可以 直接 用 SSE4 指令 给 操作 
提速 31 for y = range . start y range 
. end y + = bh0 32 { 33 for 
x = 0 x width x + = bw0 34 
{ 35 int bw = std min bw0 width x 
36 int bh = std min bh0 range . end 
y / / height 37 38 / / _ XY 
是 一个 双 通道 的 Mat 下面 remap 会 用到 
39 Mat _ XY bh bw CV _ 16SC2 XY 
matA 40 Mat dpart dst Rect x y bw bh 
41 42 for y1 = 0 y1 bh y1 + 
+ 43 { 44 short * xy = XY + 
y1 * bw * 2 45 / / 就是 X 
Y W = x y 1 * M ^ T 
的 操作 46 / / 注意 现在 是 分块 操作 
所以 才有 + M 1 * y + y1 这 
一项 47 double X0 = M 0 * x + 
M 1 * y + y1 + M 2 48 
double Y0 = M 3 * x + M 4 
* y + y1 + M 5 49 double W0 
= M 6 * x + M 7 * y 
+ y1 + M 8 50 51 / / 最 
近邻 插值 52 if interpolation = = INTER _ NEAREST 
53 { 54 x1 = 0 55 56 / / 
这里 就是 刚才 上面 所说 的 pwarp _ impl _ 
sse4 所 用到 的 位置 57 # if CV _ 
TRY _ SSE4 _ 1 58 if pwarp _ impl 
_ sse4 59 pwarp _ impl _ sse4 processNN M 
xy X0 Y0 W0 bw 60 else 61 # endif 
62 for x1 bw x1 + + 63 { 64 
/ / 计算 W 65 double W = W0 + 
M 6 * x1 66 W = W 1 . 
/ W 0 67 / / 从 齐次 坐标 变到 
增广 矢量 注意 现在 是 分块 操作 所以 才有 + 
M 0 * x1 这 一项 68 / / 把 
结果 控制在 INT _ MIN INT _ MAX 中 由于 
下 面会 有把 double 转为 int 69 double fX = 
std max double INT _ MIN std min double INT 
_ MAX X0 + M 0 * x1 * W 
70 double fY = std max double INT _ MIN 
std min double INT _ MAX Y0 + M 3 
* x1 * W 71 int X = saturate _ 
cast int fX 72 int Y = saturate _ cast 
int fY 73 74 xy x1 * 2 = saturate 
_ cast short X 75 xy x1 * 2 + 
1 = saturate _ cast short Y 76 } 77 
} 78 / / 其他 插值 方法 79 else 80 
{ 81 short * alpha = A + y1 * 
bw 82 x1 = 0 83 84 / / 原 
理上 同 85 # if CV _ TRY _ SSE4 
_ 1 86 if pwarp _ impl _ sse4 87 
pwarp _ impl _ sse4 process M xy alpha X0 
Y0 W0 bw 88 else 89 # endif 90 for 
x1 bw x1 + + 91 { 92 double W 
= W0 + M 6 * x1 93 / / 
INTER _ TAB _ SIZE 在 我 的 opencv 版本 
就是 32 INTER _ BITS 是 5 94 / / 
下面 的 代码 是 先把 值 扩大 32倍 再 左移 
5位 得到 一个 值 95 W = W INTER _ 
TAB _ SIZE / W 0 96 double fX = 
std max double INT _ MIN std min double INT 
_ MAX X0 + M 0 * x1 * W 
97 double fY = std max double INT _ MIN 
std min double INT _ MAX Y0 + M 3 
* x1 * W 98 int X = saturate _ 
cast int fX 99 int Y = saturate _ cast 
int fY 100 101 xy x1 * 2 = saturate 
_ cast short X INTER _ BITS 102 xy x1 
* 2 + 1 = saturate _ cast short Y 
INTER _ BITS 103 104 / / alpha 是 remap 
里面 所 使用 的 remapBilinear 所要 用到 的 一个 参数 
这里 就不 往下 看了 105 alpha x1 = short Y 
& INTER _ TAB _ SIZE 1 * INTER _ 
TAB _ SIZE + 106 X & INTER _ TAB 
_ SIZE 1 107 } 108 } 109 } 110 
111 if interpolation = = INTER _ NEAREST 112 / 
/ 直接 运行 重 映射 直接 把 源点 映射 到 
目标 位置 的 点 113 remap src dpart _ XY 
Mat interpolation borderType borderValue 114 else 115 { 116 Mat 
_ matA bh bw CV _ 16U A 117 remap 
src dpart _ XY _ matA interpolation borderType borderValue 118 
} 119 } 120 } 121 } 122 123 private 
124 Mat src 125 Mat dst 126 const double * 
M 127 int interpolation borderType 128 Scalar borderValue 129 } 
OpenCV 的 仿射变换 源码 和 投影变换 的 类似 只是 仿射变换 
的 矩阵 M 的 元素 个数 是 6个 参考 http 
/ / www . cnblogs . com / houkai / 
p / 6660272 . htmlhttps / / en . wikipedia 
. org / wiki / Bilinear _ i n t 
e r p o l a t i o n 
h t t p / / www . cnblogs . 
com / tiandsp / archive / 2012/12 / 16/2820916 . 
html 