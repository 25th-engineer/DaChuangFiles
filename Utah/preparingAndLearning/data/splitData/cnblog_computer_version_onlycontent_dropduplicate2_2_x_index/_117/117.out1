计算机 视觉 图像 拼接 Image Stitching2017 年 04月 28日 14 
05 19 阅读数 1027 作业 要求 1 将 多张 图片 
合并 拼接 成 一张 全景图 看 下面 效果图 2 尽量 
用 C / C + + 老师 说 用 matlab 
会给 很低 的 分 _ з ゝ ∠ _ 所以 
下面 的 代码 全部 都用 C + + 来写 效果图 
实现 大致 步骤 1 SIFT 算法 进行 图像 特征提取 SIFT 
算法 是 http / / blog . csdn . net 
/ v _ JULY _ v / article / details 
/ 6245939 找 的 不过是 用 C 写 不太好 获得 
中间 结果 为了 方便 我们 这次 作业 使用 我 改写 
成C+/nr + 代码 2 利用 RANSAC 算法 进行 图像 特征 
匹配 3 利用 匹配 关键 点 进行 图像 拼接 Blending 
实现 步骤 详解 1 SIFT 算法 进行 图像 特征提取 SIFT 
算法 在 这里 就 不详 细说 了 上面 的 链接 
已经 讲 的 很 详细 了 使用 上面 的 代码 
要 配置 opencv 环境 挺 简单 的 网上 很多 教程 
我 是 将 上面 链接 的 代码 改写 成C+/nr + 
封装 了 一些 方法 使得 能够 提取 中间 结果 SIFT 
算法 的 输入 是 图片 我们 需要 的 输出 是 
各个 关键点 的 位置 128 维 描述 子 用于 关键点 
匹配 而 代码 把 一个 关键 点 的 这些 信息 
都 封装 在 一个 结构体 Keypoint 里面 同时 代码 将 
所有 的 关键 点 Keypoint 保存为 一个 链表 List 形式 
即 可以 根据 第一 个 节点 访问 到 所有 的 
Keypoint 节点 因此 我 在 改写 后的/nr MySift . h 
文件 里 添加 了 几个 方法 一个 是 SIFT 的 
方法 入口 SiftMainProcess 一个 是 获取 处理 后 得到 的 
关键 点 的 头 结点 方法 g e t F 
i r s t K e y D e s 
c r i p t o r s MySift . 
h MySift . cpp 由于 . cpp 代码 有 1000 
+ 行 由于 篇幅 问题 在 这里 就 不放 出来了 
_ з ゝ ∠ _ 有/v 需要/v 的/uj 可以/c 私聊/a 
下/f 我/r 哈_/nr з ゝ ∠ _ 或者 直接 对 
着 上面 链 接给 的 代码 找 一下 就 好了 
函数 名都 一样 的 阶段 结果 黄色 圈圈 的 就是 
识别 出来 的 关键 点 2 利用 RANSAC 算法 进行 
图像 特征 匹配 由于/c 从/p 上面/f 步骤/n 1/m 得到/v 的/uj 
结果/n 只是/c 每/zg 张/q 图片/n 自身/r 的/uj 特征点/i 即 两张 
图片 的 特征 点 之间 还没 对应 关系 因此 我们 
需要 先 通过 上面 得到 的 128 维 描述 子 
先 进行 大致 的 特征点 匹配 结果 可能 包括 outliers 
匹 配方法 不难理解 只需 计算 两个 128 维 特征描述 子 
的 距离差 小于 某 阈值 即可 视为 相同 的 特征点 
处理 后 得到 下面 的 结果 黄色 点 为 匹配 
的 特征点 另外 再给 每对 特征点 连线 可以 看到 连线 
特别 杂乱 说明 其 中 夹杂 着 很多 outliers 因此 
需要 用 下面 的 RANSAC 算法 去 排除 outliers 其实 
我 用 的 可以 说是 伪 RANSAC 算法 _ з 
ゝ ∠ _ 简单 的 说 就是 1 对 每 
一对 关键点 P 得到 位置 间 的 转移 向量 v 
位置 相减 2 对 其他 的 每 一对 关键点 P 
计算 位置 间 的 转移 向量 v 若 v 与 
v 距离 计算 欧拉 距离 即可 小于 一定 阈值 则 
认为 P 与 P 有 相同 的 特征 点 位置 
转移 即为 inlier 看下 图 应该 好 理解 一点 3 
计算 拥有 最多 inliers 的 转移 向量 v 即可 视为 
两张 图 特征点 位置 转移 向量 V 4 再 重新 
扫描 所有 的 关键 点 对 属 于此 特征点 位置 
转移 向量 V 的 关键 点 对 则 视为 两张 
图 真正 的 特征 匹配 点 MyMatching . h MyMatching 
. cpp 阶段 结果 可以 看到 转移 向量 V 基本一致 
了 3 利用 匹配 关键 点 进行 图像 拼接 Blending 
我 使用 的 图像 拼接 方法 其实 只是 最 简单 
的 平移 + 像素 RGB 值 插值 的 方法 好在 
这次 的 数据 集 图像 不 存在 太大 的 放缩 
不然 就 不能 用 这种 方法 了 _ з ゝ 
∠ _ 涉及 到 放缩 的 图片 暂时 还 想不到 
怎么做 _ з ゝ ∠ _ 可以 直观 的 从 
下面 的 图 用 ppt 拼凑 的 哈哈 看到 由于 
输入 图像 始终保持 左图 在 右图 的 左侧 即 两 
图 并排 的 时候 右图 需要 向左 移动 变成 从 
上面 可以 看到 右图 不仅 需要 向左 平移 还 需要 
向下 / 上 平移 回想 我们 第 2步 得到 的 
转移 向量 V dx dy 就 不难 理解 转移 向量 
V 的 作用 了 dy 0 右图 向下 平移 dy 
= 0 右图 向上 平移 如果 右图 是 向下 平 
移时 可以 得到 如下 的 模型 图 而 区域 的 
划分 我们 可以 通过 简单 的 数学 关系 计算出来 明显 
A 和B/nr 单独 的 区域 可以 直接 取 原图 像素 
RGB 值 由于 两张 图 长宽 可能 不 一致 以及 
平移 的 原因 可能 产生 黑边 黑色 部分 最后 剩下 
两 图 混合 部分 A / B 如果 只是 简单 
的 对 混合 区域 两张 图上 对应点 像素 RGB 值 
各取 50% 则 容易 造成 上面 那张 图 那样 在 
分界 处 有 明显 的 边缘 以及 边缘 两边 匹 
配不上 因此 我 使用 了 插值 的 方法 即 根据 
混合 区域内 点 P 的 与 两边 边缘 的 水平 
距离 按 不同 比例 取 两张 图上 对应点 像素 RGB 
值 组合成 点 P 的 RGB 值 即 越 靠近 
左边 边缘 的 点 取 左图 对应点 RGB 值 的 
占 比 越大 这样 就 可以 实现 较好 的 过渡 
MyBlending . h # ifndef MYBLENDING _ H # define 
MYBLENDING _ H # include CImg . h # include 
iostream using namespace cimg _ library using namespace std struct 
TransVector { int dx int dy TransVector dx 1 dy 
1 { } TransVector int _ dx int _ dy 
dx _ dx dy _ dy { } } class 
MyBlending { public MyBlending ~ MyBlending MyBlending int sx int 
sy void b l e n d i n g 
M a i n P r o c e s 
s char * _ filenameA char * _ filenameB void 
saveBlendedImg char * blendedImgAddr private TransVector matchVec / / x 
为 合并 图上 的 水平 距离 yCImg int srcImgA srcImgB 
CImg int blendedImg } # endifMyBlending . cpp # include 
MyBlending . h MyBlending MyBlending { } MyBlending ~ MyBlending 
{ } MyBlending MyBlending int sx int sy { matchVec 
. dx = sx matchVec . dy = sy } 
void MyBlending b l e n d i n g 
M a i n P r o c e s 
s char * _ filenameA char * _ filenameB { 
srcImgA . load _ bmp _ filenameA srcImgB . load 
_ bmp _ filenameB blendedImg = CImg int srcImgA . 
_ width + srcImgB . _ width matchVec . dx 
srcImgA . _ height + abs matchVec . dy 1 
3 0 cimg _ forXY blendedImg x y { if 
matchVec . dy = 0 { / / 右侧 图片 
需要 往下 左 移动 if x srcImgA . _ width 
& & y srcImgA . _ height { if x 
= srcImgA . _ width matchVec . dx & & 
y = 0 matchVec . dy { / / 混合 
blendedImg x y 0 0 = float srcImgA x y 
0 0 * float srcImgA . _ width x / 
float abs matchVec . dx + float srcImgB x srcImgA 
. _ width matchVec . dx y 0 matchVec . 
dy 0 0 * float x srcImgA . _ width 
matchVec . dx / float abs matchVec . dx blendedImg 
x y 0 1 = float srcImgA x y 0 
1 * float srcImgA . _ width x / float 
abs matchVec . dx + float srcImgB x srcImgA . 
_ width matchVec . dx y 0 matchVec . dy 
0 1 * float x srcImgA . _ width matchVec 
. dx / float abs matchVec . dx blendedImg x 
y 0 2 = float srcImgA x y 0 2 
* float srcImgA . _ width x / float abs 
matchVec . dx + float srcImgB x srcImgA . _ 
width matchVec . dx y 0 matchVec . dy 0 
2 * float x srcImgA . _ width matchVec . 
dx / float abs matchVec . dx } else { 
/ / A 独 在 部分 blendedImg x y 0 
0 = srcImgA x y 0 0 blendedImg x y 
0 1 = srcImgA x y 0 1 blendedImg x 
y 0 2 = srcImgA x y 0 2 } 
} else if x = srcImgA . _ width matchVec 
. dx & & y = 0 matchVec . dy 
& & y 0 matchVec . dy + srcImgB . 
_ height { / / B 独 在 部分 blendedImg 
x y 0 0 = srcImgB x srcImgA . _ 
width matchVec . dx y 0 matchVec . dy 0 
0 blendedImg x y 0 1 = srcImgB x srcImgA 
. _ width matchVec . dx y 0 matchVec . 
dy 0 1 blendedImg x y 0 2 = srcImgB 
x srcImgA . _ width matchVec . dx y 0 
matchVec . dy 0 2 } else { / / 
黑色 部分 blendedImg x y 0 0 = 0 blendedImg 
x y 0 1 = 0 blendedImg x y 0 
2 = 0 } } else { / / matchVec 
. dy 0 右侧 图片 需要 往上 左 移动 if 
x srcImgA . _ width & & y = matchVec 
. dy { if x = srcImgA . _ width 
matchVec . dx & & y srcImgB . _ height 
{ / / 混合 blendedImg x y 0 0 = 
float srcImgA x y matchVec . dy 0 0 * 
float srcImgA . _ width x / float abs matchVec 
. dx + float srcImgB x srcImgA . _ width 
matchVec . dx y 0 0 * float x srcImgA 
. _ width matchVec . dx / float abs matchVec 
. dx blendedImg x y 0 1 = float srcImgA 
x y matchVec . dy 0 1 * float srcImgA 
. _ width x / float abs matchVec . dx 
+ float srcImgB x srcImgA . _ width matchVec . 
dx y 0 1 * float x srcImgA . _ 
width matchVec . dx / float abs matchVec . dx 
blendedImg x y 0 2 = float srcImgA x y 
matchVec . dy 0 2 * float srcImgA . _ 
width x / float abs matchVec . dx + float 
srcImgB x srcImgA . _ width matchVec . dx y 
0 2 * float x srcImgA . _ width matchVec 
. dx / float abs matchVec . dx } else 
{ / / A 独 在 部分 blendedImg x y 
0 0 = srcImgA x y matchVec . dy 0 
0 blendedImg x y 0 1 = srcImgA x y 
matchVec . dy 0 1 blendedImg x y 0 2 
= srcImgA x y matchVec . dy 0 2 } 
} else if x = srcImgA . _ width matchVec 
. dx & & y srcImgB . _ height { 
/ / B 独 在 部分 blendedImg x y 0 
0 = srcImgB x srcImgA . _ width matchVec . 
dx y 0 0 blendedImg x y 0 1 = 
srcImgB x srcImgA . _ width matchVec . dx y 
0 1 blendedImg x y 0 2 = srcImgB x 
srcImgA . _ width matchVec . dx y 0 2 
} else { / / 黑色 部分 blendedImg x y 
0 0 = 0 blendedImg x y 0 1 = 
0 blendedImg x y 0 2 = 0 } } 
} blendedImg . display blendedImg } void MyBlending saveBlendedImg char 
* blendedImgAddr { blendedImg . save blendedImgAddr } 阶段 结果 
4 最后 再 放上 使用 上面 3个 类 的 主 
函数 的 代码 吧 Main . cpp # include stdafx 
. h # include MyMatching . h # include MyBlending 
. h int main { char * inputAddr1 = Input 
/ 1 . bmp char * inputAddr2 = Input / 
2 . bmp MySift mySift1 inputAddr1 1 mySift1 . SiftMainProcess 
mySift1 . s a v e I m g W 
i t h K e y p o i n 
t Output / 1 2/1 _ kp . bmp MySift 
mySift2 inputAddr2 1 mySift2 . SiftMainProcess mySift2 . s a 
v e I m g W i t h K 
e y p o i n t Output / 1 
2/2 _ kp . bmp MyMatching myMatching mySift1 . g 
e t K e y P o i n t 
s C o u n t mySift1 . g e 
t F i r s t K e y D 
e s c r i p t o r s 
mySift2 . g e t K e y P o 
i n t s C o u n t mySift2 
. g e t F i r s t K 
e y D e s c r i p t 
o r s myMatching . f e a t u 
r e M a t c h M a i 
n P r o c e s s myMatching . 
d r a w O r i K e y 
p o i n t O n I m g 
inputAddr1 inputAddr2 Output / 1 2/1 _ kp _ real 
. bmp Output / 1 2/2 _ kp _ real 
. bmp myMatching . m i x I m a 
g e A n d D r a w P 
a i r L i n e Output / 1 
2 / mixImg . bmp Output / 1 2 / 
mixImgWithLine . bmp myMatching . m y R A N 
A C t o F i n d K p 
T r a n s A n d D r 
a w O u t Output / 1 2 / 
mixImgWithLine _ fixed . bmp MyBlending myBlending myMatching . getMatchVec 
. col myMatching . getMatchVec . row myBlending . b 
l e n d i n g M a i 
n P r o c e s s inputAddr1 inputAddr2 
myBlending . saveBlendedImg Output / 1 2 / blendedImg . 
bmp int i cin i return 0 } 好了 这就 
差不多 了 其实 差 很多 _ з ゝ ∠ _ 
其实 这份 代码 普适性 不高 _ з ゝ ∠ _ 
比如 图片 是 需要 先 人工 排序 再 扔 进去 
跑 的 这个 问题 想了 下 应该 可以 根据 转移 
向量 V 来 进行 一定 的 判别 另外 上面 也 
提到 了 如果 图片 之间 存在 物体 放缩 那就/nr 不能 
用 上面 的 方法 了 放缩 的 暂时 还 想不到 
解决方案 还有 就是 如果 图片 的 横着 的 比如 数据集 
2 就 也 不能 解决 了 想想 就 很难 _ 
з ゝ ∠ _ 如果/c 有/v 大佬/nz 能/v 解决/v 上面/f 
问题/n 的/uj 可以/c 跟/p 我/r 说说/i 也想 了解 一下 _ 
з ゝ ∠ _ 计算机 视觉 图像 拼接 Image Stitching2017 年 04月 28日 14 
05 19 阅读数 1027 作业 要求 1 将 多张 图片 
合并 拼接 成 一张 全景图 看 下面 效果图 2 尽量 
用 C / C + + 老师 说 用 matlab 
会给 很低 的 分 _ з ゝ ∠ _ 所以 
下面 的 代码 全部 都用 C + + 来写 效果图 
实现 大致 步骤 1 SIFT 算法 进行 图像 特征提取 SIFT 
算法 是 http / / blog . csdn . net 
/ v _ JULY _ v / article / details 
/ 6245939 找 的 不过是 用 C 写 不太好 获得 
中间 结果 为了 方便 我们 这次 作业 使用 我 改写 
成C+/nr + 代码 2 利用 RANSAC 算法 进行 图像 特征 
匹配 3 利用 匹配 关键 点 进行 图像 拼接 Blending 
实现 步骤 详解 1 SIFT 算法 进行 图像 特征提取 SIFT 
算法 在 这里 就 不详 细说 了 上面 的 链接 
已经 讲 的 很 详细 了 使用 上面 的 代码 
要 配置 opencv 环境 挺 简单 的 网上 很多 教程 
我 是 将 上面 链接 的 代码 改写 成C+/nr + 
封装 了 一些 方法 使得 能够 提取 中间 结果 SIFT 
算法 的 输入 是 图片 我们 需要 的 输出 是 
各个 关键点 的 位置 128 维 描述 子 用于 关键点 
匹配 而 代码 把 一个 关键 点 的 这些 信息 
都 封装 在 一个 结构体 Keypoint 里面 同时 代码 将 
所有 的 关键 点 Keypoint 保存为 一个 链表 List 形式 
即 可以 根据 第一 个 节点 访问 到 所有 的 
Keypoint 节点 因此 我 在 改写 后的/nr MySift . h 
文件 里 添加 了 几个 方法 一个 是 SIFT 的 
方法 入口 SiftMainProcess 一个 是 获取 处理 后 得到 的 
关键 点 的 头 结点 方法 g e t F 
i r s t K e y D e s 
c r i p t o r s MySift . 
h MySift . cpp 由于 . cpp 代码 有 1000 
+ 行 由于 篇幅 问题 在 这里 就 不放 出来了 
_ з ゝ ∠ _ 有/v 需要/v 的/uj 可以/c 私聊/a 
下/f 我/r 哈_/nr з ゝ ∠ _ 或者 直接 对 
着 上面 链 接给 的 代码 找 一下 就 好了 
函数 名都 一样 的 阶段 结果 黄色 圈圈 的 就是 
识别 出来 的 关键 点 2 利用 RANSAC 算法 进行 
图像 特征 匹配 由于/c 从/p 上面/f 步骤/n 1/m 得到/v 的/uj 
结果/n 只是/c 每/zg 张/q 图片/n 自身/r 的/uj 特征点/i 即 两张 
图片 的 特征 点 之间 还没 对应 关系 因此 我们 
需要 先 通过 上面 得到 的 128 维 描述 子 
先 进行 大致 的 特征点 匹配 结果 可能 包括 outliers 
匹 配方法 不难理解 只需 计算 两个 128 维 特征描述 子 
的 距离差 小于 某 阈值 即可 视为 相同 的 特征点 
处理 后 得到 下面 的 结果 黄色 点 为 匹配 
的 特征点 另外 再给 每对 特征点 连线 可以 看到 连线 
特别 杂乱 说明 其 中 夹杂 着 很多 outliers 因此 
需要 用 下面 的 RANSAC 算法 去 排除 outliers 其实 
我 用 的 可以 说是 伪 RANSAC 算法 _ з 
ゝ ∠ _ 简单 的 说 就是 1 对 每 
一对 关键点 P 得到 位置 间 的 转移 向量 v 
位置 相减 2 对 其他 的 每 一对 关键点 P 
计算 位置 间 的 转移 向量 v 若 v 与 
v 距离 计算 欧拉 距离 即可 小于 一定 阈值 则 
认为 P 与 P 有 相同 的 特征 点 位置 
转移 即为 inlier 看下 图 应该 好 理解 一点 3 
计算 拥有 最多 inliers 的 转移 向量 v 即可 视为 
两张 图 特征点 位置 转移 向量 V 4 再 重新 
扫描 所有 的 关键 点 对 属 于此 特征点 位置 
转移 向量 V 的 关键 点 对 则 视为 两张 
图 真正 的 特征 匹配 点 MyMatching . h MyMatching 
. cpp 阶段 结果 可以 看到 转移 向量 V 基本一致 
了 3 利用 匹配 关键 点 进行 图像 拼接 Blending 
我 使用 的 图像 拼接 方法 其实 只是 最 简单 
的 平移 + 像素 RGB 值 插值 的 方法 好在 
这次 的 数据 集 图像 不 存在 太大 的 放缩 
不然 就 不能 用 这种 方法 了 _ з ゝ 
∠ _ 涉及 到 放缩 的 图片 暂时 还 想不到 
怎么做 _ з ゝ ∠ _ 可以 直观 的 从 
下面 的 图 用 ppt 拼凑 的 哈哈 看到 由于 
输入 图像 始终保持 左图 在 右图 的 左侧 即 两 
图 并排 的 时候 右图 需要 向左 移动 变成 从 
上面 可以 看到 右图 不仅 需要 向左 平移 还 需要 
向下 / 上 平移 回想 我们 第 2步 得到 的 
转移 向量 V dx dy 就 不难 理解 转移 向量 
V 的 作用 了 dy 0 右图 向下 平移 dy 
= 0 右图 向上 平移 如果 右图 是 向下 平 
移时 可以 得到 如下 的 模型 图 而 区域 的 
划分 我们 可以 通过 简单 的 数学 关系 计算出来 明显 
A 和B/nr 单独 的 区域 可以 直接 取 原图 像素 
RGB 值 由于 两张 图 长宽 可能 不 一致 以及 
平移 的 原因 可能 产生 黑边 黑色 部分 最后 剩下 
两 图 混合 部分 A / B 如果 只是 简单 
的 对 混合 区域 两张 图上 对应点 像素 RGB 值 
各取 50% 则 容易 造成 上面 那张 图 那样 在 
分界 处 有 明显 的 边缘 以及 边缘 两边 匹 
配不上 因此 我 使用 了 插值 的 方法 即 根据 
混合 区域内 点 P 的 与 两边 边缘 的 水平 
距离 按 不同 比例 取 两张 图上 对应点 像素 RGB 
值 组合成 点 P 的 RGB 值 即 越 靠近 
左边 边缘 的 点 取 左图 对应点 RGB 值 的 
占 比 越大 这样 就 可以 实现 较好 的 过渡 
MyBlending . h # ifndef MYBLENDING _ H # define 
MYBLENDING _ H # include CImg . h # include 
iostream using namespace cimg _ library using namespace std struct 
TransVector { int dx int dy TransVector dx 1 dy 
1 { } TransVector int _ dx int _ dy 
dx _ dx dy _ dy { } } class 
MyBlending { public MyBlending ~ MyBlending MyBlending int sx int 
sy void b l e n d i n g 
M a i n P r o c e s 
s char * _ filenameA char * _ filenameB void 
saveBlendedImg char * blendedImgAddr private TransVector matchVec / / x 
为 合并 图上 的 水平 距离 yCImg int srcImgA srcImgB 
CImg int blendedImg } # endifMyBlending . cpp # include 
MyBlending . h MyBlending MyBlending { } MyBlending ~ MyBlending 
{ } MyBlending MyBlending int sx int sy { matchVec 
. dx = sx matchVec . dy = sy } 
void MyBlending b l e n d i n g 
M a i n P r o c e s 
s char * _ filenameA char * _ filenameB { 
srcImgA . load _ bmp _ filenameA srcImgB . load 
_ bmp _ filenameB blendedImg = CImg int srcImgA . 
_ width + srcImgB . _ width matchVec . dx 
srcImgA . _ height + abs matchVec . dy 1 
3 0 cimg _ forXY blendedImg x y { if 
matchVec . dy = 0 { / / 右侧 图片 
需要 往下 左 移动 if x srcImgA . _ width 
& & y srcImgA . _ height { if x 
= srcImgA . _ width matchVec . dx & & 
y = 0 matchVec . dy { / / 混合 
blendedImg x y 0 0 = float srcImgA x y 
0 0 * float srcImgA . _ width x / 
float abs matchVec . dx + float srcImgB x srcImgA 
. _ width matchVec . dx y 0 matchVec . 
dy 0 0 * float x srcImgA . _ width 
matchVec . dx / float abs matchVec . dx blendedImg 
x y 0 1 = float srcImgA x y 0 
1 * float srcImgA . _ width x / float 
abs matchVec . dx + float srcImgB x srcImgA . 
_ width matchVec . dx y 0 matchVec . dy 
0 1 * float x srcImgA . _ width matchVec 
. dx / float abs matchVec . dx blendedImg x 
y 0 2 = float srcImgA x y 0 2 
* float srcImgA . _ width x / float abs 
matchVec . dx + float srcImgB x srcImgA . _ 
width matchVec . dx y 0 matchVec . dy 0 
2 * float x srcImgA . _ width matchVec . 
dx / float abs matchVec . dx } else { 
/ / A 独 在 部分 blendedImg x y 0 
0 = srcImgA x y 0 0 blendedImg x y 
0 1 = srcImgA x y 0 1 blendedImg x 
y 0 2 = srcImgA x y 0 2 } 
} else if x = srcImgA . _ width matchVec 
. dx & & y = 0 matchVec . dy 
& & y 0 matchVec . dy + srcImgB . 
_ height { / / B 独 在 部分 blendedImg 
x y 0 0 = srcImgB x srcImgA . _ 
width matchVec . dx y 0 matchVec . dy 0 
0 blendedImg x y 0 1 = srcImgB x srcImgA 
. _ width matchVec . dx y 0 matchVec . 
dy 0 1 blendedImg x y 0 2 = srcImgB 
x srcImgA . _ width matchVec . dx y 0 
matchVec . dy 0 2 } else { / / 
黑色 部分 blendedImg x y 0 0 = 0 blendedImg 
x y 0 1 = 0 blendedImg x y 0 
2 = 0 } } else { / / matchVec 
. dy 0 右侧 图片 需要 往上 左 移动 if 
x srcImgA . _ width & & y = matchVec 
. dy { if x = srcImgA . _ width 
matchVec . dx & & y srcImgB . _ height 
{ / / 混合 blendedImg x y 0 0 = 
float srcImgA x y matchVec . dy 0 0 * 
float srcImgA . _ width x / float abs matchVec 
. dx + float srcImgB x srcImgA . _ width 
matchVec . dx y 0 0 * float x srcImgA 
. _ width matchVec . dx / float abs matchVec 
. dx blendedImg x y 0 1 = float srcImgA 
x y matchVec . dy 0 1 * float srcImgA 
. _ width x / float abs matchVec . dx 
+ float srcImgB x srcImgA . _ width matchVec . 
dx y 0 1 * float x srcImgA . _ 
width matchVec . dx / float abs matchVec . dx 
blendedImg x y 0 2 = float srcImgA x y 
matchVec . dy 0 2 * float srcImgA . _ 
width x / float abs matchVec . dx + float 
srcImgB x srcImgA . _ width matchVec . dx y 
0 2 * float x srcImgA . _ width matchVec 
. dx / float abs matchVec . dx } else 
{ / / A 独 在 部分 blendedImg x y 
0 0 = srcImgA x y matchVec . dy 0 
0 blendedImg x y 0 1 = srcImgA x y 
matchVec . dy 0 1 blendedImg x y 0 2 
= srcImgA x y matchVec . dy 0 2 } 
} else if x = srcImgA . _ width matchVec 
. dx & & y srcImgB . _ height { 
/ / B 独 在 部分 blendedImg x y 0 
0 = srcImgB x srcImgA . _ width matchVec . 
dx y 0 0 blendedImg x y 0 1 = 
srcImgB x srcImgA . _ width matchVec . dx y 
0 1 blendedImg x y 0 2 = srcImgB x 
srcImgA . _ width matchVec . dx y 0 2 
} else { / / 黑色 部分 blendedImg x y 
0 0 = 0 blendedImg x y 0 1 = 
0 blendedImg x y 0 2 = 0 } } 
} blendedImg . display blendedImg } void MyBlending saveBlendedImg char 
* blendedImgAddr { blendedImg . save blendedImgAddr } 阶段 结果 
4 最后 再 放上 使用 上面 3个 类 的 主 
函数 的 代码 吧 Main . cpp # include stdafx 
. h # include MyMatching . h # include MyBlending 
. h int main { char * inputAddr1 = Input 
/ 1 . bmp char * inputAddr2 = Input / 
2 . bmp MySift mySift1 inputAddr1 1 mySift1 . SiftMainProcess 
mySift1 . s a v e I m g W 
i t h K e y p o i n 
t Output / 1 2/1 _ kp . bmp MySift 
mySift2 inputAddr2 1 mySift2 . SiftMainProcess mySift2 . s a 
v e I m g W i t h K 
e y p o i n t Output / 1 
2/2 _ kp . bmp MyMatching myMatching mySift1 . g 
e t K e y P o i n t 
s C o u n t mySift1 . g e 
t F i r s t K e y D 
e s c r i p t o r s 
mySift2 . g e t K e y P o 
i n t s C o u n t mySift2 
. g e t F i r s t K 
e y D e s c r i p t 
o r s myMatching . f e a t u 
r e M a t c h M a i 
n P r o c e s s myMatching . 
d r a w O r i K e y 
p o i n t O n I m g 
inputAddr1 inputAddr2 Output / 1 2/1 _ kp _ real 
. bmp Output / 1 2/2 _ kp _ real 
. bmp myMatching . m i x I m a 
g e A n d D r a w P 
a i r L i n e Output / 1 
2 / mixImg . bmp Output / 1 2 / 
mixImgWithLine . bmp myMatching . m y R A N 
A C t o F i n d K p 
T r a n s A n d D r 
a w O u t Output / 1 2 / 
mixImgWithLine _ fixed . bmp MyBlending myBlending myMatching . getMatchVec 
. col myMatching . getMatchVec . row myBlending . b 
l e n d i n g M a i 
n P r o c e s s inputAddr1 inputAddr2 
myBlending . saveBlendedImg Output / 1 2 / blendedImg . 
bmp int i cin i return 0 } 好了 这就 
差不多 了 其实 差 很多 _ з ゝ ∠ _ 
其实 这份 代码 普适性 不高 _ з ゝ ∠ _ 
比如 图片 是 需要 先 人工 排序 再 扔 进去 
跑 的 这个 问题 想了 下 应该 可以 根据 转移 
向量 V 来 进行 一定 的 判别 另外 上面 也 
提到 了 如果 图片 之间 存在 物体 放缩 那就/nr 不能 
用 上面 的 方法 了 放缩 的 暂时 还 想不到 
解决方案 还有 就是 如果 图片 的 横着 的 比如 数据集 
2 就 也 不能 解决 了 想想 就 很难 _ 
з ゝ ∠ _ 如果/c 有/v 大佬/nz 能/v 解决/v 上面/f 
问题/n 的/uj 可以/c 跟/p 我/r 说说/i 也想 了解 一下 _ 
з ゝ ∠ _ 计算机 视觉 图像 拼接 Image Stitching2017 年 04月 28日 14 
05 19 阅读数 1027 作业 要求 1 将 多张 图片 
合并 拼接 成 一张 全景图 看 下面 效果图 2 尽量 
用 C / C + + 老师 说 用 matlab 
会给 很低 的 分 _ з ゝ ∠ _ 所以 
下面 的 代码 全部 都用 C + + 来写 效果图 
实现 大致 步骤 1 SIFT 算法 进行 图像 特征提取 SIFT 
算法 是 http / / blog . csdn . net 
/ v _ JULY _ v / article / details 
/ 6245939 找 的 不过是 用 C 写 不太好 获得 
中间 结果 为了 方便 我们 这次 作业 使用 我 改写 
成C+/nr + 代码 2 利用 RANSAC 算法 进行 图像 特征 
匹配 3 利用 匹配 关键 点 进行 图像 拼接 Blending 
实现 步骤 详解 1 SIFT 算法 进行 图像 特征提取 SIFT 
算法 在 这里 就 不详 细说 了 上面 的 链接 
已经 讲 的 很 详细 了 使用 上面 的 代码 
要 配置 opencv 环境 挺 简单 的 网上 很多 教程 
我 是 将 上面 链接 的 代码 改写 成C+/nr + 
封装 了 一些 方法 使得 能够 提取 中间 结果 SIFT 
算法 的 输入 是 图片 我们 需要 的 输出 是 
各个 关键点 的 位置 128 维 描述 子 用于 关键点 
匹配 而 代码 把 一个 关键 点 的 这些 信息 
都 封装 在 一个 结构体 Keypoint 里面 同时 代码 将 
所有 的 关键 点 Keypoint 保存为 一个 链表 List 形式 
即 可以 根据 第一 个 节点 访问 到 所有 的 
Keypoint 节点 因此 我 在 改写 后的/nr MySift . h 
文件 里 添加 了 几个 方法 一个 是 SIFT 的 
方法 入口 SiftMainProcess 一个 是 获取 处理 后 得到 的 
关键 点 的 头 结点 方法 g e t F 
i r s t K e y D e s 
c r i p t o r s MySift . 
h MySift . cpp 由于 . cpp 代码 有 1000 
+ 行 由于 篇幅 问题 在 这里 就 不放 出来了 
_ з ゝ ∠ _ 有/v 需要/v 的/uj 可以/c 私聊/a 
下/f 我/r 哈_/nr з ゝ ∠ _ 或者 直接 对 
着 上面 链 接给 的 代码 找 一下 就 好了 
函数 名都 一样 的 阶段 结果 黄色 圈圈 的 就是 
识别 出来 的 关键 点 2 利用 RANSAC 算法 进行 
图像 特征 匹配 由于/c 从/p 上面/f 步骤/n 1/m 得到/v 的/uj 
结果/n 只是/c 每/zg 张/q 图片/n 自身/r 的/uj 特征点/i 即 两张 
图片 的 特征 点 之间 还没 对应 关系 因此 我们 
需要 先 通过 上面 得到 的 128 维 描述 子 
先 进行 大致 的 特征点 匹配 结果 可能 包括 outliers 
匹 配方法 不难理解 只需 计算 两个 128 维 特征描述 子 
的 距离差 小于 某 阈值 即可 视为 相同 的 特征点 
处理 后 得到 下面 的 结果 黄色 点 为 匹配 
的 特征点 另外 再给 每对 特征点 连线 可以 看到 连线 
特别 杂乱 说明 其 中 夹杂 着 很多 outliers 因此 
需要 用 下面 的 RANSAC 算法 去 排除 outliers 其实 
我 用 的 可以 说是 伪 RANSAC 算法 _ з 
ゝ ∠ _ 简单 的 说 就是 1 对 每 
一对 关键点 P 得到 位置 间 的 转移 向量 v 
位置 相减 2 对 其他 的 每 一对 关键点 P 
计算 位置 间 的 转移 向量 v 若 v 与 
v 距离 计算 欧拉 距离 即可 小于 一定 阈值 则 
认为 P 与 P 有 相同 的 特征 点 位置 
转移 即为 inlier 看下 图 应该 好 理解 一点 3 
计算 拥有 最多 inliers 的 转移 向量 v 即可 视为 
两张 图 特征点 位置 转移 向量 V 4 再 重新 
扫描 所有 的 关键 点 对 属 于此 特征点 位置 
转移 向量 V 的 关键 点 对 则 视为 两张 
图 真正 的 特征 匹配 点 MyMatching . h MyMatching 
. cpp 阶段 结果 可以 看到 转移 向量 V 基本一致 
了 3 利用 匹配 关键 点 进行 图像 拼接 Blending 
我 使用 的 图像 拼接 方法 其实 只是 最 简单 
的 平移 + 像素 RGB 值 插值 的 方法 好在 
这次 的 数据 集 图像 不 存在 太大 的 放缩 
不然 就 不能 用 这种 方法 了 _ з ゝ 
∠ _ 涉及 到 放缩 的 图片 暂时 还 想不到 
怎么做 _ з ゝ ∠ _ 可以 直观 的 从 
下面 的 图 用 ppt 拼凑 的 哈哈 看到 由于 
输入 图像 始终保持 左图 在 右图 的 左侧 即 两 
图 并排 的 时候 右图 需要 向左 移动 变成 从 
上面 可以 看到 右图 不仅 需要 向左 平移 还 需要 
向下 / 上 平移 回想 我们 第 2步 得到 的 
转移 向量 V dx dy 就 不难 理解 转移 向量 
V 的 作用 了 dy 0 右图 向下 平移 dy 
= 0 右图 向上 平移 如果 右图 是 向下 平 
移时 可以 得到 如下 的 模型 图 而 区域 的 
划分 我们 可以 通过 简单 的 数学 关系 计算出来 明显 
A 和B/nr 单独 的 区域 可以 直接 取 原图 像素 
RGB 值 由于 两张 图 长宽 可能 不 一致 以及 
平移 的 原因 可能 产生 黑边 黑色 部分 最后 剩下 
两 图 混合 部分 A / B 如果 只是 简单 
的 对 混合 区域 两张 图上 对应点 像素 RGB 值 
各取 50% 则 容易 造成 上面 那张 图 那样 在 
分界 处 有 明显 的 边缘 以及 边缘 两边 匹 
配不上 因此 我 使用 了 插值 的 方法 即 根据 
混合 区域内 点 P 的 与 两边 边缘 的 水平 
距离 按 不同 比例 取 两张 图上 对应点 像素 RGB 
值 组合成 点 P 的 RGB 值 即 越 靠近 
左边 边缘 的 点 取 左图 对应点 RGB 值 的 
占 比 越大 这样 就 可以 实现 较好 的 过渡 
MyBlending . h # ifndef MYBLENDING _ H # define 
MYBLENDING _ H # include CImg . h # include 
iostream using namespace cimg _ library using namespace std struct 
TransVector { int dx int dy TransVector dx 1 dy 
1 { } TransVector int _ dx int _ dy 
dx _ dx dy _ dy { } } class 
MyBlending { public MyBlending ~ MyBlending MyBlending int sx int 
sy void b l e n d i n g 
M a i n P r o c e s 
s char * _ filenameA char * _ filenameB void 
saveBlendedImg char * blendedImgAddr private TransVector matchVec / / x 
为 合并 图上 的 水平 距离 yCImg int srcImgA srcImgB 
CImg int blendedImg } # endifMyBlending . cpp # include 
MyBlending . h MyBlending MyBlending { } MyBlending ~ MyBlending 
{ } MyBlending MyBlending int sx int sy { matchVec 
. dx = sx matchVec . dy = sy } 
void MyBlending b l e n d i n g 
M a i n P r o c e s 
s char * _ filenameA char * _ filenameB { 
srcImgA . load _ bmp _ filenameA srcImgB . load 
_ bmp _ filenameB blendedImg = CImg int srcImgA . 
_ width + srcImgB . _ width matchVec . dx 
srcImgA . _ height + abs matchVec . dy 1 
3 0 cimg _ forXY blendedImg x y { if 
matchVec . dy = 0 { / / 右侧 图片 
需要 往下 左 移动 if x srcImgA . _ width 
& & y srcImgA . _ height { if x 
= srcImgA . _ width matchVec . dx & & 
y = 0 matchVec . dy { / / 混合 
blendedImg x y 0 0 = float srcImgA x y 
0 0 * float srcImgA . _ width x / 
float abs matchVec . dx + float srcImgB x srcImgA 
. _ width matchVec . dx y 0 matchVec . 
dy 0 0 * float x srcImgA . _ width 
matchVec . dx / float abs matchVec . dx blendedImg 
x y 0 1 = float srcImgA x y 0 
1 * float srcImgA . _ width x / float 
abs matchVec . dx + float srcImgB x srcImgA . 
_ width matchVec . dx y 0 matchVec . dy 
0 1 * float x srcImgA . _ width matchVec 
. dx / float abs matchVec . dx blendedImg x 
y 0 2 = float srcImgA x y 0 2 
* float srcImgA . _ width x / float abs 
matchVec . dx + float srcImgB x srcImgA . _ 
width matchVec . dx y 0 matchVec . dy 0 
2 * float x srcImgA . _ width matchVec . 
dx / float abs matchVec . dx } else { 
/ / A 独 在 部分 blendedImg x y 0 
0 = srcImgA x y 0 0 blendedImg x y 
0 1 = srcImgA x y 0 1 blendedImg x 
y 0 2 = srcImgA x y 0 2 } 
} else if x = srcImgA . _ width matchVec 
. dx & & y = 0 matchVec . dy 
& & y 0 matchVec . dy + srcImgB . 
_ height { / / B 独 在 部分 blendedImg 
x y 0 0 = srcImgB x srcImgA . _ 
width matchVec . dx y 0 matchVec . dy 0 
0 blendedImg x y 0 1 = srcImgB x srcImgA 
. _ width matchVec . dx y 0 matchVec . 
dy 0 1 blendedImg x y 0 2 = srcImgB 
x srcImgA . _ width matchVec . dx y 0 
matchVec . dy 0 2 } else { / / 
黑色 部分 blendedImg x y 0 0 = 0 blendedImg 
x y 0 1 = 0 blendedImg x y 0 
2 = 0 } } else { / / matchVec 
. dy 0 右侧 图片 需要 往上 左 移动 if 
x srcImgA . _ width & & y = matchVec 
. dy { if x = srcImgA . _ width 
matchVec . dx & & y srcImgB . _ height 
{ / / 混合 blendedImg x y 0 0 = 
float srcImgA x y matchVec . dy 0 0 * 
float srcImgA . _ width x / float abs matchVec 
. dx + float srcImgB x srcImgA . _ width 
matchVec . dx y 0 0 * float x srcImgA 
. _ width matchVec . dx / float abs matchVec 
. dx blendedImg x y 0 1 = float srcImgA 
x y matchVec . dy 0 1 * float srcImgA 
. _ width x / float abs matchVec . dx 
+ float srcImgB x srcImgA . _ width matchVec . 
dx y 0 1 * float x srcImgA . _ 
width matchVec . dx / float abs matchVec . dx 
blendedImg x y 0 2 = float srcImgA x y 
matchVec . dy 0 2 * float srcImgA . _ 
width x / float abs matchVec . dx + float 
srcImgB x srcImgA . _ width matchVec . dx y 
0 2 * float x srcImgA . _ width matchVec 
. dx / float abs matchVec . dx } else 
{ / / A 独 在 部分 blendedImg x y 
0 0 = srcImgA x y matchVec . dy 0 
0 blendedImg x y 0 1 = srcImgA x y 
matchVec . dy 0 1 blendedImg x y 0 2 
= srcImgA x y matchVec . dy 0 2 } 
} else if x = srcImgA . _ width matchVec 
. dx & & y srcImgB . _ height { 
/ / B 独 在 部分 blendedImg x y 0 
0 = srcImgB x srcImgA . _ width matchVec . 
dx y 0 0 blendedImg x y 0 1 = 
srcImgB x srcImgA . _ width matchVec . dx y 
0 1 blendedImg x y 0 2 = srcImgB x 
srcImgA . _ width matchVec . dx y 0 2 
} else { / / 黑色 部分 blendedImg x y 
0 0 = 0 blendedImg x y 0 1 = 
0 blendedImg x y 0 2 = 0 } } 
} blendedImg . display blendedImg } void MyBlending saveBlendedImg char 
* blendedImgAddr { blendedImg . save blendedImgAddr } 阶段 结果 
4 最后 再 放上 使用 上面 3个 类 的 主 
函数 的 代码 吧 Main . cpp # include stdafx 
. h # include MyMatching . h # include MyBlending 
. h int main { char * inputAddr1 = Input 
/ 1 . bmp char * inputAddr2 = Input / 
2 . bmp MySift mySift1 inputAddr1 1 mySift1 . SiftMainProcess 
mySift1 . s a v e I m g W 
i t h K e y p o i n 
t Output / 1 2/1 _ kp . bmp MySift 
mySift2 inputAddr2 1 mySift2 . SiftMainProcess mySift2 . s a 
v e I m g W i t h K 
e y p o i n t Output / 1 
2/2 _ kp . bmp MyMatching myMatching mySift1 . g 
e t K e y P o i n t 
s C o u n t mySift1 . g e 
t F i r s t K e y D 
e s c r i p t o r s 
mySift2 . g e t K e y P o 
i n t s C o u n t mySift2 
. g e t F i r s t K 
e y D e s c r i p t 
o r s myMatching . f e a t u 
r e M a t c h M a i 
n P r o c e s s myMatching . 
d r a w O r i K e y 
p o i n t O n I m g 
inputAddr1 inputAddr2 Output / 1 2/1 _ kp _ real 
. bmp Output / 1 2/2 _ kp _ real 
. bmp myMatching . m i x I m a 
g e A n d D r a w P 
a i r L i n e Output / 1 
2 / mixImg . bmp Output / 1 2 / 
mixImgWithLine . bmp myMatching . m y R A N 
A C t o F i n d K p 
T r a n s A n d D r 
a w O u t Output / 1 2 / 
mixImgWithLine _ fixed . bmp MyBlending myBlending myMatching . getMatchVec 
. col myMatching . getMatchVec . row myBlending . b 
l e n d i n g M a i 
n P r o c e s s inputAddr1 inputAddr2 
myBlending . saveBlendedImg Output / 1 2 / blendedImg . 
bmp int i cin i return 0 } 好了 这就 
差不多 了 其实 差 很多 _ з ゝ ∠ _ 
其实 这份 代码 普适性 不高 _ з ゝ ∠ _ 
比如 图片 是 需要 先 人工 排序 再 扔 进去 
跑 的 这个 问题 想了 下 应该 可以 根据 转移 
向量 V 来 进行 一定 的 判别 另外 上面 也 
提到 了 如果 图片 之间 存在 物体 放缩 那就/nr 不能 
用 上面 的 方法 了 放缩 的 暂时 还 想不到 
解决方案 还有 就是 如果 图片 的 横着 的 比如 数据集 
2 就 也 不能 解决 了 想想 就 很难 _ 
з ゝ ∠ _ 如果/c 有/v 大佬/nz 能/v 解决/v 上面/f 
问题/n 的/uj 可以/c 跟/p 我/r 说说/i 也想 了解 一下 _ 
з ゝ ∠ _ 