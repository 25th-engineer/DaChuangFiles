项目 源码 一 Faster RCNN 简介 cs231n Faster _ RCNN 
计算机 视觉 Faster RCNN 学习 _ 其一 目标 检测 及 
RCNN 谱系 一篇 讲 的 非常 明白 的 文章 一文 
读懂 Faster RCNN 1 输入 测试 图像 2 将 整张 
图片 输入 CNN 进行 特征提取 3 用 RPN 生成 建议 
窗口 proposals 每张 图片 保留 约 300个 建议 窗口 4 
把 建议 窗口 映 射到 CNN 的 最后 一层 卷积 
feature map 上 5 通过 RoI pooling 层 使 每个 
RoI 生成 固定 尺寸 的 feature map 6 利用 Softmax 
Loss 探测 分类 概率 和 Smooth L1 Loss 探测 边框 
回归 对 分类 概率 和 边框 回归 Bounding box regression 
联合 训练 . 相比 FAST RCNN 主要 两处 不同 1 
使用 RPN Region Proposal Network 代替 原来 的 Selective Search 
方法 产生 建议 窗口 2 产生 建议 窗口 的 CNN 
和 目标 检测 的 CNN 共享 改进 快速 产生 建议 
框 FASTER RCNN 创造性 地 采用 卷积 网络 自行 产生 
建议 框 并且 和 目标 检测 网络 共享 卷积 网络 
使得 建议 框 数目 从 原有 的 约 2000个 减少 
为 300个 且 建议 框 的 质量 也 有 本质 
的 提高 . RPN 简介 放到 整体 网络 中 如下 
对于 共享 的 Feature Map RPN 使用 3 * 3 
的 滑窗/nr 每个 滑动 窗口 位置 生成 9个 候选 窗口 
不同 尺度 不同 宽 高 对应 36个 坐标 18个 分类 
训练 过程 中 1 丢弃 跨越 边界 的 anchor 2 
与 样本 重叠 区域 大于 0.7 的 anchor 标记 为 
前景 重叠 区域 小于 0.3 的 标定 为 背景 总结 
一下 • 在 feature map 上 滑动 窗口 • 建 
一个 神经 网络 用于 物体 分类 + 框 位置 的 
回归 • 滑动 窗口 的 位置 提供 了 物体 的 
大体 位置 信息 • 框 的 回归 提供 了 框 
更 精确 的 位置 这里 的 分类 只 需要 区分 
候选 框内 特征 为 前景 或者 背景 这里 的 边框 
回归 也 是 为了 之后 获得 更 精确 的 目标 
位置 损失 函数 故 整个 网络 包含 四个 损失 函数 
• RPN calssification anchor good . bad 判断 anchor 前景 
背景 类别 • RPN regression anchor propoasal 计算 anchor 和 
gt box 的 偏差 利用 mask 仅 计算 前景 anchor 
• Fast R CNN classification over classes 判断 proposal 分类 
包含 类 别数 C + 背景 • Fast R CNN 
regression proposal box 计算 proposal 和 gt box 的 偏差 
利用 mask 仅 计算 类别 的 proposal 注意到 前 两个 
损失 函数 目标 是 修正 anchor 后 两个 损失 函数 
目标 是 修正 proposal 实际上 产生 了 众多 anchors 后 
会 进行 筛选 非 极大值 抑制 并 按照 前景 得分 
排序 等等 选出 特定 比例 的 前景 背景 anchors 作为 
proposal 进行 后面 的 运算 二 代码 解读 Faster RCNN 
网络设计 很是 复杂 个人 觉得 但 看 论文 或者 其他 
材料 并 不能 很好 的 理解 这套 流程 本篇 我们 
从 实际 的 代码 出发 看看 到底 是 这套 网络系统 
到底 是 如何 设计 的 anchor 和 proposalregion proposal 或者 
简称 proposal 或者 简称 ROI 可以 说 RPN 网络 的 
目的 就是 为了 得到 proposal 这些 proposal 是 对 ground 
truth 更好 的 刻画 和 anchor 相比 坐标 更 贴近 
ground truth 毕竟 anchor 的 坐标 都是 批量 地 按照 
scale 和 aspect ratio 复制 的 如果 你 还 记得 
在 系列 二中 关于 网络 结构 的 介绍 那么 你 
就 应该 了解 到 RPN 网络 的 回归 支路 输出 
的 值 offset 作为 smooth l1 损失 函数 的 输入 
之一 时 其 含义 就是 使得 proposal 和 anchor 之间 
的 offset RPN 网络 的 回归 支路 输出 尽可能 与 
ground truth 和 anchor 之间 的 offset RPN 网络 的 
回归 支路 的 回归 目标 接近 调包 部分 涉及 了 
mx 基础 框架 和 一个 作者 自己 创建 的 operate 
import mxnet as mx from symnet import proposal _ target 
特征提取 器 一如 开篇 的 图 这里 是 最上面 一行 
的 网络 即 提取 Feature Map 的 部分 使用 了 
4个 pooling 层 意味着 原始 图像 Feature Map = 16 
1 def get _ vgg _ feature data # group 
1 conv1 _ 1 = mx . symbol . Convolution 
data = data kernel = 3 3 pad = 1 
1 num _ filter = 64 workspace = 2048 name 
= conv1 _ 1 relu1 _ 1 = mx . 
symbol . Activation data = conv1 _ 1 act _ 
type = relu name = relu1 _ 1 conv1 _ 
2 = mx . symbol . Convolution data = relu1 
_ 1 kernel = 3 3 pad = 1 1 
num _ filter = 64 workspace = 2048 name = 
conv1 _ 2 relu1 _ 2 = mx . symbol 
. Activation data = conv1 _ 2 act _ type 
= relu name = relu1 _ 2 pool1 = mx 
. symbol . Pooling data = relu1 _ 2 pool 
_ type = max kernel = 2 2 stride = 
2 2 name = pool1 # group 2 conv2 _ 
1 = mx . symbol . Convolution data = pool1 
kernel = 3 3 pad = 1 1 num _ 
filter = 128 workspace = 2048 name = conv2 _ 
1 relu2 _ 1 = mx . symbol . Activation 
data = conv2 _ 1 act _ type = relu 
name = relu2 _ 1 conv2 _ 2 = mx 
. symbol . Convolution data = relu2 _ 1 kernel 
= 3 3 pad = 1 1 num _ filter 
= 128 workspace = 2048 name = conv2 _ 2 
relu2 _ 2 = mx . symbol . Activation data 
= conv2 _ 2 act _ type = relu name 
= relu2 _ 2 pool2 = mx . symbol . 
Pooling data = relu2 _ 2 pool _ type = 
max kernel = 2 2 stride = 2 2 name 
= pool2 # group 3 conv3 _ 1 = mx 
. symbol . Convolution data = pool2 kernel = 3 
3 pad = 1 1 num _ filter = 256 
workspace = 2048 name = conv3 _ 1 relu3 _ 
1 = mx . symbol . Activation data = conv3 
_ 1 act _ type = relu name = relu3 
_ 1 conv3 _ 2 = mx . symbol . 
Convolution data = relu3 _ 1 kernel = 3 3 
pad = 1 1 num _ filter = 256 workspace 
= 2048 name = conv3 _ 2 relu3 _ 2 
= mx . symbol . Activation data = conv3 _ 
2 act _ type = relu name = relu3 _ 
2 conv3 _ 3 = mx . symbol . Convolution 
data = relu3 _ 2 kernel = 3 3 pad 
= 1 1 num _ filter = 256 workspace = 
2048 name = conv3 _ 3 relu3 _ 3 = 
mx . symbol . Activation data = conv3 _ 3 
act _ type = relu name = relu3 _ 3 
pool3 = mx . symbol . Pooling data = relu3 
_ 3 pool _ type = max kernel = 2 
2 stride = 2 2 name = pool3 # group 
4 conv4 _ 1 = mx . symbol . Convolution 
data = pool3 kernel = 3 3 pad = 1 
1 num _ filter = 512 workspace = 2048 name 
= conv4 _ 1 relu4 _ 1 = mx . 
symbol . Activation data = conv4 _ 1 act _ 
type = relu name = relu4 _ 1 conv4 _ 
2 = mx . symbol . Convolution data = relu4 
_ 1 kernel = 3 3 pad = 1 1 
num _ filter = 512 workspace = 2048 name = 
conv4 _ 2 relu4 _ 2 = mx . symbol 
. Activation data = conv4 _ 2 act _ type 
= relu name = relu4 _ 2 conv4 _ 3 
= mx . symbol . Convolution data = relu4 _ 
2 kernel = 3 3 pad = 1 1 num 
_ filter = 512 workspace = 2048 name = conv4 
_ 3 relu4 _ 3 = mx . symbol . 
Activation data = conv4 _ 3 act _ type = 
relu name = relu4 _ 3 pool4 = mx . 
symbol . Pooling data = relu4 _ 3 pool _ 
type = max kernel = 2 2 stride = 2 
2 name = pool4 # group 5 conv5 _ 1 
= mx . symbol . Convolution data = pool4 kernel 
= 3 3 pad = 1 1 num _ filter 
= 512 workspace = 2048 name = conv5 _ 1 
relu5 _ 1 = mx . symbol . Activation data 
= conv5 _ 1 act _ type = relu name 
= relu5 _ 1 conv5 _ 2 = mx . 
symbol . Convolution data = relu5 _ 1 kernel = 
3 3 pad = 1 1 num _ filter = 
512 workspace = 2048 name = conv5 _ 2 relu5 
_ 2 = mx . symbol . Activation data = 
conv5 _ 2 act _ type = relu name = 
relu5 _ 2 conv5 _ 3 = mx . symbol 
. Convolution data = relu5 _ 2 kernel = 3 
3 pad = 1 1 num _ filter = 512 
workspace = 2048 name = conv5 _ 3 relu5 _ 
3 = mx . symbol . Activation data = conv5 
_ 3 act _ type = relu name = relu5 
_ 3 return relu5 _ 3 特征提取 器 二 下面 
是 最后 的 一小部分 网络 我们 将 筛选 出来 的 
proposal 作用于 Feature Map 得到 候选 区域 然后 使用 ROIPooling 
得到 大小 一致 的 候选 区域 这些 区域 送入 本 
部分 网络 得到 用于 分类 回归 的 特征 def get 
_ vgg _ top _ feature data # group 6 
flatten = mx . symbol . Flatten data = data 
name = flatten fc6 = mx . symbol . FullyConnected 
data = flatten num _ hidden = 4096 name = 
fc6 relu6 = mx . symbol . Activation data = 
fc6 act _ type = relu name = relu6 drop6 
= mx . symbol . Dropout data = relu6 p 
= 0.5 name = drop6 # group 7 fc7 = 
mx . symbol . FullyConnected data = drop6 num _ 
hidden = 4096 name = fc7 relu7 = mx . 
symbol . Activation data = fc7 act _ type = 
relu name = relu7 drop7 = mx . symbol . 
Dropout data = relu7 p = 0.5 name = drop7 
return drop7 主体 函数 函数 接口 def get _ vgg 
_ train anchor _ scales anchor _ ratios rpn _ 
feature _ stride rpn _ pre _ topk rpn _ 
post _ topk rpn _ nms _ thresh rpn _ 
min _ size rpn _ batch _ rois num _ 
classes rcnn _ feature _ stride rcnn _ pooled _ 
size rcnn _ batch _ size rcnn _ batch _ 
rois rcnn _ fg _ fraction rcnn _ fg _ 
overlap rcnn _ bbox _ stds 首先 定义 了 一些 
用于 接收数据 & 标签 信息 的 占位符 变量 num _ 
anchors = len anchor _ scales * len anchor _ 
ratios data = mx . symbol . Variable name = 
data # 图片 信息 batch channel height width im _ 
info = mx . symbol . Variable name = im 
_ info gt _ boxes = mx . symbol . 
Variable name = gt _ boxes # 真实 框 信息 
obj 数量 5 # anchor 标签 1 0 1 无效 
背景 目标 rpn _ label = mx . symbol . 
Variable name = label # batch 2 中心点 行数 * 
每个 位置 anchors 数目 中心点 列数 # 根据 初始 anchor 
和 ground truth 计算 出来 的 offset rpn _ bbox 
_ target = mx . symbol . Variable name = 
bbox _ target # batch 4 * 每个 位置 anchors 
数目 中心点 行数 中心点 列数 # mask 如果 anchor 标签 
是 1 则 mask 对应 值 为 1 anchor 标签 
是 0 或 1 则 mask 对应 值 为 0 
rpn _ bbox _ weight = mx . symbol . 
Variable name = bbox _ weight # batch 4 * 
每个 位置 anchors 数目 中心点 行数 中心点 列数 获取 卷积 
特征 # shared convolutional layers conv _ feat = get 
_ vgg _ feature data 使用 3 × 3 的 
滑窗/nr 进行 卷积 # RPN layers rpn _ conv = 
mx . symbol . Convolution data = conv _ feat 
kernel = 3 3 pad = 1 1 num _ 
filter = 512 name = rpn _ conv _ 3x3 
rpn _ relu = mx . symbol . Activation data 
= rpn _ conv act _ type = relu name 
= rpn _ relu 每个 滑动 窗口 位置 生成 9个 
候选 窗口 不同 尺度 不同 宽 高 对应 36个 坐标 
18个 分类 即 根据 每 张 图片 的 feat map 
大小 生成 对应 数量 的 中心 点 以及 候选 框体 
RPN calssification anchor good . bad 下面 是 计算 全部 
候选 窗口 对应 2 分类 的 部分 生成 损失 函数 
的 第一 部分 全部 候选 窗 含 / 不含 obj 
的 二分 类 损失 # rpn classification obj / not 
_ obj # batch 2 * 每个 位置 anchors 数目 
中心点 行数 中心点 列数 rpn _ cls _ score = 
mx . symbol . Convolution data = rpn _ relu 
kernel = 1 1 pad = 0 0 num _ 
filter = 2 * num _ anchors name = rpn 
_ cls _ score # batch 2 中心点 行数 * 
每个 位置 anchors 数目 中心点 列数 rpn _ cls _ 
score _ reshape = mx . symbol . Reshape data 
= rpn _ cls _ score shape = 0 2 
1 0 name = rpn _ cls _ score _ 
reshape # 获取 交叉 熵 回传 梯度 对于 出现 了 
1 的 图片 梯度 直接 全部 置 为 0 # 
在 Faster RCNN 算法 中 anchor 一 共有 3种 标签 
1 0 1 分别 表示 无效 背景 目标 rpn _ 
cls _ prob = mx . symbol . SoftmaxOutput data 
= rpn _ cls _ score _ reshape label = 
rpn _ label multi _ output = True normalization = 
valid use _ ignore = True ignore _ label = 
1 name = rpn _ cls _ prob # 切换 
为 含 / 不含 obj 两 通道 对 每一个 anchor 
是否 有 obj 进行 softmax 处理 # batch 2 中心点 
行数 * 每个 位置 anchors 数目 中心点 列数 rpn _ 
cls _ act = mx . symbol . softmax data 
= rpn _ cls _ score _ reshape axis = 
1 name = rpn _ cls _ act # batch 
2 * 每个 位置 anchors 数目 中心点 行数 中心点 列数 
# Reshpe 方法 不同 于 reshape 方法 详情 见此 方法 
文档 rpn _ cls _ act _ reshape = mx 
. symbol . Reshape data = rpn _ cls _ 
act shape = 0 2 * num _ anchors 1 
0 name = rpn _ cls _ act _ reshape 
RPN regression anchor propoasal 下面 计算 全部 候选 窗口 对应 
4个 坐标值 的 部分 生成 损失 函数 第二 部分 全部 
候选框 坐标 回归 # rpn bbox regression # batch 4 
* 每个 位置 anchors 数目 中心点 行数 中心点 列数 rpn 
_ bbox _ pred = mx . symbol . Convolution 
data = rpn _ relu kernel = 1 1 pad 
= 0 0 num _ filter = 4 * num 
_ anchors name = rpn _ bbox _ pred # 
rpn _ bbox _ weight anchor 的 mask 如果 某个 
anchor 的 标签 是 1 则 mask 对应 值 为 
1 anchor 的 标签 是 0 或 1 则 mask 
对应 值 为 0 # rpn _ bbox _ target 
根据 初始 anchor 和 ground truth 计算 出来 的 offset 
rpn _ bbox _ loss _ = rpn _ bbox 
_ weight * mx . symbol . smooth _ l1 
name = rpn _ bbox _ loss _ scalar = 
3.0 data = rpn _ bbox _ pred rpn _ 
bbox _ target # 获取 回归 梯度 # grad _ 
scale 表示 回归 损失 占 RPN 网络 总 损失 比 
该 参数 相差 几个 量级 对 结果 影响 也 不大 
rpn _ bbox _ loss = mx . sym . 
MakeLoss name = rpn _ bbox _ loss data = 
rpn _ bbox _ loss _ grad _ scale = 
1.0 / rpn _ batch _ rois 候选框 生成 我们 
会 获取 数量 繁多 的 候选框 即 上面 得到 的 
候选框 含有 obj 的 得分 和 候选框 坐标 修 正值 
首先 会 根据 框体 含有 obj 的 概率 进行 一次 
初筛 然后 经由 非 极大值 抑制 算法 筛选 2000个 候选框 
进入 下 一步 的 操作 在 第二 步中/nr 我们 会 
获取 最终 的 128个 候选框 它们 各自 对应 的 标签 
它们 坐标 回归 的 目标 以及 标定 它们 正负 的 
坐标 掩码 用于 精确 的 训练 候选框 生成 目标 边框 
这个 一步 的 操作 使用 了 作者 新建 的 操作 
节点 具体 实现 见 源码 这里 只 简单 介绍 该 
操作 的 输入 输出 以及 作用 另 注 函数 返回 
的 候选框 5个 属性 与 后面 的 ROIPooling 一脉相承 候选框 
对应 batch 中 图片 的 索引 候选框 坐标 × 4 
后面 使用 这个 值 可以 直接 进行 ROIPooling # rpn 
proposal # 获取 指定 数目 的 候选框 proposal # 2000个 
候选框 5个 属性 # 5个 属性 batch 中 图片 index 
4个 坐标 rois = mx . symbol . contrib . 
MultiProposal cls _ prob = rpn _ cls _ act 
_ reshape # cls _ prob batch 2 * 每个 
位置 anchors 数目 中心点 行数 中心点 列数 bbox _ pred 
= rpn _ bbox _ pred # bbox _ pred 
batch 4 * 每个 位置 anchors 数目 中心点 行数 中心点 
列数 im _ info = im _ info # mx 
. symbol . Variable name = im _ info feature 
_ stride = rpn _ feature _ stride # 16 
scales = anchor _ scales ratios = anchor _ ratios 
# 0.5 1 2 rpn _ pre _ nms _ 
top _ n = rpn _ pre _ topk # 
12000 对 RPN 网络 输出 的 anchor 进行 NMS 操作 
之前 的 proposal 最大 数量 # 输入 proposal 的 数量 
大于 12000时 对 这些 proposal 的 预测 为 foreground 的 
概率 也叫 score # 换 句话 说 就是 预测 标签 
为 1 的 概率 从高 到 低 排序 然后 选择 
前面 12000个 rpn _ post _ nms _ top _ 
n = rpn _ post _ topk # 2000 经过 
NMS 过滤 之后 得到 的 proposal 数量 threshold = rpn 
_ nms _ thresh # 0.7 是 NMS 算法 阈值 
rpn _ min _ size = rpn _ min _ 
size # 16 name = rois # rcnn roi proposal 
target # 根据 上 一步 获取 的 proposal 即 rois 
和 真实 框 gt _ boxes 进行 筛选 # 获取 
128个 proposal 对应 的 128个 label 对应 的 128个 真实 
坐标 128个 坐标 掩码 构建 损失 函数 使用 group = 
mx . symbol . Custom rois = rois # 2000 
* 5 的 roi 信息 gt _ boxes = gt 
_ boxes # n * 5 的 ground truth 信息 
n 表示 object 数量 op _ type = proposal _ 
target num _ classes = num _ classes # num 
_ classes 是 实际 要 分类 的 类别 数 加上 
背景 类 batch _ images = rcnn _ batch _ 
size # 1 batch _ rois = rcnn _ batch 
_ rois # 128 fg _ fraction = rcnn _ 
fg _ fraction # 0.25 正 样本 所占 的 比例 
fg _ overlap = rcnn _ fg _ overlap # 
0.5 box _ stds = rcnn _ bbox _ stds 
# 0.1 0.1 0.2 0.2 rois = group 0 # 
rois 128 5 label = group 1 # roi 对应 
的 标签 128 bbox _ target = group 2 # 
坐标 回归 的 目标 维度 是 128 84 其中 84 
来自 20 + 1 * 4 bbox _ weight = 
group 3 # 坐标 回归 时候 的 权重 维度 是 
128 84 对于 foreground 都是 1 对于 backgroud 都是 0 
在 RPN 网络 得到 proposal 后 还会 经过 一系列 的 
过滤 操作 才会 得到 送入 检测 网络 的 proposal 节点 
proposal _ target 会将 2000个 proposal 过滤 成 128个 且为 
这 128个 proposal 分配 标签 回归 目标 定义 正负 样本 
的 1 3 比例 等 这部分 算是 RPN 网络 和 
检测 网络 Fast RCNN 的 衔接 值得 注意 的 是 
该 节点 不接受 后面 层数 传递 而来 的 梯度 且 
向前 传递 梯度 强 制为 0 已 即 网络 训练 
由其 割裂 为 两个 部分 尽管 两 部分 仍然 相连 
ROIPooling 层 将 任意 大小 的 输入 层 下 采样 
为 同样 大小 的 输出 层 方便 后面 的 计算 
这里 我们 使用 候选框 128个 寻找 各自 对应 的 图片 
并将 各自 对应 的 区域 裁剪 出来 然后 pooling 为 
同样 的 大小 本 层 的 两条 虚线 输入 中 
上面 一条 表示 batch 图像 特征 下面 一条 表示 候选框 
输入 # rcnn roi pool # 128个 候选框 512个 通道 
7行 7列 roi _ pool = mx . symbol . 
ROIPooling name = roi _ pool data = conv _ 
feat rois = rois pooled _ size = rcnn _ 
pooled _ size # 7 7 输出 大小 spatial _ 
scale = 1.0 / rcnn _ feature _ stride # 
16 feat / raw _ img 将 对应 的 候选 
区域 注意 此时 抠图 完成 已经 不是 候选框 了 经由 
vgg 的 分类 头 部分 实际上 就是 对 候选 区域 
再进一步 抽象 提取 特征 进行 处理 # rcnn top feature 
# 128 4096 对 每个 roi 提取 最终 的 vgg 
特征 top _ feat = get _ vgg _ top 
_ feature roi _ pool 最后 的 两个 损失 函数 
生成 过程 对 128个 候选 区域 的 抽象 特征 进行 
分类 此时 不是 含 / 不含 obj 而是 直接 进行 
21 分类 并对 每 一个 抽象 特征 回归 出 4个 
坐标值 两个 损失 函数 标签 均 来自 上面 自定义 节点 
的 输出 label = group 1         
                    
        # roi 对应 的 标签 128 
bbox _ target = group 2         
    # 坐标 回归 的 目标 维度 是 128 
84 其中 84 来自 20 + 1 * 4bbox _ 
weight = group 3           # 
坐标 回归 时候 的 权重 维度 是 128 84 对于 
foreground 都是 1 对于 backgroud 都是 0 # rcnn classification 
# 对 每个 roi 进行 分类 并 构建 损失 函数 
cls _ score = mx . symbol . FullyConnected name 
= cls _ score data = top _ feat num 
_ hidden = num _ classes cls _ prob = 
mx . symbol . SoftmaxOutput name = cls _ prob 
data = cls _ score label = label normalization = 
batch # rcnn bbox regression # 对 每个 roi 进行 
回归 并 构建 损失 函数 bbox _ pred = mx 
. symbol . FullyConnected name = bbox _ pred data 
= top _ feat num _ hidden = num _ 
classes * 4 bbox _ loss _ = bbox _ 
weight * mx . symbol . smooth _ l1 name 
= bbox _ loss _ scalar = 1.0 data = 
bbox _ pred bbox _ target bbox _ loss = 
mx . sym . MakeLoss name = bbox _ loss 
data = bbox _ loss _ grad _ scale = 
1.0 / rcnn _ batch _ rois 附 主体 函数 
全览/nr def get _ vgg _ train anchor _ scales 
anchor _ ratios rpn _ feature _ stride rpn _ 
pre _ topk rpn _ post _ topk rpn _ 
nms _ thresh rpn _ min _ size rpn _ 
batch _ rois num _ classes rcnn _ feature _ 
stride rcnn _ pooled _ size rcnn _ batch _ 
size rcnn _ batch _ rois rcnn _ fg _ 
fraction rcnn _ fg _ overlap rcnn _ bbox _ 
stds num _ anchors = len anchor _ scales * 
len anchor _ ratios data = mx . symbol . 
Variable name = data # 图片 信息 batch channel height 
width im _ info = mx . symbol . Variable 
name = im _ info gt _ boxes = mx 
. symbol . Variable name = gt _ boxes # 
真实 框 信息 obj 数量 5 # anchor 标签 1 
0 1 无效 背景 目标 rpn _ label = mx 
. symbol . Variable name = label # batch 2 
中心点 行数 * 每个 位置 anchors 数目 中心点 列数 # 
根据 初始 anchor 和 ground truth 计算 出来 的 offset 
rpn _ bbox _ target = mx . symbol . 
Variable name = bbox _ target # batch 4 * 
每个 位置 anchors 数目 中心点 行数 中心点 列数 # mask 
如果 anchor 标签 是 1 则 mask 对应 值 为 
1 anchor 标签 是 0 或 1 则 mask 对应 
值 为 0 rpn _ bbox _ weight = mx 
. symbol . Variable name = bbox _ weight # 
batch 4 * 每个 位置 anchors 数目 中心点 行数 中心点 
列数 # shared convolutional layers conv _ feat = get 
_ vgg _ feature data # RPN layers rpn _ 
conv = mx . symbol . Convolution data = conv 
_ feat kernel = 3 3 pad = 1 1 
num _ filter = 512 name = rpn _ conv 
_ 3x3 rpn _ relu = mx . symbol . 
Activation data = rpn _ conv act _ type = 
relu name = rpn _ relu # rpn classification obj 
/ not _ obj # batch 2 * 每个 位置 
anchors 数目 中心点 行数 中心点 列数 rpn _ cls _ 
score = mx . symbol . Convolution data = rpn 
_ relu kernel = 1 1 pad = 0 0 
num _ filter = 2 * num _ anchors name 
= rpn _ cls _ score # batch 2 中心点 
行数 * 每个 位置 anchors 数目 中心点 列数 rpn _ 
cls _ score _ reshape = mx . symbol . 
Reshape data = rpn _ cls _ score shape = 
0 2 1 0 name = rpn _ cls _ 
score _ reshape # 获取 交叉 熵 回传 梯度 对于 
出现 了 1 的 图片 梯度 直接 全部 置 为 
0 # 在 Faster RCNN 算法 中 anchor 一 共有 
3种 标签 1 0 1 分别 表示 无效 背景 目标 
rpn _ cls _ prob = mx . symbol . 
SoftmaxOutput data = rpn _ cls _ score _ reshape 
label = rpn _ label multi _ output = True 
normalization = valid use _ ignore = True ignore _ 
label = 1 name = rpn _ cls _ prob 
# 切换 为 含 / 不含 obj 两 通道 对 
每一个 anchor 是否 有 obj 进行 softmax 处理 # batch 
2 中心点 行数 * 每个 位置 anchors 数目 中心点 列数 
rpn _ cls _ act = mx . symbol . 
softmax data = rpn _ cls _ score _ reshape 
axis = 1 name = rpn _ cls _ act 
# batch 2 * 每个 位置 anchors 数目 中心点 行数 
中心点 列数 # Reshpe 方法 不同 于 reshape 方法 详情 
见此 方法 文档 rpn _ cls _ act _ reshape 
= mx . symbol . Reshape data = rpn _ 
cls _ act shape = 0 2 * num _ 
anchors 1 0 name = rpn _ cls _ act 
_ reshape # rpn bbox regression # batch 4 * 
每个 位置 anchors 数目 中心点 行数 中心点 列数 rpn _ 
bbox _ pred = mx . symbol . Convolution data 
= rpn _ relu kernel = 1 1 pad = 
0 0 num _ filter = 4 * num _ 
anchors name = rpn _ bbox _ pred # rpn 
_ bbox _ weight anchor 的 mask 如果 某个 anchor 
的 标签 是 1 则 mask 对应 值 为 1 
anchor 的 标签 是 0 或 1 则 mask 对应 
值 为 0 # rpn _ bbox _ target 根据 
初始 anchor 和 ground truth 计算 出来 的 offset rpn 
_ bbox _ loss _ = rpn _ bbox _ 
weight * mx . symbol . smooth _ l1 name 
= rpn _ bbox _ loss _ scalar = 3.0 
data = rpn _ bbox _ pred rpn _ bbox 
_ target # 获取 回归 梯度 # grad _ scale 
表示 回归 损失 占 RPN 网络 总 损失 比 该 
参数 相差 几个 量级 对 结果 影响 也 不大 rpn 
_ bbox _ loss = mx . sym . MakeLoss 
name = rpn _ bbox _ loss data = rpn 
_ bbox _ loss _ grad _ scale = 1.0 
/ rpn _ batch _ rois # rpn proposal # 
获取 指定 数目 的 候选框 proposal # 2000个 候选框 5个 
属性 # 5个 属性 batch 中 图片 index 4个 坐标 
rois = mx . symbol . contrib . MultiProposal cls 
_ prob = rpn _ cls _ act _ reshape 
# cls _ prob batch 2 * 每个 位置 anchors 
数目 中心点 行数 中心点 列数 bbox _ pred = rpn 
_ bbox _ pred # bbox _ pred batch 4 
* 每个 位置 anchors 数目 中心点 行数 中心点 列数 im 
_ info = im _ info # mx . symbol 
. Variable name = im _ info feature _ stride 
= rpn _ feature _ stride # 16 scales = 
anchor _ scales ratios = anchor _ ratios # 0.5 
1 2 rpn _ pre _ nms _ top _ 
n = rpn _ pre _ topk # 12000 对 
RPN 网络 输出 的 anchor 进行 NMS 操作 之前 的 
proposal 最大 数量 # 输入 proposal 的 数量 大于 12000时 
对 这些 proposal 的 预测 为 foreground 的 概率 也叫 
score # 换 句话 说 就是 预测 标签 为 1 
的 概率 从高 到 低 排序 然后 选择 前面 12000个 
rpn _ post _ nms _ top _ n = 
rpn _ post _ topk # 2000 经过 NMS 过滤 
之后 得到 的 proposal 数量 threshold = rpn _ nms 
_ thresh # 0.7 是 NMS 算法 阈值 rpn _ 
min _ size = rpn _ min _ size # 
16 name = rois # rcnn roi proposal target # 
根据 上 一步 获取 的 proposal 即 rois 和 真实 
框 gt _ boxes 进行 筛选 # 获取 128个 proposal 
对应 的 128个 label 对应 的 128个 真实 坐标 128个 
坐标 掩码 构建 损失 函数 使用 group = mx . 
symbol . Custom rois = rois # 2000 * 5 
的 roi 信息 gt _ boxes = gt _ boxes 
# n * 5 的 ground truth 信息 n 表示 
object 数量 op _ type = proposal _ target num 
_ classes = num _ classes # num _ classes 
是 实际 要 分类 的 类别 数 加上 背景 类 
batch _ images = rcnn _ batch _ size # 
1 batch _ rois = rcnn _ batch _ rois 
# 128 fg _ fraction = rcnn _ fg _ 
fraction # 0.25 正 样本 所占 的 比例 fg _ 
overlap = rcnn _ fg _ overlap # 0.5 box 
_ stds = rcnn _ bbox _ stds # 0.1 
0.1 0.2 0.2 rois = group 0 # rois 128 
5 label = group 1 # roi 对应 的 标签 
128 bbox _ target = group 2 # 坐标 回归 
的 目标 维度 是 128 84 其中 84 来自 20 
+ 1 * 4 bbox _ weight = group 3 
# 坐标 回归 时候 的 权重 维度 是 128 84 
对于 foreground 都是 1 对于 backgroud 都是 0 # rcnn 
roi pool # 128个 候选框 512个 通道 7行 7列 roi 
_ pool = mx . symbol . ROIPooling name = 
roi _ pool data = conv _ feat rois = 
rois pooled _ size = rcnn _ pooled _ size 
# 7 7 输出 大小 spatial _ scale = 1.0 
/ rcnn _ feature _ stride # 16 feat / 
raw _ img # rcnn top feature # 128 4096 
对 每个 roi 提取 最终 的 vgg 特征 top _ 
feat = get _ vgg _ top _ feature roi 
_ pool # rcnn classification # 对 每个 roi 进行 
分类 并 构建 损失 函数 cls _ score = mx 
. symbol . FullyConnected name = cls _ score data 
= top _ feat num _ hidden = num _ 
classes cls _ prob = mx . symbol . SoftmaxOutput 
name = cls _ prob data = cls _ score 
label = label normalization = batch # rcnn bbox regression 
# 对 每个 roi 进行 回归 并 构建 损失 函数 
bbox _ pred = mx . symbol . FullyConnected name 
= bbox _ pred data = top _ feat num 
_ hidden = num _ classes * 4 bbox _ 
loss _ = bbox _ weight * mx . symbol 
. smooth _ l1 name = bbox _ loss _ 
scalar = 1.0 data = bbox _ pred bbox _ 
target bbox _ loss = mx . sym . MakeLoss 
name = bbox _ loss data = bbox _ loss 
_ grad _ scale = 1.0 / rcnn _ batch 
_ rois # reshape output # 1 128 1 128 
21 1 128 84 label = mx . symbol . 
Reshape data = label shape = rcnn _ batch _ 
size 1 name = label _ reshape cls _ prob 
= mx . symbol . Reshape data = cls _ 
prob shape = rcnn _ batch _ size 1 num 
_ classes name = cls _ prob _ reshape bbox 
_ loss = mx . symbol . Reshape data = 
bbox _ loss shape = rcnn _ batch _ size 
1 4 * num _ classes name = bbox _ 
loss _ reshape print cls _ score . infer _ 
shape * * { data 1 3 1000 600 gt 
_ boxes 5 5 } 1 # group output # 
mx . symbol . BlockGrad 会 阻止 经由 节点 label 
回传 的 梯度 group = mx . symbol . Group 
rpn _ cls _ prob # anchors 分类 损失 batch 
2 中心点 行数 * 每个 位置 anchors 数目 中心点 列数 
rpn _ bbox _ loss # anchors 回归 损失 batch 
4 * 每个 位置 anchors 数目 中心点 行数 中心点 列数 
cls _ prob # 候选框 分类 损失 1 128 21 
bbox _ loss # 候选框 回归 损失 1 128 84 
mx . symbol . BlockGrad label # 候选框 标签 1 
128 return group if _ _ name _ _ = 
= _ _ main _ _ net = get _ 
vgg _ train anchor _ scales = 8 16 32 
anchor _ ratios = 0.5 1 2 rpn _ feature 
_ stride = 16 rpn _ pre _ topk = 
12000 rpn _ post _ topk = 2000 rpn _ 
nms _ thresh = 0.7 rpn _ min _ size 
= 16 rpn _ batch _ rois = 256 num 
_ classes = 21 rcnn _ feature _ stride = 
16 # 4个 pooling 层 rcnn _ pooled _ size 
= 7 7 rcnn _ batch _ size = 1 
rcnn _ batch _ rois = 128 rcnn _ fg 
_ fraction = 0.25 rcnn _ fg _ overlap = 
0.5 rcnn _ bbox _ stds = 0.1 0.1 0.2 
0.2 项目 源码 一 Faster RCNN 简介 cs231n Faster _ RCNN 
计算机 视觉 Faster RCNN 学习 _ 其一 目标 检测 及 
RCNN 谱系 一篇 讲 的 非常 明白 的 文章 一文 
读懂 Faster RCNN 1 输入 测试 图像 2 将 整张 
图片 输入 CNN 进行 特征提取 3 用 RPN 生成 建议 
窗口 proposals 每张 图片 保留 约 300个 建议 窗口 4 
把 建议 窗口 映 射到 CNN 的 最后 一层 卷积 
feature map 上 5 通过 RoI pooling 层 使 每个 
RoI 生成 固定 尺寸 的 feature map 6 利用 Softmax 
Loss 探测 分类 概率 和 Smooth L1 Loss 探测 边框 
回归 对 分类 概率 和 边框 回归 Bounding box regression 
联合 训练 . 相比 FAST RCNN 主要 两处 不同 1 
使用 RPN Region Proposal Network 代替 原来 的 Selective Search 
方法 产生 建议 窗口 2 产生 建议 窗口 的 CNN 
和 目标 检测 的 CNN 共享 改进 快速 产生 建议 
框 FASTER RCNN 创造性 地 采用 卷积 网络 自行 产生 
建议 框 并且 和 目标 检测 网络 共享 卷积 网络 
使得 建议 框 数目 从 原有 的 约 2000个 减少 
为 300个 且 建议 框 的 质量 也 有 本质 
的 提高 . RPN 简介 放到 整体 网络 中 如下 
对于 共享 的 Feature Map RPN 使用 3 * 3 
的 滑窗/nr 每个 滑动 窗口 位置 生成 9个 候选 窗口 
不同 尺度 不同 宽 高 对应 36个 坐标 18个 分类 
训练 过程 中 1 丢弃 跨越 边界 的 anchor 2 
与 样本 重叠 区域 大于 0.7 的 anchor 标记 为 
前景 重叠 区域 小于 0.3 的 标定 为 背景 总结 
一下 • 在 feature map 上 滑动 窗口 • 建 
一个 神经 网络 用于 物体 分类 + 框 位置 的 
回归 • 滑动 窗口 的 位置 提供 了 物体 的 
大体 位置 信息 • 框 的 回归 提供 了 框 
更 精确 的 位置 这里 的 分类 只 需要 区分 
候选 框内 特征 为 前景 或者 背景 这里 的 边框 
回归 也 是 为了 之后 获得 更 精确 的 目标 
位置 损失 函数 故 整个 网络 包含 四个 损失 函数 
• RPN calssification anchor good . bad 判断 anchor 前景 
背景 类别 • RPN regression anchor propoasal 计算 anchor 和 
gt box 的 偏差 利用 mask 仅 计算 前景 anchor 
• Fast R CNN classification over classes 判断 proposal 分类 
包含 类 别数 C + 背景 • Fast R CNN 
regression proposal box 计算 proposal 和 gt box 的 偏差 
利用 mask 仅 计算 类别 的 proposal 注意到 前 两个 
损失 函数 目标 是 修正 anchor 后 两个 损失 函数 
目标 是 修正 proposal 实际上 产生 了 众多 anchors 后 
会 进行 筛选 非 极大值 抑制 并 按照 前景 得分 
排序 等等 选出 特定 比例 的 前景 背景 anchors 作为 
proposal 进行 后面 的 运算 二 代码 解读 Faster RCNN 
网络设计 很是 复杂 个人 觉得 但 看 论文 或者 其他 
材料 并 不能 很好 的 理解 这套 流程 本篇 我们 
从 实际 的 代码 出发 看看 到底 是 这套 网络系统 
到底 是 如何 设计 的 anchor 和 proposalregion proposal 或者 
简称 proposal 或者 简称 ROI 可以 说 RPN 网络 的 
目的 就是 为了 得到 proposal 这些 proposal 是 对 ground 
truth 更好 的 刻画 和 anchor 相比 坐标 更 贴近 
ground truth 毕竟 anchor 的 坐标 都是 批量 地 按照 
scale 和 aspect ratio 复制 的 如果 你 还 记得 
在 系列 二中 关于 网络 结构 的 介绍 那么 你 
就 应该 了解 到 RPN 网络 的 回归 支路 输出 
的 值 offset 作为 smooth l1 损失 函数 的 输入 
之一 时 其 含义 就是 使得 proposal 和 anchor 之间 
的 offset RPN 网络 的 回归 支路 输出 尽可能 与 
ground truth 和 anchor 之间 的 offset RPN 网络 的 
回归 支路 的 回归 目标 接近 调包 部分 涉及 了 
mx 基础 框架 和 一个 作者 自己 创建 的 operate 
import mxnet as mx from symnet import proposal _ target 
特征提取 器 一如 开篇 的 图 这里 是 最上面 一行 
的 网络 即 提取 Feature Map 的 部分 使用 了 
4个 pooling 层 意味着 原始 图像 Feature Map = 16 
1 def get _ vgg _ feature data # group 
1 conv1 _ 1 = mx . symbol . Convolution 
data = data kernel = 3 3 pad = 1 
1 num _ filter = 64 workspace = 2048 name 
= conv1 _ 1 relu1 _ 1 = mx . 
symbol . Activation data = conv1 _ 1 act _ 
type = relu name = relu1 _ 1 conv1 _ 
2 = mx . symbol . Convolution data = relu1 
_ 1 kernel = 3 3 pad = 1 1 
num _ filter = 64 workspace = 2048 name = 
conv1 _ 2 relu1 _ 2 = mx . symbol 
. Activation data = conv1 _ 2 act _ type 
= relu name = relu1 _ 2 pool1 = mx 
. symbol . Pooling data = relu1 _ 2 pool 
_ type = max kernel = 2 2 stride = 
2 2 name = pool1 # group 2 conv2 _ 
1 = mx . symbol . Convolution data = pool1 
kernel = 3 3 pad = 1 1 num _ 
filter = 128 workspace = 2048 name = conv2 _ 
1 relu2 _ 1 = mx . symbol . Activation 
data = conv2 _ 1 act _ type = relu 
name = relu2 _ 1 conv2 _ 2 = mx 
. symbol . Convolution data = relu2 _ 1 kernel 
= 3 3 pad = 1 1 num _ filter 
= 128 workspace = 2048 name = conv2 _ 2 
relu2 _ 2 = mx . symbol . Activation data 
= conv2 _ 2 act _ type = relu name 
= relu2 _ 2 pool2 = mx . symbol . 
Pooling data = relu2 _ 2 pool _ type = 
max kernel = 2 2 stride = 2 2 name 
= pool2 # group 3 conv3 _ 1 = mx 
. symbol . Convolution data = pool2 kernel = 3 
3 pad = 1 1 num _ filter = 256 
workspace = 2048 name = conv3 _ 1 relu3 _ 
1 = mx . symbol . Activation data = conv3 
_ 1 act _ type = relu name = relu3 
_ 1 conv3 _ 2 = mx . symbol . 
Convolution data = relu3 _ 1 kernel = 3 3 
pad = 1 1 num _ filter = 256 workspace 
= 2048 name = conv3 _ 2 relu3 _ 2 
= mx . symbol . Activation data = conv3 _ 
2 act _ type = relu name = relu3 _ 
2 conv3 _ 3 = mx . symbol . Convolution 
data = relu3 _ 2 kernel = 3 3 pad 
= 1 1 num _ filter = 256 workspace = 
2048 name = conv3 _ 3 relu3 _ 3 = 
mx . symbol . Activation data = conv3 _ 3 
act _ type = relu name = relu3 _ 3 
pool3 = mx . symbol . Pooling data = relu3 
_ 3 pool _ type = max kernel = 2 
2 stride = 2 2 name = pool3 # group 
4 conv4 _ 1 = mx . symbol . Convolution 
data = pool3 kernel = 3 3 pad = 1 
1 num _ filter = 512 workspace = 2048 name 
= conv4 _ 1 relu4 _ 1 = mx . 
symbol . Activation data = conv4 _ 1 act _ 
type = relu name = relu4 _ 1 conv4 _ 
2 = mx . symbol . Convolution data = relu4 
_ 1 kernel = 3 3 pad = 1 1 
num _ filter = 512 workspace = 2048 name = 
conv4 _ 2 relu4 _ 2 = mx . symbol 
. Activation data = conv4 _ 2 act _ type 
= relu name = relu4 _ 2 conv4 _ 3 
= mx . symbol . Convolution data = relu4 _ 
2 kernel = 3 3 pad = 1 1 num 
_ filter = 512 workspace = 2048 name = conv4 
_ 3 relu4 _ 3 = mx . symbol . 
Activation data = conv4 _ 3 act _ type = 
relu name = relu4 _ 3 pool4 = mx . 
symbol . Pooling data = relu4 _ 3 pool _ 
type = max kernel = 2 2 stride = 2 
2 name = pool4 # group 5 conv5 _ 1 
= mx . symbol . Convolution data = pool4 kernel 
= 3 3 pad = 1 1 num _ filter 
= 512 workspace = 2048 name = conv5 _ 1 
relu5 _ 1 = mx . symbol . Activation data 
= conv5 _ 1 act _ type = relu name 
= relu5 _ 1 conv5 _ 2 = mx . 
symbol . Convolution data = relu5 _ 1 kernel = 
3 3 pad = 1 1 num _ filter = 
512 workspace = 2048 name = conv5 _ 2 relu5 
_ 2 = mx . symbol . Activation data = 
conv5 _ 2 act _ type = relu name = 
relu5 _ 2 conv5 _ 3 = mx . symbol 
. Convolution data = relu5 _ 2 kernel = 3 
3 pad = 1 1 num _ filter = 512 
workspace = 2048 name = conv5 _ 3 relu5 _ 
3 = mx . symbol . Activation data = conv5 
_ 3 act _ type = relu name = relu5 
_ 3 return relu5 _ 3 特征提取 器 二 下面 
是 最后 的 一小部分 网络 我们 将 筛选 出来 的 
proposal 作用于 Feature Map 得到 候选 区域 然后 使用 ROIPooling 
得到 大小 一致 的 候选 区域 这些 区域 送入 本 
部分 网络 得到 用于 分类 回归 的 特征 def get 
_ vgg _ top _ feature data # group 6 
flatten = mx . symbol . Flatten data = data 
name = flatten fc6 = mx . symbol . FullyConnected 
data = flatten num _ hidden = 4096 name = 
fc6 relu6 = mx . symbol . Activation data = 
fc6 act _ type = relu name = relu6 drop6 
= mx . symbol . Dropout data = relu6 p 
= 0.5 name = drop6 # group 7 fc7 = 
mx . symbol . FullyConnected data = drop6 num _ 
hidden = 4096 name = fc7 relu7 = mx . 
symbol . Activation data = fc7 act _ type = 
relu name = relu7 drop7 = mx . symbol . 
Dropout data = relu7 p = 0.5 name = drop7 
return drop7 主体 函数 函数 接口 def get _ vgg 
_ train anchor _ scales anchor _ ratios rpn _ 
feature _ stride rpn _ pre _ topk rpn _ 
post _ topk rpn _ nms _ thresh rpn _ 
min _ size rpn _ batch _ rois num _ 
classes rcnn _ feature _ stride rcnn _ pooled _ 
size rcnn _ batch _ size rcnn _ batch _ 
rois rcnn _ fg _ fraction rcnn _ fg _ 
overlap rcnn _ bbox _ stds 首先 定义 了 一些 
用于 接收数据 & 标签 信息 的 占位符 变量 num _ 
anchors = len anchor _ scales * len anchor _ 
ratios data = mx . symbol . Variable name = 
data # 图片 信息 batch channel height width im _ 
info = mx . symbol . Variable name = im 
_ info gt _ boxes = mx . symbol . 
Variable name = gt _ boxes # 真实 框 信息 
obj 数量 5 # anchor 标签 1 0 1 无效 
背景 目标 rpn _ label = mx . symbol . 
Variable name = label # batch 2 中心点 行数 * 
每个 位置 anchors 数目 中心点 列数 # 根据 初始 anchor 
和 ground truth 计算 出来 的 offset rpn _ bbox 
_ target = mx . symbol . Variable name = 
bbox _ target # batch 4 * 每个 位置 anchors 
数目 中心点 行数 中心点 列数 # mask 如果 anchor 标签 
是 1 则 mask 对应 值 为 1 anchor 标签 
是 0 或 1 则 mask 对应 值 为 0 
rpn _ bbox _ weight = mx . symbol . 
Variable name = bbox _ weight # batch 4 * 
每个 位置 anchors 数目 中心点 行数 中心点 列数 获取 卷积 
特征 # shared convolutional layers conv _ feat = get 
_ vgg _ feature data 使用 3 × 3 的 
滑窗/nr 进行 卷积 # RPN layers rpn _ conv = 
mx . symbol . Convolution data = conv _ feat 
kernel = 3 3 pad = 1 1 num _ 
filter = 512 name = rpn _ conv _ 3x3 
rpn _ relu = mx . symbol . Activation data 
= rpn _ conv act _ type = relu name 
= rpn _ relu 每个 滑动 窗口 位置 生成 9个 
候选 窗口 不同 尺度 不同 宽 高 对应 36个 坐标 
18个 分类 即 根据 每 张 图片 的 feat map 
大小 生成 对应 数量 的 中心 点 以及 候选 框体 
RPN calssification anchor good . bad 下面 是 计算 全部 
候选 窗口 对应 2 分类 的 部分 生成 损失 函数 
的 第一 部分 全部 候选 窗 含 / 不含 obj 
的 二分 类 损失 # rpn classification obj / not 
_ obj # batch 2 * 每个 位置 anchors 数目 
中心点 行数 中心点 列数 rpn _ cls _ score = 
mx . symbol . Convolution data = rpn _ relu 
kernel = 1 1 pad = 0 0 num _ 
filter = 2 * num _ anchors name = rpn 
_ cls _ score # batch 2 中心点 行数 * 
每个 位置 anchors 数目 中心点 列数 rpn _ cls _ 
score _ reshape = mx . symbol . Reshape data 
= rpn _ cls _ score shape = 0 2 
1 0 name = rpn _ cls _ score _ 
reshape # 获取 交叉 熵 回传 梯度 对于 出现 了 
1 的 图片 梯度 直接 全部 置 为 0 # 
在 Faster RCNN 算法 中 anchor 一 共有 3种 标签 
1 0 1 分别 表示 无效 背景 目标 rpn _ 
cls _ prob = mx . symbol . SoftmaxOutput data 
= rpn _ cls _ score _ reshape label = 
rpn _ label multi _ output = True normalization = 
valid use _ ignore = True ignore _ label = 
1 name = rpn _ cls _ prob # 切换 
为 含 / 不含 obj 两 通道 对 每一个 anchor 
是否 有 obj 进行 softmax 处理 # batch 2 中心点 
行数 * 每个 位置 anchors 数目 中心点 列数 rpn _ 
cls _ act = mx . symbol . softmax data 
= rpn _ cls _ score _ reshape axis = 
1 name = rpn _ cls _ act # batch 
2 * 每个 位置 anchors 数目 中心点 行数 中心点 列数 
# Reshpe 方法 不同 于 reshape 方法 详情 见此 方法 
文档 rpn _ cls _ act _ reshape = mx 
. symbol . Reshape data = rpn _ cls _ 
act shape = 0 2 * num _ anchors 1 
0 name = rpn _ cls _ act _ reshape 
RPN regression anchor propoasal 下面 计算 全部 候选 窗口 对应 
4个 坐标值 的 部分 生成 损失 函数 第二 部分 全部 
候选框 坐标 回归 # rpn bbox regression # batch 4 
* 每个 位置 anchors 数目 中心点 行数 中心点 列数 rpn 
_ bbox _ pred = mx . symbol . Convolution 
data = rpn _ relu kernel = 1 1 pad 
= 0 0 num _ filter = 4 * num 
_ anchors name = rpn _ bbox _ pred # 
rpn _ bbox _ weight anchor 的 mask 如果 某个 
anchor 的 标签 是 1 则 mask 对应 值 为 
1 anchor 的 标签 是 0 或 1 则 mask 
对应 值 为 0 # rpn _ bbox _ target 
根据 初始 anchor 和 ground truth 计算 出来 的 offset 
rpn _ bbox _ loss _ = rpn _ bbox 
_ weight * mx . symbol . smooth _ l1 
name = rpn _ bbox _ loss _ scalar = 
3.0 data = rpn _ bbox _ pred rpn _ 
bbox _ target # 获取 回归 梯度 # grad _ 
scale 表示 回归 损失 占 RPN 网络 总 损失 比 
该 参数 相差 几个 量级 对 结果 影响 也 不大 
rpn _ bbox _ loss = mx . sym . 
MakeLoss name = rpn _ bbox _ loss data = 
rpn _ bbox _ loss _ grad _ scale = 
1.0 / rpn _ batch _ rois 候选框 生成 我们 
会 获取 数量 繁多 的 候选框 即 上面 得到 的 
候选框 含有 obj 的 得分 和 候选框 坐标 修 正值 
首先 会 根据 框体 含有 obj 的 概率 进行 一次 
初筛 然后 经由 非 极大值 抑制 算法 筛选 2000个 候选框 
进入 下 一步 的 操作 在 第二 步中/nr 我们 会 
获取 最终 的 128个 候选框 它们 各自 对应 的 标签 
它们 坐标 回归 的 目标 以及 标定 它们 正负 的 
坐标 掩码 用于 精确 的 训练 候选框 生成 目标 边框 
这个 一步 的 操作 使用 了 作者 新建 的 操作 
节点 具体 实现 见 源码 这里 只 简单 介绍 该 
操作 的 输入 输出 以及 作用 另 注 函数 返回 
的 候选框 5个 属性 与 后面 的 ROIPooling 一脉相承 候选框 
对应 batch 中 图片 的 索引 候选框 坐标 × 4 
后面 使用 这个 值 可以 直接 进行 ROIPooling # rpn 
proposal # 获取 指定 数目 的 候选框 proposal # 2000个 
候选框 5个 属性 # 5个 属性 batch 中 图片 index 
4个 坐标 rois = mx . symbol . contrib . 
MultiProposal cls _ prob = rpn _ cls _ act 
_ reshape # cls _ prob batch 2 * 每个 
位置 anchors 数目 中心点 行数 中心点 列数 bbox _ pred 
= rpn _ bbox _ pred # bbox _ pred 
batch 4 * 每个 位置 anchors 数目 中心点 行数 中心点 
列数 im _ info = im _ info # mx 
. symbol . Variable name = im _ info feature 
_ stride = rpn _ feature _ stride # 16 
scales = anchor _ scales ratios = anchor _ ratios 
# 0.5 1 2 rpn _ pre _ nms _ 
top _ n = rpn _ pre _ topk # 
12000 对 RPN 网络 输出 的 anchor 进行 NMS 操作 
之前 的 proposal 最大 数量 # 输入 proposal 的 数量 
大于 12000时 对 这些 proposal 的 预测 为 foreground 的 
概率 也叫 score # 换 句话 说 就是 预测 标签 
为 1 的 概率 从高 到 低 排序 然后 选择 
前面 12000个 rpn _ post _ nms _ top _ 
n = rpn _ post _ topk # 2000 经过 
NMS 过滤 之后 得到 的 proposal 数量 threshold = rpn 
_ nms _ thresh # 0.7 是 NMS 算法 阈值 
rpn _ min _ size = rpn _ min _ 
size # 16 name = rois # rcnn roi proposal 
target # 根据 上 一步 获取 的 proposal 即 rois 
和 真实 框 gt _ boxes 进行 筛选 # 获取 
128个 proposal 对应 的 128个 label 对应 的 128个 真实 
坐标 128个 坐标 掩码 构建 损失 函数 使用 group = 
mx . symbol . Custom rois = rois # 2000 
* 5 的 roi 信息 gt _ boxes = gt 
_ boxes # n * 5 的 ground truth 信息 
n 表示 object 数量 op _ type = proposal _ 
target num _ classes = num _ classes # num 
_ classes 是 实际 要 分类 的 类别 数 加上 
背景 类 batch _ images = rcnn _ batch _ 
size # 1 batch _ rois = rcnn _ batch 
_ rois # 128 fg _ fraction = rcnn _ 
fg _ fraction # 0.25 正 样本 所占 的 比例 
fg _ overlap = rcnn _ fg _ overlap # 
0.5 box _ stds = rcnn _ bbox _ stds 
# 0.1 0.1 0.2 0.2 rois = group 0 # 
rois 128 5 label = group 1 # roi 对应 
的 标签 128 bbox _ target = group 2 # 
坐标 回归 的 目标 维度 是 128 84 其中 84 
来自 20 + 1 * 4 bbox _ weight = 
group 3 # 坐标 回归 时候 的 权重 维度 是 
128 84 对于 foreground 都是 1 对于 backgroud 都是 0 
在 RPN 网络 得到 proposal 后 还会 经过 一系列 的 
过滤 操作 才会 得到 送入 检测 网络 的 proposal 节点 
proposal _ target 会将 2000个 proposal 过滤 成 128个 且为 
这 128个 proposal 分配 标签 回归 目标 定义 正负 样本 
的 1 3 比例 等 这部分 算是 RPN 网络 和 
检测 网络 Fast RCNN 的 衔接 值得 注意 的 是 
该 节点 不接受 后面 层数 传递 而来 的 梯度 且 
向前 传递 梯度 强 制为 0 已 即 网络 训练 
由其 割裂 为 两个 部分 尽管 两 部分 仍然 相连 
ROIPooling 层 将 任意 大小 的 输入 层 下 采样 
为 同样 大小 的 输出 层 方便 后面 的 计算 
这里 我们 使用 候选框 128个 寻找 各自 对应 的 图片 
并将 各自 对应 的 区域 裁剪 出来 然后 pooling 为 
同样 的 大小 本 层 的 两条 虚线 输入 中 
上面 一条 表示 batch 图像 特征 下面 一条 表示 候选框 
输入 # rcnn roi pool # 128个 候选框 512个 通道 
7行 7列 roi _ pool = mx . symbol . 
ROIPooling name = roi _ pool data = conv _ 
feat rois = rois pooled _ size = rcnn _ 
pooled _ size # 7 7 输出 大小 spatial _ 
scale = 1.0 / rcnn _ feature _ stride # 
16 feat / raw _ img 将 对应 的 候选 
区域 注意 此时 抠图 完成 已经 不是 候选框 了 经由 
vgg 的 分类 头 部分 实际上 就是 对 候选 区域 
再进一步 抽象 提取 特征 进行 处理 # rcnn top feature 
# 128 4096 对 每个 roi 提取 最终 的 vgg 
特征 top _ feat = get _ vgg _ top 
_ feature roi _ pool 最后 的 两个 损失 函数 
生成 过程 对 128个 候选 区域 的 抽象 特征 进行 
分类 此时 不是 含 / 不含 obj 而是 直接 进行 
21 分类 并对 每 一个 抽象 特征 回归 出 4个 
坐标值 两个 损失 函数 标签 均 来自 上面 自定义 节点 
的 输出 label = group 1         
                    
        # roi 对应 的 标签 128 
bbox _ target = group 2         
    # 坐标 回归 的 目标 维度 是 128 
84 其中 84 来自 20 + 1 * 4bbox _ 
weight = group 3           # 
坐标 回归 时候 的 权重 维度 是 128 84 对于 
foreground 都是 1 对于 backgroud 都是 0 # rcnn classification 
# 对 每个 roi 进行 分类 并 构建 损失 函数 
cls _ score = mx . symbol . FullyConnected name 
= cls _ score data = top _ feat num 
_ hidden = num _ classes cls _ prob = 
mx . symbol . SoftmaxOutput name = cls _ prob 
data = cls _ score label = label normalization = 
batch # rcnn bbox regression # 对 每个 roi 进行 
回归 并 构建 损失 函数 bbox _ pred = mx 
. symbol . FullyConnected name = bbox _ pred data 
= top _ feat num _ hidden = num _ 
classes * 4 bbox _ loss _ = bbox _ 
weight * mx . symbol . smooth _ l1 name 
= bbox _ loss _ scalar = 1.0 data = 
bbox _ pred bbox _ target bbox _ loss = 
mx . sym . MakeLoss name = bbox _ loss 
data = bbox _ loss _ grad _ scale = 
1.0 / rcnn _ batch _ rois 附 主体 函数 
全览/nr def get _ vgg _ train anchor _ scales 
anchor _ ratios rpn _ feature _ stride rpn _ 
pre _ topk rpn _ post _ topk rpn _ 
nms _ thresh rpn _ min _ size rpn _ 
batch _ rois num _ classes rcnn _ feature _ 
stride rcnn _ pooled _ size rcnn _ batch _ 
size rcnn _ batch _ rois rcnn _ fg _ 
fraction rcnn _ fg _ overlap rcnn _ bbox _ 
stds num _ anchors = len anchor _ scales * 
len anchor _ ratios data = mx . symbol . 
Variable name = data # 图片 信息 batch channel height 
width im _ info = mx . symbol . Variable 
name = im _ info gt _ boxes = mx 
. symbol . Variable name = gt _ boxes # 
真实 框 信息 obj 数量 5 # anchor 标签 1 
0 1 无效 背景 目标 rpn _ label = mx 
. symbol . Variable name = label # batch 2 
中心点 行数 * 每个 位置 anchors 数目 中心点 列数 # 
根据 初始 anchor 和 ground truth 计算 出来 的 offset 
rpn _ bbox _ target = mx . symbol . 
Variable name = bbox _ target # batch 4 * 
每个 位置 anchors 数目 中心点 行数 中心点 列数 # mask 
如果 anchor 标签 是 1 则 mask 对应 值 为 
1 anchor 标签 是 0 或 1 则 mask 对应 
值 为 0 rpn _ bbox _ weight = mx 
. symbol . Variable name = bbox _ weight # 
batch 4 * 每个 位置 anchors 数目 中心点 行数 中心点 
列数 # shared convolutional layers conv _ feat = get 
_ vgg _ feature data # RPN layers rpn _ 
conv = mx . symbol . Convolution data = conv 
_ feat kernel = 3 3 pad = 1 1 
num _ filter = 512 name = rpn _ conv 
_ 3x3 rpn _ relu = mx . symbol . 
Activation data = rpn _ conv act _ type = 
relu name = rpn _ relu # rpn classification obj 
/ not _ obj # batch 2 * 每个 位置 
anchors 数目 中心点 行数 中心点 列数 rpn _ cls _ 
score = mx . symbol . Convolution data = rpn 
_ relu kernel = 1 1 pad = 0 0 
num _ filter = 2 * num _ anchors name 
= rpn _ cls _ score # batch 2 中心点 
行数 * 每个 位置 anchors 数目 中心点 列数 rpn _ 
cls _ score _ reshape = mx . symbol . 
Reshape data = rpn _ cls _ score shape = 
0 2 1 0 name = rpn _ cls _ 
score _ reshape # 获取 交叉 熵 回传 梯度 对于 
出现 了 1 的 图片 梯度 直接 全部 置 为 
0 # 在 Faster RCNN 算法 中 anchor 一 共有 
3种 标签 1 0 1 分别 表示 无效 背景 目标 
rpn _ cls _ prob = mx . symbol . 
SoftmaxOutput data = rpn _ cls _ score _ reshape 
label = rpn _ label multi _ output = True 
normalization = valid use _ ignore = True ignore _ 
label = 1 name = rpn _ cls _ prob 
# 切换 为 含 / 不含 obj 两 通道 对 
每一个 anchor 是否 有 obj 进行 softmax 处理 # batch 
2 中心点 行数 * 每个 位置 anchors 数目 中心点 列数 
rpn _ cls _ act = mx . symbol . 
softmax data = rpn _ cls _ score _ reshape 
axis = 1 name = rpn _ cls _ act 
# batch 2 * 每个 位置 anchors 数目 中心点 行数 
中心点 列数 # Reshpe 方法 不同 于 reshape 方法 详情 
见此 方法 文档 rpn _ cls _ act _ reshape 
= mx . symbol . Reshape data = rpn _ 
cls _ act shape = 0 2 * num _ 
anchors 1 0 name = rpn _ cls _ act 
_ reshape # rpn bbox regression # batch 4 * 
每个 位置 anchors 数目 中心点 行数 中心点 列数 rpn _ 
bbox _ pred = mx . symbol . Convolution data 
= rpn _ relu kernel = 1 1 pad = 
0 0 num _ filter = 4 * num _ 
anchors name = rpn _ bbox _ pred # rpn 
_ bbox _ weight anchor 的 mask 如果 某个 anchor 
的 标签 是 1 则 mask 对应 值 为 1 
anchor 的 标签 是 0 或 1 则 mask 对应 
值 为 0 # rpn _ bbox _ target 根据 
初始 anchor 和 ground truth 计算 出来 的 offset rpn 
_ bbox _ loss _ = rpn _ bbox _ 
weight * mx . symbol . smooth _ l1 name 
= rpn _ bbox _ loss _ scalar = 3.0 
data = rpn _ bbox _ pred rpn _ bbox 
_ target # 获取 回归 梯度 # grad _ scale 
表示 回归 损失 占 RPN 网络 总 损失 比 该 
参数 相差 几个 量级 对 结果 影响 也 不大 rpn 
_ bbox _ loss = mx . sym . MakeLoss 
name = rpn _ bbox _ loss data = rpn 
_ bbox _ loss _ grad _ scale = 1.0 
/ rpn _ batch _ rois # rpn proposal # 
获取 指定 数目 的 候选框 proposal # 2000个 候选框 5个 
属性 # 5个 属性 batch 中 图片 index 4个 坐标 
rois = mx . symbol . contrib . MultiProposal cls 
_ prob = rpn _ cls _ act _ reshape 
# cls _ prob batch 2 * 每个 位置 anchors 
数目 中心点 行数 中心点 列数 bbox _ pred = rpn 
_ bbox _ pred # bbox _ pred batch 4 
* 每个 位置 anchors 数目 中心点 行数 中心点 列数 im 
_ info = im _ info # mx . symbol 
. Variable name = im _ info feature _ stride 
= rpn _ feature _ stride # 16 scales = 
anchor _ scales ratios = anchor _ ratios # 0.5 
1 2 rpn _ pre _ nms _ top _ 
n = rpn _ pre _ topk # 12000 对 
RPN 网络 输出 的 anchor 进行 NMS 操作 之前 的 
proposal 最大 数量 # 输入 proposal 的 数量 大于 12000时 
对 这些 proposal 的 预测 为 foreground 的 概率 也叫 
score # 换 句话 说 就是 预测 标签 为 1 
的 概率 从高 到 低 排序 然后 选择 前面 12000个 
rpn _ post _ nms _ top _ n = 
rpn _ post _ topk # 2000 经过 NMS 过滤 
之后 得到 的 proposal 数量 threshold = rpn _ nms 
_ thresh # 0.7 是 NMS 算法 阈值 rpn _ 
min _ size = rpn _ min _ size # 
16 name = rois # rcnn roi proposal target # 
根据 上 一步 获取 的 proposal 即 rois 和 真实 
框 gt _ boxes 进行 筛选 # 获取 128个 proposal 
对应 的 128个 label 对应 的 128个 真实 坐标 128个 
坐标 掩码 构建 损失 函数 使用 group = mx . 
symbol . Custom rois = rois # 2000 * 5 
的 roi 信息 gt _ boxes = gt _ boxes 
# n * 5 的 ground truth 信息 n 表示 
object 数量 op _ type = proposal _ target num 
_ classes = num _ classes # num _ classes 
是 实际 要 分类 的 类别 数 加上 背景 类 
batch _ images = rcnn _ batch _ size # 
1 batch _ rois = rcnn _ batch _ rois 
# 128 fg _ fraction = rcnn _ fg _ 
fraction # 0.25 正 样本 所占 的 比例 fg _ 
overlap = rcnn _ fg _ overlap # 0.5 box 
_ stds = rcnn _ bbox _ stds # 0.1 
0.1 0.2 0.2 rois = group 0 # rois 128 
5 label = group 1 # roi 对应 的 标签 
128 bbox _ target = group 2 # 坐标 回归 
的 目标 维度 是 128 84 其中 84 来自 20 
+ 1 * 4 bbox _ weight = group 3 
# 坐标 回归 时候 的 权重 维度 是 128 84 
对于 foreground 都是 1 对于 backgroud 都是 0 # rcnn 
roi pool # 128个 候选框 512个 通道 7行 7列 roi 
_ pool = mx . symbol . ROIPooling name = 
roi _ pool data = conv _ feat rois = 
rois pooled _ size = rcnn _ pooled _ size 
# 7 7 输出 大小 spatial _ scale = 1.0 
/ rcnn _ feature _ stride # 16 feat / 
raw _ img # rcnn top feature # 128 4096 
对 每个 roi 提取 最终 的 vgg 特征 top _ 
feat = get _ vgg _ top _ feature roi 
_ pool # rcnn classification # 对 每个 roi 进行 
分类 并 构建 损失 函数 cls _ score = mx 
. symbol . FullyConnected name = cls _ score data 
= top _ feat num _ hidden = num _ 
classes cls _ prob = mx . symbol . SoftmaxOutput 
name = cls _ prob data = cls _ score 
label = label normalization = batch # rcnn bbox regression 
# 对 每个 roi 进行 回归 并 构建 损失 函数 
bbox _ pred = mx . symbol . FullyConnected name 
= bbox _ pred data = top _ feat num 
_ hidden = num _ classes * 4 bbox _ 
loss _ = bbox _ weight * mx . symbol 
. smooth _ l1 name = bbox _ loss _ 
scalar = 1.0 data = bbox _ pred bbox _ 
target bbox _ loss = mx . sym . MakeLoss 
name = bbox _ loss data = bbox _ loss 
_ grad _ scale = 1.0 / rcnn _ batch 
_ rois # reshape output # 1 128 1 128 
21 1 128 84 label = mx . symbol . 
Reshape data = label shape = rcnn _ batch _ 
size 1 name = label _ reshape cls _ prob 
= mx . symbol . Reshape data = cls _ 
prob shape = rcnn _ batch _ size 1 num 
_ classes name = cls _ prob _ reshape bbox 
_ loss = mx . symbol . Reshape data = 
bbox _ loss shape = rcnn _ batch _ size 
1 4 * num _ classes name = bbox _ 
loss _ reshape print cls _ score . infer _ 
shape * * { data 1 3 1000 600 gt 
_ boxes 5 5 } 1 # group output # 
mx . symbol . BlockGrad 会 阻止 经由 节点 label 
回传 的 梯度 group = mx . symbol . Group 
rpn _ cls _ prob # anchors 分类 损失 batch 
2 中心点 行数 * 每个 位置 anchors 数目 中心点 列数 
rpn _ bbox _ loss # anchors 回归 损失 batch 
4 * 每个 位置 anchors 数目 中心点 行数 中心点 列数 
cls _ prob # 候选框 分类 损失 1 128 21 
bbox _ loss # 候选框 回归 损失 1 128 84 
mx . symbol . BlockGrad label # 候选框 标签 1 
128 return group if _ _ name _ _ = 
= _ _ main _ _ net = get _ 
vgg _ train anchor _ scales = 8 16 32 
anchor _ ratios = 0.5 1 2 rpn _ feature 
_ stride = 16 rpn _ pre _ topk = 
12000 rpn _ post _ topk = 2000 rpn _ 
nms _ thresh = 0.7 rpn _ min _ size 
= 16 rpn _ batch _ rois = 256 num 
_ classes = 21 rcnn _ feature _ stride = 
16 # 4个 pooling 层 rcnn _ pooled _ size 
= 7 7 rcnn _ batch _ size = 1 
rcnn _ batch _ rois = 128 rcnn _ fg 
_ fraction = 0.25 rcnn _ fg _ overlap = 
0.5 rcnn _ bbox _ stds = 0.1 0.1 0.2 
0.2 项目 源码 一 Faster RCNN 简介 cs231n Faster _ RCNN 
计算机 视觉 Faster RCNN 学习 _ 其一 目标 检测 及 
RCNN 谱系 一篇 讲 的 非常 明白 的 文章 一文 
读懂 Faster RCNN 1 输入 测试 图像 2 将 整张 
图片 输入 CNN 进行 特征提取 3 用 RPN 生成 建议 
窗口 proposals 每张 图片 保留 约 300个 建议 窗口 4 
把 建议 窗口 映 射到 CNN 的 最后 一层 卷积 
feature map 上 5 通过 RoI pooling 层 使 每个 
RoI 生成 固定 尺寸 的 feature map 6 利用 Softmax 
Loss 探测 分类 概率 和 Smooth L1 Loss 探测 边框 
回归 对 分类 概率 和 边框 回归 Bounding box regression 
联合 训练 . 相比 FAST RCNN 主要 两处 不同 1 
使用 RPN Region Proposal Network 代替 原来 的 Selective Search 
方法 产生 建议 窗口 2 产生 建议 窗口 的 CNN 
和 目标 检测 的 CNN 共享 改进 快速 产生 建议 
框 FASTER RCNN 创造性 地 采用 卷积 网络 自行 产生 
建议 框 并且 和 目标 检测 网络 共享 卷积 网络 
使得 建议 框 数目 从 原有 的 约 2000个 减少 
为 300个 且 建议 框 的 质量 也 有 本质 
的 提高 . RPN 简介 放到 整体 网络 中 如下 
对于 共享 的 Feature Map RPN 使用 3 * 3 
的 滑窗/nr 每个 滑动 窗口 位置 生成 9个 候选 窗口 
不同 尺度 不同 宽 高 对应 36个 坐标 18个 分类 
训练 过程 中 1 丢弃 跨越 边界 的 anchor 2 
与 样本 重叠 区域 大于 0.7 的 anchor 标记 为 
前景 重叠 区域 小于 0.3 的 标定 为 背景 总结 
一下 • 在 feature map 上 滑动 窗口 • 建 
一个 神经 网络 用于 物体 分类 + 框 位置 的 
回归 • 滑动 窗口 的 位置 提供 了 物体 的 
大体 位置 信息 • 框 的 回归 提供 了 框 
更 精确 的 位置 这里 的 分类 只 需要 区分 
候选 框内 特征 为 前景 或者 背景 这里 的 边框 
回归 也 是 为了 之后 获得 更 精确 的 目标 
位置 损失 函数 故 整个 网络 包含 四个 损失 函数 
• RPN calssification anchor good . bad 判断 anchor 前景 
背景 类别 • RPN regression anchor propoasal 计算 anchor 和 
gt box 的 偏差 利用 mask 仅 计算 前景 anchor 
• Fast R CNN classification over classes 判断 proposal 分类 
包含 类 别数 C + 背景 • Fast R CNN 
regression proposal box 计算 proposal 和 gt box 的 偏差 
利用 mask 仅 计算 类别 的 proposal 注意到 前 两个 
损失 函数 目标 是 修正 anchor 后 两个 损失 函数 
目标 是 修正 proposal 实际上 产生 了 众多 anchors 后 
会 进行 筛选 非 极大值 抑制 并 按照 前景 得分 
排序 等等 选出 特定 比例 的 前景 背景 anchors 作为 
proposal 进行 后面 的 运算 二 代码 解读 Faster RCNN 
网络设计 很是 复杂 个人 觉得 但 看 论文 或者 其他 
材料 并 不能 很好 的 理解 这套 流程 本篇 我们 
从 实际 的 代码 出发 看看 到底 是 这套 网络系统 
到底 是 如何 设计 的 anchor 和 proposalregion proposal 或者 
简称 proposal 或者 简称 ROI 可以 说 RPN 网络 的 
目的 就是 为了 得到 proposal 这些 proposal 是 对 ground 
truth 更好 的 刻画 和 anchor 相比 坐标 更 贴近 
ground truth 毕竟 anchor 的 坐标 都是 批量 地 按照 
scale 和 aspect ratio 复制 的 如果 你 还 记得 
在 系列 二中 关于 网络 结构 的 介绍 那么 你 
就 应该 了解 到 RPN 网络 的 回归 支路 输出 
的 值 offset 作为 smooth l1 损失 函数 的 输入 
之一 时 其 含义 就是 使得 proposal 和 anchor 之间 
的 offset RPN 网络 的 回归 支路 输出 尽可能 与 
ground truth 和 anchor 之间 的 offset RPN 网络 的 
回归 支路 的 回归 目标 接近 调包 部分 涉及 了 
mx 基础 框架 和 一个 作者 自己 创建 的 operate 
import mxnet as mx from symnet import proposal _ target 
特征提取 器 一如 开篇 的 图 这里 是 最上面 一行 
的 网络 即 提取 Feature Map 的 部分 使用 了 
4个 pooling 层 意味着 原始 图像 Feature Map = 16 
1 def get _ vgg _ feature data # group 
1 conv1 _ 1 = mx . symbol . Convolution 
data = data kernel = 3 3 pad = 1 
1 num _ filter = 64 workspace = 2048 name 
= conv1 _ 1 relu1 _ 1 = mx . 
symbol . Activation data = conv1 _ 1 act _ 
type = relu name = relu1 _ 1 conv1 _ 
2 = mx . symbol . Convolution data = relu1 
_ 1 kernel = 3 3 pad = 1 1 
num _ filter = 64 workspace = 2048 name = 
conv1 _ 2 relu1 _ 2 = mx . symbol 
. Activation data = conv1 _ 2 act _ type 
= relu name = relu1 _ 2 pool1 = mx 
. symbol . Pooling data = relu1 _ 2 pool 
_ type = max kernel = 2 2 stride = 
2 2 name = pool1 # group 2 conv2 _ 
1 = mx . symbol . Convolution data = pool1 
kernel = 3 3 pad = 1 1 num _ 
filter = 128 workspace = 2048 name = conv2 _ 
1 relu2 _ 1 = mx . symbol . Activation 
data = conv2 _ 1 act _ type = relu 
name = relu2 _ 1 conv2 _ 2 = mx 
. symbol . Convolution data = relu2 _ 1 kernel 
= 3 3 pad = 1 1 num _ filter 
= 128 workspace = 2048 name = conv2 _ 2 
relu2 _ 2 = mx . symbol . Activation data 
= conv2 _ 2 act _ type = relu name 
= relu2 _ 2 pool2 = mx . symbol . 
Pooling data = relu2 _ 2 pool _ type = 
max kernel = 2 2 stride = 2 2 name 
= pool2 # group 3 conv3 _ 1 = mx 
. symbol . Convolution data = pool2 kernel = 3 
3 pad = 1 1 num _ filter = 256 
workspace = 2048 name = conv3 _ 1 relu3 _ 
1 = mx . symbol . Activation data = conv3 
_ 1 act _ type = relu name = relu3 
_ 1 conv3 _ 2 = mx . symbol . 
Convolution data = relu3 _ 1 kernel = 3 3 
pad = 1 1 num _ filter = 256 workspace 
= 2048 name = conv3 _ 2 relu3 _ 2 
= mx . symbol . Activation data = conv3 _ 
2 act _ type = relu name = relu3 _ 
2 conv3 _ 3 = mx . symbol . Convolution 
data = relu3 _ 2 kernel = 3 3 pad 
= 1 1 num _ filter = 256 workspace = 
2048 name = conv3 _ 3 relu3 _ 3 = 
mx . symbol . Activation data = conv3 _ 3 
act _ type = relu name = relu3 _ 3 
pool3 = mx . symbol . Pooling data = relu3 
_ 3 pool _ type = max kernel = 2 
2 stride = 2 2 name = pool3 # group 
4 conv4 _ 1 = mx . symbol . Convolution 
data = pool3 kernel = 3 3 pad = 1 
1 num _ filter = 512 workspace = 2048 name 
= conv4 _ 1 relu4 _ 1 = mx . 
symbol . Activation data = conv4 _ 1 act _ 
type = relu name = relu4 _ 1 conv4 _ 
2 = mx . symbol . Convolution data = relu4 
_ 1 kernel = 3 3 pad = 1 1 
num _ filter = 512 workspace = 2048 name = 
conv4 _ 2 relu4 _ 2 = mx . symbol 
. Activation data = conv4 _ 2 act _ type 
= relu name = relu4 _ 2 conv4 _ 3 
= mx . symbol . Convolution data = relu4 _ 
2 kernel = 3 3 pad = 1 1 num 
_ filter = 512 workspace = 2048 name = conv4 
_ 3 relu4 _ 3 = mx . symbol . 
Activation data = conv4 _ 3 act _ type = 
relu name = relu4 _ 3 pool4 = mx . 
symbol . Pooling data = relu4 _ 3 pool _ 
type = max kernel = 2 2 stride = 2 
2 name = pool4 # group 5 conv5 _ 1 
= mx . symbol . Convolution data = pool4 kernel 
= 3 3 pad = 1 1 num _ filter 
= 512 workspace = 2048 name = conv5 _ 1 
relu5 _ 1 = mx . symbol . Activation data 
= conv5 _ 1 act _ type = relu name 
= relu5 _ 1 conv5 _ 2 = mx . 
symbol . Convolution data = relu5 _ 1 kernel = 
3 3 pad = 1 1 num _ filter = 
512 workspace = 2048 name = conv5 _ 2 relu5 
_ 2 = mx . symbol . Activation data = 
conv5 _ 2 act _ type = relu name = 
relu5 _ 2 conv5 _ 3 = mx . symbol 
. Convolution data = relu5 _ 2 kernel = 3 
3 pad = 1 1 num _ filter = 512 
workspace = 2048 name = conv5 _ 3 relu5 _ 
3 = mx . symbol . Activation data = conv5 
_ 3 act _ type = relu name = relu5 
_ 3 return relu5 _ 3 特征提取 器 二 下面 
是 最后 的 一小部分 网络 我们 将 筛选 出来 的 
proposal 作用于 Feature Map 得到 候选 区域 然后 使用 ROIPooling 
得到 大小 一致 的 候选 区域 这些 区域 送入 本 
部分 网络 得到 用于 分类 回归 的 特征 def get 
_ vgg _ top _ feature data # group 6 
flatten = mx . symbol . Flatten data = data 
name = flatten fc6 = mx . symbol . FullyConnected 
data = flatten num _ hidden = 4096 name = 
fc6 relu6 = mx . symbol . Activation data = 
fc6 act _ type = relu name = relu6 drop6 
= mx . symbol . Dropout data = relu6 p 
= 0.5 name = drop6 # group 7 fc7 = 
mx . symbol . FullyConnected data = drop6 num _ 
hidden = 4096 name = fc7 relu7 = mx . 
symbol . Activation data = fc7 act _ type = 
relu name = relu7 drop7 = mx . symbol . 
Dropout data = relu7 p = 0.5 name = drop7 
return drop7 主体 函数 函数 接口 def get _ vgg 
_ train anchor _ scales anchor _ ratios rpn _ 
feature _ stride rpn _ pre _ topk rpn _ 
post _ topk rpn _ nms _ thresh rpn _ 
min _ size rpn _ batch _ rois num _ 
classes rcnn _ feature _ stride rcnn _ pooled _ 
size rcnn _ batch _ size rcnn _ batch _ 
rois rcnn _ fg _ fraction rcnn _ fg _ 
overlap rcnn _ bbox _ stds 首先 定义 了 一些 
用于 接收数据 & 标签 信息 的 占位符 变量 num _ 
anchors = len anchor _ scales * len anchor _ 
ratios data = mx . symbol . Variable name = 
data # 图片 信息 batch channel height width im _ 
info = mx . symbol . Variable name = im 
_ info gt _ boxes = mx . symbol . 
Variable name = gt _ boxes # 真实 框 信息 
obj 数量 5 # anchor 标签 1 0 1 无效 
背景 目标 rpn _ label = mx . symbol . 
Variable name = label # batch 2 中心点 行数 * 
每个 位置 anchors 数目 中心点 列数 # 根据 初始 anchor 
和 ground truth 计算 出来 的 offset rpn _ bbox 
_ target = mx . symbol . Variable name = 
bbox _ target # batch 4 * 每个 位置 anchors 
数目 中心点 行数 中心点 列数 # mask 如果 anchor 标签 
是 1 则 mask 对应 值 为 1 anchor 标签 
是 0 或 1 则 mask 对应 值 为 0 
rpn _ bbox _ weight = mx . symbol . 
Variable name = bbox _ weight # batch 4 * 
每个 位置 anchors 数目 中心点 行数 中心点 列数 获取 卷积 
特征 # shared convolutional layers conv _ feat = get 
_ vgg _ feature data 使用 3 × 3 的 
滑窗/nr 进行 卷积 # RPN layers rpn _ conv = 
mx . symbol . Convolution data = conv _ feat 
kernel = 3 3 pad = 1 1 num _ 
filter = 512 name = rpn _ conv _ 3x3 
rpn _ relu = mx . symbol . Activation data 
= rpn _ conv act _ type = relu name 
= rpn _ relu 每个 滑动 窗口 位置 生成 9个 
候选 窗口 不同 尺度 不同 宽 高 对应 36个 坐标 
18个 分类 即 根据 每 张 图片 的 feat map 
大小 生成 对应 数量 的 中心 点 以及 候选 框体 
RPN calssification anchor good . bad 下面 是 计算 全部 
候选 窗口 对应 2 分类 的 部分 生成 损失 函数 
的 第一 部分 全部 候选 窗 含 / 不含 obj 
的 二分 类 损失 # rpn classification obj / not 
_ obj # batch 2 * 每个 位置 anchors 数目 
中心点 行数 中心点 列数 rpn _ cls _ score = 
mx . symbol . Convolution data = rpn _ relu 
kernel = 1 1 pad = 0 0 num _ 
filter = 2 * num _ anchors name = rpn 
_ cls _ score # batch 2 中心点 行数 * 
每个 位置 anchors 数目 中心点 列数 rpn _ cls _ 
score _ reshape = mx . symbol . Reshape data 
= rpn _ cls _ score shape = 0 2 
1 0 name = rpn _ cls _ score _ 
reshape # 获取 交叉 熵 回传 梯度 对于 出现 了 
1 的 图片 梯度 直接 全部 置 为 0 # 
在 Faster RCNN 算法 中 anchor 一 共有 3种 标签 
1 0 1 分别 表示 无效 背景 目标 rpn _ 
cls _ prob = mx . symbol . SoftmaxOutput data 
= rpn _ cls _ score _ reshape label = 
rpn _ label multi _ output = True normalization = 
valid use _ ignore = True ignore _ label = 
1 name = rpn _ cls _ prob # 切换 
为 含 / 不含 obj 两 通道 对 每一个 anchor 
是否 有 obj 进行 softmax 处理 # batch 2 中心点 
行数 * 每个 位置 anchors 数目 中心点 列数 rpn _ 
cls _ act = mx . symbol . softmax data 
= rpn _ cls _ score _ reshape axis = 
1 name = rpn _ cls _ act # batch 
2 * 每个 位置 anchors 数目 中心点 行数 中心点 列数 
# Reshpe 方法 不同 于 reshape 方法 详情 见此 方法 
文档 rpn _ cls _ act _ reshape = mx 
. symbol . Reshape data = rpn _ cls _ 
act shape = 0 2 * num _ anchors 1 
0 name = rpn _ cls _ act _ reshape 
RPN regression anchor propoasal 下面 计算 全部 候选 窗口 对应 
4个 坐标值 的 部分 生成 损失 函数 第二 部分 全部 
候选框 坐标 回归 # rpn bbox regression # batch 4 
* 每个 位置 anchors 数目 中心点 行数 中心点 列数 rpn 
_ bbox _ pred = mx . symbol . Convolution 
data = rpn _ relu kernel = 1 1 pad 
= 0 0 num _ filter = 4 * num 
_ anchors name = rpn _ bbox _ pred # 
rpn _ bbox _ weight anchor 的 mask 如果 某个 
anchor 的 标签 是 1 则 mask 对应 值 为 
1 anchor 的 标签 是 0 或 1 则 mask 
对应 值 为 0 # rpn _ bbox _ target 
根据 初始 anchor 和 ground truth 计算 出来 的 offset 
rpn _ bbox _ loss _ = rpn _ bbox 
_ weight * mx . symbol . smooth _ l1 
name = rpn _ bbox _ loss _ scalar = 
3.0 data = rpn _ bbox _ pred rpn _ 
bbox _ target # 获取 回归 梯度 # grad _ 
scale 表示 回归 损失 占 RPN 网络 总 损失 比 
该 参数 相差 几个 量级 对 结果 影响 也 不大 
rpn _ bbox _ loss = mx . sym . 
MakeLoss name = rpn _ bbox _ loss data = 
rpn _ bbox _ loss _ grad _ scale = 
1.0 / rpn _ batch _ rois 候选框 生成 我们 
会 获取 数量 繁多 的 候选框 即 上面 得到 的 
候选框 含有 obj 的 得分 和 候选框 坐标 修 正值 
首先 会 根据 框体 含有 obj 的 概率 进行 一次 
初筛 然后 经由 非 极大值 抑制 算法 筛选 2000个 候选框 
进入 下 一步 的 操作 在 第二 步中/nr 我们 会 
获取 最终 的 128个 候选框 它们 各自 对应 的 标签 
它们 坐标 回归 的 目标 以及 标定 它们 正负 的 
坐标 掩码 用于 精确 的 训练 候选框 生成 目标 边框 
这个 一步 的 操作 使用 了 作者 新建 的 操作 
节点 具体 实现 见 源码 这里 只 简单 介绍 该 
操作 的 输入 输出 以及 作用 另 注 函数 返回 
的 候选框 5个 属性 与 后面 的 ROIPooling 一脉相承 候选框 
对应 batch 中 图片 的 索引 候选框 坐标 × 4 
后面 使用 这个 值 可以 直接 进行 ROIPooling # rpn 
proposal # 获取 指定 数目 的 候选框 proposal # 2000个 
候选框 5个 属性 # 5个 属性 batch 中 图片 index 
4个 坐标 rois = mx . symbol . contrib . 
MultiProposal cls _ prob = rpn _ cls _ act 
_ reshape # cls _ prob batch 2 * 每个 
位置 anchors 数目 中心点 行数 中心点 列数 bbox _ pred 
= rpn _ bbox _ pred # bbox _ pred 
batch 4 * 每个 位置 anchors 数目 中心点 行数 中心点 
列数 im _ info = im _ info # mx 
. symbol . Variable name = im _ info feature 
_ stride = rpn _ feature _ stride # 16 
scales = anchor _ scales ratios = anchor _ ratios 
# 0.5 1 2 rpn _ pre _ nms _ 
top _ n = rpn _ pre _ topk # 
12000 对 RPN 网络 输出 的 anchor 进行 NMS 操作 
之前 的 proposal 最大 数量 # 输入 proposal 的 数量 
大于 12000时 对 这些 proposal 的 预测 为 foreground 的 
概率 也叫 score # 换 句话 说 就是 预测 标签 
为 1 的 概率 从高 到 低 排序 然后 选择 
前面 12000个 rpn _ post _ nms _ top _ 
n = rpn _ post _ topk # 2000 经过 
NMS 过滤 之后 得到 的 proposal 数量 threshold = rpn 
_ nms _ thresh # 0.7 是 NMS 算法 阈值 
rpn _ min _ size = rpn _ min _ 
size # 16 name = rois # rcnn roi proposal 
target # 根据 上 一步 获取 的 proposal 即 rois 
和 真实 框 gt _ boxes 进行 筛选 # 获取 
128个 proposal 对应 的 128个 label 对应 的 128个 真实 
坐标 128个 坐标 掩码 构建 损失 函数 使用 group = 
mx . symbol . Custom rois = rois # 2000 
* 5 的 roi 信息 gt _ boxes = gt 
_ boxes # n * 5 的 ground truth 信息 
n 表示 object 数量 op _ type = proposal _ 
target num _ classes = num _ classes # num 
_ classes 是 实际 要 分类 的 类别 数 加上 
背景 类 batch _ images = rcnn _ batch _ 
size # 1 batch _ rois = rcnn _ batch 
_ rois # 128 fg _ fraction = rcnn _ 
fg _ fraction # 0.25 正 样本 所占 的 比例 
fg _ overlap = rcnn _ fg _ overlap # 
0.5 box _ stds = rcnn _ bbox _ stds 
# 0.1 0.1 0.2 0.2 rois = group 0 # 
rois 128 5 label = group 1 # roi 对应 
的 标签 128 bbox _ target = group 2 # 
坐标 回归 的 目标 维度 是 128 84 其中 84 
来自 20 + 1 * 4 bbox _ weight = 
group 3 # 坐标 回归 时候 的 权重 维度 是 
128 84 对于 foreground 都是 1 对于 backgroud 都是 0 
在 RPN 网络 得到 proposal 后 还会 经过 一系列 的 
过滤 操作 才会 得到 送入 检测 网络 的 proposal 节点 
proposal _ target 会将 2000个 proposal 过滤 成 128个 且为 
这 128个 proposal 分配 标签 回归 目标 定义 正负 样本 
的 1 3 比例 等 这部分 算是 RPN 网络 和 
检测 网络 Fast RCNN 的 衔接 值得 注意 的 是 
该 节点 不接受 后面 层数 传递 而来 的 梯度 且 
向前 传递 梯度 强 制为 0 已 即 网络 训练 
由其 割裂 为 两个 部分 尽管 两 部分 仍然 相连 
ROIPooling 层 将 任意 大小 的 输入 层 下 采样 
为 同样 大小 的 输出 层 方便 后面 的 计算 
这里 我们 使用 候选框 128个 寻找 各自 对应 的 图片 
并将 各自 对应 的 区域 裁剪 出来 然后 pooling 为 
同样 的 大小 本 层 的 两条 虚线 输入 中 
上面 一条 表示 batch 图像 特征 下面 一条 表示 候选框 
输入 # rcnn roi pool # 128个 候选框 512个 通道 
7行 7列 roi _ pool = mx . symbol . 
ROIPooling name = roi _ pool data = conv _ 
feat rois = rois pooled _ size = rcnn _ 
pooled _ size # 7 7 输出 大小 spatial _ 
scale = 1.0 / rcnn _ feature _ stride # 
16 feat / raw _ img 将 对应 的 候选 
区域 注意 此时 抠图 完成 已经 不是 候选框 了 经由 
vgg 的 分类 头 部分 实际上 就是 对 候选 区域 
再进一步 抽象 提取 特征 进行 处理 # rcnn top feature 
# 128 4096 对 每个 roi 提取 最终 的 vgg 
特征 top _ feat = get _ vgg _ top 
_ feature roi _ pool 最后 的 两个 损失 函数 
生成 过程 对 128个 候选 区域 的 抽象 特征 进行 
分类 此时 不是 含 / 不含 obj 而是 直接 进行 
21 分类 并对 每 一个 抽象 特征 回归 出 4个 
坐标值 两个 损失 函数 标签 均 来自 上面 自定义 节点 
的 输出 label = group 1         
                    
        # roi 对应 的 标签 128 
bbox _ target = group 2         
    # 坐标 回归 的 目标 维度 是 128 
84 其中 84 来自 20 + 1 * 4bbox _ 
weight = group 3           # 
坐标 回归 时候 的 权重 维度 是 128 84 对于 
foreground 都是 1 对于 backgroud 都是 0 # rcnn classification 
# 对 每个 roi 进行 分类 并 构建 损失 函数 
cls _ score = mx . symbol . FullyConnected name 
= cls _ score data = top _ feat num 
_ hidden = num _ classes cls _ prob = 
mx . symbol . SoftmaxOutput name = cls _ prob 
data = cls _ score label = label normalization = 
batch # rcnn bbox regression # 对 每个 roi 进行 
回归 并 构建 损失 函数 bbox _ pred = mx 
. symbol . FullyConnected name = bbox _ pred data 
= top _ feat num _ hidden = num _ 
classes * 4 bbox _ loss _ = bbox _ 
weight * mx . symbol . smooth _ l1 name 
= bbox _ loss _ scalar = 1.0 data = 
bbox _ pred bbox _ target bbox _ loss = 
mx . sym . MakeLoss name = bbox _ loss 
data = bbox _ loss _ grad _ scale = 
1.0 / rcnn _ batch _ rois 附 主体 函数 
全览/nr def get _ vgg _ train anchor _ scales 
anchor _ ratios rpn _ feature _ stride rpn _ 
pre _ topk rpn _ post _ topk rpn _ 
nms _ thresh rpn _ min _ size rpn _ 
batch _ rois num _ classes rcnn _ feature _ 
stride rcnn _ pooled _ size rcnn _ batch _ 
size rcnn _ batch _ rois rcnn _ fg _ 
fraction rcnn _ fg _ overlap rcnn _ bbox _ 
stds num _ anchors = len anchor _ scales * 
len anchor _ ratios data = mx . symbol . 
Variable name = data # 图片 信息 batch channel height 
width im _ info = mx . symbol . Variable 
name = im _ info gt _ boxes = mx 
. symbol . Variable name = gt _ boxes # 
真实 框 信息 obj 数量 5 # anchor 标签 1 
0 1 无效 背景 目标 rpn _ label = mx 
. symbol . Variable name = label # batch 2 
中心点 行数 * 每个 位置 anchors 数目 中心点 列数 # 
根据 初始 anchor 和 ground truth 计算 出来 的 offset 
rpn _ bbox _ target = mx . symbol . 
Variable name = bbox _ target # batch 4 * 
每个 位置 anchors 数目 中心点 行数 中心点 列数 # mask 
如果 anchor 标签 是 1 则 mask 对应 值 为 
1 anchor 标签 是 0 或 1 则 mask 对应 
值 为 0 rpn _ bbox _ weight = mx 
. symbol . Variable name = bbox _ weight # 
batch 4 * 每个 位置 anchors 数目 中心点 行数 中心点 
列数 # shared convolutional layers conv _ feat = get 
_ vgg _ feature data # RPN layers rpn _ 
conv = mx . symbol . Convolution data = conv 
_ feat kernel = 3 3 pad = 1 1 
num _ filter = 512 name = rpn _ conv 
_ 3x3 rpn _ relu = mx . symbol . 
Activation data = rpn _ conv act _ type = 
relu name = rpn _ relu # rpn classification obj 
/ not _ obj # batch 2 * 每个 位置 
anchors 数目 中心点 行数 中心点 列数 rpn _ cls _ 
score = mx . symbol . Convolution data = rpn 
_ relu kernel = 1 1 pad = 0 0 
num _ filter = 2 * num _ anchors name 
= rpn _ cls _ score # batch 2 中心点 
行数 * 每个 位置 anchors 数目 中心点 列数 rpn _ 
cls _ score _ reshape = mx . symbol . 
Reshape data = rpn _ cls _ score shape = 
0 2 1 0 name = rpn _ cls _ 
score _ reshape # 获取 交叉 熵 回传 梯度 对于 
出现 了 1 的 图片 梯度 直接 全部 置 为 
0 # 在 Faster RCNN 算法 中 anchor 一 共有 
3种 标签 1 0 1 分别 表示 无效 背景 目标 
rpn _ cls _ prob = mx . symbol . 
SoftmaxOutput data = rpn _ cls _ score _ reshape 
label = rpn _ label multi _ output = True 
normalization = valid use _ ignore = True ignore _ 
label = 1 name = rpn _ cls _ prob 
# 切换 为 含 / 不含 obj 两 通道 对 
每一个 anchor 是否 有 obj 进行 softmax 处理 # batch 
2 中心点 行数 * 每个 位置 anchors 数目 中心点 列数 
rpn _ cls _ act = mx . symbol . 
softmax data = rpn _ cls _ score _ reshape 
axis = 1 name = rpn _ cls _ act 
# batch 2 * 每个 位置 anchors 数目 中心点 行数 
中心点 列数 # Reshpe 方法 不同 于 reshape 方法 详情 
见此 方法 文档 rpn _ cls _ act _ reshape 
= mx . symbol . Reshape data = rpn _ 
cls _ act shape = 0 2 * num _ 
anchors 1 0 name = rpn _ cls _ act 
_ reshape # rpn bbox regression # batch 4 * 
每个 位置 anchors 数目 中心点 行数 中心点 列数 rpn _ 
bbox _ pred = mx . symbol . Convolution data 
= rpn _ relu kernel = 1 1 pad = 
0 0 num _ filter = 4 * num _ 
anchors name = rpn _ bbox _ pred # rpn 
_ bbox _ weight anchor 的 mask 如果 某个 anchor 
的 标签 是 1 则 mask 对应 值 为 1 
anchor 的 标签 是 0 或 1 则 mask 对应 
值 为 0 # rpn _ bbox _ target 根据 
初始 anchor 和 ground truth 计算 出来 的 offset rpn 
_ bbox _ loss _ = rpn _ bbox _ 
weight * mx . symbol . smooth _ l1 name 
= rpn _ bbox _ loss _ scalar = 3.0 
data = rpn _ bbox _ pred rpn _ bbox 
_ target # 获取 回归 梯度 # grad _ scale 
表示 回归 损失 占 RPN 网络 总 损失 比 该 
参数 相差 几个 量级 对 结果 影响 也 不大 rpn 
_ bbox _ loss = mx . sym . MakeLoss 
name = rpn _ bbox _ loss data = rpn 
_ bbox _ loss _ grad _ scale = 1.0 
/ rpn _ batch _ rois # rpn proposal # 
获取 指定 数目 的 候选框 proposal # 2000个 候选框 5个 
属性 # 5个 属性 batch 中 图片 index 4个 坐标 
rois = mx . symbol . contrib . MultiProposal cls 
_ prob = rpn _ cls _ act _ reshape 
# cls _ prob batch 2 * 每个 位置 anchors 
数目 中心点 行数 中心点 列数 bbox _ pred = rpn 
_ bbox _ pred # bbox _ pred batch 4 
* 每个 位置 anchors 数目 中心点 行数 中心点 列数 im 
_ info = im _ info # mx . symbol 
. Variable name = im _ info feature _ stride 
= rpn _ feature _ stride # 16 scales = 
anchor _ scales ratios = anchor _ ratios # 0.5 
1 2 rpn _ pre _ nms _ top _ 
n = rpn _ pre _ topk # 12000 对 
RPN 网络 输出 的 anchor 进行 NMS 操作 之前 的 
proposal 最大 数量 # 输入 proposal 的 数量 大于 12000时 
对 这些 proposal 的 预测 为 foreground 的 概率 也叫 
score # 换 句话 说 就是 预测 标签 为 1 
的 概率 从高 到 低 排序 然后 选择 前面 12000个 
rpn _ post _ nms _ top _ n = 
rpn _ post _ topk # 2000 经过 NMS 过滤 
之后 得到 的 proposal 数量 threshold = rpn _ nms 
_ thresh # 0.7 是 NMS 算法 阈值 rpn _ 
min _ size = rpn _ min _ size # 
16 name = rois # rcnn roi proposal target # 
根据 上 一步 获取 的 proposal 即 rois 和 真实 
框 gt _ boxes 进行 筛选 # 获取 128个 proposal 
对应 的 128个 label 对应 的 128个 真实 坐标 128个 
坐标 掩码 构建 损失 函数 使用 group = mx . 
symbol . Custom rois = rois # 2000 * 5 
的 roi 信息 gt _ boxes = gt _ boxes 
# n * 5 的 ground truth 信息 n 表示 
object 数量 op _ type = proposal _ target num 
_ classes = num _ classes # num _ classes 
是 实际 要 分类 的 类别 数 加上 背景 类 
batch _ images = rcnn _ batch _ size # 
1 batch _ rois = rcnn _ batch _ rois 
# 128 fg _ fraction = rcnn _ fg _ 
fraction # 0.25 正 样本 所占 的 比例 fg _ 
overlap = rcnn _ fg _ overlap # 0.5 box 
_ stds = rcnn _ bbox _ stds # 0.1 
0.1 0.2 0.2 rois = group 0 # rois 128 
5 label = group 1 # roi 对应 的 标签 
128 bbox _ target = group 2 # 坐标 回归 
的 目标 维度 是 128 84 其中 84 来自 20 
+ 1 * 4 bbox _ weight = group 3 
# 坐标 回归 时候 的 权重 维度 是 128 84 
对于 foreground 都是 1 对于 backgroud 都是 0 # rcnn 
roi pool # 128个 候选框 512个 通道 7行 7列 roi 
_ pool = mx . symbol . ROIPooling name = 
roi _ pool data = conv _ feat rois = 
rois pooled _ size = rcnn _ pooled _ size 
# 7 7 输出 大小 spatial _ scale = 1.0 
/ rcnn _ feature _ stride # 16 feat / 
raw _ img # rcnn top feature # 128 4096 
对 每个 roi 提取 最终 的 vgg 特征 top _ 
feat = get _ vgg _ top _ feature roi 
_ pool # rcnn classification # 对 每个 roi 进行 
分类 并 构建 损失 函数 cls _ score = mx 
. symbol . FullyConnected name = cls _ score data 
= top _ feat num _ hidden = num _ 
classes cls _ prob = mx . symbol . SoftmaxOutput 
name = cls _ prob data = cls _ score 
label = label normalization = batch # rcnn bbox regression 
# 对 每个 roi 进行 回归 并 构建 损失 函数 
bbox _ pred = mx . symbol . FullyConnected name 
= bbox _ pred data = top _ feat num 
_ hidden = num _ classes * 4 bbox _ 
loss _ = bbox _ weight * mx . symbol 
. smooth _ l1 name = bbox _ loss _ 
scalar = 1.0 data = bbox _ pred bbox _ 
target bbox _ loss = mx . sym . MakeLoss 
name = bbox _ loss data = bbox _ loss 
_ grad _ scale = 1.0 / rcnn _ batch 
_ rois # reshape output # 1 128 1 128 
21 1 128 84 label = mx . symbol . 
Reshape data = label shape = rcnn _ batch _ 
size 1 name = label _ reshape cls _ prob 
= mx . symbol . Reshape data = cls _ 
prob shape = rcnn _ batch _ size 1 num 
_ classes name = cls _ prob _ reshape bbox 
_ loss = mx . symbol . Reshape data = 
bbox _ loss shape = rcnn _ batch _ size 
1 4 * num _ classes name = bbox _ 
loss _ reshape print cls _ score . infer _ 
shape * * { data 1 3 1000 600 gt 
_ boxes 5 5 } 1 # group output # 
mx . symbol . BlockGrad 会 阻止 经由 节点 label 
回传 的 梯度 group = mx . symbol . Group 
rpn _ cls _ prob # anchors 分类 损失 batch 
2 中心点 行数 * 每个 位置 anchors 数目 中心点 列数 
rpn _ bbox _ loss # anchors 回归 损失 batch 
4 * 每个 位置 anchors 数目 中心点 行数 中心点 列数 
cls _ prob # 候选框 分类 损失 1 128 21 
bbox _ loss # 候选框 回归 损失 1 128 84 
mx . symbol . BlockGrad label # 候选框 标签 1 
128 return group if _ _ name _ _ = 
= _ _ main _ _ net = get _ 
vgg _ train anchor _ scales = 8 16 32 
anchor _ ratios = 0.5 1 2 rpn _ feature 
_ stride = 16 rpn _ pre _ topk = 
12000 rpn _ post _ topk = 2000 rpn _ 
nms _ thresh = 0.7 rpn _ min _ size 
= 16 rpn _ batch _ rois = 256 num 
_ classes = 21 rcnn _ feature _ stride = 
16 # 4个 pooling 层 rcnn _ pooled _ size 
= 7 7 rcnn _ batch _ size = 1 
rcnn _ batch _ rois = 128 rcnn _ fg 
_ fraction = 0.25 rcnn _ fg _ overlap = 
0.5 rcnn _ bbox _ stds = 0.1 0.1 0.2 
0.2 