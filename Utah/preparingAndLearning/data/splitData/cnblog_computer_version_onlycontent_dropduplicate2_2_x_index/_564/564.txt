横看成岭侧成峰，计算视觉大不同。观看的角度不同，成像自然不同，这对计算机视觉来说，是个大麻烦。但计算机视觉应用如此广泛，却又有不得不研究的理由。指纹机大家都用过吧，这不过是冰山之一角。产品检测，机器人，医学成像等等，都有计算机视觉的身影。学习计算机视觉，OpenCV 是个不错的选择。下载安装到指定位置后，会发现有 3.5G 之多。初步看看，重复太多，32位，64位各有一套，而 vc10，vc11，vc12 再次重复。只需把要用到的 build -> x86 -> vc12 调试版提取出来即可。我是编译源代码，将生成的 bin -> *.dll， lib -> *.lib 和原来 OpenCV 安装目录 build -> include 提取出来，放入新建文件夹中，约 60MB。平时学习，使用这个即可。1.配置系统环境变量，将 bin 加入 Path 变量，注销一下使其有效。2.启动 VS2013，新建 Win32 Console 空项目。在项目 属性 -> VC++ 目录 -> 包含目录 添加 include，库目录 添加 lib。3.新建头文件 x01CV.h，内容如下：#pragma once #pragma comment(lib,"opencv_calib3d249d.lib") #pragma comment(lib,"opencv_contrib249d.lib") #pragma comment(lib,"opencv_core249d.lib") #pragma comment(lib,"opencv_features2d249d.lib") #pragma comment(lib,"opencv_flann249d.lib") #pragma comment(lib,"opencv_gpu249d.lib") #pragma comment(lib,"opencv_highgui249d.lib") #pragma comment(lib,"opencv_imgproc249d.lib") #pragma comment(lib,"opencv_legacy249d.lib") #pragma comment(lib,"opencv_ml249d.lib") #pragma comment(lib,"opencv_nonfree249d.lib") #pragma comment(lib,"opencv_objdetect249d.lib") #pragma comment(lib,"opencv_ocl249d.lib") #pragma comment(lib,"opencv_photo249d.lib") #pragma comment(lib,"opencv_stitching249d.lib") #pragma comment(lib,"opencv_superres249d.lib") #pragma comment(lib,"opencv_ts249d.lib") #pragma comment(lib,"opencv_video249d.lib") #pragma comment(lib,"opencv_videostab249d.lib") #include <opencv2/core/core.hpp> #include <opencv2/highgui/highgui.hpp> #include <opencv2/imgproc/imgproc.hpp> #include <opencv/cv.h>x01CV.h4.新建源文件 Main.cpp，内容如下：#include <iostream> #include "x01CV.h" using namespace cv; using namespace std; namespace { const string AppTitle = "x01 Lab - OpenCV Demo"; int g_filterValue = 3; Mat g_srcImage, g_destImage; void OnBoxFilter(int, void*) { boxFilter(g_srcImage, g_destImage, -1, Size(g_filterValue + 1, g_filterValue + 1)); imshow(AppTitle, g_destImage); } void OnBlur(int, void*) { blur(g_srcImage, g_destImage, Size(g_filterValue + 1, g_filterValue + 1), Point(-1, -1)); imshow(AppTitle, g_destImage); } void OnGaussianBlur(int, void*) { int v = g_filterValue * 2 + 1; GaussianBlur(g_srcImage, g_destImage, Size(v, v), 0, 0); imshow(AppTitle, g_destImage); } void OnMediaBlur(int, void*) { medianBlur(g_srcImage, g_destImage, g_filterValue * 2 + 1); imshow(AppTitle, g_destImage); } void OnBilateralFilter(int, void*) { int v = g_filterValue + 7; bilateralFilter(g_srcImage, g_destImage, v, v * 2, v / 2); imshow(AppTitle, g_destImage); } } int main() { g_srcImage = imread("1.jpg"); // For erode and dilate demo /*Mat kernel = getStructuringElement(MORPH_RECT, Size(15, 15)); Mat dest; erode(g_srcImage, dest, kernel); namedWindow(AppTitle); imshow(AppTitle, dest);*/ g_destImage = g_srcImage.clone(); while (true) { char c = char(waitKey()); if (c == 'q') break; namedWindow(AppTitle); if (c == 'a' || c == 'A') createTrackbar("Kernel Value", AppTitle, &g_filterValue, 40, OnBlur); else if (c == 'b' || c == 'B') createTrackbar("Kernel Value", AppTitle, &g_filterValue, 40, OnBoxFilter); else if (c == 'c' || c == 'C') createTrackbar("Kernel Value", AppTitle, &g_filterValue, 40, OnGaussianBlur); else if (c == 'd' || c == 'D') createTrackbar("Kernel Value", AppTitle, &g_filterValue, 40, OnMediaBlur); else if (c == 'e' || c == 'E') createTrackbar("Kernel Value", AppTitle, &g_filterValue, 40, OnBilateralFilter); imshow(AppTitle, g_destImage); } return 0; }Main.cpp5.F5 运行无误，按 a 或 b, c, d, e 等，可进行模糊处理。效果图如下：