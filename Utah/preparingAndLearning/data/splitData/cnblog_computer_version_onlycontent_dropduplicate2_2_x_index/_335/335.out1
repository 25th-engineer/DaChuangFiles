作为 研究 计算机 视觉 的 一员 大家 肯定 对 Intel 
大名鼎鼎 的 openCV 系列 计算机 视觉 库 耳熟能详 对于 很多 
人 来说 openCV 甚至 已经 成为 其 项目 研究 不可缺少 
的 一部分 但是 由于 项目 兼容性 的 要求 openCV 的 
GUI 功能 不够 丰富 等 原因 很多 人 希望 能够 
在 C # 环境 中 使用 openCV 在 目前 针对 
c # 的 计算机 视觉 库 主要 有 两种 EmguCV 
和 openCVSharp Emgucv 的 优势 在于 不 仅仅 提供 了 
计算机 视觉 函数 接口 并且 提供 了 一系列 界面 控件 
接口 但 目前 只 支持 openCV1 的 书写 风格 openCVSharp 
提供 了 openCV 和 openCV2 两种 书写 风格 并且 和 
openCV 的 imagewatch 一样 提供 了 一种 简单 有效 的 
调试 工具 Debugger Visualizer 具体 使用 可 见 一下 网址 
https / / github . com / shimat / opencvsharp 
/ wiki / Debugger Visualizer 在 这里 我 的 推荐 
是 使用 openCVSharp 在 这里 主要 考虑 的 是 协议 
方面 的 问题 opencv 的 协议 是 BSD 协议 这是 
对 开发 者 来说 是 相当 友好 的 协议 网上 
常见 的 免费版 EmguCV 则是 GUN 协议 任何 发表 都 
需要 至少 公布 你 的 源代码 openCVSharp 则是 相对 温和 
多 的 LGUN 协议 这个 协议 和 QT 是 差不多 
相同 的 甚至 当 你 不 使用 自带 的 DLL 
时 和 openCV 一样 是 BSD 协议 如果 你 对 
协议 感 兴趣 的话 可以 自行 百度 具体 配置 方法 
可以 自行 百度 简单 来说 就是 添加 相应 的 com 
组件 注意 有 一个 com 组件 右键 添加 只能 手动 
放在 相应 的 exe 目 录下 然后 添加 相应 的 
命名 空间 下面 分别 是 c 和c+/nr + 风格 的 
代码 获取 相应 位置 像素 值 速度 由 慢 向快/nr 
排列 / / c 风格 代码 / / 方案 一 
IplImage img = new IplImage baz . png LoadMode . 
Color for int y = 0 y img . Height 
y + + { for int x = 0 x 
img . Width x + + { CvColor c = 
img y x img y x = new CvColor { 
B = byte Math . Round c . B * 
0.7 + 10 G = byte Math . Round c 
. G * 1.0 R = byte Math . Round 
c . R * 0.0 } } } / / 
方案 二 IplImage img = new IplImage baz . png 
LoadMode . Color unsafe { byte * ptr = byte 
* img . ImageData for int y = 0 y 
img . Height y + + { for int x 
= 0 x img . Width x + + { 
int offset = img . WidthStep * y + x 
* 3 byte b = ptr offset + 0 / 
/ Bbyte g = ptr offset + 1 / / 
Gbyte r = ptr offset + 2 / / Rptr 
offset + 0 = r ptr offset + 1 = 
g ptr offset + 2 = b } } } 
方案 三 IplImage img = new IplImage baz . png 
LoadMode . Color IntPtr ptr = img . ImageData for 
int x = 0 x image . Width x + 
+ { for int y = 0 y image . 
Height y + + { int offset = image . 
WidthStep * y + x * 3 byte b = 
Marshal . ReadByte ptr offset + 0 / / Bbyte 
g = Marshal . ReadByte ptr offset + 1 / 
/ Gbyte r = Marshal . ReadByte ptr offset + 
2 / / RMarshal . WriteByte ptr offset r Marshal 
. WriteByte ptr offset g Marshal . WriteByte ptr offset 
b } } / / c + + 风格 代码 
/ / 方案 一 Mat mat = new Mat lenna 
. png LoadMode . Color for int y = 0 
y mat . Height y + + { for int 
x = 0 x mat . Width x + + 
{ Vec3b color = mat . Get Vec3b y x 
byte temp = color . Item0 color . Item0 = 
color . Item2 / / B Rcolor . Item2 = 
temp / / R Bmat . Set Vec3b y x 
color } } GenericIndexer reasonably fast / / 方案 二 
Mat mat = new Mat lenna . png LoadMode . 
Color var indexer = mat . G e t G 
e n e r i c I n d e 
x e r Vec3b for int y = 0 y 
mat . Height y + + { for int x 
= 0 x mat . Width x + + { 
Vec3b color = indexer y x byte temp = color 
. Item0 color . Item0 = color . Item2 / 
/ B Rcolor . Item2 = temp / / R 
Bindexer y x = color } } 方案 三 Mat 
mat = new Mat lenna . png LoadMode . Color 
MatOfByte3 mat3 = new MatOfByte3 mat / / cv Mat 
_ cv Vec3b var indexer = mat3 . GetIndexer for 
int y = 0 y mat . Height y + 
+ { for int x = 0 x mat . 
Width x + + { Vec3b color = indexer y 
x byte temp = color . Item0 color . Item0 
= color . Item2 / / B Rcolor . Item2 
= temp / / R Bindexer y x = color 
} } 最后 openCVSharp 下载 地址 为 https / / 
github . com / shimat / opencvsharp / releases 如果 
无法 下载 私信 我 我 可以 提供 2 . 4.10 
3.1 和 3.2 三种 版本 作者 小立 1991 来源 CSDN 
原文 https / / blog . csdn . net / 
qq _ 21400315 / article / details / 52451941 版权 
声明 本文 为 博主 原创 文章 转载 请 附上 博文 
链接 作为 研究 计算机 视觉 的 一员 大家 肯定 对 Intel 
大名鼎鼎 的 openCV 系列 计算机 视觉 库 耳熟能详 对于 很多 
人 来说 openCV 甚至 已经 成为 其 项目 研究 不可缺少 
的 一部分 但是 由于 项目 兼容性 的 要求 openCV 的 
GUI 功能 不够 丰富 等 原因 很多 人 希望 能够 
在 C # 环境 中 使用 openCV 在 目前 针对 
c # 的 计算机 视觉 库 主要 有 两种 EmguCV 
和 openCVSharp Emgucv 的 优势 在于 不 仅仅 提供 了 
计算机 视觉 函数 接口 并且 提供 了 一系列 界面 控件 
接口 但 目前 只 支持 openCV1 的 书写 风格 openCVSharp 
提供 了 openCV 和 openCV2 两种 书写 风格 并且 和 
openCV 的 imagewatch 一样 提供 了 一种 简单 有效 的 
调试 工具 Debugger Visualizer 具体 使用 可 见 一下 网址 
https / / github . com / shimat / opencvsharp 
/ wiki / Debugger Visualizer 在 这里 我 的 推荐 
是 使用 openCVSharp 在 这里 主要 考虑 的 是 协议 
方面 的 问题 opencv 的 协议 是 BSD 协议 这是 
对 开发 者 来说 是 相当 友好 的 协议 网上 
常见 的 免费版 EmguCV 则是 GUN 协议 任何 发表 都 
需要 至少 公布 你 的 源代码 openCVSharp 则是 相对 温和 
多 的 LGUN 协议 这个 协议 和 QT 是 差不多 
相同 的 甚至 当 你 不 使用 自带 的 DLL 
时 和 openCV 一样 是 BSD 协议 如果 你 对 
协议 感 兴趣 的话 可以 自行 百度 具体 配置 方法 
可以 自行 百度 简单 来说 就是 添加 相应 的 com 
组件 注意 有 一个 com 组件 右键 添加 只能 手动 
放在 相应 的 exe 目 录下 然后 添加 相应 的 
命名 空间 下面 分别 是 c 和c+/nr + 风格 的 
代码 获取 相应 位置 像素 值 速度 由 慢 向快/nr 
排列 / / c 风格 代码 / / 方案 一 
IplImage img = new IplImage baz . png LoadMode . 
Color for int y = 0 y img . Height 
y + + { for int x = 0 x 
img . Width x + + { CvColor c = 
img y x img y x = new CvColor { 
B = byte Math . Round c . B * 
0.7 + 10 G = byte Math . Round c 
. G * 1.0 R = byte Math . Round 
c . R * 0.0 } } } / / 
方案 二 IplImage img = new IplImage baz . png 
LoadMode . Color unsafe { byte * ptr = byte 
* img . ImageData for int y = 0 y 
img . Height y + + { for int x 
= 0 x img . Width x + + { 
int offset = img . WidthStep * y + x 
* 3 byte b = ptr offset + 0 / 
/ Bbyte g = ptr offset + 1 / / 
Gbyte r = ptr offset + 2 / / Rptr 
offset + 0 = r ptr offset + 1 = 
g ptr offset + 2 = b } } } 
方案 三 IplImage img = new IplImage baz . png 
LoadMode . Color IntPtr ptr = img . ImageData for 
int x = 0 x image . Width x + 
+ { for int y = 0 y image . 
Height y + + { int offset = image . 
WidthStep * y + x * 3 byte b = 
Marshal . ReadByte ptr offset + 0 / / Bbyte 
g = Marshal . ReadByte ptr offset + 1 / 
/ Gbyte r = Marshal . ReadByte ptr offset + 
2 / / RMarshal . WriteByte ptr offset r Marshal 
. WriteByte ptr offset g Marshal . WriteByte ptr offset 
b } } / / c + + 风格 代码 
/ / 方案 一 Mat mat = new Mat lenna 
. png LoadMode . Color for int y = 0 
y mat . Height y + + { for int 
x = 0 x mat . Width x + + 
{ Vec3b color = mat . Get Vec3b y x 
byte temp = color . Item0 color . Item0 = 
color . Item2 / / B Rcolor . Item2 = 
temp / / R Bmat . Set Vec3b y x 
color } } GenericIndexer reasonably fast / / 方案 二 
Mat mat = new Mat lenna . png LoadMode . 
Color var indexer = mat . G e t G 
e n e r i c I n d e 
x e r Vec3b for int y = 0 y 
mat . Height y + + { for int x 
= 0 x mat . Width x + + { 
Vec3b color = indexer y x byte temp = color 
. Item0 color . Item0 = color . Item2 / 
/ B Rcolor . Item2 = temp / / R 
Bindexer y x = color } } 方案 三 Mat 
mat = new Mat lenna . png LoadMode . Color 
MatOfByte3 mat3 = new MatOfByte3 mat / / cv Mat 
_ cv Vec3b var indexer = mat3 . GetIndexer for 
int y = 0 y mat . Height y + 
+ { for int x = 0 x mat . 
Width x + + { Vec3b color = indexer y 
x byte temp = color . Item0 color . Item0 
= color . Item2 / / B Rcolor . Item2 
= temp / / R Bindexer y x = color 
} } 最后 openCVSharp 下载 地址 为 https / / 
github . com / shimat / opencvsharp / releases 如果 
无法 下载 私信 我 我 可以 提供 2 . 4.10 
3.1 和 3.2 三种 版本 作者 小立 1991 来源 CSDN 
原文 https / / blog . csdn . net / 
qq _ 21400315 / article / details / 52451941 版权 
声明 本文 为 博主 原创 文章 转载 请 附上 博文 
链接 作为 研究 计算机 视觉 的 一员 大家 肯定 对 Intel 
大名鼎鼎 的 openCV 系列 计算机 视觉 库 耳熟能详 对于 很多 
人 来说 openCV 甚至 已经 成为 其 项目 研究 不可缺少 
的 一部分 但是 由于 项目 兼容性 的 要求 openCV 的 
GUI 功能 不够 丰富 等 原因 很多 人 希望 能够 
在 C # 环境 中 使用 openCV 在 目前 针对 
c # 的 计算机 视觉 库 主要 有 两种 EmguCV 
和 openCVSharp Emgucv 的 优势 在于 不 仅仅 提供 了 
计算机 视觉 函数 接口 并且 提供 了 一系列 界面 控件 
接口 但 目前 只 支持 openCV1 的 书写 风格 openCVSharp 
提供 了 openCV 和 openCV2 两种 书写 风格 并且 和 
openCV 的 imagewatch 一样 提供 了 一种 简单 有效 的 
调试 工具 Debugger Visualizer 具体 使用 可 见 一下 网址 
https / / github . com / shimat / opencvsharp 
/ wiki / Debugger Visualizer 在 这里 我 的 推荐 
是 使用 openCVSharp 在 这里 主要 考虑 的 是 协议 
方面 的 问题 opencv 的 协议 是 BSD 协议 这是 
对 开发 者 来说 是 相当 友好 的 协议 网上 
常见 的 免费版 EmguCV 则是 GUN 协议 任何 发表 都 
需要 至少 公布 你 的 源代码 openCVSharp 则是 相对 温和 
多 的 LGUN 协议 这个 协议 和 QT 是 差不多 
相同 的 甚至 当 你 不 使用 自带 的 DLL 
时 和 openCV 一样 是 BSD 协议 如果 你 对 
协议 感 兴趣 的话 可以 自行 百度 具体 配置 方法 
可以 自行 百度 简单 来说 就是 添加 相应 的 com 
组件 注意 有 一个 com 组件 右键 添加 只能 手动 
放在 相应 的 exe 目 录下 然后 添加 相应 的 
命名 空间 下面 分别 是 c 和c+/nr + 风格 的 
代码 获取 相应 位置 像素 值 速度 由 慢 向快/nr 
排列 / / c 风格 代码 / / 方案 一 
IplImage img = new IplImage baz . png LoadMode . 
Color for int y = 0 y img . Height 
y + + { for int x = 0 x 
img . Width x + + { CvColor c = 
img y x img y x = new CvColor { 
B = byte Math . Round c . B * 
0.7 + 10 G = byte Math . Round c 
. G * 1.0 R = byte Math . Round 
c . R * 0.0 } } } / / 
方案 二 IplImage img = new IplImage baz . png 
LoadMode . Color unsafe { byte * ptr = byte 
* img . ImageData for int y = 0 y 
img . Height y + + { for int x 
= 0 x img . Width x + + { 
int offset = img . WidthStep * y + x 
* 3 byte b = ptr offset + 0 / 
/ Bbyte g = ptr offset + 1 / / 
Gbyte r = ptr offset + 2 / / Rptr 
offset + 0 = r ptr offset + 1 = 
g ptr offset + 2 = b } } } 
方案 三 IplImage img = new IplImage baz . png 
LoadMode . Color IntPtr ptr = img . ImageData for 
int x = 0 x image . Width x + 
+ { for int y = 0 y image . 
Height y + + { int offset = image . 
WidthStep * y + x * 3 byte b = 
Marshal . ReadByte ptr offset + 0 / / Bbyte 
g = Marshal . ReadByte ptr offset + 1 / 
/ Gbyte r = Marshal . ReadByte ptr offset + 
2 / / RMarshal . WriteByte ptr offset r Marshal 
. WriteByte ptr offset g Marshal . WriteByte ptr offset 
b } } / / c + + 风格 代码 
/ / 方案 一 Mat mat = new Mat lenna 
. png LoadMode . Color for int y = 0 
y mat . Height y + + { for int 
x = 0 x mat . Width x + + 
{ Vec3b color = mat . Get Vec3b y x 
byte temp = color . Item0 color . Item0 = 
color . Item2 / / B Rcolor . Item2 = 
temp / / R Bmat . Set Vec3b y x 
color } } GenericIndexer reasonably fast / / 方案 二 
Mat mat = new Mat lenna . png LoadMode . 
Color var indexer = mat . G e t G 
e n e r i c I n d e 
x e r Vec3b for int y = 0 y 
mat . Height y + + { for int x 
= 0 x mat . Width x + + { 
Vec3b color = indexer y x byte temp = color 
. Item0 color . Item0 = color . Item2 / 
/ B Rcolor . Item2 = temp / / R 
Bindexer y x = color } } 方案 三 Mat 
mat = new Mat lenna . png LoadMode . Color 
MatOfByte3 mat3 = new MatOfByte3 mat / / cv Mat 
_ cv Vec3b var indexer = mat3 . GetIndexer for 
int y = 0 y mat . Height y + 
+ { for int x = 0 x mat . 
Width x + + { Vec3b color = indexer y 
x byte temp = color . Item0 color . Item0 
= color . Item2 / / B Rcolor . Item2 
= temp / / R Bindexer y x = color 
} } 最后 openCVSharp 下载 地址 为 https / / 
github . com / shimat / opencvsharp / releases 如果 
无法 下载 私信 我 我 可以 提供 2 . 4.10 
3.1 和 3.2 三种 版本 作者 小立 1991 来源 CSDN 
原文 https / / blog . csdn . net / 
qq _ 21400315 / article / details / 52451941 版权 
声明 本文 为 博主 原创 文章 转载 请 附上 博文 
链接 