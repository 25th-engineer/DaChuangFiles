作为研究计算机视觉的一员，大家肯定对Intel大名鼎鼎的openCV系列计算机视觉库耳熟能详，对于很多人来说openCV甚至已经成为其项目研究不可缺少的一部分。但是，由于项目兼容性的要求、openCV的GUI功能不够丰富等原因很多人希望能够在C#环境中使用openCV。在目前针对c#的计算机视觉库主要有两种，EmguCV和openCVSharp。Emgucv的优势在于不仅仅提供了计算机视觉函数接口并且提供了一系列界面控件接口，但目前只支持openCV1的书写风格。openCVSharp提供了openCV和openCV2两种书写风格，并且和openCV的imagewatch一样，提供了一种简单有效的调试工具Debugger Visualizer，具体使用可见一下网址https://github.com/shimat/opencvsharp/wiki/Debugger-Visualizer。在这里我的推荐是使用openCVSharp,在这里主要考虑的是协议方面的问题。opencv的协议是BSD协议，这是对开发者来说是相当友好的协议；网上常见的免费版EmguCV则是GUN协议，任何发表都需要至少公布你的源代码；openCVSharp则是相对温和多的LGUN协议，这个协议和QT是差不多相同的，甚至当你不使用自带的DLL时，和openCV一样是BSD协议（如果你对协议感兴趣的话可以自行百度）。具体配置方法可以自行百度，简单来说就是添加相应的com组件（注意有一个com组件右键添加，只能手动放在相应的exe目录下），然后添加相应的命名空间。下面分别是c和c++风格的代码，获取相应位置像素值，速度由慢向快排列。//c风格代码//方案一IplImage img = new IplImage("baz.png", LoadMode.Color);for (int y = 0; y < img.Height; y++) {for (int x = 0; x < img.Width; x++) {CvColor c = img[y, x];img[y, x] = new CvColor() {B = (byte)Math.Round(c.B * 0.7 + 10),G = (byte)Math.Round(c.G * 1.0),R = (byte)Math.Round(c.R * 0.0),};}}//方案二IplImage img = new IplImage("baz.png", LoadMode.Color);unsafe {byte* ptr = (byte*)img.ImageData;for (int y = 0; y < img.Height; y++) {for (int x = 0; x < img.Width; x++) {int offset = (img.WidthStep * y) + (x * 3);byte b = ptr[offset + 0]; // Bbyte g = ptr[offset + 1]; // Gbyte r = ptr[offset + 2]; // Rptr[offset + 0] = r;ptr[offset + 1] = g;ptr[offset + 2] = b;}}}方案三IplImage img = new IplImage("baz.png", LoadMode.Color);IntPtr ptr = img.ImageData;for (int x = 0; x < image.Width; x++) {for (int y = 0; y < image.Height; y++) {int offset = (image.WidthStep * y) + (x * 3);byte b = Marshal.ReadByte(ptr, offset + 0); // Bbyte g = Marshal.ReadByte(ptr, offset + 1); // Gbyte r = Marshal.ReadByte(ptr, offset + 2); // RMarshal.WriteByte(ptr, offset, r);Marshal.WriteByte(ptr, offset, g);Marshal.WriteByte(ptr, offset, b);}}//c++风格代码//方案一Mat mat = new Mat("lenna.png", LoadMode.Color);for (int y = 0; y < mat.Height; y++){for (int x = 0; x < mat.Width; x++){Vec3b color = mat.Get<Vec3b>(y, x);byte temp = color.Item0;color.Item0 = color.Item2; // B <- Rcolor.Item2 = temp; // R <- Bmat.Set<Vec3b>(y, x, color);}}GenericIndexer (reasonably fast)//方案二Mat mat = new Mat("lenna.png", LoadMode.Color);var indexer = mat.GetGenericIndexer<Vec3b>();for (int y = 0; y < mat.Height; y++){for (int x = 0; x < mat.Width; x++){Vec3b color = indexer[y, x];byte temp = color.Item0;color.Item0 = color.Item2; // B <- Rcolor.Item2 = temp; // R <- Bindexer[y, x] = color;}}方案三Mat mat = new Mat("lenna.png", LoadMode.Color);MatOfByte3 mat3 = new MatOfByte3(mat); // cv::Mat_<cv::Vec3b>var indexer = mat3.GetIndexer();for (int y = 0; y < mat.Height; y++){for (int x = 0; x < mat.Width; x++){Vec3b color = indexer[y, x];byte temp = color.Item0;color.Item0 = color.Item2; // B <- Rcolor.Item2 = temp; // R <- Bindexer[y, x] = color;}}最后，openCVSharp下载地址为https://github.com/shimat/opencvsharp/releases。如果，无法下载私信我，我可以提供2.4.10、3.1和3.2三种版本。---------------------作者：小立1991来源：CSDN原文：https://blog.csdn.net/qq_21400315/article/details/52451941版权声明：本文为博主原创文章，转载请附上博文链接！