使用OpenCV3处理图像下面要介绍的内容都与图像处理有关，这时需要修改图像，比如要使用具有艺术性的滤镜、外插（extrapolate）某些部分、分割、粘贴或其他需要的操作。不同色彩空间的转换OpenCV中有数百种关于在不同色彩空间之间转换的方法。当前，在计算机视觉中有三种常用的色彩空间：灰度、BGR以及HSV(Hue,Saturation,Value)1.灰度色彩空间是通过去除彩色信息来将其转换成灰阶，灰度色彩空间对中间处理特别有效，比如人脸检测。2.BGR,即蓝-绿-红色彩空间，每一个像素点都由一个三元数组来表示，分别代表蓝、绿、红三种颜色。网页开发者可能熟悉另一个与之相似的颜色空间：RGB，它们只是在颜色的顺序上不同。3.HSV,H(Hue)是色调，S(Saturation)是饱和度,V(Value)表示黑暗的程度（或光谱另一端的明亮程度）傅里叶变换在OpenCV中，对图像和视频的大多数处理都或多或少会涉及傅里叶变换的概念。傅里叶观察到所有的波形都可以由一系列简单且频率不同的正弦曲线叠加得到。也就是说，人们所看到的波形都是由其他波形叠加得到的。这个概念也对操作图像非常有帮助，因为这样我们可以区分图像里哪些区域的信号（比如图像像素）变化特别强，哪些区域的信号变化不那么强，从而可以任意地标记噪声区域、感兴趣区域、前景和背景等。原始图像由许多频率组成，人们能够分离这些频率来理解图像和提取感兴趣地数据注意：在OpenCV环境中，有许多实现了的算法让我们能够处理图像、理解图像中所包含的意义。这些算法在Numpy中也有实现，而且更容易使用。Numpy中有快速傅里叶变换（FFT）包，它包含了fft2()函数，该函数可以计算一幅图像的离散傅里叶变换（DFT）下面通过傅里叶变换来介绍图像的幅度谱。图像的幅度谱是另一种图像，幅度谱图像呈现了原始图像在变化方面的一种表示：把一幅图像中最明亮的像素放在图像中央，然后逐渐变暗，在边缘上的像素最暗。这样可以发现图像中有多少亮的像素和暗的像素，以及它们分布的百分比。傅里叶变换的概念是许多常见的图像处理操作的基础，比如边缘检测或线段和形状检测。1.高通滤波器高通滤波器（HPF）是检测图像的某个区域，然后根据像素与周围像素的亮度差值来提升（boost）该像素的亮度的滤波器。核是指一组权重的集合，他会应用在源图像的一个区域，并由此生成目标图像的一个像素。比如，大小为7的核意味着每49（7×7）个源图像的像素会产生目标图像的一个像素。可把核看作一块覆盖在源图像上可移动的毛玻璃片，玻璃片覆盖区域的光线会按某种方式进行扩散混合后透过去。在计算完中央像素与周围近邻像素的亮度差值之和以后，如果亮度变化很大，中央像素的亮度会增加（反之则不会）。换句话说，如果一个像素比它周围的像素更突出，就会提升它的亮度这在边缘检测上尤其有效，它会采用一种称为高频提升滤波器的高通滤波器。高通和低通滤波器都有一个称为半径的属性，它决定了多大面积的邻近像素参与滤波运算2.低通滤波器低通滤波器（LPF）则是在像素与周围像素的亮度差值小于一个特定值时，平滑该像素的亮度。它主要用于去噪和模糊化，比如说，高斯模糊是最常用的模糊滤波器（平滑滤波器）之一，它是一个削弱高频信号强度的低通滤波器。边缘检测边缘在人类视觉和计算机视觉中均起着重要的作用。人类能够仅凭一张背景剪影或一个草图就识别出物体的类型和姿态。OpenCV提供了许多边缘检测滤波器，包括Laplacian()、Sobel()以及Scharr()。这些滤波函数都会将非边缘区域转为黑色，将边缘区域转为白色或其他饱和的颜色。但是，这些函数都很容易将噪声错误地识别为边缘。缓解这个问题的方法是在找到边缘之前对图像进行模糊处理。OpenCV也提供了许多模糊滤波函数，包括blur()（简单的算术平均）、medianBlur()以及GaussianBlur()。边缘检测滤波函数和模糊滤波函数的参数有很多，但总会有一个ksize参数，它是一个奇数，表示滤波核的宽和高。这里使用medianBlur()作为模糊函数，它对去除数字化的视频噪声非常有效，特别是去除彩色图像的噪声；使用Laplacian()作为边缘检测函数，他会产生明显的边缘线条，灰度图像更是如此。在使用medianBlur()函数之后，将要使用Laplacian()函数之前，需要将图像从BGR色彩空间转为灰度色彩空间。用定制内核做卷积OpenCV预定义的许多滤波器（滤波函数）都会使用核。其实核是一组权重，它决定如何通过邻近像素点来计算新的像素点。核也称为卷积矩阵，它对一个区域的像素做调和（mix up）或卷积运算。通常基于核的滤波器（滤波函数）也被称为卷积滤波器（滤波函数）。OpenCV提供了一个非常通用的filter2D()函数，它运用由用户指定的任意核或卷积矩阵。为了理解这个函数的使用方法，首先来了解卷积矩阵的格式。卷积矩阵是一个二维数组，有奇数行、奇数列，中心的元素对应于感兴趣的像素，其他的元素对应于这个像素周围的邻近像素，每个元素都有一个整数或浮点数的值，这些值就是应用在像素值上的权重。cv2.filter2D（src,-1,kernel,dst）第二个参数指定了目标图像每个通道的位深度（比如，位深度cv2.CV_8U表示每个通道为8位），如果为负值，则表示目标图像和源图像有同样的位深度。注意：对彩色图像来说，filter2D()会对每个通道都用同样的核。如果要对每个通道使用不同的核，就必须用split()函数和merge()函数。锐化、边缘检测以及模糊等滤波器都使用了高度对称的核。但是有时不对称的核也会得到一些有趣的效果。Canny边缘检测OpenCV还提供了一个非常方便的Canny函数，该算法非常流行，不仅是因为它的效果，还因为在OpenCV程序中实现时非常简单。import cv2 import numpy as np img=cv2.imread("1.jpg",0) cv2.imwrite("canny.jpg",cv2.Canny(img,200,300)) cv2.imshow("canny",cv2.imread("canny.jpg")) cv2.waitKey() cv2.destroyAllWindows()Canny边缘检测算法非常复杂，但也很有趣：它有5个步骤，即使用高斯滤波器对图像进行去噪、计算梯度、在边缘上使用非最大抑制（NMS）、在检测到的边缘上使用双阈值去除假阳性，最后还会分析所有的边缘及其之间的连接，以保留真正的边缘并消除不明显的边缘。轮廓检测在计算机视觉中，轮廓检测是另一个比较重要的任务，不单是用来检测图像或者视频帧中物体的轮廓，而且还有其他操作与轮廓检测有关。这些操作有：计算多边形边界、形状逼近核计算感兴趣区域。这是与图像数据交互时的简单操作，因为Numpy中的矩形区域可以使用数组切片（slice）来定义。在介绍物体检测（包括人脸）和物体跟踪的概念时会大量使用这种技术。边界框、最小矩形区域和最小闭圆的轮廓找到一个正方形轮廓很简单，要找到不规则、歪斜的以及旋转的形状可用OpenCV的cv2.findContours函数，它能得到最好的结果。现实的应用会对目标的边界框、最小矩形面积、最小闭圆特别感兴趣。将cv2.findContours函数与少量的OpenCV的功能相结合就能非常容易地实现这些功能：import cv2 import numpy as np img=cv2.pyrDown(cv2.imread("1.jpg",cv2.IMREAD_UNCHANGED)) ret,thresh=cv2.threshold(cv2.cvtColor(img.copy(),cv2.COLOR_BGR2GRAY),127,255,cv2.THRESH_BINARY) img,contours,hier=cv2.findContours(thresh,cv2.RETR_EXTERNAL,cv2.CHAIN_APPROX_SIMPLE) for c in contours: x,y,w,h=cv2.boundingRect(c)#计算出一个简单地边界框 #这个操作很简单，它将轮廓信息转换成（x，y）坐标，并加上矩形地高度和宽度。 cv2.rectangle(img,(x,y),(x+w,y+h),(0,255,0),2)#画出该矩形 rect=cv2.minAreaRect(c)#计算出包围目标地最小矩形区域 box=cv2.boxPoints(rect) box=np.int0(box) #这里用到一种非常有趣的机制：Opencv没有函数能直接从轮廓信息中计算出最小矩形顶点的坐标。所以需要计算出最小矩形区域，然后计算这个矩形的顶点。注意计算出来的顶点坐标是浮点型，但是所得像素的坐标值是整数（不能获取像素的一部分），所以需要做一个转换。然后画出这个矩形，可由cv2.drawContours函数来实现 cv2.drawContours(img,[box],0,(0,0,255),3) (x,y),radius=cv2.minEnclosingCircle(c)#返回一个二元组，第一个元素为圆心的坐标组成的元祖，第二个元素为圆的半径值 center=(int(x),int(y)) radius=int(radius) img=cv2.circle(img,center,radius,(0,255,0),2) cv2.drawContours(img,contours,-1,(255,0,0),1) cv2.imshow("contours",img) cv2.waitKey() cv2.destroyAllWindows()