一 要 解决 的 问题 问题 常常 一些 单位 或 
组织 召开 会议 时 需要 录入 会议记录 我们 需要 通过 
机器学习 对 用户 输入 的 文本 内容 进行 自动 评判 
合格 或 不合格 同样 的 问题 还 类似 垃圾 短信 
检测 工作 日志 质量 分析 等 处理 思路 我们 人工 
对 现有 会议 记录 进行 评判 标记 合格 或 不合格 
通过 对 这些 记录 的 学习 形成 模型 学习 算法 
仍 采用 二元 分类 的 快速 决策树 算法 和 上一 
篇文章 不同 这次 输入 的 特征值 不再 是 浮点数 而是 
中文 文本 这里 就 要 涉及 到 文本 特征提取 为什么 
要 进行 文本 特征提取 呢 因为 文本 是 人类 的 
语言 符号 文字 序列 不能 直接 传递 给 算法 而 
计算机程序 算法 只 接受 具有 固定 长度 的 数字矩阵 特征向量 
float 或 float 数组 无法 理解 可变 长度 的 文本文档 
常用 的 文本 特征提取 方法 有 如下 几种 以上 只是 
需要 了解 大致 的 含义 我们 不 需要 去 实现 
一个 文本 特征提取 的 算法 只 需要 使用 平台 自带 
的 方法 就 可以 了 系统 自带 的 文本 特征 
处理 的 方法 输入 是 一个 字符串 要求 将 一个 
语句 中的 词 语用 空格 分开 英语 的 句子 中 
词汇 是 天生 通过 空格 分割 的 但 中文 句子 
不是 所以 我们 需要 首先 进行 分词 操作 具体 流程 
如下 二 代码 代码 整体 流程 和 上一 篇文章 描述 
的 基本 一致 为 简便 起见 我们 省略 了 模型 
存储 和 读取 的 过程 先 看一下 数据集 代码 如下 
namespace B i n a r y C l a 
s s i f i c a t i o 
n _ TextFeaturize { class Program { static readonly string 
DataPath = Path . Combine Environment . CurrentDirectory Data meeting 
_ data _ full . csv static void Main string 
args { MLContext mlContext = new MLContext var fulldata = 
mlContext . Data . LoadFromTextFile MeetingInfo DataPath separatorChar hasHeader false 
var trainTestData = mlContext . Data . TrainTestSplit fulldata testFraction 
0.15 var trainData = trainTestData . TrainSet var testData = 
trainTestData . TestSet var trainingPipeline = mlContext . Transforms . 
CustomMapping JiebaLambdaInput J i e b a L a m 
b d a O u t p u t mapAction 
JiebaLambda . MyAction contractName JiebaLambda . Append mlContext . Transforms 
. Text . FeaturizeText outputColumnName Features inputColumnName JiebaText . Append 
mlContext . B i n a r y C l 
a s s i f i c a t i 
o n . Trainers . FastTree labelColumnName Label f e 
a t u r e C o l u m 
n N a m e Features ITransformer trainedModel = trainingPipeline 
. Fit trainData / / 评估 var predictions = trainedModel 
. Transform testData var metrics = mlContext . B i 
n a r y C l a s s i 
f i c a t i o n . Evaluate 
data predictions labelColumnName Label Console . WriteLine $ Evalution Accuracy 
{ metrics . Accuracy P2 } / / 创建 预测 
引擎 var predEngine = mlContext . Model . C r 
e a t e P r e d i c 
t i o n E n g i n e 
MeetingInfo PredictionResult trainedModel / / 预测 1 MeetingInfo sampleStatement1 = 
new MeetingInfo { Text = 支委会 } var p r 
e d i c t i o n r e 
s u l t 1 = predEngine . Predict sampleStatement1 
Console . WriteLine $ { sampleStatement1 . Text } { 
p r e d i c t i o n 
r e s u l t 1 . PredictedLabel } 
/ / 预测 2 MeetingInfo sampleStatement2 = new MeetingInfo { 
Text = 开展 新 时代 中国 特色 社会主义 思想 三十 
讲 党员 答题 活动 } var p r e d 
i c t i o n r e s u 
l t 2 = predEngine . Predict sampleStatement2 Console . 
WriteLine $ { sampleStatement2 . Text } { p r 
e d i c t i o n r e 
s u l t 2 . PredictedLabel } Console . 
WriteLine Press any to exit Console . ReadKey } } 
public class MeetingInfo { LoadColumn 0 public bool Label { 
get set } LoadColumn 1 public string Text { get 
set } } public class PredictionResult MeetingInfo { public string 
JiebaText { get set } public float Features { get 
set } public bool PredictedLabel public float Score public float 
Probability } } View Code 三 代码 分析 和上/nr 一篇 
文章 中 相似 的 内容 我 就 不再 重复 解释 
了 重点 介绍 一下 学习 管道 的 建立 var trainingPipeline 
= mlContext . Transforms . CustomMapping JiebaLambdaInput J i e 
b a L a m b d a O u 
t p u t mapAction JiebaLambda . MyAction contractName JiebaLambda 
. Append mlContext . Transforms . Text . FeaturizeText outputColumnName 
Features inputColumnName JiebaText . Append mlContext . B i n 
a r y C l a s s i f 
i c a t i o n . Trainers . 
FastTree labelColumnName Label f e a t u r e 
C o l u m n N a m e 
Features 首先 在 进行 文本 特征 转换 之前 我们 需要 
对 文本 进行 分词 操作 您 可以 对 样本 数据 
进行 预处理 形成 分词 的 结果 再 进行 学习 我们 
没有 采用 这个 方法 而是 自定义 了 一个 分词 处理 
的 数据处理 管道 通过 这个 管道 进行 分词 其 定义 
如下 namespace B i n a r y C l 
a s s i f i c a t i 
o n _ TextFeaturize { public class JiebaLambdaInput { public 
string Text { get set } } public class J 
i e b a L a m b d a 
O u t p u t { public string JiebaText 
{ get set } } public class JiebaLambda { public 
static void MyAction JiebaLambdaInput input J i e b a 
L a m b d a O u t p 
u t output { JiebaNet . Segmenter . JiebaSegmenter jiebaSegmenter 
= new JiebaNet . Segmenter . JiebaSegmenter output . JiebaText 
= string . Join jiebaSegmenter . Cut input . Text 
} } } 最后 我们 新建 了 两个 对象 进行 
实际 预测 / / 预测 1 MeetingInfo sampleStatement1 = new 
MeetingInfo { Text = 支委会 } var p r e 
d i c t i o n r e s 
u l t 1 = predEngine . Predict sampleStatement1 Console 
. WriteLine $ { sampleStatement1 . Text } { p 
r e d i c t i o n r 
e s u l t 1 . PredictedLabel } / 
/ 预测 2 MeetingInfo sampleStatement2 = new MeetingInfo { Text 
= 开展 新 时代 中国 特色 社会主义 思想 三十 讲 
党员 答题 活动 } var p r e d i 
c t i o n r e s u l 
t 2 = predEngine . Predict sampleStatement2 Console . WriteLine 
$ { sampleStatement2 . Text } { p r e 
d i c t i o n r e s 
u l t 2 . PredictedLabel } 预测 结果 如下 
四 调试 上 一篇 文章 提到 当 我们 运行 Transform 
方法 时 会对 所有 记录 进行 转换 转换 后的/nr 数据 
集 是 什么 样子 呢 我们 可以 写 一个 调试程序 
看一下 var predictions = trainedModel . Transform testData DebugData mlContext 
predictions private static void DebugData MLContext mlContext IDataView predictions { 
var trainDataShow = new List PredictionResult mlContext . Data . 
CreateEnumerable PredictionResult predictions false true foreach var dataline in trainDataShow 
{ dataline . PrintToConsole } } public class PredictionResult { 
public string JiebaText { get set } public float Features 
{ get set } public bool PredictedLabel public float Score 
public float Probability public void PrintToConsole { Console . WriteLine 
$ JiebaText = { JiebaText } Console . WriteLine $ 
PredictedLabel { PredictedLabel } Score { Score } Probability { 
Probability } Console . WriteLine $ TextFeatures Length { Features 
. Length } if Features = null { foreach var 
f in Features { Console . Write $ { f 
} } Console . WriteLine } Console . WriteLine } 
} 通过 对 调试 结果 的 分析 可以 看到 整个 
数据处理 管道 的 工作 流程 五 资源 获取 源码 下载 
地址 https / / github . com / seabluescn / 
Study _ ML . NET 工程 名称 B i n 
a r y C l a s s i f 
i c a t i o n _ TextFeaturize 点击 
查看 机器学习 框架 ML . NET 学习 笔记 系列 文章 
目录 