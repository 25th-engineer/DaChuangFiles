在看 机器学习 实战 时候 到 第三 章的对/nr 决策树 画图 的 
时候 有/v 一段/m 递归函数/l 怎么/r 都/d 看不懂/v 因为 以后 想 
选 这个 方向 为 自己 的 职业 导向 抱着 精 
看 的 态度 对 这本 树 进行 地毯式 扫描 所以 
就 没 跳过 一直 卡 了 一天 多 才 差不多 
搞懂 才对 那个 函数 中的 plotTree . xOff 的 取值 
以及 计算 cntrPt 的 方法 搞懂 相信 也 有人 和我/nr 
一样 希望 能够 相互 交流 先把 代码 贴 在 这里 
import matplotlib . pyplot as plt # 这里 是 对 
绘制 是 图形 属性 的 一些 定义 可以 不用 管 
主要 是 后面 的 算法 decisionNode = dict boxstyle = 
sawtooth fc = 0.8 leafNode = dict boxstyle = round4 
fc = 0.8 arrow _ args = dict arrowstyle = 
# 这是 递归计算 树 的 叶子 节点 个数 比较简单 def 
getNumLeafs myTree numLeafs = 0 firstStr = myTree . keys 
0 secondDict = myTree firstStr for key in secondDict . 
keys if type secondDict key . _ _ name _ 
_ = = dict # test to see if the 
nodes are dictonaires if not they are leaf nodes numLeafs 
+ = getNumLeafs secondDict key else numLeafs + = 1 
return numLeafs # 这是 递归计算 树 的 深度 比较简单 def 
getTreeDepth myTree maxDepth = 0 firstStr = myTree . keys 
0 secondDict = myTree firstStr for key in secondDict . 
keys if type secondDict key . _ _ name _ 
_ = = dict # test to see if the 
nodes are dictonaires if not they are leaf nodes thisDepth 
= 1 + getTreeDepth secondDict key else thisDepth = 1 
if thisDepth maxDepth maxDepth = thisDepth return maxDepth # 这个 
是 用来 一 注释 形式 绘制 节点 和 箭头 线 
可以 不用 管 def plotNode nodeTxt centerPt parentPt nodeType createPlot 
. ax1 . annotate nodeTxt xy = parentPt xycoords = 
axes fraction xytext = centerPt textcoords = axes fraction va 
= center ha = center bbox = nodeType arrowprops = 
arrow _ args # 这个 是 用来 绘制 线上 的 
标注 简单 def plotMidText cntrPt parentPt txtString xMid = parentPt 
0 cntrPt 0 / 2.0 + cntrPt 0 yMid = 
parentPt 1 cntrPt 1 / 2.0 + cntrPt 1 createPlot 
. ax1 . text xMid yMid txtString va = center 
ha = center rotation = 30 # 重点 递归 决定 
整个 树 图 的 绘制 难 自己 认为 def plotTree 
myTree parentPt nodeTxt # if the first key tells you 
what feat was split on numLeafs = getNumLeafs myTree # 
this determines the x width of this tree depth = 
getTreeDepth myTree firstStr = myTree . keys 0 # the 
text label for this node should be this cntrPt = 
plotTree . xOff + 1.0 + float numLeafs / 2.0 
/ plotTree . totalW plotTree . yOff plotMidText cntrPt parentPt 
nodeTxt plotNode firstStr cntrPt parentPt decisionNode secondDict = myTree firstStr 
plotTree . yOff = plotTree . yOff 1.0 / plotTree 
. totalD for key in secondDict . keys if type 
secondDict key . _ _ name _ _ = = 
dict # test to see if the nodes are dictonaires 
if not they are leaf nodes plotTree secondDict key cntrPt 
str key # recursion else # it s a leaf 
node print the leaf node plotTree . xOff = plotTree 
. xOff + 1.0 / plotTree . totalW plotNode secondDict 
key plotTree . xOff plotTree . yOff cntrPt leafNode plotMidText 
plotTree . xOff plotTree . yOff cntrPt str key plotTree 
. yOff = plotTree . yOff + 1.0 / plotTree 
. totalD # if you do get a dictonary you 
know it s a tree and the first element will 
be another dict # 这个 是 真正 的 绘制 上边 
是 逻辑 的 绘制 def createPlot inTree fig = plt 
. figure 1 facecolor = white fig . clf axprops 
= dict xticks = yticks = createPlot . ax1 = 
plt . subplot 111 frameon = False # no ticks 
plotTree . totalW = float getNumLeafs inTree plotTree . totalD 
= float getTreeDepth inTree plotTree . xOff = 0.5 / 
plotTree . totalW plotTree . yOff = 1.0 plotTree inTree 
0.5 1.0 plt . show # 这个 是 用来 创建 
数据集 即 决策树 def retrieveTree i listOfTrees = { no 
surfacing { 0 { flippers { 0 no 1 yes 
} } 1 { flippers { 0 no 1 yes 
} } 2 { flippers { 0 no 1 yes 
} } } } { no surfacing { 0 no 
1 { flippers { 0 { head { 0 no 
1 yes } } 1 no } } } } 
return listOfTrees i createPlot retrieveTree 0 绘制 出来 的 图形 
如下 先导 这里 说 一下 为什么 说 一个 递归 树 
的 绘制 为什么 会 是 很难 懂 这里 不 就是 
利用 递归函数 来 绘图 么 就如 递归计算 树 的 深度 
叶子 节点 一样 问题 不是 递归 的 思路 而是 这 
本书 中 一些 坐标 的 起始 取值 以及 在 计算 
节点 坐标 所作 的 处理 而且在 树 中 对 这部分 
并 没有 取 讲述 所以 在看 这段 代码 的 时候 
可能 大体 思路 明白 但是 具体 的 细节 却 知之甚少 
所以 本篇 主要 是 对 其中 书中 提及 甚少 的 
作 详细 的 讲述 当然 代码 的 整体 思路 也 
不会 放过 的 准备 这里 说 一下 具体 绘制 的 
时候 是 利用 自定义 plotNode 函 数来 绘制 这个 函数 
一次 绘制 的 是 一个 箭头 和 一个 节点 如 
下图 思路 这里 绘图 作者 选取 了 一个 很 聪明 
的 方式 并 不会 因为 树 的 节点 的 增减 
和 深度 的 增减 而 导致 绘制 出来 的 图形 
出现问题 当然 不能 太 密集 这里 利用 整棵树 的 叶子 
节 点数 作为 份数 将 整个 x 轴 的 长度 
进行 平均 切分 利用 树 的 深度 作为 份数 将 
y 轴 长度 作 平均 切分 并 利用 plotTree . 
xOff 作为 最近 绘制 的 一个 叶子 节点 的 x 
坐标 当 再一次 绘制 叶子 节点 坐标 的 时候 才会 
plotTree . xOff 才会 发生 改变 用 plotTree . yOff 
作为 当前 绘制 的 深度 plotTree . yOff 是 在 
每 递归 一层 就会 减 一份 上边 所说 的 按 
份 平均 切分 其他 时候 是 利用 这 两个 坐标 
点 去 计算 非 叶子 节点 这 两个 参数 其实 
就 可以 确定 一个 点 坐标 这个 坐标 确定 的 
时候 就是 绘制 节点 的 时候 整体 算法 的 递归 
思路 倒是 很 容易 理解 每一次 都分/nr 三个 步骤 1 
绘制 自身 2 判断 子 节点 非 叶子 节点 递归 
3 判断 子 节点 为 叶子 节点 绘制 详细 解析 
def plotTree myTree parentPt nodeTxt # if the first key 
tells you what feat was split on numLeafs = getNumLeafs 
myTree # this determines the x width of this tree 
depth = getTreeDepth myTree firstStr = myTree . keys 0 
# the text label for this node should be this 
cntrPt = plotTree . xOff + 1.0 + float numLeafs 
/ 2.0 / plotTree . totalW plotTree . yOff plotMidText 
cntrPt parentPt nodeTxt plotNode firstStr cntrPt parentPt decisionNode secondDict = 
myTree firstStr plotTree . yOff = plotTree . yOff 1.0 
/ plotTree . totalD for key in secondDict . keys 
if type secondDict key . _ _ name _ _ 
= = dict # test to see if the nodes 
are dictonaires if not they are leaf nodes plotTree secondDict 
key cntrPt str key # recursion else # it s 
a leaf node print the leaf node plotTree . xOff 
= plotTree . xOff + 1.0 / plotTree . totalW 
plotNode secondDict key plotTree . xOff plotTree . yOff cntrPt 
leafNode plotMidText plotTree . xOff plotTree . yOff cntrPt str 
key plotTree . yOff = plotTree . yOff + 1.0 
/ plotTree . totalD # if you do get a 
dictonary you know it s a tree and the first 
element will be another dict def createPlot inTree fig = 
plt . figure 1 facecolor = white fig . clf 
axprops = dict xticks = yticks = createPlot . ax1 
= plt . subplot 111 frameon = False # no 
ticks plotTree . totalW = float getNumLeafs inTree plotTree . 
totalD = float getTreeDepth inTree plotTree . xOff = 0.5 
/ plotTree . totalW plotTree . yOff = 1.0 # 
totalW 为整 树 的 叶子 节点 树 totalD 为 深度 
plotTree inTree 0.5 1.0 plt . show 上边 代码 中 
红色 部分 如此 处理 原理 首先 由于 整个 画布 根据 
叶子 节 点数 和 深度 进行 平均 切分 并且 x 
轴 的 总 长度 为 1 即 如同 下图 1 
其中 方形 为非 叶子 节点 的 位置 @ 是 叶子 
节点 的 位置 因此 每份 即 上图 的 一个 表格 
的 长度 应该 为 1 / plotTree . totalW 但是 
叶子 节点 的 位置 应该 为 @ 所在位置 则在 开始 
的 时候 plotTree . xOff 的 赋值 为 0.5 / 
plotTree . totalW 即 意为 开始 x 位置 为 第一 
个 表格 左边 的 半个 表格 距离 位置 这样 作 
的 好处 为 在 以后 确定 @ 位置 时候 可以 
直接 加 整数倍 的 1 / plotTree . totalW 2 
对于 plotTree 函数 中的 红色 部分 即 如下 cntrPt = 
plotTree . xOff + 1.0 + float numLeafs / 2.0 
/ plotTree . totalW plotTree . yOff plotTree . xOff 
即为 最近 绘制 的 一个 叶子 节点 的 x 坐标 
在 确定 当前 节点 位置 时 每次 只需 确定 当前 
节点 有几个 叶子 节点 因此 其 叶子 节点 所占 的 
总 距离 就 确定 了 即为 float numLeafs / plotTree 
. totalW * 1 因为 总 长度 为 1 因此 
当前 节点 的 位置 即为 其 所有 叶子 节点 所占 
距离 的 中间 即 一半 为 float numLeafs / 2.0 
/ plotTree . totalW * 1 但是 由于 开始 plotTree 
. xOff 赋值 并非 从0/nr 开始 而是 左移 了 半个 
表格 因此 还 需 加上 半个 表格 距离 即为 1/2 
/ plotTree . totalW * 1 则 加 起来 便 
为 1.0 + float numLeafs / 2.0 / plotTree . 
totalW * 1 因此 偏移量 确定 则 x 位置 变为 
plotTree . xOff + 1.0 + float numLeafs / 2.0 
/ plotTree . totalW3 对于 plotTree 函数参数 赋值 为 0.5 
1.0 因为 开始 的 根 节点 并 不用 划线 因此 
父 节点 和 当前 节点 的 位置 需要 重合 利用 
2中 的 确定 当前 节点 的 位置 便 为 0.5 
1.0 总结 利用 这样 的 逐渐 增加 x 的 坐标 
以及/c 逐渐/d 降低/v y/w 的/uj 坐标/v 能/v 能够/v 很好/i 的/uj 
将/d 树/v 的/uj 叶子/nr 节/t 点数/n 和/c 深度/ns 考虑/v 进去/v 
因此 图 的 逻辑 比例 就 很好 的 确定 了 
这样 不用 去 关心 输出 图形 的 大小 一旦 图形 
发生变化 函数 会 重新 绘制 但是 假如 利用 像素 为 
单位 来 绘制 图形 这样 缩放 图形 就 比较 有 
难度 了 