在用 PMML 实现 机器学习 模型 的 跨平台 上线 中 我们 
讨论 了 使用 PMML 文件 来 实现 跨平台 模型 上线 
的 方法 这个 方法 当然 也 适用 于 tensorflow 生成 
的 模型 但是 由于 tensorflow 模型 往往 较大 使用 无法 
优化 的 PMML 文件 大多数 时候 很 笨拙 因此 本文 
我们 专门 讨论 下 tensorflow 机器学习 模型 的 跨平台 上线 
的 方法 1 .   tensorflow 模型 的 跨平台 上线 
的 备选 方案 tensorflow 模型 的 跨平台 上线 的 备选 
方案 一般 有三种 即 PMML 方式 tensorflow serving 方式 以及 
跨语言 API 方式 PMML 方式 的 主要 思路 在上 一篇 
以及 讲过 这里 唯一 的 区别 是 转 化生成 PMML 
文件 需要 用 一个 Java 库 jpmml tensorflow 来 完成 
生成 PMML 文件 后 跨语言 加载 模型 和 其他 PMML 
模型 文件 基本 类似 tensorflow serving 是 tensorflow 官方 推荐 
的 模型 上线 预测 方式 它 需要 一个 专门 的 
tensorflow 服务器 用来 提供 预测 的 API 服务 如果 你 
的 模型 和 对应 的 应用 是 比较 大 规模 
的 那么 使用 tensorflow serving 是 比较 好 的 使用 
方式 但是 它 也 有一个 缺点 就是 比较 笨重 如果 
你 要 使用 tensorflow serving 那么 需要 自己 搭建 serving 
集群 并 维护 这个 集群 所以 为了 一个 小 的 
应用 去做 这个工作 有时候 会 觉得 麻烦 跨语言 API 方式 
是 本文 要 讨论 的 方式 它 会用 tensorflow 自己 
的 Python API 生成 模型 文件 然后 用 tensorflow 的 
客户端 库 比如 Java 或 C + + 库 来做 
模型 的 在线 预测 下面 我们 会 给 一个 生成 
生成 模型 文件 并用 tensorflow Java API 来做 在线 预测 
的 例子 2 . 训练 模型 并 生成 模型 文件 
我们 这里 给 一个 简单 的 逻辑 回归 并 生成 
逻辑 回归 tensorflow 模型 文件 的 例子 完整 代码 参见 
我 的 github https / / github . com / 
ljpzzz / machinelearning / blob / master / model in 
product / tensorflow java 首先 我们 生成 了 一个 6 
特征 3 分类 输出 的 4000个 样本数据 import numpy as 
np import matplotlib . pyplot as plt % matplotlib inline 
from sklearn . datasets . samples _ generator import make 
_ classification import tensorflow as tf X1 y1 = make 
_ classification n _ samples = 4000 n _ features 
= 6 n _ redundant = 0 n _ clusters 
_ per _ class = 1 n _ classes = 
3 接着 我们 构建 tensorflow 的 数据流 图 这里 要 
注意 里面 的 两个 名字 第一个 是 输入 x 的 
名字 input 第二个 是 输出 prediction _ labels 的 名字 
output 这里 的 这 两个 名字 可以 自己 取 但是 
后面 会 用到 所以 要 保持 一致 learning _ rate 
= 0.01 training _ epochs = 600 batch _ size 
= 100 x = tf . placeholder tf . float32 
None 6 name = input # 6 features y = 
tf . placeholder tf . float32 None 3 # 3 
classes W = tf . Variable tf . zeros 6 
3 b = tf . Variable tf . zeros 3 
# softmax 回归 pred = tf . nn . softmax 
tf . matmul x W + b name = softmax 
cost = tf . reduce _ mean tf . reduce 
_ sum y * tf . log pred reduction _ 
indices = 1 optimizer = tf . train . G 
r a d i e n t D e s 
c e n t O p t i m i 
z e r learning _ rate . minimize cost prediction 
_ labels = tf . argmax pred axis = 1 
name = output init = tf . global _ variables 
_ initializer 接着就是 训练 模型 了 代码 比较简单 毕竟 只是 
一个 演示 sess = tf . Session sess . run 
init y2 = tf . one _ hot y1 3 
y2 = sess . run y2 for epoch in range 
training _ epochs _ c = sess . run optimizer 
cost feed _ dict = { x X1 y y2 
} if epoch + 1 % 10 = = 0 
print Epoch % 04d % epoch + 1 cost = 
{ . 9f } . format c print 优化 完毕 
correct _ prediction = tf . equal tf . argmax 
pred 1 tf . argmax y2 1 accuracy = tf 
. reduce _ mean tf . cast correct _ prediction 
tf . float32 acc = sess . run accuracy feed 
_ dict = { x X1 y y2 } print 
acc 打印输出 我 这里 就不 写了 大家 可以 自己 去 
试一试 接着就是 关键 的 一步 存 模型 文件 了 注意 
要用 convert _ variables _ to _ constants 这个 API 
来 保存 模型 否则 模型 参数 不会 随着 模型 图 
一起 存 下来 graph = tf . graph _ util 
. convert _ variables _ to _ constants sess sess 
. graph _ def output tf . train . write 
_ graph graph . rf . pb as _ text 
= False 至此 我们 的 模型 文件 rf . pb 
已经 被 保存 下来 了 下面 就是 要 跨平台 上线 
了 3 .   模型 文件 在 Java 平台 上线 
这里 我们 以 Java 平台 的 模型 上线 为例 C 
+ + 的 API 上线 我 没有 用过 这里 就不 
写了 我们 需要 引入 tensorflow 的 java 库 到 我们 
工程 的 maven 或者 gradle 文件 这里 给出 maven 的 
依赖 如下 版本 可以 根据 实际 情况 选择 一个 较 
新的 版本 dependency groupId org . tensorflow / groupId artifactId 
tensorflow / artifactId version 1 . 7.0 / version / 
dependency 接着就是 代码 了 这个 代码 会比 JPMML 的 要 
简单 我 给 出了 4个 测试 样本 的 预测 例子 
如下 一定 要 注意 的 是 里面 的 input 和 
output 要和 训练 模型 的 时候 对应 的 节点 名字 
一致 import org . tensorflow . * import org . 
tensorflow . Graph import java . io . IOException import 
java . nio . file . Files import java . 
nio . file . Paths / * * * Created 
by 刘建平 pinard on 2018 / 7/1 . * / 
public class TFjavaDemo { public static void main String args 
{ byte graphDef = l o a d T e 
n s o r f l o w M o 
d e l D / rf . pb float inputs 
= new float 4 6 for int i = 0 
i 4 i + + { for int j = 
0 j 6 j + + { if i 2 
{ inputs i j = 2 * i 5 * 
j 6 } else { inputs i j = 2 
* i + 5 * j 6 } } } 
Tensor Float input = c o v e r t 
A r r a y T o T e n 
s o r inputs Graph g = new Graph g 
. importGraphDef graphDef Session s = new Session g Tensor 
result = s . runner . feed input input . 
fetch output . run . get 0 long rshape = 
result . shape int rs = int rshape 0 long 
realResult = new long rs result . copyTo realResult for 
long a realResult { System . out . println a 
} } static private byte l o a d T 
e n s o r f l o w M 
o d e l String path { try { return 
Files . readAllBytes Paths . get path } catch IOException 
e { e . printStackTrace } return null } static 
private Tensor Float c o v e r t A 
r r a y T o T e n s 
o r float inputs { return Tensors . create inputs 
} } 我 的 预测 输出 是 1 1 0 
0 供 大家 参考 4 . 一点 小结 对于 tensorflow 
来说 模型 上线 一般 选择 tensorflow serving 或者 client API 
库 来 上线 前者 适合于 较大 的 模型 和 应用 
场景 后者 则 适合 中小型 的 模型 和 应用 场景 
因此 算法 工程师 使用 在 产品 之前 需要 做好 选择 
和 评估 欢迎 转载 转载 请 注明 出处 欢迎 沟通交流 
liujianping ok @ 163 . com 