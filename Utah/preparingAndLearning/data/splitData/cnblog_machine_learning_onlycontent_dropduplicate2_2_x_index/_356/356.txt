写这个系列是因为最近公司在搞技术分享，学习Spark，我的任务是讲PySpark的应用，因为我主要用Python，结合Spark，就讲PySpark了。然而我在学习的过程中发现，PySpark很鸡肋（至少现在我觉得我不会拿PySpark做开发）。为什么呢？原因如下：
1.PySpark支持的算法太少了。我们看一下PySpark支持的算法:(参考官方文档)
前面两个pyspark.sql和pyspark.streaming是对sql和streaming的支持。主要是读取数据，和streaming处理这种方式（当然这是spark的优势，要是这也不支持真是见鬼了）。pyspark.ml和pyspark.mllib分别是ml的api和mllib的api，ml的算法真心少啊，而且支持的功能很有限，譬如Lr（逻辑回归）和GBT目前只支持二分类，不支持多分类。mllib相对好点，支持的算法也多点，虽然昨天发的博文讲mlllib的时候说过有的算法不支持分布式，所以才会有限，但是我在想，如果我需要用到A算法，而Ml和Mllib的包里面都没有，这样是不是意味着要自己开发分布式算法呢？代价有点大诶，感觉写这个的时间不如多找找有用的特征，然后上LR，这样效果说不定更好。因为目前还没有在实际中用过，所以以上只是我的想法。下面把ml和mllib的所有api列出来，这样看的更清楚。
图一 pyspark.ml的api
图二 pyspark.mllib的api
从上面两张图可以看到，mllib的功能比ml强大的不是一点半点啊，那ml这个包的存在还有什么意义呢？不懂（如果有了解的欢迎留言）。虽然有这么多疑问，但是我还是跟大家讲了，用的数据依然是iris（其实我真心想换个数据集啊 == ，下次换）。上代码：
1 from pyspark.sql import SQLContext 2 sqlContext = SQLContext(sc) 3 df = sqlContext.read.format('com.databricks.spark.csv').options(header='true', inferschema='true').load('iris.csv') 4 # Displays the content of the DataFrame to stdout 5 df.show() 6 7 8 from pyspark.ml.feature import StringIndexer 9 indexer = StringIndexer(inputCol="Species", outputCol="labelindex") 10 indexed = indexer.fit(df).transform(df) 11 indexed.show() 12 13 from pyspark.sql import Row 14 from pyspark.mllib.linalg import Vectors 15 from pyspark.ml.classification import NaiveBayes 16 17 # Load and parse the data 18 def parseRow(row): 19 return Row(label=row["labelindex"], 20 features=Vectors.dense([row["Sepal.Length"], 21 row["Sepal.Width"], 22 row["Petal.Length"], 23 row["Petal.Width"]])) 24 25 ## Must convert to dataframe after mapping 26 parsedData = indexed.map(parseRow).toDF() 27 labeled = StringIndexer(inputCol="label", outputCol="labelpoint") 28 data = labeled.fit(parsedData).transform(parsedData) 29 data.show() 30 31 ## 训练模型 32 #Naive Bayes 33 nb = NaiveBayes(smoothing=1.0, modelType="multinomial") 34 model_NB = nb.fit(data) 35 predict_data= model_NB.transform(data) 36 traing_err = predict_data.filter(predict_data['label'] != predict_data['prediction']).count() 37 total = predict_data.count() 38 nb_scores = float(traing_err)/total 39 print traing_err, total, nb_scores 40 #7 150 0.0466666666667 41 42 43 #Logistic Regression########################################################### 44 # Logistic regression. Currently, this class only supports binary classification. 45 from pyspark.ml.classification import LogisticRegression 46 lr = LogisticRegression(maxIter=5, regParam=0.01) 47 model_lr = lr.fit(data) 48 predict_data= model_lr.transform(data) 49 traing_err = predict_data.filter(predict_data['label'] != predict_data['prediction']).count() 50 total = predict_data.count() 51 lr_scores = float(traing_err)/total 52 print traing_err, total, float(traing_err)/total 53 54 55 #Decision Tree 56 from pyspark.ml.classification import DecisionTreeClassifier 57 dt = DecisionTreeClassifier(maxDepth=2,labelCol = 'labelpoint') 58 model_DT= dt.fit(data) 59 predict_data= model_DT.transform(data) 60 traing_err = predict_data.filter(predict_data['label'] != predict_data['prediction']).count() 61 total = predict_data.count() 62 dt_scores = float(traing_err)/total 63 print traing_err, total, float(traing_err)/total 64 65 66 #GBT########################################################### 67 ## GBT. Currently, this class only supports binary classification. 68 from pyspark.ml.classification import GBTClassifier 69 gbt = GBTClassifier(maxIter=5, maxDepth=2,labelCol="labelpoint") 70 model_gbt = gbt.fit(data) 71 predict_data= model_gbt.transform(data) 72 traing_err = predict_data.filter(predict_data['label'] != predict_data['prediction']).count() 73 total = predict_data.count() 74 dt_scores = float(traing_err)/total 75 print traing_err, total, float(traing_err)/total 76 77 78 #Random Forest 79 from pyspark.ml.classification import RandomForestClassifier 80 rf = RandomForestClassifier(numTrees=3, maxDepth=2, labelCol="labelpoint", seed=42) 81 model_rf= rf.fit(data) 82 predict_data= model_rf.transform(data) 83 traing_err = predict_data.filter(predict_data['label'] != predict_data['prediction']).count() 84 total = predict_data.count() 85 dt_scores = float(traing_err)/total 86 print traing_err, total, float(traing_err)/total 87 88 #MultilayerPerceptronClassifier########################################################### 89 # Classifier trainer based on the Multilayer Perceptron. Each layer has sigmoid activation function, output layer has softmax. 90 # Number of inputs has to be equal to the size of feature vectors. Number of outputs has to be equal to the total number of labels. 91 from pyspark.ml.classification import MultilayerPerceptronClassifier 92 mlp = MultilayerPerceptronClassifier(maxIter=100, layers=[150, 5, 150], blockSize=1, seed=11) 93 model_mlp= mlp.fit(parsedData) 94 predict_data= model_mlp.transform(parsedData) 95 traing_err = predict_data.filter(predict_data['label'] != predict_data['prediction']).count() 96 total = predict_data.count() 97 dt_scores = float(traing_err)/total 98 print traing_err, total, float(traing_err)/total
因为数据集和上次讲pyspark聚类应用的数据是一样的，就不一步步的展示了，但是我这个程序里只有NaiveBayes的效果还行，0.94的正确率，其他的像DecisionTree等，效果真心差，可能参数还需要调。先掌握怎么用再来调参，官方文档里关于参数的解释也非常详细，可以看看。下一次讲回归，我决定不只写pyspark.ml的应用了，因为实在是图样图naive，想弄清楚pyspark的机器学习算法是怎么运行的，跟普通的算法运行有什么区别，优势等，再写个pyspark.mllib，看相同的算法在ml和mllib的包里运行效果有什么差异，如果有，是为什么，去看源码怎么写的。此外，我真的想弄清楚这货在实际生产中到底有用吗，毕竟还是要落实生产的，我之前想，如果python的sklearn能够在spark上应用就好了，后来在databricks里面找到了一个包好像是准备把sklearn弄到spark上来，当然算法肯定要重新写，不过还没有发布，期待发布的时候。此外，我在知乎上也看到过有人提问说“spark上能用skearn吗？”（大概是这意思，应该很好搜），里面有个回答好像说可以，不过不是直接用（等我找到了把链接放出来）。其实换一种想法，不用spark也行，直接用mapreduce编程序，但是mapreduce慢啊（此处不严谨，因为并没有测试过两者的性能差异，待补充），在我使用spark的短暂时间内，我个人认为spark的优势在于数据处理快，它不需要像mapreduce一样把数据切分成这么多块计算然后再reduce合并，而是直接将数据导入的时候就指定分区，运行机制不同，尤其是spark streaming的功能，还是很快的，所以这是spark的优势（鄙人拙见，如有错误欢迎指出）。而spark的劣势也比较明显，因为它对设备的要求太高了（吃内存啊能不高吗!）,这也是它快的原因，你把数据都放在内存里，取的时间比放在磁盘里当然要快，不过实际上在存储数据或者输出结果的时候还是会选择（memory+disk）的方式，保险嘛。前段时间看的alluxio也是占了内存的优势。恩，说了很多废话。下周争取研究的深一点，不然在公司里讲都没人听 = =。