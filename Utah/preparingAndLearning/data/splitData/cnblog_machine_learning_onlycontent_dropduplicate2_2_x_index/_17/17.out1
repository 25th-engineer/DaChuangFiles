1   简介 决策树 学习 是 一种 逼近 离散 值 
目标函数 的 方法 在 这种 学习 到 的 函数 被 
表示 为 一棵 决策树 2 决策树 表示 决策树 通过 把 
实例 从根/nr 节点 排列 到 某个 叶子 结点 来 分类 
实例 叶子 结点 即为 实例 所属 的 分类 树上 的 
每一个 结点 指定 了 对 实例 的 某个 属性 的 
测试 并且 该 结点 的 每一个 后续 分支 对应 于该/nr 
属性 的 一个 可能 值 分类 实例 的 方法 是 
从这 棵树 的 根 节点 开始 测试 这个 结点 指定 
的 属性 然后 按照 给定 实例 的 该 属性值 对应 
的 树枝 向下 移动 然后 这个 过程 在 以 新 
结点 为 根 的 子树 上 重复 画 出了 一棵 
典型 的 学习 到 的 决策树 这棵 决策树 根据 天气 
情况 分类 星期六 上午 是否 适合 打网球 例如 下面 的 
实例   Outlook = Sunny Temperature = Hot Humidity = 
High Wind = Strong   将被 沿着 这棵 决策树 的 
最左 分支 向下 排列 因而 被 评定 为 反例 也 
就是 这 棵树 预测 这个 实例 Play Tennis = No 
这 棵树 以及 表 3 2 中 用来 演示 ID3 
学习 算法 的 例子 摘自 Quinlan   1986 通常 决策树 
代表 实例 属性值 约束 的 合取 conjunction 的 析取 式 
disjunction 从 树根 到 树叶 的 每 一条 路径 对应 
一组 属性 测试 的 合取 树 本身 对应 这些 合取 
的 析取 例如 Outlook = Sunny ٨ Humidity = Normal 
٧ Outlook = Overcast ٧ Outlook = Rain ٨ Wind 
= Weak 3 决策树 的 ID3 算法 基本 的 ID3 
算法 通过 自顶向下 构造 决策树 来 进行 学习 构造 过程 
是从 哪一个 属性 将在 树 的 根 结点 被 测试 
这个 问题 开始 的 为了 回答 这个 问题 使用 统计 
测试 来 确定 每 一个 实例 属性 单独 分类 训练 
样例 的 能力 1 分类 能力 最好 的 属性 被 
选作 树 的 根 结点 的 测试 2 然后 为 
根 结点 属性 的 每个 可能 值 产生 一个 分支 
并把 训练 样例 排列 到 适当 的 分支 也 就是 
样例 的 该 属性值 对应 的 分支 之下 3 然后 
重复 整个 过程 用 每个 分支 结点 关联 的 训练 
样例 来 选取 在 该点 被 测试 的 最佳 属性 
这 形成 了 对 合格 决策树 的 贪婪 搜索 greedy 
search 也 就是 算法 从不 回溯 重新考虑 以前 的 选择 
伪代码 3.1 哪个 属性 是 最佳 的 分类 属性 ID3 
算法 的 核心 问题 是 选取 在 树 的 每个 
结点 要 测试 的 属性 我们 希望 选择 的 是 
最 有助于 分类 实例 的 属性 那么 衡量 属性 价值 
的 一个 好 的 定量 标准 是 什么 呢 这里 
将 定义 一个 统计 属性 称为 信息 增益 information gain 
用来 衡量 给定 的 属性 区分 训练 样例 的 能力 
ID3 算法 在 增长 树 的 每一步 使用 这个 信息 
增益 标准 从 候选 属性 中 选择 属性 3 . 
1.1 用 熵 度量 样例 的 均 一性 为了 精确地 
定义 信息 增益 我们 先 定义 信息论 中 广泛 使用 
的 一个 度量 标准 称为 熵 entropy 它 刻画 了 
任意 样例 集 的 纯度 purity 给定 包含 关于 某个 
目标 概念 的 正反 样例 的 样例 集 那么 相对/nr 
这个 布尔 型 分类 的 熵 为 Entropy S = 
P ⊕ log2P ⊕ P Θ log2P Θ 其中 P 
⊕ 是 在 中正 例 的 比例 P Θ 是 
在 中 负 例 的 比例 在 有关 熵 的 
所有 计算 中 我们 定义 0 log0 为 0 举例说明 
假设 是 一个 关于 某 布尔 概念 的 有 14 
个 样例 的 集合 它 包括 9 个 正 例和 
5 个 反例 我们 采用 记号 9 + 5 来 
概括 这样 的 数据 样例 那么 相对 于 这个 布尔 
分类 的 熵 Entropy 为 Entropy 9 + 5 = 
9/14 log2 9/14   5/14 log2 5/14 至此 我们 讨论 
了 目标 分类 是 布尔 型 的 情况下 的 熵 
更 一般 的 如果 目标 属性 具有 c 个 不同 
的 值 那么 相对于 c 个 状态 c wise 的 
分类 的 熵 定义 为 Entropy S = Σ Pi 
* log2Pi 1 ≤   i ≤ c 3 . 
1.2 用 信息 增益 度量 期望 的 熵 降低 已经 
有了熵/nr 作为 衡量 训练 样例 集合 纯度 的 标准 现在 
可以 定义 属性 分类 训练 数据 的 效力 的 度量 
标准 这个 标准 被 称为 信息 增益 information gain 简单 
的 说 一个 属性 的 信息 增益 就是 由于 使用 
这个 属性 分割 样例 而 导致 的 期望 熵 降低 
更 精确 地 讲 一个 属性 A 相对 样例 集合 
S 的 信息 增益 Gain S A 被 定义 为 
其中 Values A 是 属性 A 所有 可能 值 的 
集合 SV   是 中 属性 A 的 值 为 
v 的 子集 也 就是 Sv = { s ∈ 
S | A s = v } 请注意 等式 的 
第一 项 就是 原来 集合 的 熵 第二项 是 用 
A 分类 后熵的/nr 期望值 这个 第二项 描述 的 期望 熵 
就是 每个 子集 的 熵 的 加权 和 权值 | 
Sv | / | | 为 属于 的 样例 占 
原始 样例 的 比例 所以 Gain S A 是 由于 
知道 属性 A 的 值 而 导致 的 期望 熵 
减少 换句话 来讲 Gain S A 是 由于 给定 属性 
A 的 值 而 得到 的 关于 目标 函数值 的 
信息 例如 假定 S 是 一套 有关 天气 的 训练 
样例 描述 它 的 属性 包括 可能 是 具有 Weak 
和 Strong 两个 值 的 Wind 像前 面 一样 假定 
S 包含 14 个 样例 9 + 5 在 这 
14 个 样例 中 假定 正 例 中的 6 个 
和 反例 中的 2 个 有 Wind = Weak 其他 
的 有 Wind = Strong 由于 按照 属性 Wind 分类 
14 个 样例 得到 的 信息 增益 可以 计算 如下 
实验 举例 训练样本 D1 Sunny Hot High Weak No D2 
Sunny Hot High Strong No D3 Overcast Hot High Weak 
Yes D4 Rain Mild High Weak Yes D5 Rain Cool 
Normal Weak Yes D6 Rain Cool Normal Strong No D7 
Overcast Cool Normal Strong Yes D8 Sunny Mild High Weak 
No D9 Sunny Cool Normal Weak Yes D10 Rain Mild 
Normal Weak Yes D11 Sunny Mild Normal Strong Yes D12 
Overcast Mild High Strong Yes D13 Overcast Hot Normal Weak 
Yes D14 Rain Mild High Strong No 测试 样本 D1 
Sunny Hot High Weak D2 Sunny Hot High Strong D3 
Overcast Hot High Weak D4 Rain Mild High Weak D5 
Rain Cool Normal Weak D6 Rain Cool Normal Strong D7 
Overcast Cool Normal Strong D8 Sunny Mild High Weak D9 
Sunny Cool Normal Weak D10 Rain Mild Normal Weak D11 
Sunny Mild Normal Strong D12 Overcast Mild High Strong D13 
Overcast Hot Normal Weak D14 Rain Mild High Strong 头文件 
head . h # ifndef ID3 _ H _ INCLUDED 
# define ID3 _ H _ INCLUDED # include map 
# include fstream # include vector # include set # 
include iostream # include cmath using namespace std const int 
DataRow = 14 const int DataColumn = 6 const int 
testRow = 14 const int testColumn = 5 struct Node 
{ double value / / 标签 值 1 为 YES 
0 为 No int attrid / / 属性 标号 int 
attrvalue / / 属性值 vector Node * childNode } # 
endif / / ID3 _ H _ INCLUDEDC + + 
代码 # include id3 . h string DataTable DataRow DataColumn 
/ / 保存 训练 样例 string TestTable testRow DataColumn / 
/ 保存 测试 样例 map string int string2int set int 
S set int Attributes string attrName DataColumn = { Day 
OutLook Temperature Humidity Wind PlayTennis } string attrValue DataColumn DataColumn 
= { { } { Sunny Overcast Rain } / 
/ sunny 1 overcast 2 rain3 { Hot Mild Cool 
} / / hot 1 mild 2 cool 3 { 
High Normal } / / High 1 normal 2 { 
Weak Strong } / / weak 1 strong 2 { 
Yes No } / / yes 1 no 2 } 
int attrCount DataColumn = { 14 3 3 2 2 
2 } double lg2 double n { return log n 
/ log 2 } void Init / / 初始化 { 
ifstream fin dataset . txt for int i = 0 
i DataRow + + i { for int j = 
0 j DataColumn + + j { fin DataTable i 
j } } fin . close for int i = 
1 i = DataColumn 1 + + i { string2int 
attrName i = i for int j = 0 j 
attrCount i + + j string2int attrValue i j = 
j } for int i = 0 i DataRow i 
+ + . insert i for int i = 1 
i = DataColumn 2 i + + Attributes . insert 
i } double Entropy const set int & s / 
/ 计算 熵值 { double yes = 0 no = 
0 for set int size _ type i = 1 
i s . size i + + { if string2int 
DataTable i DataColumn 1 = = 0 yes + + 
else no + + } if no = = 0 
| | yes = = 0 return 0 double Py 
= yes / s . size double Pn = no 
/ s . size double ans = 1 * Py 
* lg2 Py + 1 * Pn * lg2 Pn 
return ans } double Gain const set int & s 
int attrid / / 计算 信息 增益值 { double ans 
= 0 int attrcount = attrCount attrid double sumEntropy = 
Entropy s set int * pset = new set int 
attrcount for set int const _ iterator iter = s 
. begin iter = s . end iter + + 
{ pset string2int DataTable * iter attrid . insert * 
iter } for int i = 0 i attrcount i 
+ + { ans = double pset i . size 
/ double s . size * Entropy pset i } 
return sumEntropy ans } int F i n d e 
r B e s t A t t r i 
b u t e const set int & s const 
set int & attr / / 找到 最佳 分类 属性 
{ double maxg = 0 int k = 1 for 
set int const _ iterator iter = attr . begin 
iter = attr . end + + iter { double 
tem = Gain s * iter if tem maxg { 
maxg = tem k = * iter } } int 
sum = s . size sum = attr . size 
if k = = 1 cout F i n d 
e r B e s t A t t r 
i b u t e Error endl return k } 
Node * Id3 _ solution set int s set int 
attr { Node * now = new Node now value 
= 1 if attr . empty return NULL int yes 
= 0 no = 0 sum = s . size 
for set int iterator iter = s . begin iter 
= s . end iter + + { if DataTable 
* iter DataColumn 1 = = Yes yes + + 
else no + + } if yes = = sum 
| | no = = sum { now value = 
yes / sum return now } int bestattrid = F 
i n d e r B e s t A 
t t r i b u t e s attr 
/ / 找到 最佳 的 分类 属性 now attrid = 
bestattrid attr . erase attr . find bestattrid vector set 
int child = vector set int attrCount bestattrid for set 
int iterator iter = s . begin iter = s 
. end iter + + / / 插入 孩子 结点 
{ int id = string2int DataTable * iter bestattrid child 
id . insert * iter } for int i = 
0 i child . size i + + / / 
对孩子 结点 进行 递归调用 { Node * rel = Id3 
_ solution child i attr rel attrvalue = i now 
childNode . push _ back rel } return now } 
void test Node * Root / / 用 测试 样例 
进行 测试 { Node * pnow = Root ifstream fin 
test . txt for int i = 0 i testRow 
i + + { for int j = 0 j 
testColumn j + + fin TestTable i j } fin 
. close for int i = 0 i testRow i 
+ + { pnow = Root while true { if 
pnow value = = 1 { TestTable i DataColumn 1 
= yes break } else if pnow value = = 
0 { TestTable i DataColumn 1 = no break } 
for vector Node * iterator iter = pnow childNode . 
begin iter = pnow childNode . end + + iter 
{ if * iter attrvalue = = string2int TestTable i 
pnow attrid { pnow = * iter break } } 
} } } int main { Init Node * Root 
= Id3 _ solution S Attributes test Root for int 
i = 0 i testRow i + + { for 
int j = 0 j DataColumn j + + cout 
TestTable i j cout endl } return 0 } 结果 
