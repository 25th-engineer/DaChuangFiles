Spark 机器学习 之 协同 过滤 算法 一 协同 过滤 1.1 
概念 协同 过滤 是 一种 借助 集体 计算 的 途径 
它 利用 大量 已有 的 用户 偏好 来 估计 用户 
对其 未 接触 过 的 物品 的 喜好 程度 其 
内在 思想 是 相似 度 的 定义 1.2 分类 1 
. 在 基于 用户 的 方法 的 中 如果 两个 
用户 表现出 相似 的 偏好 即对 相同 物品 的 偏好 
大体 相同 那就 认为 他们 的 兴趣 类似 要 对 
他们 中 的 一个 用户 推荐 一个 未知 物品 便可 
选取 若干 与其 类似 的 用户 并 根据 他们 的 
喜好 计算出 对 各个 物品 的 综合 得分 再以 得分 
来 推荐 物品 其 整体 的 逻辑 是 如果 其他 
用户 也 偏好 某些 物品 那 这些 物品 很可能 值得 
推荐 2 . 同样 也 可以 借助 基于 物品 的 
方法 来 做 推荐 这种方法 通常 根据 现有 用户 对 
物品 的 偏好 或是 评级 情况 来 计算 物品 之间 
的 某种 相似 度 这时 相似 用户 评级 相同 的 
那些 物品 会 被 认为 更 相近 一旦 有了/nr 物品 
之间 的 相似 度 便 可用 用户 接触 过 的 
物品 来 表示 这个 用户 然后 找出 和 这些 已知 
物品 相似 的 那些 物品 并 将 这些 物品 推荐 
给 用户 同样 与 已有 物品 相似 的 物品 被 
用来 生成 一个 综合 得分 而 该 得分 用于 评估 
未知 物品 的 相似 度 二 矩阵 分解 Spark 推荐 
模型库 当前 只 包含 基于 矩阵 分解 matrix factorization 的 
实现 由此 我们 也 将 重点 关注 这类 模型 它们 
有 吸引 人 的 地方 首先 这些 模型 在 协同 
过滤 中 的 表现 十分 出色 而在 Netflix Prize 等 
知名 比赛 中 的 表现 也很 拔尖 1 显 式 
矩阵 分解 要 找到 和 用户  物品 矩阵 近似 
的 k 维 低阶 矩阵 最终 要求 出 如下 两个 
矩阵 一个 用于 表示 用户 的 U × k 维 
矩阵 以及 一个 表征 物品 的 I × k 维 
矩阵 这 两个 矩阵 也 称作 因子 矩阵 它们 的 
乘积 便是 原始 评级 矩阵 的 一个 近似 值得 注意 
的 是 原始 评级 矩阵 通常 很 稀疏 但 因子 
矩阵 却是 稠密 的 特点 因子 分解 类 模型 的 
好处 在于 一旦 建立 了 模型 对 推荐 的 求解 
便 相对 容易 但也 有 弊端 即 当 用户 和 
物品 的 数量 很多 时 其 对应 的 物品 或 
是 用户 的 因子 向量 可能 达到 数以百万计 这 将在 
存储 和 计算 能力 上 带来 挑战 另 一个 好处 
是 这类 模型 的 表现 通常 都很/nr 出色 2 隐式 
矩阵 分解 关联 因子 分 确定 可能 随时 会 变化 
隐式 模型 仍然会 创建 一个 用户 因子 矩阵 和 一个 
物品 因子 矩阵 但是 模型 所 求解 的 是 偏好 
矩阵 而非 评级 矩阵 的 近似 类 似地 此时 用户 
因子 向量 和 物品 因子 向量 的 点积 所 得到 
的 分数 也 不再 是 一个 对 评级 的 估值 
而是 对 某个 用户 对 某一 物品 偏好 的 估值 
该 值 的 取值 虽 并不 严格 地 处于 0 
到 1 之间 但 十分 趋近 于 这个 区间 3 
最小二乘 法 Alternating Least Squares     ALS 解决 矩阵 
分解 的 最优化 方法 ALS 的 实现 原理 是 迭代 
式 求解 一系列 最小二乘 回归 问题 在 每一次 迭 代时 
固定 用户 因子 矩阵 或是 物品 因子 矩阵 中 的 
一个 然后 用 固定 的 这个 矩阵 以及 评级 数据 
来 更新 另一个 矩阵 之后 被 更新 的 矩阵 被 
固定 住 再 更新 另外 一个 矩阵 如此 迭代 直到 
模型 收敛 或是 迭代 了 预 设好 的 次数 三 
Spark 下 ALS 算法 的 应用 1 数据 来源 电 
影集 ml 100k2 代码 实现 基于 用户 相似 度 片段 
代码 val movieFile = sc . textFile fileName val RatingDatas 
= movieFile . map _ . split \ t . 
take 3 / / 转为 Ratings 数据 val ratings = 
RatingDatas . map x = Rating x 0 . toInt 
x 1 . toInt x 2 . toDouble / / 
获取 用户 评价 模型 设置 k 因子 和 迭代 次数 
隐藏 因子 lambda 获取 模型 val model = ALS . 
train ratings 50 10 0.01 / / 基于 用户 相似 
度 推荐 println userNumber + model . userFeatures . count 
+ \ t + productNum + model . productFeatures . 
count / / 指定 用户 及 商品 输出 预测值 println 
model . predict 789 123 / / 为 指定 用户 
推荐 的 前 N 商品 model . r e c 
o m m e n d P r o d 
u c t s 789 11 . foreach println _ 
/ / 为 每个 人 推荐 前 十个 商品 model 
. r e c o m m e n d 
P r o d u c t s F o 
r U s e r s 10 . take 1 
. foreach { case x rating = println rating 0 
} 基于 商品 相似 度 代码 计算 相似 度 的 
方法 有 相似 度 是 通过 某种 方式 比较 表示 
两个 物品 的 向量 而 得到 的 常见 的 相似 
度 衡量 方法 包括 皮尔森 相关系数 Pearson correlation 针对 实数 
向量 的 余弦 相似 度 cosine similarity 和 针对 二元 
向量 的 杰 卡德 相似系数 Jaccard similarity val itemFactory = 
model . productFeatures . lookup 567 . head val itemVector 
= new DoubleMatrix itemFactory / / 求 余弦 相似 度 
val sim = model . productFeatures . map { case 
id factory = val factorVector = new DoubleMatrix factory val 
sim = cosineSimilarity factorVector itemVector id sim } val sortedsim 
= sim . top 11 Ordering . by Int Double 
Double { case id sim = sim } println sortedsim 
. take 10 . mkString \ n def cosineSimilarity vec1 
DoubleMatrix vec2 DoubleMatrix Double = { vec1 . dot vec2 
/ vec1 . norm2 * vec2 . norm2 } 均方差 
评估 模型 代码 / / 模型 评估 通过 均 误差 
/ / 实际 用户 评估值 val actualRatings = ratings . 
map { case Rating user item rats = user item 
rats } val userItems = ratings . map { case 
Rating user item rats = user item } / / 
模型 的 用户 对 商品 的 预测 值 val predictRatings 
= model . predict userItems . map { case Rating 
user item rats = user item rats } / / 
联合 获取 rate 值 val rates = actualRatings . join 
predictRatings . map { case x = x . _ 
2 . _ 1 x . _ 2 . _ 
2 } / / 求 均方差 val r e g 
r e s s i o n M e t 
r i c s = new R e g r 
e s s i o n M e t r 
i c s rates //i //i 越/d 接近/v 0/m 越佳/nr 
println r e g r e s s i o 
n M e t r i c s . meanSquaredError 
全局 准确率 评估 MAP 使用 MLlib 的 RankingMetrics 类 来 
计算 基于 排名 的 评估 指标 类 似地 需要 向 
我们 之前 的 平均 准确率 函数 传入 一个 键值 对 
类型 的 RDD 其 键 为 给定 用户 预测 的 
推荐 物品 的 ID 数组 而 值 则是 实际 的 
物品 ID 数组 / / 全局 平均 准确率 MAP val 
itemFactors = model . productFeatures . map { case id 
factor = factor } . collect val itemMatrix = new 
DoubleMatrix itemFactors / / 分布式 广播 商品 的 特征 矩阵 
val imBroadcast = sc . broadcast itemMatrix / / 计算 
每 一个 用户 的 推荐 在 这个 操作 里 会对 
用户 因子 矩阵 和 电影 因子 矩阵 做 乘积 其 
结果 为 一个 表示 各个 电影 预计 评级 的 向量 
长度 为 / / 1682 即 电影 的 总数 目 
val allRecs = model . userFeatures . map { case 
userId array = val userVector = new DoubleMatrix array val 
scores = imBroadcast . value . mmul userVector val sortedWithId 
= scores . data . zipWithIndex . sortBy _ . 
_ 1 val recommendedIds = sortedWithId . map _ . 
_ 2 + 1 . toSeq / / + 1 
矩阵 从0/nr 开始 userId recommendedIds } / / 实际 评分 
val userMovies = ratings . map { case Rating user 
product rating = user product } . groupBy _ . 
_ 1 val p r e d i c t 
e d A n d T r u e F 
o r R a n k i n g = 
allRecs . join userMovies . map { case userId predicted 
actualWithIds = val actual = actualWithIds . map _ . 
_ 2 predicted . toArray actual . toArray } / 
/ 求 MAP 越大 越 好吧 val rankingMetrics = new 
RankingMetrics p r e d i c t e d 
A n d T r u e F o r 
R a n k i n g println Mean Average 
Precision = + rankingMetrics . m e a n A 
v e r a g e P r e c 
i s i o n 详细 代码 package com . 
spark . milb . study import org . apache . 
log4j . { Level Logger } import org . apache 
. spark . mllib . evaluation . { RankingMetrics R 
e g r e s s i o n M 
e t r i c s } import org . 
apache . spark . mllib . recommendation . { ALS 
Rating } import org . apache . spark . { 
SparkConf SparkContext } import org . jblas . DoubleMatrix / 
* * * Created by hadoop on 17 5 3 
. * 协同 过滤 处理 对象 movie 使用 算法 ALS 
最小二乘 法 实现 用户 推荐 * 余弦 相似 度 实现 
商品 相似 度 推荐 * / object cfTest { def 
main args Array String Unit = { Logger . getLogger 
org . apache . spark . setLevel Level . WARN 
Logger . getLogger org . eclipse . jetty . server 
. setLevel Level . OFF val conf = new SparkConf 
. setMaster local . setAppName AlsTest val sc = new 
SparkContext conf CF sc ml 100k / u . data 
} def CF sc SparkContext fileName String Unit = { 
val movieFile = sc . textFile fileName val RatingDatas = 
movieFile . map _ . split \ t . take 
3 / / 转为 Ratings 数据 val ratings = RatingDatas 
. map x = Rating x 0 . toInt x 
1 . toInt x 2 . toDouble / / 获取 
用户 评价 模型 设置 k 因子 和 迭代 次数 隐藏 
因子 lambda 获取 模型 / * *  rank 对应 
ALS 模型 中 的 因子 个数 也 就是 在 低阶 
近似 矩阵 中的 隐含 特征 个数 因子 个 数 一般 
越多越好 但/c 它/r 也会/i 直接影响/i 模型/n 训练/vn 和/c 保存/v 时/n 
所需/n 的/uj 内存/n 开销/v 尤其 是 在 用户 和 物品 
很多 的 时候 因此 实践 中 该 参数 常 作为 
训练 效果 与 系统 开销 之间 的 调节 参数 通 
常 其 合理 取值 为 10 到 200 iterations 对应 
运行时 的 迭代 次数 ALS 能 确保 每次 迭代 都能 
降低 评级 矩阵 的 重建 误 差 但/c 一般/a 经少/nr 
数次/m 迭代/v 后/f ALS/w 模型/n 便/d 已能/i 收敛/v 为/p 一个/m 
比较/d 合理/vn 的/uj 好/a 模型/n 这样 大部分 情况下 都 没必要 
迭代 太 多次 10次 左右 一般 就 挺好 lambda 该 
参数 控制 模型 的 正则化 过程 从而 控制 模型 的 
过拟合 情况 其 值 越高 正则 化 越 严厉 该 
参数 的 赋值 与 实际 数据 的 大小 特征 和 
稀疏 程度 有关 和 其他 的 机器学习 模型 一样 正则参数 
应该 通过 用 非样本 的 测试数据 进行 交叉 验证 来 
调整 * * / val model = ALS . train 
ratings 50 10 0.01 / / 基于 用户 相似 度 
推荐 println userNumber + model . userFeatures . count + 
\ t + productNum + model . productFeatures . count 
/ / 指定 用户 及 商品 输出 预测值 println model 
. predict 789 123 / / 为 指定 用户 推荐 
的 前 N 商品 model . r e c o 
m m e n d P r o d u 
c t s 789 11 . foreach println _ / 
/ 为 每个 人 推荐 前 十个 商品 model . 
r e c o m m e n d P 
r o d u c t s F o r 
U s e r s 10 . take 1 . 
foreach { case x rating = println rating 0 } 
/ / 基于 商品 相似 度 使用 余弦 相似 度 
进行 推荐 获取 某个 商品 的 特征 值 val itemFactory 
= model . productFeatures . lookup 567 . head val 
itemVector = new DoubleMatrix itemFactory / / 求 余弦 相似 
度 val sim = model . productFeatures . map { 
case id factory = val factorVector = new DoubleMatrix factory 
val sim = cosineSimilarity factorVector itemVector id sim } val 
sortedsim = sim . top 11 Ordering . by Int 
Double Double { case id sim = sim } println 
sortedsim . take 10 . mkString \ n / / 
模型 评估 通过 均 误差 / / 实际 用户 评估值 
val actualRatings = ratings . map { case Rating user 
item rats = user item rats } val userItems = 
ratings . map { case Rating user item rats = 
user item } / / 模型 的 用户 对 商品 
的 预测 值 val predictRatings = model . predict userItems 
. map { case Rating user item rats = user 
item rats } / / 联合 获取 rate 值 val 
rates = actualRatings . join predictRatings . map { case 
x = x . _ 2 . _ 1 x 
. _ 2 . _ 2 } / / 求 
均方差 val r e g r e s s i 
o n M e t r i c s = 
new R e g r e s s i o 
n M e t r i c s rates //i 
//i 越/d 接近/v 0/m 越佳/nr println r e g r 
e s s i o n M e t r 
i c s . meanSquaredError / / 全局 平均 准确率 
MAP val itemFactors = model . productFeatures . map { 
case id factor = factor } . collect val itemMatrix 
= new DoubleMatrix itemFactors / / 分布式 广播 商品 的 
特征 矩阵 val imBroadcast = sc . broadcast itemMatrix / 
/ 计算 每 一个 用户 的 推荐 在 这个 操作 
里 会对 用户 因子 矩阵 和 电影 因子 矩阵 做 
乘积 其 结果 为 一个 表示 各个 电影 预计 评级 
的 向量 长度 为 / / 1682 即 电影 的 
总数 目 val allRecs = model . userFeatures . map 
{ case userId array = val userVector = new DoubleMatrix 
array val scores = imBroadcast . value . mmul userVector 
val sortedWithId = scores . data . zipWithIndex . sortBy 
_ . _ 1 val recommendedIds = sortedWithId . map 
_ . _ 2 + 1 . toSeq / / 
+ 1 矩阵 从0/nr 开始 userId recommendedIds } / / 
实际 评分 val userMovies = ratings . map { case 
Rating user product rating = user product } . groupBy 
_ . _ 1 val p r e d i 
c t e d A n d T r u 
e F o r R a n k i n 
g = allRecs . join userMovies . map { case 
userId predicted actualWithIds = val actual = actualWithIds . map 
_ . _ 2 predicted . toArray actual . toArray 
} / / 求 MAP 越大 越 好吧 val rankingMetrics 
= new RankingMetrics p r e d i c t 
e d A n d T r u e F 
o r R a n k i n g println 
Mean Average Precision = + rankingMetrics . m e a 
n A v e r a g e P r 
e c i s i o n } / / 
余弦 相似 度 计算 def cosineSimilarity vec1 DoubleMatrix vec2 DoubleMatrix 
Double = { vec1 . dot vec2 / vec1 . 
norm2 * vec2 . norm2 } } View Code 