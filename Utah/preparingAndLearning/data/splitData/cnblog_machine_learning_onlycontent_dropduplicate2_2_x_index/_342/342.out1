假期 结束 你 的 状态 有 没有 回归 那么 放空 
脑袋 后 先来 学习 学习 欢迎 大家 继续 关注 腾讯 
云 技术 社区 作者 赵 成龙 这是 一篇 很 难写 
的 文章 因为 我 希望 这 篇 文章 能对/nr 大家 
有所 帮助 我 不会 给 大家 介绍 机器学习 数据挖掘 的 
行业 背景 也 不会 具体 介绍 逻辑 回归 SVM GBDT 
神经 网络 等 学习 算法 的 理论 依据 和 数学 
推导 本文 更多 的 是 在 流程 化 上 帮助 
大家 快速 的 入门 机器学习 和 数据 建模 本文 主要 
分为 四 个 部分 限于 时间 关系 会 分为 上下 
两篇 上篇 准备 篇 主要 涉及 环境 搭建 以及 pandas 
基本知识 应用 篇 我会 以 kaggle 上 的 Titanic 为例 
从 数据源 获取 数据 清洗 特征 处理 模型 选择 模型 
输出 与 运用 下篇 优化 篇 介绍 了 几种 优化 
的 方法 思考 篇 提出 几个 困扰 我 的 问题 
希望 能 得到 大家 的 帮助 吧 一 准备 篇 
1 环境 搭建 整个 sklearn 的 实验 环境 是 python 
2.7 + pycharm + Anaconda 2 pandas 基础 这里 只能 
大家 介绍 下 面会 用到 的 pandas 知识 有兴趣 的 
可以 去 具体 的 学习 给 大家 推荐 一本 参考书 
Python for Data Analysis 有 基础 的 可以 直接 跳到 
应用 篇 pandas 主要 会 用到 Series 和 DataFrame 两种 
数据结构 Series 像是 一维 的 数组 而 DataFrame 更像 是 
一种 二维 的 表 结构 Series 的 构造方法 label = 
1 0 1 0 1 data = pd . Series 
data = label index = a b c d e 
dtype = int name = label print dataSeries 取 数据 
通过 index 取 数 data a data a b DataFrame 
的 构造 1 以 字典 的 形式 构造 frame = 
pd . DataFrame { name Time Jack Lily Age 20 
30 12 weight 56.7 64.0 50.0 } 2 由 DataFrame 
构建 DataFrameframe1 = pd . DataFrame frame columns = name 
Age 从 frame 中 读 取了 两列 构成 新的 DataFrame 
DataFrame 的 操作 1 增加 列 frame1 friends _ num 
= 10 12 14 2 删除 列 frame2 = frame1 
. drop name Age axis = 1 3 查找 数据 
行 frame1 frame1 friends _ num 10 结果 如下 DataFrame 
的 统计 方法 1 apply 配合 lambda 处理 列 如 
将 frame1 的 Age 列 进行 分段 frame1 Age _ 
group = frame1 Age . apply lambda x 0 if 
x 20 else 1 2 describe 输出 统计 信息 非常 
强大 frame1 . describe 给 出了 8个 统计量 对 我们 
的 数据 处理 特别 有用 有个/nr 问题 直接 使用 describe 
方法 只能 统计 数值 类 的 列 对于 字符 类 
的 变量 没有 统计 加个 参数 就行 frame1 . describe 
include = O 3 缺失 值 处理 pandas 对 缺失 
值 一般 填充 NAN # 以 0 填充 缺失 值 
frame1 . fillna 0 # 丢掉 任何 包含 NAN 的 
行 frame1 . dropna # 删除 全为 nan 的 行 
frame1 . dropna how = all 二 应用 篇 1 
数据 读取 本例 以 Titanic 作为 数据源 大家 可以 在 
附件 获取 到 数据 data = pd . DataFrame pd 
. read _ csv train _ path data _ test 
= pd . DataFrame pd . read _ csv test 
_ path data _ test = data _ test Pclass 
Name Sex Age SibSp Parch Ticket Fare Cabin Embarked x 
= data Pclass Name Sex Age SibSp Parch Ticket Fare 
Cabin Embarked y = data Survived print x . describe 
print x . describe include = O print data _ 
test . describe print data _ test . describe include 
= O 数据 的 初始 统计 信息 2 数据 清洗 
1 缺失 值 处理 Age 和 Embarked 列 存在 少量 
缺失 值 分别 处理 # 用 众数 填充 缺失 值 
data _ set Embarked = data _ set Embarked . 
fillna S # 用 均值 填充 Age 缺失 值 data 
_ set Age = data _ set Age . fillna 
data _ set Age . mean 2 删除 缺失 率 
较大 的 列 初步 处理 时 Cabin 列 的 缺失 
率 达到 了 75% 删除 改 列 data _ set 
= data _ set . drop Cabin axis = 1 
3 特征 处理 特征 处理 是 基于 具体 的 数据 
的 所以在 特征 处理 之前 要 对 数据 做 充分 
的 理解 特征 处理 没有 固定 方法 之说 主要 靠 
个人 的 经验 与 观察 通过 不断 的 尝试 和 
变换 以 期望 挖掘出 较好 的 特征 变量 所以 说 
特征 处理 是 模型 建立 过程 中 最 耗时 和 
耗神 的 工作 1 单 变量 特征提取 # 根据 name 
的 长度 抽象 出 name _ len 特征 data _ 
set name _ len = data _ set Name . 
apply len 观察 name 列 通过观察 Name 列 数据 可以 
发现 名字 中 带有 性别 和 婚否 的 称谓 信息 
提取 这些 信息 可能 是 有用 的 特征 data _ 
set name _ class = data _ set Name . 
apply lambda x x . split 1 . apply lambda 
x x . split 0 2 多 变量 的 组合 
sibsp 代表 兄弟 姐妹 和 配偶 的 数量 parch 代表/n 
父母/n 和/c 子女/n 的/uj 数量/n 因此/c 可以/c 将/d sibsp/w 和/c 
parch/w 结合/v 获得/v 家庭/n 成员/n 的/uj 数量/n data/w _/i set/w 
family _ num = data _ set Parch + data 
_ set SibSp + 13 名义 变量 转 数值 变量 
# Embarked data _ set Embarked = data _ set 
Embarked . map { S 1 C 2 Q 3 
} . astype int # Sex data _ set Sex 
= data _ set Sex . apply lambda x 0 
if x = = male else 1 4 数据 分段 
根据 统计 信息 和 经验 分段 # 7.91 14.45 31.0 
根据 Fare 的 统计 信息 进行 分段 data _ set 
Fare = data _ set Fare . apply lambda x 
cutFeature 7.91 14.45 31.0 x # 18 48 64 按照 
经验 分段 data _ set Age = data _ set 
Age . apply lambda x cutFeature 18 48 64 x 
简单 的 数据 处理 后 我们 得到 了 如下 12 
维 数据 4 模型 选择 与 测试 初步 选取 了 
5种 模型 进行 试验 R a n d o m 
F o r e s t C l a s 
s i f i e r E x t r 
a T r e e s C l a s 
s i f i e r A d a B 
o o s t C l a s s i 
f i e r G r a d i e 
n t B o o s t i n g 
C l a s s i f i e r 
V C 模型 参数 # 随机 森林 rf _ params 
= { n _ jobs 1 n _ estimators 500 
warm _ start True # max _ features 0.2 max 
_ depth 6 min _ samples _ leaf 2 max 
_ features sqrt verbose 0 } # Extra Trees 随机 
森林 et _ params = { n _ jobs 1 
n _ estimators 500 # max _ features 0.5 max 
_ depth 8 min _ samples _ leaf 2 verbose 
0 } # AdaBoost ada _ params = { n 
_ estimators 500 learning _ rate 0.75 } # GBDT 
gb _ params = { n _ estimators 500 # 
max _ features 0.2 max _ depth 5 min _ 
samples _ leaf 2 verbose 0 } # SVC svc 
_ params = { kernel linear C 0.025 } 模型 
选择 代码 classifiers = rf _ model R a n 
d o m F o r e s t C 
l a s s i f i e r * 
* rf _ params et _ model E x t 
r a T r e e s C l a 
s s i f i e r * * et 
_ params ada _ model A d a B o 
o s t C l a s s i f 
i e r * * ada _ params gb _ 
model G r a d i e n t B 
o o s t i n g C l a 
s s i f i e r * * gb 
_ params svc _ model SVC * * svc _ 
params heldout = 0.95 0.90 0.75 0.50 0.01 rounds = 
20 xx = 1 . np . array heldout for 
name clf in classifiers print training % s % name 
rng = np . random . RandomState 42 yy = 
for i in heldout yy _ = for r in 
range rounds X _ train _ turn X _ test 
_ turn y _ train _ turn y _ test 
_ turn = \ train _ test _ split x 
_ train labels _ train test _ size = i 
random _ state = rng clf . fit X _ 
train _ turn y _ train _ turn y _ 
pred = clf . predict X _ test _ turn 
yy _ . append 1 np . mean y _ 
pred = = y _ test _ turn yy . 
append np . mean yy _ plt . plot xx 
yy label = name plt . legend loc = upper 
right plt . xlabel Proportion train plt . ylabel Test 
Error Rate plt . show 选择 结果 如下 从 上图 
可以 看出 randomForest 的 一般 表现 要 优于 其他 算法 
初步 选择 randomforest 算法 模型 的 在 训练 集上 的 
表现 def modelScore x _ train labels _ train x 
_ test y _ test model _ name et _ 
params print % s % model _ name model = 
model _ name * * et _ params model . 
fit x _ train labels _ train if feature _ 
importances _ in dir model print model . feature _ 
importances _ print classification _ report labels _ train model 
. predict x _ train print classification _ report y 
_ test model . predict x _ test return model 
modelScore x _ train labels _ train x _ test 
y _ test R a n d o m F 
o r e s t C l a s s 
i f i e r rf _ params 训练 集 
的 混淆 矩阵 如 下图 测试 集 的 混淆 矩阵 
如 下图 到此 初步 的 学习 模型 就 建立 起来 
了 测试 集 的 准确度 为 83% 由于 时间 关系 
优化 篇 和 思考 篇 将 放在 下篇 文章 与 
大家 分享 敬请期待 如有 任何 错误 或 疑问 欢迎 大家 
留言 期待 与 大家 共同 成长 共同进步 温馨提示 文章 相关 
的 资料 请 阅读 原文 获取 相关 阅读 机器学习 从 
入门 到 第一 个 模型 机器学习 概念 总结 笔记 四 
当 强化 学习 遇见 泛函分析 此文 已由 作者 授权 腾讯 
云 技术 社区 发布 转载 请 注明 文章 出处 原文 
链接 https / / cloud . tencent . com / 
community / article / 229506 