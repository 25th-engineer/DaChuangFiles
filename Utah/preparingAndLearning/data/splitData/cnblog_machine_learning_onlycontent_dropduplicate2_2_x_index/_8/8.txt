---------------------------------------------------------------------------------------
本系列文章为《机器学习实战》学习笔记，内容整理自书本，网络以及自己的理解，如有错误欢迎指正。
源码在Python3.5上测试均通过，代码及数据 --> https://github.com/Wellat/MLaction
---------------------------------------------------------------------------------------
1、算法概述
1.1 朴素贝叶斯
朴素贝叶斯是使用概率论来分类的算法。其中朴素：各特征条件独立；贝叶斯：根据贝叶斯定理。
根据贝叶斯定理，对一个分类问题，给定样本特征x，样本属于类别y的概率是：
-------（1）
在这里，x 是一个特征向量，设 x 维度为 M。因为朴素的假设，即特征条件独立，根据全概率公式展开，上式可以表达为：
这里，只要分别估计出，特征 Χi 在每一类的条件概率就可以了。类别 y 的先验概率可以通过训练集算出，同样通过训练集上的统计，可以得出对应每一类上的，条件独立的特征对应的条件概率向量。
1.2 算法特点
优点：在数据较少的情况下仍然有效，可以处理多类别问题。
缺点：对于输入数据的准备方式较为敏感。
适用数据类型：标称型数据。
2、使用Python进行文本分类
要从文本中获取特征，需要先拆分文本。可以把词条想象为单词，也可以使用非单词词条，如URL、IP地址或者任意其他字符串。然后将每一个文本片段表示为一个词条向量，其中值为1表示词条出现在文档中，0表示词条未出现。
2.1 准备数据：从文本中构建词向量
1 from numpy import * 2 3 def loadDataSet(): 4 ''' 5 postingList: 进行词条切分后的文档集合 6 classVec:类别标签 7 ''' 8 postingList=[['my', 'dog', 'has', 'flea', 'problems', 'help', 'please'], 9 ['maybe', 'not', 'take', 'him', 'to', 'dog', 'park', 'stupid'], 10 ['my', 'dalmation', 'is', 'so', 'cute', 'I', 'love', 'him'], 11 ['stop', 'posting', 'stupid', 'worthless', 'garbage'], 12 ['mr', 'licks', 'ate', 'my', 'steak', 'how', 'to', 'stop', 'him'], 13 ['quit', 'buying', 'worthless', 'dog', 'food', 'stupid']] 14 classVec = [0,1,0,1,0,1] #1代表侮辱性文字，0代表正常言论 15 return postingList,classVec 16 17 def createVocabList(dataSet): 18 vocabSet = set([])#使用set创建不重复词表库 19 for document in dataSet: 20 vocabSet = vocabSet | set(document) #创建两个集合的并集 21 return list(vocabSet) 22 23 def setOfWords2Vec(vocabList, inputSet): 24 returnVec = [0]*len(vocabList)#创建一个所包含元素都为0的向量 25 #遍历文档中的所有单词，如果出现了词汇表中的单词，则将输出的文档向量中的对应值设为1 26 for word in inputSet: 27 if word in vocabList: 28 returnVec[vocabList.index(word)] = 1 29 else: print("the word: %s is not in my Vocabulary!" % word) 30 return returnVec 31 ''' 32 我们将每个词的出现与否作为一个特征，这可以被描述为词集模型(set-of-words model)。 33 如果一个词在文档中出现不止一次，这可能意味着包含该词是否出现在文档中所不能表达的某种信息, 34 这种方法被称为词袋模型(bag-of-words model)。 35 在词袋中，每个单词可以出现多次，而在词集中，每个词只能出现一次。 36 为适应词袋模型，需要对函数setOfWords2Vec稍加修改，修改后的函数称为bagOfWords2VecMN 37 ''' 38 def bagOfWords2VecMN(vocabList, inputSet): 39 returnVec = [0]*len(vocabList) 40 for word in inputSet: 41 if word in vocabList: 42 returnVec[vocabList.index(word)] += 1 43 return returnVec
2.2 训练算法：从词向量计算概率
计算每个类别的条件概率，伪代码：
1 def trainNB0(trainMatrix,trainCategory): 2 ''' 3 朴素贝叶斯分类器训练函数(此处仅处理两类分类问题) 4 trainMatrix:文档矩阵 5 trainCategory:每篇文档类别标签 6 ''' 7 numTrainDocs = len(trainMatrix) 8 numWords = len(trainMatrix[0]) 9 pAbusive = sum(trainCategory)/float(numTrainDocs) 10 #初始化所有词出现数为1，并将分母初始化为2，避免某一个概率值为0 11 p0Num = ones(numWords); p1Num = ones(numWords)# 12 p0Denom = 2.0; p1Denom = 2.0 # 13 for i in range(numTrainDocs): 14 if trainCategory[i] == 1: 15 p1Num += trainMatrix[i] 16 p1Denom += sum(trainMatrix[i]) 17 else: 18 p0Num += trainMatrix[i] 19 p0Denom += sum(trainMatrix[i]) 20 #将结果取自然对数，避免下溢出，即太多很小的数相乘造成的影响 21 p1Vect = log(p1Num/p1Denom)#change to log() 22 p0Vect = log(p0Num/p0Denom)#change to log() 23 return p0Vect,p1Vect,pAbusive
2.3 测试算法
分类函数：
1 def classifyNB(vec2Classify, p0Vec, p1Vec, pClass1): 2 ''' 3 分类函数 4 vec2Classify:要分类的向量 5 p0Vec, p1Vec, pClass1:分别对应trainNB0计算得到的3个概率 6 ''' 7 p1 = sum(vec2Classify * p1Vec) + log(pClass1) 8 p0 = sum(vec2Classify * p0Vec) + log(1.0 - pClass1) 9 if p1 > p0: 10 return 1 11 else: 12 return 0
测试：
1 def testingNB(): 2 listOPosts,listClasses = loadDataSet() 3 myVocabList = createVocabList(listOPosts) 4 trainMat=[] 5 for postinDoc in listOPosts: 6 trainMat.append(setOfWords2Vec(myVocabList, postinDoc)) 7 #训练模型，注意此处使用array 8 p0V,p1V,pAb = trainNB0(array(trainMat),array(listClasses)) 9 testEntry = ['love', 'my', 'dalmation'] 10 thisDoc = array(setOfWords2Vec(myVocabList, testEntry)) 11 print(testEntry,'classified as: ',classifyNB(thisDoc,p0V,p1V,pAb)) 12 testEntry = ['stupid', 'garbage'] 13 thisDoc = array(setOfWords2Vec(myVocabList, testEntry)) 14 print(testEntry,'classified as: ',classifyNB(thisDoc,p0V,p1V,pAb))
3、实例：使用朴素贝叶斯过滤垃圾邮件
一般流程：
3.1 切分文本
将长字符串切分成词表，包括将大写字符转换成小写，并过滤字符长度小于3的字符。
1 def textParse(bigString):# 2 ''' 3 文本切分 4 输入文本字符串，输出词表 5 ''' 6 import re 7 listOfTokens = re.split(r'\W*', bigString) 8 return [tok.lower() for tok in listOfTokens if len(tok) > 2] 9
3.2 使用朴素贝叶斯进行垃圾邮件分类
1 def spamTest(): 2 ''' 3 垃圾邮件测试函数 4 ''' 5 docList=[]; classList = []; fullText =[] 6 for i in range(1,26): 7 #读取垃圾邮件 8 wordList = textParse(open('email/spam/%d.txt' % i,'r',encoding= 'utf-8').read()) 9 docList.append(wordList) 10 fullText.extend(wordList) 11 #设置垃圾邮件类标签为1 12 classList.append(1) 13 wordList = textParse(open('email/ham/%d.txt' % i,'r',encoding= 'utf-8').read()) 14 docList.append(wordList) 15 fullText.extend(wordList) 16 classList.append(0) 17 vocabList = createVocabList(docList)#生成次表库 18 trainingSet = list(range(50)) 19 testSet=[] # 20 #随机选10组做测试集 21 for i in range(10): 22 randIndex = int(random.uniform(0,len(trainingSet))) 23 testSet.append(trainingSet[randIndex]) 24 del(trainingSet[randIndex]) 25 trainMat=[]; trainClasses = [] 26 for docIndex in trainingSet:#生成训练矩阵及标签 27 trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex])) 28 trainClasses.append(classList[docIndex]) 29 p0V,p1V,pSpam = trainNB0(array(trainMat),array(trainClasses)) 30 errorCount = 0 31 #测试并计算错误率 32 for docIndex in testSet: 33 wordVector = bagOfWords2VecMN(vocabList, docList[docIndex]) 34 if classifyNB(array(wordVector),p0V,p1V,pSpam) != classList[docIndex]: 35 errorCount += 1 36 print("classification error",docList[docIndex]) 37 print('the error rate is: ',float(errorCount)/len(testSet)) 38 #return vocabList,fullText
4、实例：使用朴素贝叶斯分类器从个人广告中获取区域倾向
一般流程：
在这个中，我们将分别从美国的两个城市中选取一些人，通过分析这些人发布的征婚广告信息，来比较这两个城市的人们在广告用词上是否不同 。
4.1 实现代码
1 ''' 2 函数localWords()与程序清单中的spamTest()函数几乎相同，区别在于这里访问的是 3 RSS源而不是文件。然后调用函数calcMostFreq()来获得排序最高的30个单词并随后将它们移除 4 ''' 5 def localWords(feed1,feed0): 6 import feedparser 7 docList=[]; classList = []; fullText =[] 8 minLen = min(len(feed1['entries']),len(feed0['entries'])) 9 for i in range(minLen): 10 wordList = textParse(feed1['entries'][i]['summary']) 11 docList.append(wordList) 12 fullText.extend(wordList) 13 classList.append(1) #NY is class 1 14 wordList = textParse(feed0['entries'][i]['summary']) 15 docList.append(wordList) 16 fullText.extend(wordList) 17 classList.append(0) 18 vocabList = createVocabList(docList)#create vocabulary 19 top30Words = calcMostFreq(vocabList,fullText) #remove top 30 words 20 for pairW in top30Words: 21 if pairW[0] in vocabList: vocabList.remove(pairW[0]) 22 trainingSet = list(range(2*minLen)); testSet=[] #create test set 23 for i in range(10): 24 randIndex = int(random.uniform(0,len(trainingSet))) 25 testSet.append(trainingSet[randIndex]) 26 del(trainingSet[randIndex]) 27 trainMat=[]; trainClasses = [] 28 for docIndex in trainingSet:#train the classifier (get probs) trainNB0 29 trainMat.append(bagOfWords2VecMN(vocabList, docList[docIndex])) 30 trainClasses.append(classList[docIndex]) 31 p0V,p1V,pSpam = trainNB0(array(trainMat),array(trainClasses)) 32 errorCount = 0 33 for docIndex in testSet: #classify the remaining items 34 wordVector = bagOfWords2VecMN(vocabList, docList[docIndex]) 35 if classifyNB(array(wordVector),p0V,p1V,pSpam) != classList[docIndex]: 36 errorCount += 1 37 print('the error rate is: ',float(errorCount)/len(testSet)) 38 return vocabList,p0V,p1V 39 40 def calcMostFreq(vocabList,fullText): 41 ''' 42 返回前30个高频词 43 ''' 44 import operator 45 freqDict = {} 46 for token in vocabList: 47 freqDict[token]=fullText.count(token) 48 sortedFreq = sorted(freqDict.items(), key=operator.itemgetter(1), reverse=True) 49 return sortedFreq[:30] 50 51 if __name__== "__main__": 52 #导入RSS数据源 53 import operator 54 ny=feedparser.parse('http://newyork.craigslist.org/stp/index.rss') 55 sf=feedparser.parse('http://sfbay.craigslist.org/stp/index.rss') 56 localWords(ny,sf)