简言 机器 学习 的 项目 不可避免 的 需要 补充 一些 
优化 算法 对于 优化 算法 爬山 算法 还是 比较 重要 
的 . 鉴于此 花了 些 时间 仔细 阅读 了 些 
爬山 算法 的 paper . 基于 这些 做 一些 总结 
. 目录 1 . 爬山 算法 简单 描述 2 . 
爬山 算法 的 主要 算法 2.1 首选 爬山 算法 2.2 
  最 陡 爬山 算法 2.3 随机 重新 开始 爬山 
算法 2.4 模拟 退火算法 也是 爬山 算法 3 .   
实例 求解 正文 爬山 算法 是 一种 局部 贪心 的 
最优 算法 . 该 算法 的 主要 思想 是 每次 
拿 相邻 点 与 当前 点 进行 比对 取 两者 
中 较 优者 作为 爬坡 的 下一步 . 举 一个 
例子 求解 下面 表达式 的 最大值 . 且 假设 x 
y 均按 为 0.1 间隔 递增 . 为了 更好 的 
描述 我们 先 使用 pyhton 画出 该 函数 的 图像 
图像 的 python 代码 1 # encoding utf8 2 from 
matplotlib import pyplot as plt 3 import numpy as np 
4 from mpl _ toolkits . mplot3d import Axes3D 5 
6 7 def func X Y x _ move = 
0 y _ move = 0 8 def mul X 
Y alis = 1 9 return alis * np . 
exp X * X + Y * Y 10 11 
return mul X Y + mul X x _ move 
Y y _ move 2 12 13 14 def show 
X Y 15 fig = plt . figure 16 ax 
= Axes3D fig 17 X Y = np . meshgrid 
X Y 18 Z = func X Y 1.7 1.7 
19 plt . title demo _ hill _ climbing 20 
ax . plot _ surface X Y Z rstride = 
1 cstride = 1 cmap = rainbow 21 ax . 
set _ xlabel x label color = r 22 ax 
. set _ ylabel y label color = g 23 
ax . set _ zlabel z label color = b 
24 # 具体 函数 方法 可用 help function 查看 如 
help ax . plot _ surface 25 # ax . 
scatter X Y Z c = r # 绘 点 
26 plt . show 27 28 if _ _ name 
_ _ = = _ _ main _ _ 29 
X = np . arange 2 4 0.1 30 Y 
= np . arange 2 4 0.1 31 32 show 
X Y View Code 对于 上面 这个 问题 我们 使用 
爬山 算法 该 如何 求解 呢   下面 我们 从 
爬山 算法 中的 几种 方式 分别 求解 一下 这个 小题 
. 1 . 首选 爬山 算法 依次 寻找 该点 X 
的 邻近 点中 首次 出现 的 比 点 X 价值 
高的点/nr 并将 该点 作为 爬山 的 点 此处 说 的 
价值 高 在 该 题中 是 指 Z 或 f 
x y 值 较大 . 依次 循环 直至 该点 的 
邻近 点中 不再 有比 其 大 的 点 . 我们 
成为 该 点 就是 山的/nr 顶点 又 称为 最 优点 
. 那么 解题 思路 就有 1 .   随机 选择 
一个 登山 的 起点 x0 y0 z0 并 以此 为 
起点 开始 登山 . 直至 登顶 . 下面 是 我们 
实现 的 代码 1 # encoding utf8 2 from random 
import random randint 3 4 from matplotlib import pyplot as 
plt 5 import numpy as np 6 from mpl _ 
toolkits . mplot3d import Axes3D 7 8 9 def func 
X Y x _ move = 1.7 y _ move 
= 1.7 10 def mul X Y alis = 1 
11 return alis * np . exp X * X 
+ Y * Y 12 13 return mul X Y 
+ mul X x _ move Y y _ move 
2 14 15 16 def show X Y Z 17 
fig = plt . figure 18 ax = Axes3D fig 
19 plt . title demo _ hill _ climbing 20 
ax . plot _ surface X Y Z rstride = 
1 cstride = 1 cmap = rainbow 21 ax . 
set _ xlabel x label color = r 22 ax 
. set _ ylabel y label color = g 23 
ax . set _ zlabel z label color = b 
24 # ax . scatter X Y Z c = 
r # 绘 点 25 plt . show 26 27 
28 def drawPaht X Y Z px py pz 29 
fig = plt . figure 30 ax = Axes3D fig 
31 plt . title demo _ hill _ climbing 32 
ax . plot _ surface X Y Z rstride = 
1 cstride = 1 cmap = rainbow 33 ax . 
set _ xlabel x label color = r 34 ax 
. set _ ylabel y label color = g 35 
ax . set _ zlabel z label color = b 
36 ax . plot px py pz r . # 
绘 点 37 plt . show 38 39 40 def 
hill _ climb X Y 41 global _ X = 
42 global _ Y = 43 44 len _ x 
= len X 45 len _ y = len Y 
46 # 随机 登山 点 47 st _ x = 
randint 0 len _ x 1 48 st _ y 
= randint 0 len _ y 1 49 50 def 
argmax stx sty alisx = 0 alisy = 0 51 
cur = func X 0 st _ x Y st 
_ y 0 52 next = func X 0 st 
_ x + alisx Y st _ y + alisy 
0 53 54 return cur next and True or False 
55 56 while len _ x st _ x = 
0 or len _ y st _ y = 0 
57 if st _ x + 1 len _ x 
and argmax st _ x st _ y 1 58 
st _ x + = 1 59 elif st _ 
y + 1 len _ x and argmax st _ 
x st _ y 0 1 60 st _ y 
+ = 1 61 elif st _ x = 1 
and argmax st _ x st _ y 1 62 
st _ x = 1 63 elif st _ y 
= 1 and argmax st _ x st _ y 
0 1 64 st _ y = 1 65 else 
66 break 67 global _ X . append X 0 
st _ x 68 global _ Y . append Y 
st _ y 0 69 return global _ X global 
_ Y func X 0 st _ x Y st 
_ y 0 70 71 72 if _ _ name 
_ _ = = _ _ main _ _ 73 
X = np . arange 2 4 0.1 74 Y 
= np . arange 2 4 0.1 75 X Y 
= np . meshgrid X Y 76 Z = func 
X Y 1.7 1.7 77 px py maxhill = hill 
_ climb X Y 78 print px py maxhill 79 
drawPaht X Y Z px py func np . array 
px np . array py 1.7 1.7 View Code 对比 
几次 运行 的 结果 从上 图中 我们 可以 比较 清楚 
的 观察 到 首选 爬山 算法 的 缺陷 . 2 
. 那么 最 陡 爬山 算法 呢 简单 描述 最 
陡 爬山 算法 是 在 首选 爬山 算 法上 的 
一种 改良 它 规定 每次 选取 邻近 点价 值 最大 
的 那个 点 作为 爬上 的 点 . 下面 我们 
来 实现 一下 它 1 # encoding utf8 2 from 
random import random randint 3 4 from matplotlib import pyplot 
as plt 5 import numpy as np 6 from mpl 
_ toolkits . mplot3d import Axes3D 7 8 9 def 
func X Y x _ move = 1.7 y _ 
move = 1.7 10 def mul X Y alis = 
1 11 return alis * np . exp X * 
X + Y * Y 12 13 return mul X 
Y + mul X x _ move Y y _ 
move 2 14 15 16 def show X Y Z 
17 fig = plt . figure 18 ax = Axes3D 
fig 19 plt . title demo _ hill _ climbing 
20 ax . plot _ surface X Y Z rstride 
= 1 cstride = 1 cmap = rainbow 21 ax 
. set _ xlabel x label color = r 22 
ax . set _ ylabel y label color = g 
23 ax . set _ zlabel z label color = 
b 24 # ax . scatter X Y Z c 
= r # 绘 点 25 plt . show 26 
27 28 def drawPaht X Y Z px py pz 
29 fig = plt . figure 30 ax = Axes3D 
fig 31 plt . title demo _ hill _ climbing 
32 ax . plot _ surface X Y Z rstride 
= 1 cstride = 1 cmap = rainbow 33 ax 
. set _ xlabel x label color = r 34 
ax . set _ ylabel y label color = g 
35 ax . set _ zlabel z label color = 
b 36 ax . plot px py pz r . 
# 绘 点 37 plt . show 38 39 40 
def hill _ climb X Y 41 global _ X 
= 42 global _ Y = 43 44 len _ 
x = len X 45 len _ y = len 
Y 46 # 随机 登山 点 47 st _ x 
= randint 0 len _ x 1 48 st _ 
y = randint 0 len _ y 1 49 50 
def argmax stx sty alisx alisy 51 cur = func 
X 0 stx Y sty 0 52 next = func 
X 0 alisx Y alisy 0 53 if cur next 
54 return alisx alisy 55 return stx sty 56 # 
return cur next and alisx alisy or stx sty 57 
58 tmp _ x = st _ x 59 tmp 
_ y = st _ y 60 while len _ 
x st _ x = 0 or len _ y 
st _ y = 0 61 if st _ x 
+ 1 len _ x 62 tmp _ x tmp 
_ y = argmax tmp _ x tmp _ y 
st _ x + 1 st _ y 63 64 
if st _ x = 1 65 tmp _ x 
tmp _ y = argmax tmp _ x tmp _ 
y st _ x 1 st _ y 66 67 
if st _ y + 1 len _ x 68 
tmp _ x tmp _ y = argmax tmp _ 
x tmp _ y st _ x st _ y 
+ 1 69 70 if st _ y = 1 
71 tmp _ x tmp _ y = argmax tmp 
_ x tmp _ y st _ x st _ 
y 1 72 73 if tmp _ x = st 
_ x or tmp _ y = st _ y 
74 st _ x = tmp _ x 75 st 
_ y = tmp _ y 76 else 77 break 
78 global _ X . append X 0 st _ 
x 79 global _ Y . append Y st _ 
y 0 80 return global _ X global _ Y 
func X 0 st _ x Y st _ y 
0 81 82 83 if _ _ name _ _ 
= = _ _ main _ _ 84 X = 
np . arange 2 4 0.1 85 Y = np 
. arange 2 4 0.1 86 X Y = np 
. meshgrid X Y 87 Z = func X Y 
1.7 1.7 88 px py maxhill = hill _ climb 
X Y 89 print px py maxhill 90 drawPaht X 
Y Z px py func np . array px np 
. array py 1.7 1.7 View Code 从 这个 结果 
来看 因为 范围 扩大 了 一点 所以 效果 会好 一点点 
当 依旧 是 一个 局部 最优 算法 . 3 . 
随机 重新 开始 爬山 算法 呢 简单 的 描述 随机 
重新 开始 爬山 算法 是 基于 最 陡 爬山 算法 
其实 就是 加 一个 达到 全局 最优 解的/nr 条件 如果 
满足 该 条件 就 结束 运算 反之 则 无限 次 
重复 运算 最 陡 爬山 算法 . 由于 此 题 
并 没有 结束 的 特征 条件 我们 这里 就 不给予 
实现 . 4 . 模拟 退火算法 简单 描述 1 随机 
挑选 一个 单元 k 并给 它 一个 随机 的 位移 
求出 系统 因此 而 产生 的 能量 变化 Δ Ek 
2 若 Δ Ek ⩽ 0 该 位移 可采纳 而 
变化 后的/nr 系统 状态 可 作为 下 次 变化 的 
起点 若 Δ Ek 0 位移 后的/nr 状态 可采纳 的 
概率 为 式 中 T 为 温度 然后 从 0 
1 区间 均匀分布 的 随机数 中 挑选 一个 数 R 
若 R Pk 则将 变化 后的/nr 状态 作为 下次 的 
起点 否则 将 变化 前 的 状态 作为 下次 的 
起点 3 转 第 1 步 继续执行 知道 达到 平衡 
状态 为止 代码 实现 为 1 # encoding utf8 2 
from random import random randint 3 4 from matplotlib import 
pyplot as plt 5 import numpy as np 6 from 
mpl _ toolkits . mplot3d import Axes3D 7 8 9 
def func X Y x _ move = 1.7 y 
_ move = 1.7 10 def mul X Y alis 
= 1 11 return alis * np . exp X 
* X + Y * Y 12 13 return mul 
X Y + mul X x _ move Y y 
_ move 2 14 15 16 def show X Y 
Z 17 fig = plt . figure 18 ax = 
Axes3D fig 19 plt . title demo _ hill _ 
climbing 20 ax . plot _ surface X Y Z 
rstride = 1 cstride = 1 cmap = rainbow 21 
ax . set _ xlabel x label color = r 
22 ax . set _ ylabel y label color = 
g 23 ax . set _ zlabel z label color 
= b 24 # ax . scatter X Y Z 
c = r # 绘 点 25 plt . show 
26 27 28 def drawPaht X Y Z px py 
pz 29 fig = plt . figure 30 ax = 
Axes3D fig 31 plt . title demo _ hill _ 
climbing 32 ax . plot _ surface X Y Z 
rstride = 1 cstride = 1 color = b 33 
ax . set _ xlabel x label color = r 
34 ax . set _ ylabel y label color = 
g 35 ax . set _ zlabel z label color 
= b 36 ax . plot px py pz r 
. # 绘 点 37 plt . show 38 39 
40 def hill _ climb X Y 41 global _ 
X = 42 global _ Y = 43 # 初始 
温度 44 temperature = 105.5 45 # 温度 下降 的 
比率 46 delta = 0.98 47 # 温度 精确度 48 
tmin = 1e 10 49 50 len _ x = 
len X 51 len _ y = len Y 52 
53 # 随机 登山 点 54 st _ x = 
X 0 randint 0 len _ x 1 55 st 
_ y = Y randint 0 len _ y 1 
0 56 st _ z = func st _ x 
st _ y 57 58 def argmax stx sty alisx 
alisy 59 cur = func st _ x st _ 
y 60 next = func alisx alisy 61 62 return 
cur next and True or False 63 64 while temperature 
tmin 65 # 随机 产生 一个 新的 邻 近点 66 
# 说明 温度 越高 幅度 邻 近点 跳跃 的 幅度 
越大 67 tmp _ x = st _ x + 
random * 2 1 * temperature 68 tmp _ y 
= st _ y + + random * 2 1 
* temperature 69 if 4 tmp _ x = 2 
and 4 tmp _ y = 2 70 if argmax 
st _ x st _ y tmp _ x tmp 
_ y 71 st _ x = tmp _ x 
72 st _ y = tmp _ y 73 else 
# 有 机会 跳出 局域 最优 解 74 pp = 
1.0 / 1.0 + np . exp func tmp _ 
x tmp _ y func st _ x st _ 
y / temperature 75 if random pp 76 st _ 
x = tmp _ x 77 st _ y = 
tmp _ y 78 temperature * = delta # 以 
一定 的 速率 下降 79 global _ X . append 
st _ x 80 global _ Y . append st 
_ y 81 return global _ X global _ Y 
func st _ x st _ y 82 83 84 
if _ _ name _ _ = = _ _ 
main _ _ 85 X = np . arange 2 
4 0.1 86 Y = np . arange 2 4 
0.1 87 X Y = np . meshgrid X Y 
88 Z = func X Y 1.7 1.7 89 px 
py maxhill = hill _ climb X Y 90 print 
px py maxhill 91 drawPaht X Y Z px py 
func np . array px np . array py 1.7 
1.7 View Code 效果 