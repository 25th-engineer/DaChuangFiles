在 本 章中 我们 将 展示 两个 独立 的 例子 
一个 用于 人脸 检测 另 一个 用于 动态 检测 以及 
如何 快速 地 将 这些 功能 添加到 应用 程序 中 
在 这 一章 中 我们 将 讨论 面部 检测 动态 
检测 将 检测 添加到 应用 程序 中 面部 检测 人脸 
检测 是 人脸 识别 的 第一 部分 如果 你 不能 
从 屏幕 上 的 所有 东西 中 识别 出 一个 
或 多个 人脸 那么 你 将 永远 无法 识别 那是 
谁 的 脸 首先 让 我们 看 一张 我们 的 
应用 程序 截图 上 图中 通过 摄像头 我们 已经 捕获 
到 一张 图像 接下来 启用 面部 跟踪 看看 会 发生 
什么 物体 面部 特征 正在 被 追踪 我们 在 物体 
周围 看到 的 是 面部 追踪器 白色 线框 它 告诉 
我们 我们 这里 有 一张 脸 以及 我们 的 角度 
探测器 红线 它 提供 了 一些 关于 我们 脸 所处 
水平 方向 的 参考 当 我们 移动 物体 时 面部 
追踪器 和 角度 探测器 会 追踪 他 这 一切 都 
很好 但是 如果 我们 在 真实 的 人 脸上 启用 
面部 跟踪 会 发生 什么 呢 如 下图 面部 追踪器 
和 角度 探测器 正在 追踪 人 的 面部 当 我们 
把 头 从 一边 移到 另一边 时 面部 追踪器 会 
跟踪 这个 动作 可以 看到 角度 探测器 会 根据 它 
所 识别 的 面部 水平 角度 进行 调整 可以 看到 
在 这里 我们 的 颜色 是 黑白 的 而 不是 
彩色 的 因为 这 是 一个 直方图 的 反向 投影 
而且 它 是 一个 可以 更改 的 选项 即使 我们 
远离 摄像机 让 其他 物体 也 进入 视野 中 面部 
追踪器 也能 在 诸多 噪音 中 跟踪 我们 的 脸 
如下 图 所示 这 正是 我们 在 电影 中 看到 
的 面部 识别 系统 的 工作 原理 尽管 它 更为 
先进 现在 让 我们 深入 程序 内部 看看 它 到底 
是 如何 工作 的 首先 我们 需要 问 自己 一个 
问题 我们 想 要 解决 的 问题 到底 是 什么 
到底 是 人脸识别 还是 人脸 检测 这里 不得不 提到 Viola 
Jones 算法 因为 首先/d 它/r 有/v 很高/i 的/uj 检出率/n 和/c 
很低/i 的/uj 误报率/n 然后 它 非常 擅长 对 数据 的 
实时处理 最终 要 的 一点 是 它 非常 善于 从非/nr 
人脸 中 分别出 人脸 要 永远 记住 人脸 检测 只是 
人脸 识别 的 第一 步 这个 算法 要求 输入 一个 
完整 的 正面 垂直 的 脸 脸部 需要 直接 指向 
采集 设备 头部 尽量 不要 歪 不要 昂头 或 低头 
这里 有 必要 在 强调 一次 我们 要 做 的 
只是 在 图像 中 检测 出 人脸 即可 我们 的 
算法 需要 经过 四 个 步骤 来 完成 这件事 Haar 
特征选择 创建 一个 完整 的 图像 AdaBoost 算法 通过 迭代 
弱 分类器 而 产生 最终 的 强 分类器 的 算法 
训练 分类器 级联 分类器 在 正式 开始 之前 让 我们 
先 捋 一捋 面部 检测 到底 是 如果 工作 的 
所有 的 脸 无论是 人 的 动物 的 还是 其他 
的 都有/nr 一些/m 相似/v 的/uj 特征/n 例如 都有/nr 一个/m 鼻子/n 
两个 鼻孔 一 张嘴巴 两个 眼睛 两个 耳朵 等等 我们 
的 算法 通过 Haar 特征 来 匹配 这些 内容 我们 
可以 通过 其中 任 一项 找到 其他 的 特征 但是 
我们 这里 会 遇到 一个 问题 在 一个 24x24 像素 
的 窗口 中 一 共有 162336个 可能 的 特征 如果 
这个 计算 结果 是 正确 的 那么 计算 他们 的 
时间 和 成本 将 非常 之高 因此 我们 将 会 
使用 一种 被 称为 adaptive boosting 自适应 提升 法 的 
算法 或者 更为 常见 的 AdaBoost 算法 如果 你 研究 
过 机器学习 我 相信 你 听说 过 一种 叫做 boosting 
提升 的 技术 我们 的 学习 算法 将 使用 AdaBoost 
来 选择 最好 的 特征 并 训练 分类器 来 使用 
它们 AdaBoost 可以 与 许多 类型 的 学习 算法 一起 
使用 并且 被 业界 认为 是 许多 需要 增强 的 
任务 的 最佳 开箱 即用 算法 通常在 切换 到 另一种 
算法 并对 其 进行 基准测试 之前 您/zg 不会/v 注意/v 到/v 
它/r 有/v 多好/i 和/c 多快/i 实际上 这种 区别 是 非常 
明显 的 在 继续 之前 我们 先 来 了解 一下 
什么 是 boosting 提升 技术 Boosting 从 其他 弱 学习 
算法 中 获取 输出 并 将其 与 weighted sum 加权 
和 结合 加权 和是/nr boost 分类器 的 最终 输出 AdaBoost 
的 自适应 部分 来自 于 这样 一个 事实 即 后续 
的 学习者 被 调整 以 支持 那些 被 以前 的 
分类器 错误 分类 的 实例 与 其他 算法 相比 该 
算法 更 倾向 于对/nr 数据 进行 过拟合 所以 AdaBoost 对 
噪声 数据 和 异常值 很 敏感 因此 我们 在 准备 
数据 的 时候 需要 格外 注意 这 一点 现在 让 
我们 来 看看 示例 中的 程序 到底 是 如何 工作 
的 对于 这个 示例 我们 将 再次 使用 Accord 框架 
首先 创建 一个 FaceHaarCascade 对象 该 对象 包含 一系列 Haarlike 
的 特征 的 弱 分类 阶段 的 集合 每个 阶段 
都 包含 一组 分类器 树 这些 分类器 树 将在 决策 
过程 中 使用 FaceHaarCascade 自动 为 我们 创建 了 所有 
这些 阶段 和树/nr 而 不 需要 我们 去 关心 具体 
实现 的 细节 首先 需要 在 底层 构建 一个 决策树 
它 将为 每个 阶段 提供 节点 并为 每个 特性 提供 
数值 以下 是 Accord 的 部分 源码 List HaarCascadeStage stages 
= new List HaarCascadeStage List HaarFeatureNode nodes HaarCascadeStage stage stage 
= new HaarCascadeStage 0 . 822689414024353 nodes = new List 
HaarFeatureNode nodes . Add new { new HaarFeatureNode 0 . 
0 0 4 0 1 4 1 9 5 8 
7 4 3 3 3 3 8 2 0 . 
0337941907346249 0 . 8378106951713562 new int { 3 7 14 
4 1 } new int { 3 9 14 2 
2 } } nodes . Add new { new HaarFeatureNode 
0 . 0151513395830989 0 . 1514132022857666 0 . 7488812208175659 new 
int { 1 2 18 4 1 } new int 
{ 7 2 6 4 3 } } nodes . 
Add new { new HaarFeatureNode 0 . 0 0 4 
2 1 0 9 9 3 1 8 1 9 
1 4 0 9 1 0 . 0900492817163467 0 . 
6374819874763489 new int { 1 7 15 9 1 } 
new int { 1 10 15 3 3 } } 
一旦 构建 完成 我们 就 可以 使用 cascade 对象 来 
创建 H a a r O b j e c 
t D e t e c t o r 这 
就是 我们 将 用于 检测 的 对象 接下来 我们 需要 
提供 我们 的 面部 级联 对象 搜索 对象 时 使用 
的 最小 窗口 大小 我们 的 搜索 模式 假设 我们 
只 搜索 一个 对象 在 搜索 期间 重新 缩放 搜索 
窗口 时要/nr 使用 的 重新 缩放 因子 HaarCascade cascade = 
new FaceHaarCascade detector = new H a a r O 
b j e c t D e t e c 
t o r cascade 25 O b j e c 
t D e t e c t o r e 
a r c h M o d e . Single 
1.2 f O b j e c t D e 
t e c t o r c a l i 
n g M o d e . GreaterToSmaller 现在 我们 
需要 准备 数据 在 本 示例 中 我们 将 使用 
笔记本 电脑 上 的 摄像头 捕获 所有 图像 然而 Accord 
. NET framework 使得 使用 其他 源 进行 数据采集 变得 
很 容易 例如 avi 文件 jpg 文件 等等 接下来 连接 
摄像头 选择 分辨率 / / 创建 视频 源 V i 
d e o C a p t u r e 
D e v i c e videoSource = new V 
i d e o C a p t u r 
e D e v i c e form . VideoDevice 
/ / 设置 帧 的 大小 videoSource . VideoResolution = 
selectResolution videoSource / / / summary / / / 获取 
帧 的 大小 / / / / summary / / 
/ param name = videoSource 视频 源 / param / 
/ / returns 帧 的 大小 / returns private V 
i d e o C a p a b i 
l i t i e s selectResolution V i d 
e o C a p t u r e D 
e v i c e videoSource { foreach var cap 
in videoSource . V i d e o C a 
p a b i l i t i e s 
{ if cap . FrameSize . Height = = 240 
return cap if cap . FrameSize . Width = = 
320 return cap } return videoSource . V i d 
e o C a p a b i l i 
t i e s . Last } 在 这个 演示 
中 你 会 注意 到 检测 物体 正对着 摄像机 在 
背景 中 还有 一些 其他 的 东西 那 就是 所谓 
的 随机噪声 这样 做 是 为了 展示 人脸 检测 算法 
是 如何 区分 出 脸 的 如果 我们 的 探测器 
不 能 处理 这些 它 就 会在 噪声 中 消失 
从而 无法 检测 到 脸 随着 视频 源 的 加入 
我们 需要 在 接收 到 新的 视频 帧 时 得到 
通知 以便 处理 它 应用 标记 等等 我们 通过 频 
源 播放器 的 NewFrameReceived 事件 来 实现 这 一点 \/i 
在/p 我们/r 已经/d 有了/nr 一个/m 视频/n 源/ng 和/c 一个/m 视频/n 
让/v 我们/r 看看/v 每当/p 我们/r 被/p 通知/v 有/v 一个/m 新/a 
的/uj 视频/n 帧/q 可用/v 时/n 发生/v 了/ul 什么/r 我们 需要 
做 的 第一 件事 是 对 图像 进行 采样 以使 
它 更容易 工作 R e s i z e N 
e a r e s t N e i g 
h b o r resize = new R e s 
i z e N e a r e s t 
N e i g h b o r 160 120 
UnmanagedImage downsample = resize . Apply im 如果 我们 没有 
找到 一张 脸 我们 将 保持 跟踪 模式 等待 一个 
具有 可 检测 面部 的 帧 一旦 我们 找到 了 
面部 区域 我们 需要 重置 跟踪器 定位 脸部 减小 它 
的 大小 以 尽可能 的 剔除 背景噪声 然后 初始化 跟踪器 
并将 在 图像 上 进行 标记 代码 如下 Rectangle regions 
= detector . ProcessFrame downsample if regions = null & 
& regions . Length 0 { tracker . Reset / 
/ 跟踪 第一张 脸 Rectangle face = regions 0 / 
/ 减小 人脸 检测 的 大小 避免 跟踪 背景 上 
的 其他 内容 Rectangle window = new Rectangle int regions 
0 . X + regions 0 . Width / 2f 
* xscale int regions 0 . Y + regions 0 
. Height / 2f * yscale 1 1 window . 
Inflate int 0.2 f * regions 0 . Width * 
xscale int 0.4 f * regions 0 . Height * 
yscale if tracker = null { tracker . SearchWindow = 
window tracker . ProcessFrame im } marker = new RectanglesMarker 
window marker . ApplyInPlace im eventArgs . Frame = im 
. ToManagedImage tracking = true } else { detecting = 
true } 一旦 检测 到 脸 我们 的 图像 帧 
是 这样 的 如果把 头 偏向 一边 我们 现在 的 
形象 应该 是 这样 的 动态 检测 可以 看到 在 
上 一个 例子 中 我们 不仅 实现 了 面部 检测 
还 实现 了 动态 检测 现在 让 我们 把 目光 
转向 更大 的 范围 检测 任何 物体 的 运动 而 
不仅仅 是 面部 我们 将 继续 使用 Accord . NET 
来 实现 在 动态 检测 中 我们 会 用 红色 
高亮 显示 屏幕 上 的 任何 运动 移动 的 数量 
由 任何 一个 区域 的 红色 浓度 表示 所以 如下 
图 所示 我们 可以 看到 手指 在 移动 但是 其他 
的 都是 静止 的 如下 图 所示 可以 看到 整个 
手 的 移动 范围 在 增加 如下 图 所示 一旦 
整只 手 开始 移动 你 不仅 可以 看到 更多 的 
红色 而且 红色 的 总量 是 在 增加 的 如果 
不 希望 对 整个 屏幕 区域 进行 运动 处理 可以 
自定义 运动 区域 运动 检测 只会 发生 在 这些 区域 
如 下图 可以 看到 我们 已经 定义 了 一个 运动 
区域 这是 唯一 的 一个 区域 现在 如果 我们 在 
摄像头 前面 做 一些 运动 可以 看到 程序 只 检测 
到 了 来自 我们 定义 区域 发生 的 运动 现在 
我们 来 做 这样 一个 测试 在 我们 自定义 的 
检测 区域 范围内 放置 一个 物体 然后 我们 把手 放在 
这个 物体 后面/nr 进行 运动 当然 手 也是 在 这个 
自 定义 的 检测 区域 范围内 进行 运动 的 如 
下图 可以 看到 手 的 运动 被 检测 出来 了 
现在 我们 使用 另 一个 选项 网格 运动 突出 显示 
它 会 使得 检测 到 的 运动 区域 基于 定义 
的 网格 在 红色 方块 中 突出 显示 如下 图 
所示 将 检测 添加到 应用 程序 中 以下 是 处理 
接收 到 新的 帧 的 代码 private void v i 
d e o o u r c e P l 
a y e r _ NewFrame object sender N e 
w F r a m e E v e n 
t A r g s args { lock this { 
if motionDetector = null { float motionLevel = motionDetector . 
ProcessFrame args . Frame if motionLevel motionAlarmLevel { / / 
快门速度 2秒 flash = int 2 * 1000 / timer 
. Interval } / / 检查 对象 的 数 if 
motionDetector . M o t i o n P r 
o c e s s i n g A l 
g o r i t h m is B l 
o b C o u n t i n g 
O b j e c t s P r o 
c e s s i n g { B l 
o b C o u n t i n g 
O b j e c t s P r o 
c e s s i n g countingDetector = B 
l o b C o u n t i n 
g O b j e c t s P r 
o c e s s i n g motionDetector . 
M o t i o n P r o c 
e s s i n g A l g o 
r i t h m d e t e c 
t e d O b j e c t s 
C o u n t = countingDetector . ObjectsCount } 
else { d e t e c t e d 
O b j e c t s C o u 
n t = 1 } / / 积累 的 历史 
motionHistory . Add motionLevel if motionHistory . Count 300 { 
motionHistory . RemoveAt 0 } if 显示 运动 历史 T 
o o l t r i p M e n 
u I t e m . Checked D r a 
w M o t i o n H i s 
t o r y args . Frame } } } 
这里 的 关键 是 检测 视频 帧 中 发生 的 
动量 这 是 通过 以下 代码 完成 的 对于 本例 
我们 使用 的 是 两级 的 运动 报警 级别 但是 
你 也 可以 使用 任何 你 喜欢 的 级别 定义 
一旦 超过 这个 阈值 就 可以 实现 所需 的 逻辑 
例如 发送 电子邮件 开始 视频 捕获 等等 float motionLevel = 
motionDetector . ProcessFrame args . Frame if motionLevel motionAlarmLevel { 
/ / 快门速度 2秒 flash = int 2 * 1000 
/ timer . Interval } 总 结在 这 一章 中 
我们 学习 了 面部 和 动态 检测 还 展示 了 
一些 简单易用 的 代码 我们 可以 轻松 的 将 这些 
功能 添加 到 自己 的 程序 中 