在 机器 学习 用 于 产品 的 时候 我们 经常 
会 遇到 跨平台 的 问题 比如 我们 用 Python 基于 
一 系列 的 机器学习 库 训练 了 一个 模型 但是 
有时候 其他 的 产品 和 项目 想把 这个 模型 集成 
进去 但是 这些 产品 很多 只 支持 某些 特定 的 
生产 环境 比如 Java 为了 上 一个 机器学习 模型 去 
大动干戈 修改 环境 配置 很 不划算 此时 我们 就 可以 
考虑 用 预测模型 标记 语言 Predictive Model Markup Language 以下 
简称 PMML 来 实现 跨 平台 的 机器学习 模型 部署 
了 1 . PMML 概述 PMML 是 数据 挖掘 的 
一种 通用 的 规范 它 用 统一 的 XML 格式 
来 描述 我们 生成 的 机器学习 模型 这样 无论 你 
的 模型 是 sklearn R 还是 Spark MLlib 生成 的 
我们 都 可以 将 其 转化 为 标准 的 XML 
格式 来 存储 当 我们 需要 将 这个 PMML 的 
模型 用于 部署 的 时候 可以 使用 目标 环境 的 
解析 PMML 模型 的 库 来 加载 模型 并 做 
预测 可以 看出 要 使用 PMML 需要 两步 的 工作 
第 一块 是 将 离线 训练 得到 的 模型 转化 
为 PMML 模型 文件 第二块 是 将 PMML 模型 文件 
载入 在线 预测 环境 进行 预测 这两块 都 需要 相关 
的 库 支持 2 . PMML 模型 的 生成 和 
加载 相关 类库 PMML 模型 的 生成 相关 的 库 
需要 看 我们 使用 的 离线 训练 库 如果 我们 
使用 的 是 sklearn 那么 可以 使用 sklearn2pmml 这个 python 
库 来做 模型 文件 的 生成 这个 库 安装 很 
简单 使用 pip install sklearn2pmml 即可 相关 的 使用 我们 
后面 会 有一个 demo 如果 使用 的 是 Spark MLlib 
这个 库 有一些 模型 已经 自 带了 保存 PMML 模型 
的 方法 可惜 并不 全 如果 是 R 则 需要 
安装包 XML 和 PMML 此外 JAVA 库 JPMML 可以 用来 
生成 R SparkMLlib xgBoost Sklearn 的 模型 对应 的 PMML 
文件 github 地址 是 https / / github . com 
/ jpmml / jpmml 加载 PMML 模型 需要 目标 环境 
支持 PMML 加载 的 库 如果 是 JAVA 则 可以 
用 JPMML 来 加载 PMML 模型 文件 相关 的 使用 
我们 后面 会 有一个 demo 3 . PMML 模型 生成 
和 加载 示例 下面 我们 给 一个 示例 使用 sklearn 
生成 一个 决策树 模型 用 sklearn2pmml 生成 模型 文件 用 
JPMML 加载 模型 文件 并 做 预测 完整 代码 参见 
我 的 github https / / github . com / 
ljpzzz / machinelearning / blob / master / model in 
product / sklearn jpmml 首先 是 用用 sklearn 生成 一个 
决策树 模型 由于 我们 是 需要 保存 PMML 文件 所以 
最好 把 模型 先 放到 一个 Pipeline 数组 里面 这个 
数组 里面 除了 我们 的 决策 树 模型 以外 还 
可以 有 归一化 降 维 等 预处理 操作 这里 作为 
一个 示例 我们 Pipeline 数组 里面 只有 决策树 模型 代码 
如下 import numpy as np import matplotlib . pyplot as 
plt % matplotlib inline import pandas as pd from sklearn 
import tree from sklearn2pmml . pipeline import PMMLPipeline from sklearn2pmml 
import sklearn2pmml import os os . environ PATH + = 
os . pathsep + C / Program Files / Java 
/ jdk1 . 8.0 _ 171 / bin X = 
1 2 3 1 2 4 1 5 7 8 
3 6 4 8 4 7 2 5 6 9 
y = 0 1 0 2 1 pipeline = PMMLPipeline 
classifier tree . D e c i s i o 
n T r e e C l a s s 
i f i e r random _ state = 9 
pipeline . fit X y sklearn2pmml pipeline . \ demo 
. pmml with _ repr = True 上面 这段 代码 
做 了 一个 非常 简单 的 决策树 分类 模型 只有 
5个 训练样本 特征 有 4个 输出 类别 有 3个 实际 
应用 时 我们 需要 将 模型 调 参 完毕 后才 
将其 放入 PMMLPipeline 进行 保存 运行 代码 后 我们 在 
当前目录 会 得到 一个 PMML 的 XML 文件 可以 直接 
打开 看 内容 大概 如下 xml version = 1.0 encoding 
= UTF 8 standalone = yes PMML xmlns = http 
/ / www . dmg . org / PMML 4 
_ 3 version = 4.3 Header Application name = JPMML 
SkLearn version = 1 . 5.3 / Timestamp 2018 06 
24T05 47 17Z / Timestamp / Header MiningBuildTask Extension PMMLPipeline 
steps = classifier D e c i s i o 
n T r e e C l a s s 
i f i e r class _ weight = None 
criterion = gini max _ depth = None max _ 
features = None max _ leaf _ nodes = None 
min _ impurity _ decrease = 0.0 min _ impurity 
_ split = None min _ samples _ leaf = 
1 min _ samples _ split = 2 min _ 
weight _ fraction _ leaf = 0.0 presort = False 
random _ state = 9 splitter = best / Extension 
/ MiningBuildTask DataDictionary DataField name = y optype = categorical 
dataType = integer Value value = 0 / Value value 
= 1 / Value value = 2 / / DataField 
DataField name = x3 optype = continuous dataType = float 
/ DataField name = x4 optype = continuous dataType = 
float / / DataDictionary T r a n s f 
o r m a t i o n D i 
c t i o n a r y DerivedField name 
= double x3 optype = continuous dataType = double FieldRef 
field = x3 / / DerivedField DerivedField name = double 
x4 optype = continuous dataType = double FieldRef field = 
x4 / / DerivedField / T r a n s 
f o r m a t i o n D 
i c t i o n a r y TreeModel 
functionName = classification m i s s i n g 
V a l u e t r a t e 
g y = nullPrediction s p l i t C 
h a r a c t e r i s 
t i c = multiSplit MiningSchema MiningField name = y 
usageType = target / MiningField name = x3 / MiningField 
name = x4 / / MiningSchema Output OutputField name = 
probability 0 optype = continuous dataType = double feature = 
probability value = 0 / OutputField name = probability 1 
optype = continuous dataType = double feature = probability value 
= 1 / OutputField name = probability 2 optype = 
continuous dataType = double feature = probability value = 2 
/ / Output Node True / Node SimplePredicate field = 
double x3 operator = lessOrEqual value = 3.5 / Node 
score = 1 recordCount = 1.0 SimplePredicate field = double 
x3 operator = lessOrEqual value = 2.0 / c o 
r e D i s t r i b u 
t i o n value = 0 recordCount = 0.0 
/ c o r e D i s t r 
i b u t i o n value = 1 
recordCount = 1.0 / c o r e D i 
s t r i b u t i o n 
value = 2 recordCount = 0.0 / / Node Node 
score = 0 recordCount = 2.0 True / c o 
r e D i s t r i b u 
t i o n value = 0 recordCount = 2.0 
/ c o r e D i s t r 
i b u t i o n value = 1 
recordCount = 0.0 / c o r e D i 
s t r i b u t i o n 
value = 2 recordCount = 0.0 / / Node / 
Node Node score = 2 recordCount = 1.0 SimplePredicate field 
= double x4 operator = lessOrEqual value = 8.0 / 
c o r e D i s t r i 
b u t i o n value = 0 recordCount 
= 0.0 / c o r e D i s 
t r i b u t i o n value 
= 1 recordCount = 0.0 / c o r e 
D i s t r i b u t i 
o n value = 2 recordCount = 1.0 / / 
Node Node score = 1 recordCount = 1.0 True / 
c o r e D i s t r i 
b u t i o n value = 0 recordCount 
= 0.0 / c o r e D i s 
t r i b u t i o n value 
= 1 recordCount = 1.0 / c o r e 
D i s t r i b u t i 
o n value = 2 recordCount = 0.0 / / 
Node / Node / TreeModel / PMML 可以 看到 里面 
就是 决策树 模型 的 树结构 节点 的 各个 参数 以及 
输入 值 我们 的 输入 被 定义 为 x1 x4 
输出 定义 为 y 有了 PMML 模型 文件 我们 就 
可以 写 JAVA 代码 来 读取 加载 这个 模型 并 
做 预测 了 我们 创建 一个 Maven 或者 gradle 工程 
加入 JPMML 的 依赖 这里 给出 maven 在 pom . 
xml 的 依赖 gradle 的 结构 是 类似 的 dependency 
groupId org . jpmml / groupId artifactId pmml evaluator / 
artifactId version 1 . 4.1 / version / dependency dependency 
groupId org . jpmml / groupId artifactId pmml evaluator extension 
/ artifactId version 1 . 4.1 / version / dependency 
接着就是 读取 模型 文件 并 预测 的 代码 了 具体 
代码 如下 import org . dmg . pmml . FieldName 
import org . dmg . pmml . PMML import org 
. jpmml . evaluator . * import org . xml 
. sax . SAXException import javax . xml . bind 
. JAXBException import java . io . FileInputStream import java 
. io . IOException import java . io . InputStream 
import java . util . HashMap import java . util 
. LinkedHashMap import java . util . List import java 
. util . Map / * * * Created by 
刘建平 Pinard on 2018 / 6/24 . * / public 
class PMMLDemo { private Evaluator loadPmml { PMML pmml = 
new PMML InputStream inputStream = null try { inputStream = 
new FileInputStream D / demo . pmml } catch IOException 
e { e . printStackTrace } if inputStream = = 
null { return null } InputStream is = inputStream try 
{ pmml = org . jpmml . model . PMMLUtil 
. unmarshal is } catch SAXException e1 { e1 . 
printStackTrace } catch JAXBException e1 { e1 . printStackTrace } 
finally { / / 关闭 输 入流 try { is 
. close } catch IOException e { e . printStackTrace 
} } M o d e l E v a 
l u a t o r F a c t 
o r y m o d e l E v 
a l u a t o r F a c 
t o r y = M o d e l 
E v a l u a t o r F 
a c t o r y . newInstance Evaluator evaluator 
= m o d e l E v a l 
u a t o r F a c t o 
r y . n e w M o d e 
l E v a l u a t o r 
pmml pmml = null return evaluator } private int predict 
Evaluator evaluator int a int b int c int d 
{ Map String Integer data = new HashMap String Integer 
data . put x1 a data . put x2 b 
data . put x3 c data . put x4 d 
List InputField inputFields = evaluator . getInputFields / / 过 
模型 的 原始 特征 从 画像 中 获取 数据 作为 
模型 输入 Map FieldName FieldValue arguments = new LinkedHashMap FieldName 
FieldValue for InputField inputField inputFields { FieldName inputFieldName = inputField 
. getName Object rawValue = data . get inputFieldName . 
getValue FieldValue inputFieldValue = inputField . prepare rawValue arguments . 
put inputFieldName inputFieldValue } Map FieldName results = evaluator . 
evaluate arguments List TargetField targetFields = evaluator . getTargetFields TargetField 
targetField = targetFields . get 0 FieldName targetFieldName = targetField 
. getName Object targetFieldValue = results . get targetFieldName System 
. out . println target + targetFieldName . getValue + 
value + targetFieldValue int primitiveValue = 1 if targetFieldValue instanceof 
Computable { Computable computable = Computable targetFieldValue primitiveValue = Integer 
computable . getResult } System . out . println a 
+ + b + + c + + d + 
+ primitiveValue return primitiveValue } public static void main String 
args { PMMLDemo demo = new PMMLDemo Evaluator model = 
demo . loadPmml demo . predict model 1 8 99 
1 demo . predict model 111 89 9 11 } 
} 代码 里 有 两个 函数 第一 个 loadPmml 是 
加载 模型 的 第二个 predict 是 读取 预测 样本 并 
返回 预测值 的 我 的 代码运行 结果 如下 target y 
value { result = 2 probability _ entries = 0 
= 0.0 1 = 0.0 2 = 1.0 entityId = 
5 confidence _ entries = } 1 8 99 1 
2target y value { result = 1 probability _ entries 
= 0 = 0.0 1 = 1.0 2 = 0.0 
entityId = 6 confidence _ entries = } 111 89 
9 11 1 也 就是 样本 1 8 99 1 
被 预测 为 类别 2 而 111 89 9 11 
被 预测 为 类别 1 以上 就是 PMML 生成 和 
加载 的 一个 示例 使用 起来 其实 门槛 并不 高 
也 很 简单 4 . PMML 总结 与 思考 PMML 
的确 是 跨平台 的 利器 但是 是不是 就 没有 缺点 
呢 肯定 是 有的 第一 个 就是 PMML 为了 满足 
跨平台 牺牲 了 很多 平台 独有 的 优化 所以 很多 
时候 我们 用 算 法库 自己 的 保存 模型 的 
API 得到 的 模型 文件 要比 生成 的 PMML 模型 
文件 小 很多 同时 PMML 文件 加载 速度 也比 算 
法库 自己 独有 格式 的 模型 文件 加载 慢 很多 
第二 个 就是 PMML 加载 得到 的 模型 和 算法 
库 自己 独有 的 模型 相比 预测 会 有 一点点 
的 偏差 当然 这个 偏差 并不大 比如 某一个 样本 用 
sklearn 的 决策树 模型 预测 为 类别 1 但是 如果 
我们 把 这个 决策树 落 盘 为 一个 PMML 文件 
并用 JAVA 加载 后 继续 预测 刚才 这个 样本 有 
较小 的 概率 出现 预测 的 结果 不为 类别 1 
. 第三 个 就是 对 于超 大模型 比如 大规模 的 
集成 学习 模型 比如 xgboost 随机 森林 或者 tensorflow 生成 
的 PMML 文件 很容易 得到 几个 G 甚至 上 T 
这时 使用 PMML 文件 加载 预测 速度 会 非常 慢 
此时 推荐 为 模型 建立 一个 专有 的 环境 就 
没有 必要 去 考虑 跨平台 了 此外 对于 TensorFlow 不 
推荐 使用 PMML 的 方式 来 跨平台 可能 的 方法 
一是 TensorFlow serving 自己 搭建 预测 服务 但是 会 稍 
有些 复杂 另 一个 方法 就是 将 模型 保存为 TensorFlow 
的 模型 文件 并用 TensorFlow 独有 的 JAVA 库 加载 
来做 预测 我们 在 下 一篇 会 讨论 用 python 
+ tensorflow 训练 保存 模型 并用 tensorflow 的 JAVA 库 
加载 做 预测 的 方法 和 实例 欢迎 转载 转载 
请 注明 出处 欢迎 沟通交流 liujianping ok @ 163 . 
com 