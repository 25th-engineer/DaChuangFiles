在上 一篇 文章 机器学习 之 PageRank 算法 应用 与 C 
# 实现 1 算法 介绍   中 对 PageRank 算法 
的 原理 和 过程 进行 了 详细 的 介绍 并 
通过 一个 很 简单 的 例子 对 过程 进行 了 
讲解 从上 一篇 文章 可以 很快 的 了解 PageRank 的 
基础 知识 相比 其他 一些 文献 的 介绍 上一 篇 
文章 的 介绍 非常 简洁明了 说明 本文 的 主要 内容 
都是/nr 来自 赵国 宋 建成 . Google 搜索引擎 的 数学 
模型 及其 应用 西南 民族 大学 学报 自然科学 版 . 
2010 vol 36 3 这篇 学术论文 鉴于 文献 中 本身 
提供 了 一个 非常 简单 容易 理解 和 入门 的 
案例 所以 本文 就 使用 文章 的 案例 和 思路 
来 说明 PageRank 的 应用 文章 中 的 文字 也 
大部分 是 复制 该 篇 论文 个人 研究 是 对 
文章 的 理解 以及 最后 一篇 的 使用 C # 
实现 该 算法 的 过程 可以 让 读者 更好 的 
理解 如何 用 程序 来 解决问题 所以 特意 对 作者 
表示感谢 如果 有 认为 侵权 请 及时 联系 我 将 
及时 删除 处理 论 文中 的 案例 其实 是 来源于 
1993年 全国 大学生 数学 建模 竞赛 的 B 题 足球队 
排名 问题 本文 原文 链接 原创 机器学习 之 PageRank 算法 
应用 与 C # 实现 2 球队 排名 应用 与 
C # 代码 1 . 足球队 排名 问题 1993年 的 
全国 大学生 数学 建模 竞赛 B 题 就 出了 这道 
题目 不过 当时 PageRank 算法 还 没有 问世 所以 现在 
用 PageRank 来 求解 也 只能 算 马后炮 不过 可以 
借鉴 一下 思路 顺便 可以 加深 对 算法 的 理解 
并可以 观察 算法 实际 的 效果 怎么样 顺便 说 一下 
全国 大学生 数学 建模 竞赛 的确 非常 有用 我 在 
大学 期间 连续 参加 过 2004 和 2005年 的 比赛 
虽然 只 拿 了 一个 省 二等奖 但是 这个 过程 
对 我 的 影响 非常 大 包括 我 现在 的 
编程 解决 问题 的 思路 都 是从 建模 培训 开始 
的 希望 在校 大学生 珍惜 这些 机会 如果 能 入选 
校队 参加 集训 努力学习 对 以后 的 学习 工作/vn 都/d 
非常/d 有/v 帮助/v 下面 看看 这个 题目 的 具体 问题 
具体 数据 由于 篇幅 较大 已经 上 传为 图片 需要 
看 的 点击 链接 数据 链接 2 . 利用 PageRank 
算法 的 思路 2.1 问题 分析 足球队 排 名次 问题 
要求 我们 建立 一个 客观 的 评估 方法 只 依据 
过去 一段 时间 几个 赛季 或 几年 内 每个 球队 
的 战绩 给出 各个 球队 的 名次 具有 很强 的 
实际 背景 ． 通过 分析 题中 12支 足球队 在 联赛 
中 的 成绩 不难 发现 表中 的 数据 残缺不全 队 
与 队 之间 的 比赛 场 数 相差 很大 直接 
根据 比赛 成绩 来 排 名次 比较 困难 下面 我们 
利用 PageRank 算法 的 随机 冲浪 模型 来 求解 ． 
类比 PageRank 算法 我们 可以 综合 考虑 各队 的 比赛 
成绩 为 每支 球队 计算 相应 的 等级分 Rank 然后 
根据 各队 的 等级分 高低 来 确定 名次 直观 上看 
给定 球队 的 等级分 应该 由 它 所 战胜 和 
战平 的 球队 的 数量 以及 被 战胜 或 战平 
的 球队 的 实力 共同 决定 ． 具体来说 确定 球队 
Z 的 等级分 的 依据 应为 一是/i 看/v 它/r 战胜/n 
和/c 战平/n 了/ul 多少/m 支/n 球队/n 二 要看 它 所 
战胜 或 战平 球队 的 等级分 的 高低 ． 这两条 
就是 我们 确定 排名 的 基本 原理 ． 在 实际 
中 若 出现 等级分 相同 的 情况 可以 进一步 根据 
净胜球 的 多少 来 确定 排名 ． 由于 表中 包含 
的 数据 量 庞大 我们 先在 不计 平局 只 考虑 
获 胜局 的 情形 下 计算 出 各队 的 等级分 
以 说明 算法 原理 然后 我们 综合考虑 获 胜局 和 
平局 加权 后 得到 各队 的 等级分 并 据此 进行 
排名 考虑到 竞技 比赛 的 结果 的 不确定性 我们 最后 
建立 了 等级分 的 随机 冲浪 模型 分析表明 等级分 排名 
结果 具有 良好 的 参数 稳定性 2.2 获取 转移 概率 
矩阵 首先 利用 有向 赋权 图 的 权重 矩阵 来 
表达 出 各队 之间 的 胜负 关系 ． 用图 的 
顶点 表示 相应 球队 用 连接 两个 顶点 的 有向 
边 表示 两队 的 比赛 结果 同时 给 边赋/nr 权重 
表明 占 胜 的 次数 所以 可以 得到 数据 表中 
给出 的 12支 球队 所 对应 的 权重 矩阵 这是 
计算 转义 概率 矩阵 的 必要 步骤 这里 直接 对 
论文 中 的 截图 进行 引用 2.3 关于 加权 等级分 
上述 权重 不够 科学 在 论文 中 作者 提出 了 
加权 等级分 就是 考虑 平局 的 影响 对 2个 矩阵 
进行 加权 得到 权重 矩阵 从而 得到 转移 概率 矩阵 
这里 由于 篇幅 比较 大 但是 思路 比较 简单 不再 
详细 说明 如果 需要 详细 了解 可以 看 论文 本文 
还是 集中 在 C # 的 实现 过程 2.4 随机 
冲浪 模型 3 . C # 编程 实现 过程 下面 
我们 将 使用 C # 实现 论 文中 的 上述 
过程 注意 2.3 和 2.2 的 思想 是 类似 的 
只不过是 多 了 一个 加权 的 过程 对 程序 来说 
还是 很 简单 的 下面 还是 按照 步骤 一个 一个 
来 很多 人 看到 问题 写 程序 很难 下手 其实 
习惯 就 好了 按照 算法 的 步骤 来 一个 一个 
实现 总之 要 先 动手 不要 老是 想 想来想去 没有 
结果 浪费时间 只有 实际 行动 起来 才能 知道 实际 的 
问题 一个 一个 解决 持之以恒 思路 会 越来越 清晰 3.1 
计算 权重 矩阵 权重 矩阵 要根据 测试数据 球队 和每/nr 2个 
球队 直接 的 比分 来 获取 所以 我们 使用 一个 
字典 来 存储 原始数据 将 每个 节点 2个 队伍 的 
比赛 结果 比分 都 写成 数组 的 形式 来 根据 
胜平负 的 场次 计算 积分 得到 边的/nr 权重 看 代码 
吧 1 / / / summary 根据 比赛 成绩 直接 
根据 积 分来 构造 权重 矩阵 根据 i 对 j 
比赛 获取 的 分数 / summary 2 / / / 
param name = data key 为 2个 对 的 边 
名称 value 是 比分 列表 分别为 主客 进球数 / param 
3 / / / param name = teamInfo 球队 的 
编号 列表 / param 4 / / / returns 权重 
矩阵 / returns 5 public static double C a l 
c L e v e l T o t a 
l c o r e Dictionary String Int32 data List 
Int32 teamInfo 6 { 7 Int32 N = teamInfo . 
Count 8 double result = new double N N 9 
10 # region 利用 对称性 只 计算 一半 11 for 
int i = 1 i N i + + 12 
{ 13 for int j = i + 1 j 
= N j + + 14 { 15 # region 
循环 计算 16 String key = String . Format { 
0 } { 1 } teamInfo i 1 teamInfo j 
1 17 / / 不存在 比赛 成绩 18 if data 
. ContainsKey key 19 { 20 result i 1 j 
1 = result j 1 i 1 = 0 21 
continue 22 } 23 / / 计算 i j 直接 
的 互 胜 场次 24 var scores = data key 
/ / i j 直接 的 比分 列表 25 var 
Si3 = scores . Where n = n 0 n 
1 . ToList / / i 胜 场次 26 var 
S1 = scores . Where n = n 0 = 
= n 1 . ToList / / i 平 场次 
27 var Si0 = scores . Where n = n 
0 n 1 . ToList / / i 负 场次 
28 result i 1 j 1 = Si3 . Count 
* 3 + S1 . Count 29 result j 1 
i 1 = Si0 . Count * 3 + S1 
. Count 30 # endregion 31 } 32 } 33 
# endregion 34 / / 按照 列 向量 进行 归一化 
35 return G e t N o r m a 
l i z e d B y C o l 
u m n result 36 } 上面 最后 返 回调 
用了 归一化 的 函数 比较简单 直接 代码 贴出来 折叠 一下 
1 / / / summary 按照 列 向量 进行 归一化 
/ summary 2 / / / param name = data 
/ param 3 / / / returns / returns 4 
public static double G e t N o r m 
a l i z e d B y C o 
l u m n double data 5 { 6 int 
N = data . GetLength 0 7 double result = 
new double N N 8 # region 各个 列 向量 
归一化 9 for int i = 0 i N i 
+ + / / 列 10 { 11 double sum 
= 0 12 / / 行 13 for int j 
= 0 j N j + + sum + = 
data j i 14 for int j = 0 j 
N j + + 15 { 16 if sum = 
0 result j i = data j i / double 
sum / / 归一化 每 列 除以 和值/nr 17 else 
result j i = data j i 18 } 19 
} 20 # endregion 21 22 return result 23 } 
View Code3 . 2 计算 最大 特征值 及 特征向量 计算 
特征值 和 特征向量 是 一个 数学 问题 我们 采用 了 
Math . NET 数学计算 组件 可以 直接 计算 很 方便 
详细 的 使用 可以 参考 下面 代码 组件 的 其他 
信息 可以 参考 本站 导航 栏 上 的 专题 目录 
有 大量 的 使用 文章 看 代码 吧 1 / 
/ / summary 求 最大 特征值 下 的 特征向量 / 
summary 2 / / / param name = data / 
param 3 / / / returns / returns 4 public 
static double GetEigenVectors double data 5 { 6 var formatProvider 
= CultureInfo CultureInfo . InvariantCulture . Clone 7 formatProvider . 
TextInfo . ListSeparator = 8 9 int N = data 
. GetLength 0 10 Matrix double A = DenseMatrix . 
OfArray data 11 var evd = A . Evd 12 
var vector = evd . EigenVectors / / 特征向量 13 
var ev = evd . EigenValues / / 特征值 复数形式 
发 14 15 if ev 0 . Imaginary 0 throw 
new Exception 第一 个 特征值 为 复数 16 / / 
取 vector 第一列 为 最大 特征向量 17 var result = 
new double N 18 for int i = 0 i 
N i + + 19 { 20 result i = 
Math . Abs vector i 0 / / 第一列 取 
绝对值 21 } 22 return result 23 } 3.3 随机 
冲浪 模型 的 实现 随机 冲浪 模型 主要 是 有一个 
比例 设置 之后 可以 直接 求解 也 比较 简单 函数 
如下 1 / / / summary 获取 随机 冲浪 模型 
的 转移 矩阵 2 / / / 作用 很 明显 
结果 有 明显 的 改善 3 / / / / 
summary 4 / / / returns / returns 5 public 
static double G e t R a n d o 
m M o d e V e c t o 
r double data double d = 0.35 6 { 7 
int N = data . GetLength 0 8 double k 
= 1.0 d / double N 9 double result = 
new double N N 10 for int i = 0 
i N i + + 11 { 12 for int 
j = 0 j N j + + result i 
j = data i j * d + k 13 
} 14 return result 15 } 3.4 其他 其他 问题 
就是 数据 组合 的 过程 这里 太多 不 详细 讲解 
主要 是 构建 测试数据 以及 排序 后 结果 的 处理 
很 简单 贴 一个 球队 排序 的 函数 根据 特征向量 
1 / / / summary 排序 输出 球队 编号 / 
summary 2 / / / param name = w / 
param 3 / / / param name = teamInfo / 
param 4 / / / returns / returns 5 public 
static Int32 TeamOrder double w List Int32 teamInfo 6 { 
7 Dictionary int double dic = new Dictionary int double 
8 for int i = 1 i = w . 
Length i + + dic . Add i w i 
1 9 return dic . O r d e r 
B y D e s c e n d i 
n g n = n . Value . Select n 
= n . Key . ToArray 10 } 4 . 
算法 测试 我们 使用 问题 1中 的 数据 进行 测试 
首先 构建 测试 集合 代码 如下 太长 折叠 一下 主要 
是 问题 1 的 原始数据 1 / / / summary 
2 / / / 获取 测试 的 数据 集 key 
= 对 1 对 2 value = int 为 比分 
3 / / / / summary 4 public static Dictionary 
String Int32 GetTestData 5 { 6 Dictionary String Int32 data 
= new Dictionary string int 7 # region 依次 添加 
数据 8 # region T1 9 data . Add 1 
2 new Int32 { new Int32 { 0 1 } 
new Int32 { 1 0 } new Int32 { 0 
0 } } 10 data . Add 1 3 new 
Int32 { new Int32 { 2 2 } new Int32 
{ 1 0 } new Int32 { 0 2 } 
} 11 data . Add 1 4 new Int32 { 
new Int32 { 2 0 } new Int32 { 3 
1 } new Int32 { 1 0 } } 12 
data . Add 1 5 new Int32 { new Int32 
{ 3 1 } } 13 data . Add 1 
6 new Int32 { new Int32 { 1 0 } 
} 14 data . Add 1 7 new Int32 { 
new Int32 { 0 1 } new Int32 { 1 
3 } } 15 data . Add 1 8 new 
Int32 { new Int32 { 0 2 } new Int32 
{ 2 1 } } 16 data . Add 1 
9 new Int32 { new Int32 { 1 0 } 
new Int32 { 4 0 } } 17 data . 
Add 1 10 new Int32 { new Int32 { 1 
1 } new Int32 { 1 1 } } 18 
# endregion 19 20 # region T2 21 data . 
Add 2 3 new Int32 { new Int32 { 2 
0 } new Int32 { 0 1 } new Int32 
{ 1 3 } } 22 data . Add 2 
4 new Int32 { new Int32 { 0 0 } 
new Int32 { 2 0 } new Int32 { 0 
0 } } 23 data . Add 2 5 new 
Int32 { new Int32 { 1 1 } } 24 
data . Add 2 6 new Int32 { new Int32 
{ 2 1 } } 25 data . Add 2 
7 new Int32 { new Int32 { 1 1 } 
new Int32 { 1 1 } } 26 data . 
Add 2 8 new Int32 { new Int32 { 0 
0 } new Int32 { 0 0 } } 27 
data . Add 2 9 new Int32 { new Int32 
{ 2 0 } new Int32 { 1 1 } 
} 28 data . Add 2 10 new Int32 { 
new Int32 { 0 2 } new Int32 { 0 
0 } } 29 # endregion 30 31 # region 
T3 32 data . Add 3 4 new Int32 { 
new Int32 { 4 2 } new Int32 { 1 
1 } new Int32 { 0 0 } } 33 
data . Add 3 5 new Int32 { new Int32 
{ 2 1 } } 34 data . Add 3 
6 new Int32 { new Int32 { 3 0 } 
} 35 data . Add 3 7 new Int32 { 
new Int32 { 1 0 } new Int32 { 1 
4 } } 36 data . Add 3 8 new 
Int32 { new Int32 { 0 1 } new Int32 
{ 3 1 } } 37 data . Add 3 
9 new Int32 { new Int32 { 1 0 } 
new Int32 { 2 3 } } 38 data . 
Add 3 10 new Int32 { new Int32 { 0 
1 } new Int32 { 2 0 } } 39 
# endregion 40 41 # region T4 42 data . 
Add 4 5 new Int32 { new Int32 { 2 
3 } } 43 data . Add 4 6 new 
Int32 { new Int32 { 0 1 } } 44 
data . Add 4 7 new Int32 { new Int32 
{ 0 5 } new Int32 { 2 3 } 
} 45 data . Add 4 8 new Int32 { 
new Int32 { 2 1 } new Int32 { 1 
3 } } 46 data . Add 4 9 new 
Int32 { new Int32 { 0 1 } new Int32 
{ 0 0 } } 47 data . Add 4 
10 new Int32 { new Int32 { 0 1 } 
new Int32 { 1 1 } } 48 # endregion 
49 50 # region T5 51 data . Add 5 
6 new Int32 { new Int32 { 0 1 } 
} 52 data . Add 5 11 new Int32 { 
new Int32 { 1 0 } new Int32 { 1 
2 } } 53 data . Add 5 12 new 
Int32 { new Int32 { 0 1 } new Int32 
{ 1 1 } } 54 # endregion 55 56 
# region T7 57 data . Add 7 8 new 
Int32 { new Int32 { 1 0 } new Int32 
{ 2 0 } new Int32 { 0 0 } 
} 58 data . Add 7 9 new Int32 { 
new Int32 { 2 1 } new Int32 { 3 
0 } new Int32 { 1 0 } } 59 
data . Add 7 10 new Int32 { new Int32 
{ 3 1 } new Int32 { 3 0 } 
new Int32 { 2 2 } } 60 data . 
Add 7 11 new Int32 { new Int32 { 3 
1 } } 61 data . Add 7 12 new 
Int32 { new Int32 { 2 0 } } 62 
# endregion 63 64 # region T8 65 data . 
Add 8 9 new Int32 { new Int32 { 0 
1 } new Int32 { 1 2 } new Int32 
{ 2 0 } } 66 data . Add 8 
10 new Int32 { new Int32 { 1 1 } 
new Int32 { 1 0 } new Int32 { 0 
1 } } 67 data . Add 8 11 new 
Int32 { new Int32 { 3 1 } } 68 
data . Add 8 12 new Int32 { new Int32 
{ 0 0 } } 69 # endregion 70 71 
# region T9 72 data . Add 9 10 new 
Int32 { new Int32 { 3 0 } new Int32 
{ 1 0 } new Int32 { 0 0 } 
} 73 data . Add 9 11 new Int32 { 
new Int32 { 1 0 } } 74 data . 
Add 9 12 new Int32 { new Int32 { 1 
0 } } 75 # endregion 76 77 # region 
T10 78 data . Add 10 11 new Int32 { 
new Int32 { 1 0 } } 79 data . 
Add 10 12 new Int32 { new Int32 { 2 
0 } } 80 # endregion 81 82 # region 
T11 83 data . Add 11 12 new Int32 { 
new Int32 { 1 1 } new Int32 { 1 
2 } new Int32 { 1 1 } } 84 
# endregion 85 # endregion 86 return data 87 } 
View Code 测试 的 主要 方法 是 1 var team 
= new List Int32 { 1 2 3 4 5 
6 7 8 9 10 11 12 } 2 var 
data = GetTestData 3 var k3 = CalcLevelScore3 data team 
4 var w3 = GetEigenVectors k3 5 6 var teamOrder 
= TeamOrder w3 team 7 Console . WriteLine teamOrder . 
ArrayToString 排序 结果 如下 7 3 1 9 8 2 
10 4 6 5 12 11 结果 和 论文 差不多 
差别 在前面 2个 队伍 7 和3的/nr 位置 有点问题 具体 应该 
是 计算 精度 的 关系 如果 前面 的 计算 有一些 
精度 损失 的话 对 后面 的 计算 有 一点点 影响 
PageRank 的 一个 基本 应用 今天 就 到此为止 接下来 如果 
大家 感兴趣 我 将 继续 介绍 PageRank 在 球队 排名 
和 比赛 预测 结果 中 的 应用 情况 看 时间 
安排 大概 思路 和 本文 类似 只不过 在 细节 上 
要 处理 一下 