机器学习 简易 入门 二 分类 摘要 本文 简单 叙述 了 
如何 通过 分类 算法 来 评估 银行 发放 贷款 的 
模型 声明 本文 的 内容 非 原创 但 经过 本人 
翻译 和 总结 而来 转载 请 注明 出处 本文 内容 
来源 https / / www . dataquest . io / 
mission / 57 / classification basics 在 你 向 银行 
申请 信用卡 或者 贷款 时 银行 会 使用 根据 过往 
的 数据 所 建立 的 模型 再 根据 你 的 
实际 情况 来 决定 是否 接受 你 的 申请 原始数据 
展现 银行 在 以往 的 某段 时间 为了 训练 这个 
评分 模型 向/p 所有/b 申请者/n 都/d 发放/v 了/ul 贷款/n 然后 
记录 全部 人 是否 有 还款 以及 他们 的 评分 
情况 paid 字段 表明 该 申请 人 是否 有 如实 
还款 1 是 正常 还款 0 是 违约 model _ 
score 字段 表明 该 申请人 在 获得 贷款 前 在 
评分 模型 中 的 得分 import pandas credit = pandas 
. read _ csv credit . csv 评估 模型 根据 
上面 的 历史 数据 找到 适合 的 阀值 model _ 
score 究竟 为 多少 分时 才 接受 贷款 申请 然后 
获取 最大 的 利润 准确率 我们 通过 设置 一个 model 
_ score 的 阀值 来 决定 是否 接受 贷款 申请 
如果 该 申请者 的 model _ score 大于 该 阀值 
就 接受 反之亦然 通过 控制 这个 阀值 来 控制 新 
客户 量 衡量 一个 模型 的 准确性 是 通过 公示 
准确率 = 正确 预测 数 / 样本 总量 # 设置 
阀值 为 0.5 计算 这个 模型 的 准确率 评分 大于 
0.5 且 如实 还款 pred = credit model _ score 
0.5 accuracy = sum pred = = credit paid / 
len pred # paid 字 段为 1 且 model _ 
score 大于 0.5 这个 结果 表明 如果 只 向 model 
_ score 大于 0.5 的 申请者 发放贷款 大概 会有 86% 
的 人 还款 混淆 矩阵 下表 描述 二元 分类 问题 
的 混淆 矩阵 表中 每个 表项 Fij 表示 实际 类 
标 号为 i 但 被 预测 为 类 j 的 
记录 数 例如 F01 代表 原本 属于 类 0 但 
被 误 分为 类 1 的 记录 数 按照 混淆 
矩阵 中的 表项 被 分类 模型 正确 预测 的 样本 
总数 是 F11 + F00 而被 错误 预测 的 样本 
总数 是 F10 + F01 预测 的 类 类 = 
1类 = 0 实际 的 类 类 = 1F11F10 类 
= 0F01F00 在 本 文中 的 混淆 矩阵 是 这样 
的 实际上 会 还款 实际上 不会 还款 预测 会 还款 
TPFP 预测 不会 还款 FNTN 真正 True Positive TP 被 
模型 预测 为 正 的 正 样本 假 负 False 
Negative FN 被 模型 预测 为 负 的 正 样本 
假 正 False Positive FP 被 模型 预测 为 正 
的 负 样本 真 负 True Negative TN 被 模型 
预测 为 负 的 负 样本 真正 率 True Positive 
Rate TPR 或 灵敏度 sensitivity TPR = TP / TP 
+ FN 正 样本 预测 结果 数 / 正 样本 
实际 数 假 负 率 False Negative Rate FNR FNR 
= FN / TP + FN 被 预测 为 负 
的 正 样本 结果 数 / 正 样本 实际 数 
假 正 率 False Positive Rate FPR FPR = FP 
/ FP + TN 被 预测 为 正 的 负 
样本 结果 数 / 负 样本 实际 数 真 负 
率 True Negative Rate TNR 或 特指 度 specificity TNR 
= TN / TN + FP 负 样本 预测 结果 
数 / 负 样本 实际 数 # 把 阀值 设置 
为 0.5 分别 计算 上面 的 混淆 矩阵 TP = 
sum credit model _ score 0.5 = = 1 & 
credit paid = = 1 FN = sum credit model 
_ score = 0.5 = = 1 & credit paid 
= = 1 FP = sum credit model _ score 
0.5 = = 1 & credit paid = = 0 
TN = sum credit model _ score = 0.5 = 
= 1 & credit paid = = 0 只要 我们 
的 模型 中 真正 率 TPR 大于 假 正 率 
FPR 就能 保证 还款 的 人 要比 违约 的 人多 
从而 保证 银行 不会 亏本 计算 ROC 曲线 ROC 曲线 
receiver operating characteristic curve 又 称为 感受性 曲线 sensitivity curve 
得 此名 的 原因 在于 曲 线上 各点 反映 着 
相同 的 感受性 它们 都是 对 同一 信号 刺激 的 
反应 只不过是 在 几种 不同 的 判定 标准 下 所得 
的 结果 而已 接受者 操作 特性 曲线 就是 以 虚惊 
概率 为 横轴 击中 概率 为 纵轴 所 组成 的 
坐标 图 和被试/nr 在 特定 刺激 条件 下 由于 采用 
不同 的 判断 标准 得出 的 不同 结果 画出 的 
曲线 根据 上文 所述 现在 要 寻找 一个 阀值 使得 
真正 率 大于 假 正 率 import numpy def roc 
_ curve observed probs # 将 阀值 由 1 到 
0 分成 100个 小数 thresholds = numpy . asarray 100 
j / 100 for j in range 100 # 初始 
化为 全0/nr fprs = numpy . asarray 0 . for 
j in range 100 tprs = numpy . asarray 0 
. for j in range 100 # 对 每个 阀值 
进行 循环 for j thres in enumerate thresholds pred = 
probs thres FP = sum observed = = 0 & 
pred = = 1 TN = sum observed = = 
0 & pred = = 0 FPR = float FP 
/ FP + TN TP = sum observed = = 
1 & pred = = 1 FN = sum observed 
= = 1 & pred = = 0 TPR = 
float TP / TP + FN fprs j = FPR 
tprs j = TPR return fprs tprs thresholds fpr tpr 
thres = roc _ curve credit paid credit model _ 
score idx = numpy . where fpr 0.20 0 0 
# 选择 假 正 率 为 0.2 的 阀值 理由 
在 下面 print FPR 0.2 print TPR { } . 
format tpr idx print Threashold { } . format thres 
idx # 以 假 正 率 做 x 轴 真正 
率 做 y 轴 作图 plt . plot fpr tpr 
plt . xlabel FPR plt . ylabel TPR plt . 
show 说明 了当 阀值 设置 为 0.38时 FPR = 0.2 
TPR = 0.93 在上 图中 可见 当 FPR 假 正 
率 达到 了 0.2 之后 整条 曲线 都变/nr 平了 也 
就是说 当 FPR 大于 0.2 之后 违约 的 人数 增加 
了 不 违约 的 人数 却 没有 增加 多少 计算 
AUC 如果 用 两个 模型 分别 作出 了 不同 的 
ROC 曲线 那么 要 怎样 对比 这两条 ROC 曲线 的 
优异 程度 呢 可以 使用 AUC AUC 通过 测量 ROC 
曲线 下面 的 面积 来 获得 如果 一个 模型 是 
完美 的 那么 他 的 TPR 就会 是 1 所以 
AUC 也是 1 而 如果 一个 模型 的 TPR 是 
0 那么 AUC 也会 是 0 . 所以 可以 通过 
比较 AUC 的 大小 来 比较 两 个 模型 的 
优异 越高 的 AUC 意味着 模型 越 完美 可以 通过 
roc _ auc _ score 函数 来 计算 # 一个 
简单 的 例子 from sklearn . metrics import roc _ 
auc _ score probs = 0.98200848 0.92088976 0.13125231 0.0130085 0.35719083 
0.34381803 0.46938187 0.53918899 0.63485958 0.56959959 obs = 1 1 0 
0 1 0 1 0 0 1 testing _ auc 
= roc _ auc _ score obs probs print Example 
AUC { auc } . format auc = testing _ 
auc 计算 本文 的 AUCauc = roc _ auc _ 
score credit paid credit model _ score 召回率/i 和/c 准确率/n 
除了/p 上面/f 用/p 来/v 计算/v ROC/w 的/uj TPR/w 和/c FPR/w 
之外/f 还有 两个 重要 的 指标 正确率 precision 和 召回率 
recall 在 本文 中 越高 的 正确 率 说明 在 
发放 贷款 之后 还款率 要比 违约 率 高 越高 的 
召回率 说明 潜在 客户 那些 有 能力 还 款 但是 
被 银行 拒绝 了 发放贷款 的 流失 率 越低 # 
以 阀值 0.5 来 计算 pred = credit model _ 
score 0.5 # True Positives TP = sum pred = 
= 1 & credit paid = = 1 # False 
Positives FP = sum pred = = 0 & credit 
paid = = 1 # False Negatives FN = sum 
pred = = 1 & credit paid = = 0 
precision = TP / TP + FP recall = TP 
/ TP + FN print precision { } . format 
precision print recall { } . format recall 类似于 ROC 
曲线 作出 正确率 与 召回率 曲线 from sklearn . metrics 
import precision _ recall _ curve precision recall thresholds = 
precision _ recall _ curve credit paid credit model _ 
score plt . plot recall precision plt . xlabel Recall 
plt . ylabel Precision plt . show 在上 图中 曲线 
在 Recall = 0.8 的 时候 才 陡然 下降 此时 
的 Precision = 0.9 说明 了 此时 只 流失 了 
少量 的 潜在 客户 同时 违约 率 也 很低 