前言 上 一篇 比较 详细 的 介绍 了 卡方检验 和 
卡方 分布 这篇 我们 就 实际 操刀 找到 一些 训练 
集 正所谓 纸上 得来 终觉 浅 绝 知 此事 要 
躬行 然而 我 在 躬行 的 时候 发现 了 卡方检验 
对于 文本 分类 来说 应该 把 公式 再 变形 一般 
那样 就 完美 了 目录 文本 分类 学习 一 开篇 
文本 分类 学习 二 文本 表示 文本 分类 学习 三 
特征 权重 TF / IDF 和 特征提取 文本 分类 学习 
四 特征选择 之 卡方检验 文本 分类 学习 五 机器学习 SVM 
的 前奏 特征提取 卡方检验 续集 一 回顾 卡方检验 1 . 
公式 一 先 回顾 一下 卡方检验 卡方检验 事先 做 一个 
假设 计算/v 由/p 有/v 假设/vn 得来/v 的/uj 理论值/n 于/p 实际/n 
观察/v 值/n 之间/f 的/uj 偏差/n 来/v 推断/v 这个/r 假设/vn 是否/v 
成立/v 公式 2 . 四 表格 的 卡方检验 公式 卡方检验 
对于 文本 分类 每个 词 对于 每个 类别 使用 四 
表格 的 形式 计算 该词 对于 该类 是否 有 较大 
的 影响 公式 二 训练 集 的 准备 我 选择 
了 复旦 语料库 中 的 历史 篇 469篇 每篇 的 
格式 大多 如下 文献号 1 1408 原文 出处 科技日报 原 
刊 地名 京 原 刊期 号 19960825 原 刊 页号 
⑵ 分 类 号 K91 分 类 名 中国地理 作 
者 于 希贤 复印 期 号 199610 标 题 历史 
上 中国 地理 环境 的 几次 突变 正 文 在 
人类 历史 时期 特别/d 是/v 有/v 文字/n 记载/v 的/uj 近/a 
几千年/m 来/v 地理/n 环境/n 有/v 没有/v 变化/vn 有 多大 变化 
是 怎样 变化 的 这 是 人们 普遍 关心 的 
问题 也是 学 术 界 长期 争论不休 的 问题 之一 
以 气候 而言 古代 欧洲 亚里士多德 相信 寒冷 而 多雨 
的 气候 是 周期 循环 的 此后 １９ 世纪 至 
２０ 世纪初 德国 的 汉恩 和 法国 的 阿拉 哥 
为 代表 倡导 气候 不变 论 直至 本世纪 ７０ 年代 
把 地理 环境 的 变化 仅 误 认为 是 一种 
单纯 的 缓慢 的 渐进 作用 甚至 认为 不 因人 
的 活动 自然环境 的 变化 是 非常 微小 的 事实上 
有/v 史/nr 时代/n 人类/n 生活/vn 的/uj 地理环境/n 不仅 有其/nr 相对 
缓慢 变化 的 平静 时期 也 有其 激烈 动荡 的 
突变 时期 地理 环境 中 自然 灾异 的 群发 性 
和 集中 突发性 形成 了 地理 环境 的 突变 如 
火山 喷发 地震 山崩 海浸 海退 大雨 洪水 江河 泛滥 
干旱 螟 蝗 瘟疫 肆虐 大雪 奇寒 生物 聚集 变迁 
和 大规模 迁徙 奇特 的 天文 现象 太阳黑子 流星雨 等 
这样 一些 灾异 在 近 几千年 来 有时 出现 多而 
集中 这 就是 突变 期 有时 出现 少 而 分散 
这是 渐变 期 根据 历史 文献 记载 和 考古 及 
历史 地理 野外 调查 初步 至少 提出 以下 一些 灾变 
期 大约 距今 ４０００年 前后 有 洪水 灾变 期 在 
中国 欧洲 和 中近东 的 许多 民族 如 巴比伦 波斯 
印度/ns 等/u 都/d 广泛/a 地/uv 有/v 洪水/nr 灾变/n 的/uj 记载/v 
和/c 传说/n 尚书 尧 典 首 记 其事 汤汤 怀山襄陵 
浩浩 滔天 孟子 滕文公 说 昔 尧 之时 天下 犹 
未平 洪水横流 泛滥 于 天下 当今 的 考古 发掘 与 
上述 记述 相吻合 距今 ４ ０００年 前后 黄河 下游 曾大/nr 
改道 洪水 发生 的 地域 正是 禹贡 九州 中的 兖州 
豫州 和 徐州 考古学家 俞伟超 教授 研究 说 中国 北方 
的 龙山 文化/n 和/c 江浙/l 一带/n 的/uj 良渚/ns 文化/n 一度/mq 
都/d 达到/v 了/ul 相当/d 高度/n 的/uj 文明/nr 距今 ４０００年 之时 
情况 忽然 大变 龙山文化 变为 岳石文化 良渚 文化 也 突然 
变为 马桥 湖 熟 文化 时代 虽然 前后相接 文化 面貌 
却 缺乏 紧密 的 承袭 关系 岳石 与 马桥 湖 
熟 诸 文化 遗址 分布 密度 居址 的 面积 乃至 
文化 本身 的 产生 生活 水平 又 皆 远远 低于 
龙山 良渚 文化 他 指出 这 是 因为 生产 生活 
环境 发生 了 巨大 变化 族群 人口 大为 减少 文化 
处于 低落 时期 的 遗存 据此 他 推断 说 ４０００ 
多年 以前 我国 曾 发生 一次 延续 若干年 的 洪水 
大灾难 应该 是 历史 事实 距今 ２１００ 多年前 我国 逐步 
进入 另一 次 灾变 时期 其 高潮 是 公元 ２年 
至 ５７ 年间 西汉 末年 曾 发生 了 渤海 海湾 
西岸 大 海浸 汉书 沟洫 志 记载 河 入 勃海 
海水 溢 西 南出 浸 九百里 九 河 之地 已为 
东海 所 渐 矣 宋代 的 学者 认为 自 碣石 
以西 现今 整个 勃 海湾 在此之前 全是 陆地 谭其骧 教授 
研究 认为 其 海浸 范围 当今 渤海湾 ４米 等高线 以下 
今 天津 黄 骅 宁海 一带 有 几十 处 文化 
遗址 它们 不是 东周 西汉时期 就是 隋唐 时期 其间 独 
缺失 东汉 魏晋 南北朝 时期 的 文化 遗址 笔者 在 
武清县 雍奴 故城 遗址 上 发现 海相 地层 在 西汉 
泉州 故城 遗址 上 已 湮没 ２米 深 淤泥 当时 
确有 大 海浸 海浸 之前 的 许多 村落 城市 被 
海相 地层 压 置 至 公元 ６ 世纪 海水 退出 
又 才有 新的 村落 与 文化层 当中 独 缺失 公元 
１ ５ 世纪 的 人类 活动 痕迹 汉书 五行 志 
载 汉成帝 和平 元年 前 ２８ 三月 己未 １４日 日出 
黄 有黑/nr 气大 如 钱 居日/nr 中央 这条 记载 是 
世界 上 公认 的 太阳黑子 活动 的 最早 记录 此 
黑子 之大 为 后世 罕见 公元 １１年 黄河 在 今 
河北 大名 决口 泛滥 祸及 河东 数 郡 这次 水灾 
延续 了 ６０年 至 公元 ７０年 才 由 王景 领导 
的 数十万 民工 治好 据 邓云/nr 特 统计 这 ５７年 
中共 发生 ９次 特大 蝗灾 ８次 特大 水灾 ３次 特大 
瘟 疾 致使 死者 十 之 七八 公元 ２年 全国 
人口 ５９００ 多万 至 公元 ５７年 全国 人口 仅有 ２１００ 
多万 减少 了 ３８００ 多万 公元 ９ １２ 世纪 的 
寒冷 灾变 期 赫连 勃勃的 夏国 首都 统万城 今 陕西 
横山 西北 原先 是 一片 临 广泽/nr 而带 清流 的 
美丽 城市 至 公元 ８８２年 已 堆/v 沙高及/nr 城堞/i 又 
过 １００年 已 深 在 沙漠 之中 了 公元 ９２５年 
两汉 大水 户口 流亡者 十 之 四五 ９３８年 定州 大旱 
民 多 流散 ９４３年 春 夏旱 秋冬 水 蝗 大 
起 东自/nr 海滨 西 抵 陇 坻 南 逾 江淮 
北至 幽 冀 原野 山谷 城郭 庐舍 皆 满 竹木 
俱 尽 民 馁 者 数 十万口 流亡 不可胜数 朱熹 
统计 有史以来 黄 河大 决 １６次 其中 五代 半个世纪 内 
就 占了 ９次 至 北宋 尤甚 １６ １７ 世纪 寒冷 
灾变 期 长白山 主峰 白头山 两次 喷 发过 黑龙江 德都 
火山 １７２０年 前后 也 喷 发过 云南 腾冲 打 鹰山 
在 １６１１年 前后 也 喷 发过 公元 １５５５年 陕西 山西 
河南 同时 大地震 此 期 水灾 旱灾 很多 尤以 大雪 
奇寒 为甚 １６１６年 黄山 连续 积雪 达 １３０ 多天 河南 
嵩山 １６２３年 雪 深 道 绝 太华山 泓 谷至/nr 阴历 
三月 初三 还 层冰 积雪 状/ng 满谷间/nr １６２８年 福建 顺昌 
于 阴历 三月 十九 还 群峰 积雪 有如 环 玉 
１６３ ３年 阴历 八 月初 六日 五台山 仍 滴水 皆 
冰 阴崖悬/nr 冰 数百丈 依据 种种 资料 证实 此 冷期 
摆动 范围 远比 竺可桢 确定 的 ± ２℃ 为大 冬 
半年 当 较 今 冷６/nr ８℃ 左右 明末 灾异 的 
群发 性 与 突发性 使 当时 官员 金 士衡 在 
邸报 中 总结 说 举报 重 极大 之灾 至 怪 
至 异 之事 毕集于/nr 一时/d 总之 从有史/nr 时代/n 地理环境/n 几千年/m 
的/uj 变异/n 来看/u 一 方面 要 正视 地理 环境 的 
突变 灾异 群 的 出现 会给 人类 社会 造成 明显 
甚至 是 重大 的 影响 地理 环境 的 变化 参与 
了 人类 历史 发展 演化 的 进程 另一方面 也 应当 
看到 地理环境 几千年 来 的 灾变 并 没有 造成 世界末日 
科学 的 态度 是从 查清 历史 事实 中 使/v 人们/n 
有/v 一个/m 清醒/a 的/uj 认识/v 和/c 恰当/d 的/uj 选取/v 对策/n 
作者 系 北京大学 地理系 教授 中国 地理 学会 历史 地理 
专业 委员会 副 主任 ＊ 历史 类 文档 自己 爬 
了 博客园 的 博客 420篇 选择 一篇 贴出来 Redis 特性 
和 应用 场景 Redis 特性 速度快 Redis 使用 标准 C 
编写 实现 而且 将 所有 数据 加载 到 内存 中 
所以 速度 非常 快 官方 提供 的 数据 表明 在 
一个 普通 的 Linux 机器 上 Redis 读写 速度 分别 
达到 81000 / s 和 110000 / s 数据结构 可以 
将 Redis 看做 数据结构 服务器 目前 Redis 支持 5种 数据结构 
持久化 由于 所有 数据 保持在 内存 中 所以 对 数据 
的 更新 将 异步 地 保存 到 磁 盘上 Redis 
提供 了 一些 策略 来 保存 数据 比如 根据 时间 
或 更新 次数 数据 超过 内存 使用 swap 保证数据 memcacache 
不能 持久化 mongo 是 部分 在 内存 自动 操作 Redis 
对 不同 数据类型 的 操作 是 自动 的 因此 设置 
或 增加 key 值 从/p 一个/m 集合/v 中/f 增加/v 或/c 
删除/v 一个/m 元素/n 都能/nr 安全/an 的/uj 操作/v 支持 多种 语言 
Redis 支持 多种 语言 诸如 Ruby Python Twisted Python PHP 
Erlang Tcl Perl Lua Java Scala Clojure 等 主 从 
复制 Redis 支持 简单 而 快速 的 主 从 复制 
官方 提供 了 一个 数据 Slave 在 21秒 即 完成 
了 对 Amazon 网站 10Gkey set 的 复制 Sharding 很容易 
将 数据 分布 到 多个 Redis 实例 中 但这 主要 
看 该 语言 是否 支持 目前 支持 Sharding 功能 的 
语言 只有 PHP Ruby 和 Scala 1 . redis 数据 
使用 方式 redis 的 作者 antirez 曾 笑称 其为 一个 
数据结构 服务器 data structures server redis 的 所有 功能 就是 
将 数据 以 其 固有 的 几种 结构 保存 并 
提供 给 用户 操作 这 几种 结构 的 接口 我们 
可以 想象 我们 在 各种 语言 中 的 那些 固有 
数据类型 及其 操作 Redis 的 几种 使用 方式 Strings Hashs 
Lists Sets Sorted Sets Pub / Sub Redis 的 七种 
特性 以及 适合 的 应用 场景 1.1 . Strings Strings 
数据结构 是 简单 的 key value 类型 value 其实 不仅 
是 String 也 可以 是 数字 使用 Strings 类型 完全 
实现 目前 Memcached 的 功能 并且 效率 更高 还 可以 
享受 Redis 的 定时 持久化 操作 日志 及 Replication 等功能 
除了 提供 与 Memcached 一样 的 get set incr decr 
等 操作 外 Redis 还 提供 了 下面 一些 操作 
获取 字符串 长度 strlen 往 字符串 append 内容 append 设置/vn 
和/c 获取/v 字符串/n 的/uj 某一/i 段/q 内容/n setrange getrange 设置 
及 获取 字符串 的 某 一位 getrange 批量 设置 一 
系列 字符串 的 内容 String 是 最简单 的 数据 类型 
一个 key 对应 一个 Value String 是 二进制 安全 的 
它 可以 包含/nr 任何 数据 图片 或者 其他 序列化 后的/nr 
对象 方法 说明 特性 set 设置 key 对应 的 的 
值 为 String 类型 的 value get 获取 对应 key 
对应 的 String 的 值 如果 不 存在 返回 nil 
setnx 设置 可以 为 对应 的 值 为 String 类型 
的 value 如果 key 存在 返回 0 不 覆盖 不 
存在 返回 1 nx 的 意思为 not exist Set the 
value of a key only if the key does not 
exist setex 置 key 对应 的 值 为 String 类型 
的 value 并 指定 此 键值 对应 的 有效期 SETEX 
key seconds value 例 setex mykey 10 你好 setrange 设置 
key 的 value 的 子 字符串 setrange key 位置 替换 
的 内容 如果 替换 内容 没有 原 value 长 则 
原 value 剩余 的 内容 将 被 保留 mset 一次 
设置 多个 key 的 值 成功 返回 ok 失败 返回 
0 要 成功 都 成功 要 不成功 全部 失败 mset 
key1 内容 一 key2 内容 二 msetnx 一次 设置 多个 
key 的 值 成功 返回 ok 失败 返回 0 不 
覆盖 已经 存在 的 值 要 成功 都 成功 要 
失败 都 失败 getset 设置 key 的 值 并 返回 
key 的 旧 值 getset key newValuse getrange 获取 key 
对应 的 value 子 字符串 getrange key 0 5 / 
/ 获取 前 6 个字符 mget 批量 获取 mget key1 
key2 key3 / / 没有 设置 则 返 回空 incr 
对 key 的 值 做 增加 操作 并 返回 新的 
值 + 1 incrby 对 可以 的 value 加 指定 
的 值 key 如果 不 存在 会 设置 key 并 
value 为 0 incrby key1 5 / / 对 key1 
的 值 加 5 decr 对 key 的 值 做 
减减 操作 1 decrby 对 key 的 值 减去 指 
定值 append 给 指定 key 的 字符串 追加 value 返回 
新的 字符串 长度 strlen 取 指定 key 的 value 值 
的 长度 1.2 . Hashs 在 Memcached 中 我们 经常 
将 一些 结构化 的 信息 打包 成 hashmap 在 客户端 
序列化 后 存储 为 一个 字符串 的 值 比如 用户 
的 昵称 年龄 性别 积分 等 这时候 在 需要 修改 
其中 某一 项时/nr 通常 需要 将 所有 值 取出 反 
序列化 后 修改 某 一项 的 值 再 序列化 存储 
回去 这样 不仅 增大 了 开销 也不 适用 于 一些 
可能 并发 操作 的 场合 比如 两个 并发 的 操作 
都 需要 修改 积分 而 Redis 的 Hash 结构 可以 
使 你 像在 数据库 中 Update 一个 属性 一样 只 
修改 某一 项 属性值 它 是 一个 String 类型 的 
field 和 value 的 映 射表 它 的 添加 和 
删除 都是 平均 的 hash 特别 适合 用于 存储 对象 
对于 将 对象 存储 成 字符串 而言 hash 会 占用 
更少 的 内存 并且 可以 更 方便 的 存取 整个 
对象 . 它 和 java 的 HashMap 完全 类似 方法 
说明 特性 hset 设置 一个 hash 的 field 为 指定 
值 如果 key 不存在 则 先 创建 hset tab ke1 
val1 hget 获取 某个 hash 的 某个 field 值 hget 
tab ke1 hsetnx 类似 string 只是 操作 的 是 hash 
hmset 批量 设置 hash 的 内容 hmget 获取 hash 表 
的 全部 key 值 Hmget key field1 field2 hincrby 给 
hash 表 的 某个 字段 增加值 hexists 判断 hash 表中 
某个 key 是否 存在 hlen 返回 hash 表 中的 key 
数量 hdel 删除 指定 hash 表 的 某个 键值 对 
hkeys 返回 hash 表中 所有 的 key hvals 返回 hash 
表中 所有 的 value hgetall 获取 hash 表中 所有 key 
和 value 1.3 . Lists Lists 就是 链表 略有 数据结构 
知识 的 人都 应该 能 理解 其 结构 使用 Lists 
结构 我们 可以 轻松 地 实现 最新消息 排行 等功能 Lists 
的 另一 个 应用 就是 消息队列 可以 利用 Lists 的 
PUSH 操作 将 任务 存在 Lists 中 然后 工作 线程 
再用 POP 操作 将 任务 取出 进行 执行 Redis 还 
提供 了 操作 Lists 中 某 一段 的 api 你 
可以 直接 查询 删除 Lists 中 某 一段 的 元素 
Redis 的 list 是 每个 子 元素 都是 String 类型 
的 双向链表 可以/c 通过/p push/w 和/c pop/w 操作/v 从/p 列表/n 
的/uj 头部/n 或者/c 尾部/n 添加/v 或者/c 删除/v 元素/n 这样 List 
即 可以 作为 栈 也 可以 作为 队列 方法 说明 
特性 lpush 在 key 所 对应 的 list 头部 添加 
一个 元素 l 的 意思 是 left rpush 在 key 
说 对应 的 list 尾部 添加 一个 元素 r 的 
意思 是 right lrange 显示 list 里面 的 内容 lrange 
0 1 / / 全部 显示 linsert 在 key 对应 
的 list linsert mylist before one myvalue lset 设置 list 
中 指定 下标 元素 的 值 lset mylist index myvalue 
lrem 从/p key/w 对应/vn 的/uj list/w 中/f 删除/v n/w 个/q 
和/c value/w 相同/d 的/uj 元素/n 结果 返回 影响 元素 的 
个数 n 0 从 尾部 开始 删除 n = 0 
全 删除 lrem mylist count value ltrim 保留 指定 key 
范围内 的 数据 返回 ok 成功 ltrim mylist 0 3 
/ / 0 3 是 保留 的 范围 lpop 从 
list 的 头部 删除 一个 元素 并 返回 该 删除 
的 元素 rpop 从 list 的 尾部 弹出 一个 元素 
并 返回 该 删除 的 元素 rpoplpush 从 第一 个 
list 的 尾部 元素 异常 元素 并 添加 到 第二 
个 list 的 头部 rpoplpush mylistA mylistB lindex 返回 list 
位置 的 元素 lindex mylist 3 llen 返回 list 中 
元素 的 个数 llen mylist 1.4 . Sets Sets 就是 
一个 集合 集合 的 概念 就 是 一堆 不 重复 
值 的 组合 利用 Redis 提供 的 Sets 数据结构 可以 
存储 一些 集 合性 的 数据 案例 在 微博 应用 
中 可以 将 一个 用户 所有 的 关注 人 存在 
一个 集合 中 将其 所有 粉丝 存在 一个 集合 Redis 
还为 集合 提供 了 求 交集 并 集 差集 等 
操作 可以 非常 方便 的 实现 如 共同 关注 共同 
喜好 二度 好友 等 功能 对 上面 的 所有 集合 
操作 你 还 可以 使用 不同 的 命令 选择 将 
结果 返回 给 客户端 还是 存 集 到 一个 新的 
集合 中 Set 是 集合 是 String 类型 的 无序 
集合 set 是 通过 hashtable 实现 的 概念 和 数学 
中 个 的 集合 基本 类似 可以 交集 并 集 
差集 等等 set 中的 元素 是 没有 顺序 的 方法 
说明 特性 sadd 向 名称 为 key 的 set 中 
添加 元素 返回 影响 元素 的 个数 0 为 失败 
1 为 成功 sadd myset value smembers 查看 集合 中 
所有 的 成员 smebers myset srem 删除 集合 的 一个 
元素 srem myset two spop 随机 返回 并 删除 set 
中 一个 元素 spop myset sdiff 返回 所有 set 与 
第一 个 set 的 差集 sdiff myset1 myset2 sdiffstore 比较 
差集 并且 存储 到 另一个 set 中 返回 1 代表 
成功 sdiffstore setstoreSet mySet1 myset2 sinter 返回 所有 给定 集合 
的 交集 sinter myset1 mysert2 / / 1 集合 和2/nr 
集合 的 交集 sinterstore 返回 给定 集合 的 交集 并 
存储 到 另一个 集合 sinterstore desset myset1 myset2 / / 
存到 desset 集合 中 sunion 返回 所有 给定 集合 的 
并 集 sunion set1 set2 sunionstore 返回 所有 的 并 
集 并且 存储 到 另一个 集合 中 返回 影响 的 
元素 个数 sunionstore destSet myset1 myset2 smove 把 第一 个 
集合 的 元素 移动 到 第二 个 集合 中 smove 
myset myset 你好 scard 返回 集合 中 元素 的 个数 
scard myset1 sismember 测试 某个 元素 是否 在 集合 中 
返回 0 是不是 大于 0 是 存在 sismember mykey1 你好 
srandmember 随机 返回 个 集合 中的 元素 srandmemeber myset1 1.5 
. Sorted Sets 和 Sets 相比 Sorted Sets 增加 了 
一个 权重 参数 score 使得 集合 中的 元素 能够 按 
score 进行 有序/nr 排列 比如 一个 存储 全班 同学 成绩 
的 Sorted Sets 其 集合 value 可以 是 同学 的 
学号 而 score 就 可以 是 其 考试 得分 这样 
在 数据 插入 集合 的 时候 就 已经 进行 了 
天然 的 排序 案例 可以 用 Sorted Sets 来做 带 
权重 的 队列 比如 普通 消息 的 score 为 1 
重要 消息 的 score 为 2 然后 工作 线程 可以 
选择 按 score 的 倒序 来 获取 工作任务 让 重要 
的 任务 优先 执行 Zset 类型 它 是 set 的 
一个 升级 版本 在 set 的 基础 上 增加 了 
顺序 这一 属性 在 添加 修改 元素 时 可以 指定 
每次 指定 后 zset 会 自动 按 新的 值 调整 
顺序 方法 说明 特性 zadd 向 zset 中 添加 元素 
member score 用于 排序 如果 元素 存在 则 更新 其 
顺序 返回 0 代表 没 添加 成功 ZADD key score 
member zadd myset 3 itim zrange 取出 集合 中的 元素 
zrange myset 0 1 withscores / / 显示 序号 by 
index zrem 删除 名称 为 key 的 zset 中的 元素 
member zrem myset itim zincrby 修改 元素 的 排序 如果 
元素 不 存在 则 添加 该 元素 且 排序 的 
score 值 为 增加值 zincrby myzset score itim zrank 返回 
元素 在 集合 中的 排序 位置 就是 索引 值 zrank 
myzset itim / / itim 在 集合 中 的 位置 
zrevrank 返回 从大到/nr 小 的 排序 索引 值 就是 逆序 
位置 zrevrangk myzset itim / / 逆序 的 位置 zrevrange 
返回 集合 中 从大到/nr 小 排序 降序 的 索引 start 
到 end 的 所有 元素 zrevrange myzset 0 1 / 
/ 逆序 后的/nr 元素 zrangebyscore 根据 排序 索引 的 scores 
来 返回 元素 zrangebyscore myzset 1 3 withscores / / 
zcount 返回 集合 中 给定 区间 的 数量 zcount myzset 
2 4 / / 集合 中 2 4 索引 元素 
的 个数 zcard 返回 集合 中 所有 元素 的 个数 
zcard myzset / / 返回 所有 元素 的 个数 zremrangebyrank 
删除 集合 中 排序 在 给定 区间 的 所有 元素 
按 索引 删除 zremrangebyrank myzset 2 3 / / zremrangebyscore 
删除 集合 中 在 给定 排序 区间 的 元素 按顺序 
删除 zremrangebyscore myzset 2 5 / / 1.6 . Pub 
/ Sub Pub / Sub 从 字面 上 理解 就是 
发布 Publish 与 订阅 Subscribe 在 Redis 中 你 可以 
设定 对 某一个 key 值 进行 消息 发布 及 消息 
订阅 当 一个 key 值 上 进行 了 消息 发布 
后 所有 订阅 它 的 客户端 都会 收到 相应 的 
消息 这一 功能 最 明显 的 用法 就是 用作 实时 
消息 系统 比如 普通 的 即时 聊天 群聊 等功能 案例 
Qlocenter 下发 策略 2 . redis 数据 存储 redis 的 
存储 分为 内存 存储 磁盘 存储 和 log 文件 三 
部分 配置文件 中有 三个 参数 对 其 进行 配置 l 
save seconds updates save 配置 指出 在 多 长时间 内 
有 多少 次 更新 操作 就将 数据 同步 到 数据文件 
这个 可以 多 个 条件 配合 比如 默认 配置文件 中的 
设置 就 设置 了 三个 条件 l appendonly yes / 
no appendonly 配置 指出 是否 在 每次 更新 操作 后 
进行 日志 记录 如果 不 开启 可能会 在 断电 时 
导致 一段 时间 内 的 数据 丢失 因为 redis 本身 
同步 数据文件 是 按上 面的 save 条件 来 同步 的 
所以有 的 数据 会 在 一段 时间 内 只 存在 
于 内存 中 l appendfsync no / always / everysec 
appendfsync 配置 no 表示 等 操作 系统 进行 数据缓存 同步 
到 磁盘 always 表示 每次 更新 操作 后 手动 调用 
fsync 将 数据 写到 磁盘 everysec 表示 每秒 同步 一次 
redis 使用 了 两种 文件格式 全量/nr 数据/n 和/c 增量/n 请求/v 
全量/nr 数据格式 是 把 内存 中 的 数据 写入 磁盘 
便于 下次 读取 文件 进行 加载 增量 请求 文件 则是 
把 内存 中 的 数据 序列化 为 操作 请求 用于 
读取 文件 进行 replay 得到 数据 序列化 的 操作 包括 
SET RPUSH SADD ZADD redis 是 一个 支持 持久化 的 
内存 数据库 也 就是说 redis 需要 经常 将 内存 中 
的 数据 同步 到 磁盘 来 保证 持久化 redis 支持 
两种 持久化 方式 一种 是 Snapshotting 快照 也是 默认 方式 
另一种 是 Append only file 缩写 aof 的 方式 下面 
分别 介绍 Snapshotting RDB 方式 快照 是 默认 的 持久化 
方式 这种 方式 是 就是 将 内存 中 数据 以 
快照 的 方式 写入 到 二进制 文件 中 默认 的 
文件 名为 dump . rdb 可以 通过 配置 设置 自动 
做 快照 持久 化 的 方式 我们 可以 配置 redis 
在 n 秒内 如果 超过 m 个 key 被 修改 
就 自动 做 快照 下面 是 默认 的 快照 保存 
配置 save 900 1 # 900秒 内 如果 超过 1个 
key 被 修改 则 发起 快照 保存 save 300 10 
# 300秒 内容 如 超过 10个 key 被 修改 则 
发起 快照 保存 save 60 10000 下面 介绍 详细 的 
快照 保存 过程 1 . redis 调用 fork 现在 有了 
子 进程 和 父进程 2 . 父进程 继续 处理 client 
请求 子 进程 负责 将 内存 内容 写入 到 临时文件 
由于 os 的 写 时 复制 机制 copy on write 
父子 进程 会 共享 相同 的 物理 页面 当 父进程 
处理 写 请求 时 os 会为 父进程 要 修改 的 
页面 创建 副本 而 不是 写 共享 的 页面 所以 
子 进程 的 地址 空间 内 的 数 据 是 
fork 时刻 整个 数据库 的 一个 快照 3 . 当子 
进程 将 快照 写入 临时文件 完毕 后 用 临时文件 替换 
原来 的 快照 文件 然后 子 进程 退出 client 也 
可以 使用 save 或者 bgsave 命令 通知 redis 做 一次 
快照 持久化 save 操作 是 在 主线程 中 保存 快照 
的 由于 redis 是 用 一个 主线程 来 处理 所有 
client 的 请求 这种 方式 会 阻塞 所有 client 请求 
所以 不 推荐 使用 另一 点 需要 注意 的 是 
每次 快照 持久化 都是 将 内存 数据 完整 写入 到 
磁盘 一次 并不 是 增量 的 只 同步 脏数据 如果 
数据量 大 的话 而且 写 操作 比较 多 必然 会 
引起 大量 的 磁盘 io 操作 可能 会 严重影响 性能 
另外 由于 快照 方式 是 在 一定 间隔 时间 做 
一次 的 所以 如果 redis 意外 down 掉 的话 就会 
丢失 最后 一次 快照 后的/nr 所有 修改 如果 应用 要求 
不能 丢失 任何 修改 的话 可以 采用 aof 持久化 方式 
下面 介绍 Append only file AOF 方式 aof 比 快照 
方式 有 更好 的 持久 化性 是 由于 在 使用 
aof 持久化 方式 时 redis 会将 每一个 收到 的 写 
命令 都 通过 write 函数 追加 到 文件 中 默认 
是 appendonly . aof 当 redis 重启 时会/nr 通过 重新 
执行 文件 中 保存 的 写 命令 来 在 内存 
中 重建 整个 数据库 的 内容 当然 由于 os 会在 
内核 中 缓存 write 做 的 修改 所以 可能 不是 
立即 写到 磁 盘上 这样 aof 方式 的 持久化 也 
还是 有 可能会 丢失 部分 修改 不过 我们 可以 通过 
配置文件 告诉 redis 我们 想要 通过 fsync 函数 强制 os 
写入 到 磁盘 的 时机 有三种 方式 如下 默认 是 
每秒 fsync 一次 appendonly yes / / 启用 aof 持久化 
方式 # appendfsync always / / 每次 收到 写 命令 
就 立即 强制 写入 磁盘 最慢 的 但是 保证 完全 
的 持久化 不 推荐 使用 appendfsync everysec / / 每秒钟 
强制 写入 磁盘 一次 在 性能 和 持久 化 方面 
做 了 很好 的 折中 推荐 # appendfsync no / 
/ 完全 依赖 os 性能 最好 持久化 没 保证 aof 
的 方式 也 同时 带来 了 另一个 问题 持久化 文件 
会变 的 越来越 大 例如 我们 调用 incr test 命令 
100次 文件 中 必须 保存 全部 的 100条 命令 其实有 
99条 都是 多余 的 因为 要 恢复 数据库 的 状态 
其实 文件 中 保存 一条 set test 100 就 够了 
为了 压缩 aof 的 持久化 文件 redis 提供 了 bgrewriteaof 
命令 收到 此 命令 redis 将 使用 与 快照 类似 
的 方式 将 内存 中 的 数据 以 命令 的 
方式 保存 到 临时 文件 中 最后 替换 原来 的 
文件 具体 过程 如下 1 . redis 调用 fork 现在 
有 父子 两个 进程 2 . 子 进程 根据 内存 
中的 数据库 快照 往 临时文件 中 写入 重建 数据库 状态 
的 命令 3 . 父进程 继续 处理 client 请求 除了 
把 写 命令 写入 到 原来 的 aof 文件 中 
同时 把 收到 的 写 命令 缓存 起来 这样 就 
能 保证 如 果子 进程 重写 失败 的话 并 不会 
出 问题 4 . 当子 进程 把 快照 内容 写入 
已 命令 方式 写到 临时文件 中 后 子 进程 发信号 
通知 父进程 然后 父进程 把 缓存 的 写 命令 也 
写入 到 临时文件 5 . 现在 父进程 可以 使用 临时文件 
替换 老 的 aof 文件 并 重命名 后面 收到 的 
写 命令 也 开始 往 新的 aof 文件 中 追加 
需要 注意 到 是 重写 aof 文件 的 操作 并 
没有 读取 旧 的 aof 文件 而是 将 整个 内存 
中的 数据库 内容 用 命令 的 方式 重写 了 一个 
新的 aof 文件 这点 和 快照 有点 类似 3 . 
主从复制 redis/w 主从复制/l 配置/v 和/c 使用/v 都/d 非常/d 简单/a 通过 
主从复制 可以允许 多个 slave server 拥有 和 master server 相同 
的 数据库 副本 下面 是 关于 redis 主从复制 的 一些 
特点 l master 可以 有 多个 slave l 除了 多个 
slave 连到 相同 的 master 外 slave 也 可以 连接 
其他 slave 形成 图 状 结构 l 主从复制 不会 阻塞 
master 也 就是说 当 一个 或 多个 slave 与 master 
进行 初次 同步 数据 时 master 可以 继续 处理 client 
发来 的 请求 相反 slave 在 初次 同步 数据 时 
则会 阻塞 不能 处理 client 的 请求 l 主从复制 可以 
用 来 提高 系统 的 可伸缩性 我们 可以 用 多个 
slave 专门 用于 client 的 读 请求 比如 sort 操作 
可以 使用 slave 来 处理 也 可以 用来 做 简单 
的 数据冗余 l 可以 在 master 禁用 数据 持久化 只需要 
注释 掉 master 配置文件 中 的 所有 save 配置 然后 
只在 slave 上 配置 数据 持久化 主从复制 的 过程 当 
设置 好 slave 服务器 后 slave 会 建立 和 master 
的 连接 然后 发送 sync 命令 无论 是 第一 次 
同步 建立 的 连接 还是 连接 断开 后的/nr 重新 连 
接 master 都会 启动 一个 后台 进程 将 数据库 快照 
保存 到 文件 中 同时 master 主 进程 会 开始 
收集 新的 写 命令 并 缓存 起来 后台 进程 完成 
写 文件 后 master 就 发送 文件 给 slave slave 
将 文件 保存 到 磁 盘上 然后 加载 到 内存 
恢复 数据库 快 照到 slave 上 接着 master 就 会把 
缓存 的 命 令 转发给 slave 而且 后续 master 收到 
的 写 命令 都会 通过 开始 建立 的 连接 发送给 
slave 从/p master/w 到/v slave/w 的/uj 同步/d 数据/n 的/uj 命令/n 
和从/nr client 发送 的 命令 使用 相同 的 协议 格式 
当 master 和 slave 的 连接 断 开时 slave 可以 
自动 重新 建立 连接 如果 master 同时 收到 多个 slave 
发来 的 同步 连接 命令 只会 使用 启动 一个 进程 
来写 数据库 镜像 然后 发 送给 所有 slave 4 . 
Redis 应用 场景 毫无疑问 Redis 开创 了 一种 新的 数据 
存储 思路 使用 Redis 我们 不用 在 面对 功能 单调 
的 数据库 时 把 精力 放在 如何 把 大象 放进 
冰箱 这样 的 问题 上 而是 利用 Redis 灵活 多变 
的 数据 结构 和 数据 操作 为 不同 的 大象 
构建 不同 的 冰箱 Redis 比较 适合 的 一些 应用 
场景 NoSQLFan 简单 列举 在 这里 供 大家 一览 1 
. 7.1 . 取 最新 N 个 数据 的 操作 
记录 前 N 个 最新 登陆 的 用户 Id 列表 
超出 的 范围 可以 从 数据库 中 获得 / / 
把 当前 登录 人 添加到 链 表里 ret = r 
. lpush login last _ login _ times uid / 
/ 保持 链表 只有 N 位 ret = redis . 
ltrim login last _ login _ times 0 N 1 
/ / 获得 前 N 个 最新 登陆 的 用户 
Id 列表 last _ login _ list = r . 
lrange login last _ login _ times 0 N 1 
比如 sina 微博 在 Redis 中 我们 的 最新 微博 
ID 使用 了 常驻 缓存 这是 一直 更新 的 但是 
我们 做 了 限制 不能超过 5000个 ID 因此 我们 的 
获取 ID 函数 会 一直 询问 Redis 只有在 start / 
count 参数 超出 了 这个 范围 的 时候 才 需要 
去 访问 数据库 我们 的 系统 不会 像 传统 方式 
那样 刷新 缓存 Redis 实例 中 的 信息 永远 是 
一致 的 SQL 数据库 或是 硬 盘上 的 其他 类型 
数据库 只是 在 用户 需要 获取 很远 的 数据 时 
才会 被 触发 而 主页 或 第一个 评论 页 是 
不会 麻烦 到 硬 盘上 的 数据库 了 1 . 
7.2 . 排行榜 应用 取 TOP N 操作 这个 需求 
与 上面 需求 的 不同 之 处 在于 前面 操作 
以 时间 为 权重 这个 是以 某个 条件 为 权重 
比如 按 顶 的 次数 排序 这时候 就 需要 我们 
的 sorted set 出马 了 将 你 要 排序 的 
值 设置成 sorted set 的 score 将 具体 的 数据 
设置 成 相应 的 value 每次 只 需要 执行 一条 
ZADD 命令 即可 / / 将 登录 次数 和 用户 
统一 存储 在 一个 sorted set 里 zadd login login 
_ times 5 1 zadd login login _ times 1 
2 zadd login login _ times 2 3 ZADD key 
score member / / 当 用户 登录 时 对 该 
用户 的 登录 次数 自 增 1 ret = r 
. zincrby login login _ times 1 uid / / 
那么 如何 获得 登录 次数 最多 的 用户 呢 逆序 
排列 取得 排名 前 N 的 用户 ret = r 
. zrevrange login login _ times 0 N 1 ZREVRANGE 
key start stop WITHSCORES 另 一个 很 普遍 的 需求 
是 各种 数据库 的 数据 并非 存储 在 内存 中 
因此在 按得 分排 序 以及 实时 更新 这些 几乎 每 
秒钟 都 需要 更新 的 功能 上 数据库 的 性能 
不够 理想 典型 的 比如 那些 在线游戏 的 排行榜 比如 
一个 Facebook 的 游戏 根据 得分 你 通常 想要 列出 
前 100名 高分 选手 列出 某 用户 当前 的 全球 
排名 这些 操作 对于 Redis 来说 小菜一碟 即使 你 有 
几百万 个 用户 每分钟 都会 有 几百万 个 新的 得分 
模式 是 这样 的 每次 获得 新得 分时 我们 用 
这样 的 代码 ZADD leaderboard score username 你 可能 用 
userID 来 取代 username 这 取决于 你 是 怎么 设计 
的 得到 前 100名 高分 用户 很 简单 ZREVRANGE leaderboard 
0 99 用户 的 全球 排名 也 相似 只需要 ZRANK 
leaderboard username ZRANK key member Determine the index of a 
member in a sorted set 1 . 7.3 . 需要 
精准 设定 过期 时间 的 应用 比如 你 可以 把 
上面 说到 的 sorted set 的 score 值 设置成 过期 
时间 的 时间 戳 那么 就 可以 简单 地 通过 
过期 时间 排序 定时 清除 过期数据 了 不仅 是 清除 
Redis 中的 过期数据 你 完全 可以 把 Redis 里 这个 
过期 时间 当成 是 对 数据库 中 数据 的 索引 
用 Redis 来找 出 哪些 数据 需要 过期 删除 然后再 
精准 地 从 数据库 中 删除 相应 的 记录 1 
. 7.4 . 获取 某段 时间 所 有 数据 去 
重 值 这个 使用 Redis 的 set 数据结构 最 合适 
了 只 需要 不断 地 将 数据 往 set 中 
扔 就行了 set 意为 集合 所以 会 自动 排 重 
1 . 7.5 . Pub / Sub 构建 实时 消息 
系统 Redis 的 Pub / Sub 系统 可以 构建 实时 
的 消息 系统 比如 很多 用 Pub / Sub 构建 
的 实时 聊天 系统 的 例子 1 . 7.6 . 
消息队列 系统 使用 list 可以 构建 队列 系统 使用 sorted 
set 甚至 可以 构建 有 优先级 的 队列 系统 比如 
将 Redis 用作 日志 收集器 实际上 还是 一个 队列 多个 
端 点将 日志 信息 写入 Redis 然后 一个 worker 统一 
将 所有 日志 写到 磁盘 1 . 7.7 . 缓存 
性能 优于 Memcached 数据结构 更 多样化 1 . 7.8 . 
范围 查找 比如 有 一个 IP 范围 对应 地址 的 
列表 现在 需要 给 出 一个 IP 的 情况 下 
迅速 的 查找 到 这个 IP 在 哪个 范围 也 
就是 要 判断 此 IP 的 所有 地 例如 查询 
IP 是否 存在 的 问题 ADSM 查询 IP 是否 在 
其他 分组 中 存在 写 json 文件 sadd 向 名称 
为 key 的 set 中 添加 元素 返回 影响 元素 
的 个数 0 为 失败 1 为 成功 例如 有 
下面 两个 范围 10 － 20 和 30 － 40 
A _ start 10 A _ end 20 B _ 
start 30 B _ end 40 我们 将 这两个 范围 
的 起始 位置 存在 Redis 的 Sorted Sets 数据结构 中 
基本 范围 起始值 作为 score 范围 名 加 start 和 
end 为其 value 值 redis 127.0 . 0.1 6379 zadd 
ranges 10 A _ start integer 1 redis 127.0 . 
0.1 6379 zadd ranges 20 A _ end integer 1 
redis 127.0 . 0.1 6379 zadd ranges 30 B _ 
start integer 1 redis 127.0 . 0.1 6379 zadd ranges 
40 B _ end integer 1 这样 数据 在 插入 
Sorted Sets 后 相当 于是 将 这些 起始 位置 按 
顺序 排列 好了 现在 我 需要 查找 15 这个 值 
在哪 一个 范围 中 只 需要 进行 如下 的 zrangbyscore 
查找 redis 127.0 . 0.1 6379 zrangebyscore ranges 15 + 
inf LIMIT 0 1 1 A _ end 这个 命令 
的 意思 是 在 Sorted Sets 中 查找 大于 15 
的 第一 个 值 + inf 在 Redis 中 表示 
正 无穷大 15 前面 的 括号 表示 15 而非 = 
15 查找 的 结果 是 A _ end 由于 所有 
值 是 按 顺序 排列 的 所以 可以 判定 15 
是 在 A _ start 到 A _ end 区间 
上 也 就是说 15 是 在 A 这个 范围 里 
至此 大功告成 当然 如果 你 查 找到 的 是 一个 
start 比如 咱们 用 25 执行 下面 的 命令 redis 
127.0 . 0.1 6379 zrangebyscore ranges 25 + inf LIMIT 
0 1 1 B _ start 返回 结果 表明 其 
下 一个 节点 是 一个 start 节点 也 就是说 25 
这个 值 不 处在 任何 start 和 end 之间 不属于 
任何 范围 11 . 存储 社交 关系 Sina 实例 l 
hash sets 关注 列表 粉丝 列表 双向 关注 列表 key 
value field 排序 l string counter 微博 数 粉丝 数 
. . . 避免了 select count * from . . 
. l sort sets 自动 排序 TopN 热门 微博 等 
自动 排序 l lists queue push / sub 新 提醒 
. . . 12 . 交集 并 集 差集 Set 
/ / book 表 存储 book 名称 set book 1 
name The Ruby Programming Language set book 2 name Ruby 
on rail set book 3 name Programming Erlang / / 
tag 表 使用 集合 来 存储 数据 因为 集合 擅长 
求 交集 并 集 sadd tag ruby 1 sadd tag 
ruby 2 sadd tag web 2 sadd tag erlang 3 
/ / 即 属于 ruby 又 属于 web 的 书 
inter _ list = redis . sinter tag . web 
tag ruby / / 即 属于 ruby 但 不属于 web 
的 书 inter _ list = redis . sdiff tag 
. ruby tag web / / 属于 ruby 和 属于 
web 的 书 的 合集 inter _ list = redis 
. sunion tag . ruby tag web 5 . Redis 
Tools 1.8 . 实用 命令 l Keys * 返回 所有 
的 key * 可使用 正则表达式 查询 l Type key 返回 
key 的 类型 string zset list l Select 1 选择 
第一 个 数据库 默认 0 15个 数据库 默认 是 第 
0个 数据 库库 中 l Dbsize 当前 数据库 中的 key 
的 个数 l Monitor 监控 收到 的 请求 1.9 . 
phpRedisAdmin 类似 phpmyadmin 是 一个 PHP 的 MySQL WEB 管理工具 
是 一个 PHP 的 Redis WEB 管理工具 图例 1.10 . 
RedBridge 为 Redis 提供 HTTP API 及 连接池 功能 RedBridge 
是 一款 基于 Redis 的 HTTP API 使用 LUA 直接 
跟 Redis 交互 对 Redis 的 连接 实现 连接池 类似 
数据库 的 存储过程 高效 的 实现 复杂 的 业务 逻辑 
特性 介绍 RedBridge 具有 以下 特征 1 . 使用 C 
+ epoll 编写 的 Web Server 支持 HTTP GET 操作 
2 . 连接池 连接 句柄 复用 提 高跟 Redis 连接 
效率 3 . 部分 类库 使用 Redis 的 代码 更加 
的 稳定 4 . 使用 LUA 直接 调用 Redis 命令 
实现 一次性 数据 交互 实现 复杂 的 业务 逻辑 不 
需要 多次 数据 交互 5 . 服务 模型 采用 单 
进程 双 线程 模式 6 . 配置文件 采用 Lua 语法 
容易 读取 和 书写 7 . RedBridge 发布 前 还 
没有 类似 的 开源 项目 转 自 heoo 的 Redis 
特性 和 应用 场景 计算机 类 博客 这里 就要 抛出 
一个 问题 来 机器学习 你 到底 需要 多少 训练 数据 
尤其 是 SVM 我 这里 训练 集 加 起来 才 
889篇 可以 明确 的 是 这些 训练 集 是 肯定 
不够 的 理论 上 来说 训练 集 应该 越多越好 但是 
其 分类 想过 应该 是 一个 越来越 平缓 的 曲线 
这个 貌似 应该 研究 起来 也 是 一个 不少 篇幅 
的 内容 三 开始 特征提取 吧 接下来 就 开始 机器学习 
第一步 也是 最 重要 的 一步 也是 最 麻烦 的 
一步 吧 事实上 自己 要做 的 工作 就是 这 一步 
毕竟 后面 的 训练 只要 用 前辈 们 已经 不断 
完善 的 分类 算法 和 工具 了 我 选择 的 
是 SVM 算法 和 libsvm 工具包 再 声明 一下 我 
是 利用 卡方检验 对 需要 进行 二 分类 的 文本 
进行 特征选择 已达到 降 维 的 目的 最终 要 得到 
的 是 能够 代表 每个 类别 的 特征 集合 和 
一个 总 的 特征 词典 当然 在 这个 工程 中 
我们 也 会 看到 每个 词 对于 一个 文本 重要性 
的 规律 1 . 分词 工具 第一步 选择 分词 工具 
对 训练 集 进行 分词 我 选择 的 分词 工具 
是 JIEba 分词 而 我 使用 的 语言 是 C 
# 关于 . net core 版本 的 JIEba 分词 可以 
在 这篇 博文 里面 找到 http / / www . 
cnblogs . com / dacc123 / p / 8431369 . 
html 利用 JIEba 分词 工具 我们 才能 进行 后面 的 
计算 词频 词 的 文档 频率 词 的 四 表 
格值 词 的 卡方 值 χ 2     这里 
还是 把 自己 的 代码 贴 出来 吧 如果 有 
需要 的话 我 会 整理 在 GitHub 上 2 . 
计算 词频 第二步 计算 词频 相信 大家 都 会写 我 
把 自己 代码 贴出来 以 供参考 代码 中 多 用了 
Dictionary 数据结构 对了 分词 之前 咱们/r 应该/v 有/v 一份/m 比较/d 
全的/nr 停用/v 词表/n 插 一句 对于 文本 分类 来说 停用词 
越多越好 对于 搜索引擎 来说 就 不是 这样 了 1800 多个 
停用词 # $ % & * + . . . 
. . . . . . . . . . 
. . . . . . . . . . 
. . . . . . . . . / 
. 一 . 数 . 日 / / / 0 
1 2 3 4 5 6 7 8 9 / 
/ = @ A Lex \ ^ _ ` exp 
sub sup | } ~ ~ ~ ~ ~ × 
× × × Δ Ψ γ μ φ φ ． 
В ③ ′ ∈ ′ ｜ ℃ Ⅲ ↑ → 
∈ ［ ∪ φ ∈ ≈ ① ② ② ｃ 
③ ③ ］ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ 
■ ▲ 」 ㈧ 一 一 . 一一 一下 一个 
一些 一 何 一切 一则 一则 通过 一天 一定 一方面 
一旦 一时 一来 一样 一次 一片 一番 一直 一致 一般 
一起 一转眼 一边 一面 七 万一 三 三天两头 三番两次 三番五次 
上 上下 上升 上去 上来 上述 上面 下 下列 下去 
下来 下面 不 不一 不下 不久 不了 不亦乐乎 不仅 不仅 
. . . 而且 不仅仅 不 仅仅 是 不会 不但 
不但 . . . 而且 不光 不免 不再 不力 不单 
不变 不只 不可 不可开交 不可抗拒 不同 不外 不外乎 不够 不大 
不如 不妨 不定 不对 不少 不尽 不尽然 不巧 不已 不常 
不得 不得不 不得了 不得已 不必 不怎么 不怕 不惟 不成 不拘 
不择手段 不敢 不料 不断 不日 不时 不是 不曾 不止 不止一次 
不比 不消 不满 不然 不然的话 不特 不独 不由得 不知不觉 不管 
不管怎样 不经意 不胜 不能 不能不 不至于 不若 不要 不论 不起 
不足 不过 不迭 不问 不限 与 与其 与其说 与否 与此同时 
专门 且 且不说 且说 两者 严格 严重 个 个人 个别 
中小 中间 丰富 串行 临 临到 为 为主 为了 为什么 
为 什麽 为何 为止 为此 为着 主张 主要 举凡 举行 
乃 乃至 乃至于 么 之 之一 之前 之后 之後 之所以 
之类 乌乎/nr 乎 乒 乘 乘势 乘机 乘胜 乘虚 乘隙 
九 也 也好 也 就是说 也是 也罢 了 了解 争取 
二 二来 二话不说 二话没说 于 于是 于是乎 云云 云尔 互 
互相 五 些 交口 亦 产生 亲口 亲手 亲眼 亲自 
亲身 人 人人 人们 人家 人民 什么 什么样 什麽 仅 
仅仅 今 今后 今天 今年 今後 介于 仍 仍旧 仍然 
从 从不 从严 从中 从事 从今以后 从优 从古到今 从古至今 从头 
从宽 从小 从新 从无到有 从早到晚 从未 从来 从此 从此以后 从而 
从轻 从速 从重 他 他人 他们 他 是 他 的 
代替 以 以上 以下 以为 以便 以免 以前 以及 以后 
以外 以 後 以故 以期 以来 以至 以至于 以致 们 
任 任何 任凭 任务 企图 伙同 会 伟大 传 传说 
传闻 似乎 似的 但 但凡 但愿 但是 何 何乐而不为 何以 
何况 何处 何妨 何尝 何必 何时 何止 何苦 何须 余外 
作为 你 你们 你 是 你 的 使 使得 使用 
例如 依 依据 依照 依靠 便 便于 促进 保持 保管 
保险 俺 俺们 倍加 倍感 倒不如 倒不如说 倒是 倘 倘使 
倘或 倘然 倘若 借 借以 借此 假使 假如 假若 偏偏 
做到 偶尔 偶而 傥 然 像 儿 允许 元／吨/nr 充其极/nr 
充其量 充分 先不先 先后 先後 先生 光 光是 全体 全力 
全年 全然 全身心 全部 全都 全面 八 八成 公然 六 
兮 共 共同 共总 关于 其 其一 其中 其二 其他 
其余 其后 其它 其实 其次 具体 具体地说 具体来说 具体说来 具有 
兼之 内 再 再其次 再则 再有 再次 再者 再者说 再说 
冒 冲 决不 决定 决非 况且 准备 凑巧 凝神 几 
几乎 几度 几时 几番 几经 凡 凡是 凭 凭借 出 
出于 出去 出来 出现 分别 分头 分期 分期分批 切 切不可 
切切 切勿 切莫 则 则甚 刚 刚好 刚巧 刚才 初 
别 别人 别处 别是 别的 别管 别说 到 到了儿 到处 
到头 到头来 到底 到 目前 为止 前后 前此 前者 前进 
前面 加上 加之 加以 加入 加强 动不动 动辄 勃然 匆匆 
十分 千 千万 千万千万 半 单 单单 单纯 即 即令 
即使 即便 即刻 即如 即将 即或 即是 说 即若 却 
却不 历 原来 去 又 又及 及 及其 及时 及至 
双方 反之 反之亦然 反之 则 反倒 反倒 是 反应 反手 
反映 反而 反过来 反过来说 取得 取道 受到 变成 古来 另 
另一个 另一方面 另外 另悉 另方面 另行 只 只当 只怕 只是 
只有 只消 只要 只限 叫 叫做 召开 叮咚 叮当 可 
可以 可好 可是 可能 可见 各 各个 各人 各位 各地 
各式 各种 各级 各自 合理 同 同一 同时 同样 后 
后来 后者 后面 向 向使 向着 吓 吗 否则 吧 
吧哒 吱 呀 呃 呆呆地 呐 呕 呗 呜 呜呼 
呢 周围 呵 呵呵 呸 呼哧 呼啦 咋 和 咚 
咦 咧 咱 咱们 咳 哇 哈 哈哈 哉 哎 
哎呀 哎哟 哗 哗啦 哟 哦 哩 哪 哪个 哪些 
哪儿 哪天 哪 年 哪怕 哪样 哪边 哪里 哼 哼唷 
唉 唯有 啊 啊呀 啊哈 啊哟 啐 啥 啦 啪达 
啷当 喀 喂 喏 喔唷 喽 嗡 嗡嗡 嗬 嗯 
嗳 嘎 嘎嘎 嘎登 嘘 嘛 嘻 嘿 嘿嘿 四 
因 因为 因了 因此 因着 因而 固 固然 在 在下 
在于 地 均 坚决 坚持 基于 基本 基本上 处在 处处 
处理 复杂 多 多么 多亏 多多 多多少少 多多益善 多少 多年前 
多年来 多数 多次 够瞧的 大 大不了 大举 大事 大体 大体上 
大凡 大力 大多 大多数 大大 大家 大张旗鼓 大批 大抵 大概 
大略 大约 大致 大都 大量 大面儿 上 失去 奇 奈 
奋勇 她 她们 她 是 她 的 好 好在 好 
的 好象 如 如上 如上所述 如下 如今 如何 如其 如前所述 
如同 如常 如是 如期 如果 如次 如此 如此等等 如若 始而 
姑且 存在 存心 孰料 孰知 宁 宁可 宁愿 宁肯 它 
它们 它们 的 它 是 它 的 安全 完全 完成 
定 实现 实际 宣布 容易 密切 对 对于 对应 对待 
对方 对比 将 将才 将要 将近 小 少数 尔 尔后 
尔尔 尔等 尚且 尤其 就 就地 就是 就是了 就是说 就此 
就算 就要 尽 尽可能 尽如人意 尽心尽力 尽心竭力 尽快 尽早 尽然 
尽管 尽管如此 尽量 局外 居然 届时 属于 屡 屡屡 屡次 
屡次三番 岂 岂但 岂止 岂非 川流不息 左右 巨大 巩固 差一点 
差不多 己 已 已矣 已经 巴 巴巴 带 帮助 常 
常常 常言说 常言 说得好 常言道 平素 年复一年 并 并不 并 
不是 并且 并排 并无 并没 并 没有 并肩 并非 广大 
广泛 应当 应用 应该 庶乎 庶几 开外 开始 开展 引起 
弗 弹指之间 强烈 强调 归 归根到底 归根结底 归齐 当 当下 
当中 当儿 当前 当即 当口儿 当地 当场 当头 当庭 当时 
当然 当真 当着 形成 彻夜 彻底 彼 彼时 彼此 往 
往往 待 待到 很 很多 很少 後 来 後 面 
得 得了 得出 得到 得天独厚 得起 心里 必 必定 必将 
必然 必要 必须 快 快要 忽地 忽然 怎 怎么 怎么办 
怎么样 怎奈 怎样 怎麽 怕 急匆匆 怪 怪不得 总之 总是 
总的来看 总的来说 总的说来 总结 总而言之 恍然 恐怕 恰似 恰好 恰如 
恰巧 恰恰 恰恰相反 恰逢 您 您们 您 是 惟其 惯常 
意思 愤然 愿意 慢说 成为 成年 成年累月 成心 我 我们 
我 是 我 的 或 或则 或多或少 或是 或曰 或者 
或许 战斗 截然 截至 所 所以 所在 所幸 所有 所谓 
才 才能 扑通 打 打从 打开天窗说亮话 扩大 把 抑或 抽冷子 
拦腰 拿 按 按时 按期 按照 按理 按说 挨个 挨家挨户 
挨次 挨着 挨门挨户 挨门逐户 换句话说 换言之 据 据实 据悉 据我所知 
据此 据称 据说 掌握 接下来 接着 接著 接连不断 放量 故 
故意 故此 故而 敞开儿 敢 敢于 敢情 数 / 整个 
断然 方 方便 方才 方能 方面 旁人 无 无宁 无法 
无论 既 既 . . . 又 既往 既是 既然 
日复一日 日渐 日益 日臻 日见 时候 昂然 明显 明确 是 
是不是 是以 是否 是的 显然 显著 普通 普遍 暗中 暗地里 
暗自 更 更为 更加 更进一步 曾 曾经 替 替代 最 
最后 最大 最好 最後 最近 最高 有 有些 有关 有利 
有力 有及/nr 有所 有效 有时 有点 有的 有的是 有着 有著 
望 朝 朝着 末 # # 末 本 本人 本地 
本着 本身 权时 来 来不及 来得及 来看 来着 来自 来讲 
来说 极 极为 极了 极其 极力 极大 极度 极端 构成 
果然 果真 某 某个 某些 某某 根据 根本 格外 梆 
概 次第 欢迎 欤 正值 正在 正如 正巧 正常 正是 
此 此中 此后 此地 此处 此外 此时 此次 此间 殆 
毋宁 每 每个 每天 每年 每当 每时每刻 每每 每逢 比 
比及 比如 比如说 比方 比照 比起 比较 毕竟 毫不 毫无 
毫无例外 毫无 保留 地 汝 沙沙 没 没奈何 没有 沿 
沿着 注意 活 深入 清楚 满 满足 漫说 焉 然 
然则 然后 然 後 然而 照 照着 牢牢 特别 是 
特殊 特点 犹 且 犹自 独 独自 猛然 猛然间 率尔 
率然 现代 现在 理应 理当 理该 瑟瑟 甚且 甚么 甚或 
甚而 甚至 甚至于 用 用来 甫 甭 由 由于 由是 
由此 由此可见 略 略为 略加 略微 白 白白 的 的确 
的话 皆可 目前 直到 直接 相似 相信 相反 相同 相对 
相对而言 相应 相当 相等 省得 看 看上去 看出 看到 看来 
看样子 看看 看见 看起来 真是 真正 眨眼 着 着呢 矣 
矣 乎 矣哉 知道 砰 确定 碰巧 社会主义 离 种 
积极 移动 究竟 穷年累月 突出 突然 窃 立 立刻 立即 
立地 立时 立马 竟 竟然 竟而 第 第二 等 等到 
等等 策略 地 简直 简而言之 简言之 管 类如 粗 精光 
紧接着 累年 累次 纯 纯粹 纵 纵令 纵使 纵然 练习 
组成 经 经常 经过 结合 结果 给 绝 绝不 绝对 
绝非 绝顶 继之 继 后 继续 继而 维持 综上所述 缕缕 
罢了 老 老大 老是 老老实实 考虑 者 而 而且 而况 
而又 而后 而外 而已 而是 而言 而论 联系 联袂 背地里 
背靠背 能 能否 能够 腾 自 自个儿 自从 自各儿 自后 
自家 自己 自打 自身 臭 至 至于 至今 至若 致 
般的 良好 若 若夫 若是 若果 若非 范围 莫 莫不 
莫不然 莫如 莫若 莫非 获得 藉以 虽 虽则 虽然 虽说 
蛮 行为 行动 表明 表示 被 要 要不 要不是 要不然 
要么 要是 要求 见 规定 觉得 譬喻 譬如 认为 认真 
认识 让 许多 论 论说 设使 设或 设若 诚如 诚然 
话说 该 该当 说明 说来 说说 请勿 诸 诸位 诸如 
谁 谁人 谁料 谁知 谨 豁然 贼死 赖以 赶 赶快 
赶早 不 赶晚 起 起先 起初 起头 起来 起见 起首 
趁 趁便 趁势 趁早 趁机 趁热 趁着 越是 距 跟 
路经 转动 转变 转贴 轰然 较 较为 较之 较比 边 
达到 达旦 迄 迅速 过 过于 过去 过来 运用 近 
近几年来 近年来 近来 还 还是 还有 还要 这 这一来 这个 
这么 这么些 这么样 这么点儿 这些 这会儿 这儿 这就是说 这时 这样 
这次 这点 这种 这般 这边 这里 这麽 进入 进去 进来 
进步 进而 进行 连 连同 连声 连日 连日来 连袂 连连 
迟早 迫于 适应 适当 适用 逐步 逐渐 通常 通过 造成 
逢 遇到 遭到 遵循 遵照 避免 那 那个 那么 那么些 
那么样 那些 那会儿 那儿 那时 那末 那样 那般 那边 那里 
那麽 部分 都 鄙人 采取 里面 重大 重新 重要 鉴于 
针对 长期以来 长此下去 长线 长话短说 问题 间或 防止 阿 附近 
陈年 限制 陡然 除 除了 除却 除去 除外 除开 除此 
除此之外 除此以外 除此而外 除非 随 随后 随时 随着 随著 隔夜 
隔日 难得 难怪 难说 难道 难道说 集中 零 需要 非但 
非常 非徒 非得 非特 非独 靠 顶多 顷 顷刻 顷刻之间 
顷刻间 顺 顺着 顿时 颇 风雨无阻 饱 首先 马上 高低 
高兴 默然 默默地 齐 ︿ ＃ ＄ ％ ＆ ＇ 
÷ １ － ＊ ＋ ＋ ξ ＋ ＋ 也 
－ － β － － － ［ ＊ ］ － 
． ／ ０ ０ ２ １ １ ． １２％ ２ 
２．３％ ３ ４ ５ ５ ０ ６ ７ ８ ９ 
＜ ＜ ± ＜ Δ ＜ λ ＜ φ ＜ 
＜ ＝ ＝ ″ ＝ ☆ ＝ ＝ － ＝ 
［ ＝ ｛ ＞ ＞ λ ＠ Ａ ＬＩ Ｒ 
． Ｌ ． ＺＸＦＩＴＬ ［ ［ ① ① ］ ［ 
① ② ］ ［ ① ③ ］ ［ ① ④ 
］ ［ ① ⑤ ］ ［ ① ⑥ ］ ［ 
① ⑦ ］ ［ ① ⑧ ］ ［ ① ⑨ 
］ ［ ① Ａ ］ ［ ① Ｂ ］ ［ 
① Ｃ ］ ［ ① Ｄ ］ ［ ① Ｅ 
］ ［ ① ］ ［ ① ａ ］ ［ ① 
ｃ ］ ［ ① ｄ ］ ［ ① ｅ ］ 
［ ① ｆ ］ ［ ① ｇ ］ ［ ① 
ｈ ］ ［ ① ｉ ］ ［ ① ｏ ］ 
［ ② ［ ② ① ］ ［ ② ② ］ 
［ ② ③ ］ ［ ② ④ ［ ② ⑤ 
］ ［ ② ⑥ ］ ［ ② ⑦ ］ ［ 
② ⑧ ］ ［ ② ⑩ ］ ［ ② Ｂ 
］ ［ ② Ｇ ］ ［ ② ］ ［ ② 
ａ ］ ［ ② ｂ ］ ［ ② ｃ ］ 
［ ② ｄ ］ ［ ② ｅ ］ ［ ② 
ｆ ］ ［ ② ｇ ］ ［ ② ｈ ］ 
［ ② ｉ ］ ［ ② ｊ ］ ［ ③ 
① ］ ［ ③ ⑩ ］ ［ ③ Ｆ ］ 
［ ③ ］ ［ ③ ａ ］ ［ ③ ｂ 
］ ［ ③ ｃ ］ ［ ③ ｄ ］ ［ 
③ ｅ ］ ［ ③ ｇ ］ ［ ③ ｈ 
］ ［ ④ ］ ［ ④ ａ ］ ［ ④ 
ｂ ］ ［ ④ ｃ ］ ［ ④ ｄ ］ 
［ ④ ｅ ］ ［ ⑤ ］ ［ ⑤ ］ 
］ ［ ⑤ ａ ］ ［ ⑤ ｂ ］ ［ 
⑤ ｄ ］ ［ ⑤ ｅ ］ ［ ⑤ ｆ 
］ ［ ⑥ ］ ［ ⑦ ］ ［ ⑧ ］ 
［ ⑨ ］ ［ ⑩ ］ ［ ＊ ］ ［ 
－ ［ ］ ］ ］ ∧ ′ ＝ ［ ］ 
［ ＿ ａ ］ ｂ ］ ｃ ］ ｅ ］ 
ｆ ］ ｎｇ 昉 ｛ ｛ － ｜ ｝ ｝ 
＞ ± ＋ ￥ a b c d e f 
g h i j k l m n o p 
q r s t u v w x y z 
停用 词表 计算 词频 代码 public void ReadText { rd 
= File . OpenText . / stopwords . txt string 
s = while s = rd . ReadLine = null 
{ if s = = null continue if stopwords . 
ContainsKey s stopwords . Add s 1 } Console . 
WriteLine * * * * * * * 读取 停用词 
完毕 rd . Close } / / 计算 词频 url1 
地址 是 放入 训练 集 的 文件夹 url2 地址 是 
存放 计算 词频 结果 的 文件 public void WriteText string 
url1 string url2 { DirectoryInfo folder = new DirectoryInfo url1 
foreach FileInfo file in folder . GetFiles * . txt 
{ rd = File . OpenText file . FullName string 
s = System . Console . WriteLine * * * 
* * * * * * * * * * 
* 开始 读取数据 . . . while s = rd 
. ReadLine = null { var segment = segmenter . 
Cut s false false foreach var x in segment { 
if stopwords . ContainsKey x continue if keys . ContainsKey 
x keys . Add x 1 else keys x + 
+ } } } System . Console . WriteLine * 
* * * * * * * * * * 
* * * 读取 完毕 计算 词频 并 插入 . 
. . wt = new StreamWriter url2 true / / 
wt = File . AppendText url2 var dicSort = from 
objDic in keys orderby objDic . Value descending select objDic 
foreach KeyValuePair string int kvp in dicSort { wt . 
WriteLine kvp . Key + + kvp . Value . 
ToString } System . Console . WriteLine * * * 
* * * * * * * * * * 
* 插入 完毕 . . . wt . Flush rd 
. Close wt . Close } 经过 一顿 操作 历史 
类           计算机 博客 类 选择 
词频 排名 前 30 的 词 来 看看 排名 靠前 
的 词 乍一看 好像 貌似 是 那么回事 这 也是 有时候 
你 只用 词频 这一个 属性 来 分类 文本 发现 效果 
也 不是 那么 差 仔细 看 一下 历史 类 标 
题 年 . . . . 等等 计算机 博客 类 
中 时 等等 这些 词 总是 那么 的 刺眼 我们 
需要 把 这些 冒充 上来 的 词 给 去掉 忘了 
说 下 计算机 博客 类 的 词 的 个数 是 
21503个 历史 类 的 词 的 个数 是 68912个 由于 
自己 找 的 训练 集 不是 那么 好 所以 两 
种类 的 词 差别 有点 大 词 的 个数 这么多 
如果 用 词频 排序 的 词表 来 当做 特 征集 
是不是 效果 不能到达 最好 而且 维度 太大 了 3 . 
文档 频率 DF 前面 提到 过 一个 名词 文档 频率 
DF 也 就是 一个 词 在 多少 个 文档 中 
出现 过 对于 那些 文档 频率 十分 低 的 词 
我们 叫做 生僻 词 这些 词 有 可能 词频 很高 
比如 一个人 写 博客 我 是 大牛 我 是 大牛 
我 是 大牛 . . . . . 循环 了 
几千次 那么 大牛 这个词 就很 靠前 了 然而 他 只 
出现 过 在 一篇 博客 里 所以 我们 可以 把 
这些 生僻 词 去掉 我 也 统计 了 两个 类别 
中的 生僻 词 发现 一大半 都是 DF 为 1 2 
的 词 这里 也 就不 贴 代码 和 统计 结果 
了 因为 我们 不 需要 取出 文档 频率 低 的 
词 为什么 呢 因为有 卡方检验 啊 这个 十分 强大 的 
机器 是 肯定 会 帮 我们 过滤掉 DF 极低 的 
词 所以 咱们 直奔 卡方检验 看看 是不是 可以 验证 自己 
的 猜想 而 统计 DF 的 值 恰恰 帮助 了 
我们 计算 卡方检验 4 . 卡方检验 一 根据 上 一篇 
博客 中 的 公式 对于 每个 词 我们 需要 计算 
四个 值 A B C D 再 解释一下 以 大牛 
和 计算机 博客 类 为 例子 A 包含 大牛 属于 
计算机 博客 的 文档 个数 B 包含 大牛 不属于 计算机 
博客 的 文档 个数 C 不 包含 大牛 属于 计算机 
博客 类 的 文档 个数 D 不 包含 大牛 不属于 
计算机 的 文档 个数 看起来 很 繁琐 其实 只要 有了 
上 一步 统计 的 DF 表 那就 很 容易 了 
以 计算机 博客 类 为 例子 BlogDF 表示 计算机 博客 
类 的 词 的 文档 频率 表 HistoryDF 表示 历史 
类 的 词 的 文档 频率 表 那么 A 的 
值 自然 就是 BlogDF 的 值 B 的 值 forearch 
BlogDF if HistoryDF x = 0 B x = HistoryDF 
x else B x = 0 C 和D/nr 的 值 
自然 就是 foreach C D C x = 计算机 总 
文档 数 A x D x = 计算机 总 文档 
数 B x 代码 如下 比较 简陋 没有 收拾 public 
static Dictionary string int keysA = new Dictionary string int 
public static Dictionary string int keysB = new Dictionary string 
int public static Dictionary string int keys2 = new Dictionary 
string int public static Dictionary string int keysC = new 
Dictionary string int public static Dictionary string int keysD = 
new Dictionary string int public static Dictionary string double result 
= new Dictionary string double public static Dictionary string int 
stopwords = new Dictionary string int public static System . 
IO . StreamReader rd public static System . IO . 
StreamWriter wt public JiebaSegmenter segmenter = new JiebaSegmenter / / 
属于 类别 一 训练 集 的 个数 public static int 
category1 = 0 / / 属于 类别 而 训练 集 
的 个数 public static int category2 = 0 / / 
先 读取 记录 public void ReadText string url string url2 
{ rd = File . OpenText . / stopwords . 
txt string s = while s = rd . ReadLine 
= null { if s = = null continue if 
stopwords . ContainsKey s stopwords . Add s 1 } 
Console . WriteLine * * * * * * * 
读取 停用词 完毕 rd . Close rd = File . 
OpenText url s = while s = rd . ReadLine 
= null { string s1 = string s2 = int 
tag = 0 int l = s . Length for 
int i = 0 i l i + + { 
if s i = = { tag = 1 continue 
} if tag = = 0 { s1 + = 
s i } else s2 + = s i } 
keysA . Add s1 Int32 . Parse s2 } rd 
. Close rd = File . OpenText url2 s = 
while s = rd . ReadLine = null { string 
s1 = string s2 = int tag = 0 int 
l = s . Length for int i = 0 
i l i + + { if s i = 
= { tag = 1 continue } if tag = 
= 0 { s1 + = s i } else 
s2 + = s i } keys2 . Add s1 
Int32 . Parse s2 } rd . Close Console . 
WriteLine * * * * * * * 加载 旧 
记录 完毕 foreach var x in keysA { if keys2 
. ContainsKey x . Key keysB . Add x . 
Key keys2 x . Key else keysB . Add x 
. Key 0 } } / / 写入 特征 public 
void WriteText string url1 string url2 string url3 string url4 
{ DirectoryInfo folder = new DirectoryInfo url1 foreach FileInfo file 
in folder . GetFiles * . txt { category1 + 
+ } DirectoryInfo folder2 = new DirectoryInfo url2 foreach FileInfo 
file in folder2 . GetFiles * . txt { category2 
+ + } foreach var x in keysA { keysC 
. Add x . Key category1 keysA x . Key 
keysD . Add x . Key category2 keysB x . 
Key } ComputeChi if File . Exists url3 { FileStream 
fs = File . Create url3 fs . Close } 
if File . Exists url4 { FileStream fs = File 
. Create url4 fs . Close } System . Console 
. WriteLine * * * * * * * * 
* * * * * * 读取 完毕 计算 A 
B C D 并 插入 . . . wt = 
new StreamWriter url3 false / / wt = File . 
AppendText url2 var dicSort = from objDic in keysA orderby 
objDic . Value descending select objDic foreach KeyValuePair string int 
kvp in dicSort { wt . WriteLine kvp . Key 
+ + kvp . Value . ToString + + keysB 
kvp . Key + + keysC kvp . Key + 
+ keysD kvp . Key } System . Console . 
WriteLine * * * * * * * * * 
* * * * * 插入 完毕 . . . 
wt . Flush System . Console . WriteLine * * 
* * * * * * * * * * 
* * 读取 完毕 计算 卡方检验 并 插入 . . 
. wt = new StreamWriter url4 false / / wt 
= File . AppendText url2 var dicSort2 = from objDic 
in result orderby objDic . Value descending select objDic foreach 
KeyValuePair string double kvp in dicSort2 { wt . WriteLine 
kvp . Key + + kvp . Value . ToString 
} System . Console . WriteLine * * * * 
* * * * * * * * * * 
插入 完毕 . . . wt . Flush rd . 
Close wt . Close } public static void ComputeChi { 
foreach var x in keysA { result . Add x 
. Key double double category1 + category2 * double keysA 
x . Key * keysD x . Key double keysB 
x . Key * keysC x . Key * double 
keysA x . Key * keysD x . Key double 
keysB x . Key * keysC x . Key / 
double keysA x . Key + keysB x . Key 
* double keysC x . Key + keysD x . 
Key * double keysA x . Key + keysC x 
. Key * double keysB x . Key + keysD 
x . Key } } 计算 卡方检验 于是 兴高采烈 的 
看看 我们 的 强大 的 卡方检验 得到 的 值 以 
计算机 类 为了 做 对比 左边 是 词频 排名 右边 
的 是 卡方检验 排名 顿时 傻眼 了 为什么 卡方检验 之后 
词 的 排名 变成 这样 了 历史 中国 发展 貌似 
是 代表 的 历史 了 难道 自己 代码 写错 了 
仔细 排查 发现 代码 并 没有 写错 这些 词 也 
确实 在 计算机 博客 类别 的 文档 里 出现 过 
可是 为什么 这些 词 的 排名 如此 之高 查找 这些 
的 A B C D 值 以 标 为例 属于 
计算机 类 博客 不属于 计算机 类 博客 属于 历史 类 
包含 标 A 3B 443 不 包含 标 C 417D 
26 根据 公式 计算 出来 的 值 确实是 780多 而 
标的 词频 只有 3 翻看 历史 类 别的 卡方 值 
也是 780多 这个 标 这么 全能 吗 实际上 两个 类别 
的 公共 词 的 卡方 值 都是 一样 的 观察 
公式 和 ABCD 的 值 就 可以 发现 了 我们 
再 回顾 一 开始 的 卡方检验 我们 假设 某个 词 
对于 文档 是不是 某个 类别 是 没有 影响 的 而 
不是 某个 词 是不是 能 代表 某个 类别 那么 标 
这个词 虽然 对 计算机 博客 类 几乎 没有 一点 代表性 
但是 你 看看 之前 的 词频 表 标 在 历史 
类 中的 词频 排名 非常 靠前 到 这里 就 应该 
清楚 了 标 这个词 卡方检验 认为 标 这个词 对 历史 
类别 的 影响 很大 当 一个 文档 出现 标 那么 
可以 很大 一部分 确定 他 是 历史 类别 不是 计算机 
博客 类别 所以 标 对于 文档 不是 计算机 类别 还是 
有 很大 影响力 的 自然 排名 靠前 这里 就 有 
一个 疑问 了 为什么 标 这种 词 可以 很好 的 
代表 历史 这个 后面 再提 这也 是 前面 说过 的 
卡方检验 的 低 词频 性 缺陷 5 . 卡方检验 二 
所以 眼前 这个 酷似 历史 的 卡方检验 排名表 是否 可以 
作为 计算机 博客 类 的 特征 集合 呢 答案 是 
肯定 的 这些 排名 靠前 的 词 对于 判断 一个 
文档 是否 属于 计算机 博客 类别 相当 有 说服力 但是 
这样 的 排名表 我 看着 真 的 不是 很 喜欢 
于是 我 就做 了点 小动作 我们 回顾 一下 卡方检验 公式 
推导 过程 为了 防止 正负 相互 抵消 所以 我 们 
采用 了 平方和 然后 在 二分 类 问题 中 这个 
正负 其实 是 很有 意义 的 不 应该 就 这么 
被和谐 掉 我们 看看 标 的 四格 表 属于 计算机 
类 博客 不属于 计算机 类 博客 属于 历史 类 包含 
标 A 3B 443 不 包含 标 C 417D 26A 
和D的/nr 值 很小 B 和C的/nr 值 很大 这就 告诉 了 
我们 一个 信息 含有 标 很大 可能 是 历史 类 
很小 可能 是 计算机 类 在 计算 过程 中 以 
计算 A 的 观察 值 和 理论值 的 偏差 为例 
约等于 实际上 这个 偏差 应该是 负 的 3 210 应该 
是 负数 我们 使用 平方和 才 变成 为 正 的 
所以 我们 不 使用 平方和 而是 使用 E A * 
| E A | 偏差 为 负 表示 啥 呢 
表示 这个 词 能够 否定 文 本属于 该类 文档 语气 
重 了 一点 为 正 表示 这个 词 能够 肯定 
文 本属于 该类 文档 属于 计算机 类 博客 不属于 计算机 
类 博客 属于 历史 类 包含 标 A 3   
EA 210B 443 EB 235 不 包含 标 C 417 
EC 209D 26   ED 233 推广 到 四个 值 
发现 实际上 B 的 偏差 值 是 正 的 443 
235 是 正数 嘛 实际上 对于 B 我们 应该 取 
负数 同理 C 应该 去 负数 对于 B C 在 
计算 结果 之后 加上 一个 负数 这样 算 出来 的 
标 就是 780多 为什么 呢 因为 B 是 包含 标 
属于 历史 类 对于 计算机 类 说是 反例 同理 C 
也是 所以 要 取反 正变 负 负 变 正 这样 
我们 可以 想象 如果 用 符号 表示 卡方 值 的 
大小 那么 卡方检验 得到 的 值 应该 是 类似于 正态分布 
越/d 靠近/v 0/m 的/uj 词/n 越/d 没有用/i 离 0 越远 
的 词 我们 就越 关注 那么 这个 具体 的 阀值 
是 什么 还 记得 在 卡方 分布 中 说过 的 
那个 拒绝域 吗 3.84 对 就是 他 了 你 别看 
上面 的 图 + 3.84 和 3.84 之间 距离 很短 
但是 这么 短 的 距离 中 包含 的 词 可 
多着呢 我 的 数据 集中 大概 三分之二 的 词 都 
集中 在 3.84 到 + 3.84 之间 于是 在 这个 
有 符号 的 卡方检验 指导下 我们 变更 公式 对于 四格 
表 而言 哦 也 就是 对于 二 分类 而言 哦 
根据 此 公式 我们 修改 代码 / / 计算 观察 
值 A 的 偏差 符号为 + double EA = double 
keysA x . Key + keysB x . Key * 
double keysA x . Key + keysC x . Key 
/ double category1 + category2 double a = double keysA 
x . Key EA * System . Math . Abs 
double keysA x . Key EA / EA / / 
计算 观察 值 B 的 偏差 符号为 double EB = 
double keysA x . Key + keysB x . Key 
* double keysB x . Key + keysD x . 
Key / double category1 + category2 double b = 1 
* double keysB x . Key EB * System . 
Math . Abs double keysB x . Key EB / 
EB / / 计算 观察 值 C 的 偏差 符号为 
double EC = double keysC x . Key + keysD 
x . Key * double keysA x . Key + 
keysC x . Key / double category1 + category2 double 
c = 1 * double keysC x . Key EC 
* System . Math . Abs double keysC x . 
Key EC / EC / / 计算 观察 值 D 
的 偏差 符号为 + double ED = double keysC x 
. Key + keysD x . Key * double keysB 
x . Key + keysD x . Key / double 
category1 + category2 double d = double keysD x . 
Key ED * System . Math . Abs double keysD 
x . Key ED / ED result . Add x 
. Key a + b + c + d 得到 
一个 新的 卡方检验 表 以 计算机 类别 同样 和 词频 
作 对比 乍一看 卡方检验 的 效果 确实 不错 仔细 一看 
嗯 还是 效果 很好 哈哈哈 中 这个词 终于 消失了 果然 
名不虚传 卡方检验 确实 是 一个 好 东西 6 . 卡方检验 
的 低 词频 性 再 看看 历史 类 的 哎呀 
这个 标 期 . . . . 等等 真是 差强人意 
看看 之前 的 文本 范例 我们 就 明白 了 文献号 
1 1 原文 出处 历史研究 原 刊 地名 京 原 
刊期 号 199602 原 刊 页号 5 25 分 类 
号 K1 分 类 名 历史学 作 者 林甘泉 复印 
期 号 199607 标 题 二十 世纪 中国 历史学 回顾 
二十 世纪 的 中国 历史学 正 文 每 一篇 都 
有一个 标题 文献号 等等 因为 卡方检验 本来 就是 忽视 了 
词频 的 这次 个 每 篇文章 只 出现 一次 的 
词 反而 重要性 排 第一 去了 所以 我们 就 需要 
结合 词频 信息 对 卡方检验 再次 来 改造 具体 应该 
怎么 权衡 卡方检验 和 词频 的 值 呢 一 时间 
我 也 没有 想到 好 的 方法 可以 将 卡方检验 
排名 靠前 的 词 词频 小于 等于 文档 数 或者 
小于 等于 文档 数 2倍 的 词 都 去掉 7 
. 卡方检验 的 神奇 再来 看看 卡方检验 排名表 的 后半 
部分 左边 计算机 博客 类 右边 历史 类 可以 看到 
这些 历史 类 排名 最后 的 是不是 很 像是 计算机 
博客 类 的 词语 这些 距离 0 很远 的 词 
是 论证 文章 不 属于 历史 类 的 词语 也 
验证 了 上面 的 正态分布 的 猜想 两个 类别 正好 
倒 过来 了 十分 对称 十分 完美 绝 知 此事 
要 躬行 躬行 之后 的 感觉 果然 不同 呀 其实 
具体 实验 的 时候 才 发现 词汇 这个 组成 文章 
的 基本 成分 在 众多 文本 之间 有 太多 规律 
太多 巧妙 的 地方 值得 去 挖掘 了 这也 是 
自然 语言 处理 的 魅力 了吧 再次 回到 之前 的 
文档 频率 DF 我们 说 文档 频率 DF 低 的 
不用 处理 卡方检验 会 帮 我 处理 看看 结果 这里 
截 两张 图 第一 个 参数 是 卡方检验 的 值 
第二个 值 是 文档 频率 DF 果然 这些 DF 十分 
低 的 词 都被 分配 到了 0 周围 坚决 的 
和 0站 在 一起 坚决 的 要被 淘汰 掉 四 
结语 那么 经过 前面 的 步骤 的确 得到 了 可以 
代表 两个 类 的 特征 集合 将 两个 特征 集合 
距离 0 的 距离 大于 3.84 的 特征 就是 词 
啦 取 一个 并 集 那么 就是 一个 特征 词典 
了 我们 可以 想象 历史 类 和 计算机 博客 类 
的 文本 向量 如果 映射 在 这个 词典 上 他们 
分布 是 不同 的 而 SVM 正是 解决 中 在 
高维空间 也 就是 向量 维度 很高 把 两类 向量 进行 
分类 如果 线性 不可分 SVM 会 使用 核 函数 映射 
到 更高 的 维度 使其 变成 线性 可分 具体 的 
原理 这里 也不 细究 可见 在 SVM 之前 将 文本 
变成 向量 的 过程 是 一个 非常 重要 的 步骤 
