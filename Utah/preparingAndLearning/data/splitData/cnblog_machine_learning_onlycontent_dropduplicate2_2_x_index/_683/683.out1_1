欢迎 大家 前往 云+/nr 社区 获取 更多 腾讯 海量 技术 
实践 干货 哦 ~ 下载 heaton javascript ml . zip 
45.1 KB 基本 介绍 在 本文 中 你 会对 如何 
使用 JavaScript 实现 机器学习 这个 话题 有 一些 基本 的 
了解 我会 使用 Encon 一个 先进 的 神经 网络 和 
机器学习 框架 这个 框架 并向 你们 展示 如何 用 这个 
框架 来 实现 光学 字符 辨识 模拟退火 法 遗传算法 和 
神经 网络 Encog 同时 包括 了 几个 GUI 窗体 小 
部件 这些 小 部件 可以 更 方便 地 显示 出 
一般 机器学习 任务 的 输出 运行 环境 Encog 是 一个 
面向 Java C # JavaScript 和C//nr C + + 的 
高级 机器学习 平台 除此之外 Encog 还 可以 为 http / 
/ www . heatonresearch . com / wiki / Meta 
_ Trader _ 4 的 实际 案例 生成 对应 代码 
本文 将 重点 介绍 如何 使用 支持 JavaScript 的 Encog 
框架 该 框架 允许 你 创建 利用 人工智能 实现 的 
交互式 web 应用程序 访问 以下 网址 获取 有关 Encog 的 
更多 信息 http / / www . heatonresearch . com 
/ encog 代码 调用 本文 介绍 的 所有 示例代码 都 
可以 在 附带 的 下载 中找到 这段 代码 同时 被 
托管 在 下面 的 GitHub 库 中 https / / 
github . com / encog / encog javascript 你 可以 
看到 本文 讨论 的 所有 示例 都 运行 在 下面 
的 URL 中 http / / www . heatonresearch . 
com / funEncog 框架 包含 在 两个 JavaScript 文件 中 
第一 个 JavaScript 文件 包含 了 所有 核心 的 机器学习 
函数 这个 JavaScript 文件 被 命名 为 encog js x 
. js 第二 个 文件 包含 了 所有 的 GUI 
窗体 小 组件 并被 命名 为 encog widget . js 
你 可以 在 下面 的 引用 路径 中 阅读 这 
两个 文件 script src = encog js 1.0 . js 
/ script script src = encog widget 1.0 . js 
/ script 欧氏距离 我们 从 欧氏距离 开始 谈起 欧氏距离 是 
一个 非常 简单 的 概念 适用 于 不同 的 机器 
学习 技术 欧氏距离 提供 的 结果 是 一个 数字 该 
数字 决定 了 相同 长度 的 两个 数组 之间 的 
相似性 思考 下面 三个 数组 Array 1 1 2 3 
Array 2 1 3 2 Array 3 3 2 1 
我们 可以 计算出 上面 任意 两个 数组 之间 的 欧氏距离 
这 对于 确定 数组 之间 的 相似 度 是 非常 
有用 的 思考 一下 假如 我们 想 要 确定 一下 
数组 2 或者 数组 3 哪个 距离 数组 1 更近 
为了 做到 这 一点 我们 需要 计算 数组 1 和 
数组 2 之间 的 欧氏距离 然后再 计算 数组 1 和 
数组 3 之间 的 欧氏距离 两 相比较 最短 的 就是 
最 相似 的 从 数学 角度 来讲 欧氏距离 由 以下 
方程式 进行 计算 图 1 欧氏距离 使用 这个 公式 我们 
现在 可以 计算 上文 中的 欧氏距离 d a1 a2 = 
sqrt a2 0 a1 0 ^ 2 + a2 1 
a1 1 ^ 2 + a2 1 a1 1 ^ 
2 d a1 a2 = sqrt 1 1 ^ 2 
+ 3 2 ^ 2 + 2 3 ^ 2 
d a1 a2 = sqrt 0 + 1 + 1 
d a1 a2 = sqrt 2 = 1.4 d a1 
a3 = sqrt a3 0 a1 0 ^ 2 + 
a3 1 a1 1 ^ 2 + a3 1 a1 
1 ^ 2 d a1 a3 = sqrt 3 1 
^ 2 + 2 2 ^ 2 + 1 3 
^ 2 d a1 a3 = sqrt 4 + 0 
+ 4 d a1 a3 = sqrt 8 = 2.3 
从 结果 中 我们 可以 看出 数组 2 比 数组 
1 更为 接近 数组 3 下面 的 JavaScript 代码 实现 
了 欧氏距离 的 计算 ENCOG . MathUtil . e u 
c l i d e a n D i s 
t a n c e = function a1 a2 startIndex 
len { use strict var result = 0 i diff 
for i = startIndex i startIndex + len i + 
= 1 { diff = a1 i a2 i result 
+ = diff * diff } return Math . sqrt 
result } 欧氏距离 可以 被 用来 创建 一个 简单 的 
光学 字符 辨识 实例 你 可以 在 下图 中 看到 
应用 程序运行 实例 图 2 JavaScript 光学 字符 辨识 你 
可以 在 下面 这个 URL 中 查看 程序 的 运行 
实例 http / / www . heatonresearch . com / 
fun / ocrHTML5 启用 触 控 设备 的 JavaScript 应用 
程序 可以 通过 简单 的 欧氏距离 来 实现 基本 的 
光学 字符 辨识 为了 使用 这个 示例 需要 在 下面 
这个 大 的 矩形 中 绘制 一个 数字 然后 点击 
Recognize 识别 按钮 程序 会 尝试 猜测 你 画 的 
这个 数字 虽然 准确性 并 不是 特别 高 但 它 
做 的 确实 已经 很 不错 了 该 程序 已经 
通过 了 数据 训练 你 可以 移除 这些 数字 条目 
中 的 任何 一个 或者 创建 你 自己 的 条目 
如果 需要 训练 一个 新 字符 的 OCR 只要 简单 
绘出 那 个字符 然后 点击 Teach 教学 按钮 则 该 
字符 就 会被 增加到 已知 的 字符 列表 中 你 
会 发现 你 所 绘制 的 任何 东西 都是 先 
剪裁 然后 向下 采样 的 程序 会对 你 所 绘制 
的 高分辨率 字符 向下 采样 并将 采样 点 分配 到 
5 × 8 网格 中 然后 将 这个 通过 向下 
采样 得到 的 网格 与 每个 数字 的 向下 采样 
网格 进行 比较 如果 要 查看 程序 中经 训练 后 
得到 的 网格 需要 在 字符 列表 中 单击 你 
希望 看到 的 字符 然后 程序 会 将 这个 网格 
转换 成 一个 一维 数组 而 一个 5 × 8 
的 网格 会有 40个 数组 元素 以下 JavaScript 代码执行 了 
这个 搜索 并且 实现 了 一个 欧氏距离 的 计算 var 
c data sum i delta for c in charData { 
data = charData c / / 现在 我们 将 会 
识别 出 这个 画 出来 的 字母 . / / 
为此 我们 需要 利用 欧氏距离 来 计算 / / http 
/ / www . heatonresearch . com / wiki / 
Euclidean _ Distance 这是 欧氏距离 运行 实例 的 URL sum 
= 0 for var i = 0 i & lt 
data . length i + + { delta = data 
i downSampleData i sum = sum + delta * delta 
} sum = Math . sqrt sum / / 最 
基本 的 我们 需要 计算 的 是 欧氏距离 / / 
我们 画 上去 的 字母 我们 学习 的 每一个 样本 
/ / 程序 将 会 返回 欧氏距离 最小 的 那个 
字符 if sum & lt bestScore | | bestChar = 
= { bestScore = sum bestChar = c } } 
蜂拥 算法 这个 例子 展示 一个 名为 flocking 蜂拥 的 
迷人 的 简单 算法 此处 的 粒子 是 成群 存在 
的 起初 的 时候 它们 各自 随机 出现 在 某个 
位置 然而 这些 粒子 会 很快 地 填充 成 各种 
形式 的 组 并以 看似 复杂 的 模式 路线 飞行 
或者 你 也 可以 手动 点击 或者 触摸 一个 位置 
这些 粒子 会 排斥 并 远离 你 的 接触点 flocking 
蜂拥 算法 你 可以 在 线 运行 以下 URL 的 
实例 程序 http / / www . heatonresearch . com 
/ fun / flock 这个 实例 可能 需要 一 分钟 
大约 才能 让 成熟 的 蜂拥 集群 出现 即使 这些 
集群 出现 了 它们 也 经常 会 再次 分裂 和 
重组 重启 时 点击 Clear 清除 或者 也 可以 点击 
Big Bang 大爆炸 模式 该 模式 不会 使用 任何 随机 
的 初始化 而是 将 粒子 统一 放置 在 面板 中央 
并且 以 粒子 设定 的 复杂 模式 迅速 向外 移动 
克雷格 雷诺兹 在 1986年 首次 用 他 的 模拟程序 Boids 
在 计算机 上 成功 模拟 出了 蜂拥 算法 蜂拥 集群 
是 一种 非常 复杂 的 行为 他 在 不同 种类 
的 动物 中 有 各自 表现形式 各自 使用 了 很多 
不同 的 名字 比如 一群 小鸟 一群 昆虫 一个 学校 
的 鱼群 一群牛 等等 其实 就是 用 不同 的 名字 
来 描述 本质 相同 的 行为 初 看上去 蜂拥 算 
法可能 看似 复杂 因为 我们 需要 创建 一个 对象 来 
处理 集群 中的 个体 需要 定义 一个 蜂拥 对象 来 
容纳 集群 成员 需要 为 确定 蜂拥 集群 应该 向 
哪个 方向 移动 而 制定 常规 行为 我们 还 必须 
确定 如何 将 蜂拥 集群 分成 两群 或者 更多 的 
群 那么 问题 是 什么样 的 标准 可以 决定 某 
个 群体 可以 得到 成员 数量 新成员 如何 被 确认 
是 属于 哪 一个 集群 你 可以 在 下面 内容 
中 看到 一些 真实 的 蜂拥 集群 例子 蜂拥 算法 
其实 很 简单 它 只有 三条 规则 分离   远离 
拥挤 的 邻居 短距离 相互 排斥 对齐 趋 近于 邻居 
的 平均 方向 内聚 转向 邻居 的 平均 距离 位置 
长距离 相互 吸引 这三个 基本 规则 是 必需 的 蜂拥 
算法 其实 就是 简单 的 复杂 的 典型 例子 我 
希望 这个 例子 能够 尽可能 的 简单 但是 仍然 表现 
出 看似 复杂 的 行为 方式 其实 这些 粒子 都 
是以 恒定 的 速度 运行 的 每个/r 粒子/n 都有/nr 一个/m 
角度/n 属性/n 来/v 定义/n 粒子/n 运动/vn 的/uj 方向/n 所以 这些 
粒子 不 可以 加速 或者 减速 唯一 可以 做到 是 
转向 上述 的 三种 规则 其实 是 分别 为 粒子 
的 运动 设 定好 了 一个 理想 的 角度 遵守 
这三种 规则 的 期望 被 特定 的 百分比 属性 所 
抑制 这些 抑制 因子 是 你 在 底部 看到 的 
三个 数字 你 可以 尝试 填入 一些 数字 看看 它们 
是 如何 影响 集群 粒子 的 运动 轨迹 的 其实 
有 很多 的 数字 组合 不会 产生 集群 的 行为 
而 我 在 实例 中 填入 的 默认值 是 比较 
合适 的 如果 你 想 单独 查看 这三种 规则 中 
单独 一条 生效 时的/nr 结果 那么 可以 将 该 规则 
设置 为 1.0 其它 的 规则 设置 为 0.0 例如 
当 内聚 的 规则 单独 生效 时 你 会 所有 
的 粒子 会 聚集 在 面板 区域 中 少数 的 
几个 位置 在 这个 区域 中 不 存在 任何 随机性 
除了 粒子 最初 出现 的 位置 是 随机 的 之外 
不会 产生 更多 的 随机数 你 甚至 可以 点击 Big 
Bang 大爆炸 模式 按钮 来 消除 系统 中 所有 的 
随机性 如果 你 点击 了 Big Bang 按钮 则 所有 
的 粒子 都会 被 放置 到 区域 的 中心 位置 
并以 同样 的 方向 运动 如此一来 要 形成 一幅 复杂 
的 运动 模式 并 不会 花费 很长 时间 所以 对于 
用 非常 简单 的 规则 来 实现 非常 复杂 的 
系统 来说 蜂拥 算法 是 一个 非常 典型 的 例子 
理解 欧氏距离 对于 例子 很 重要 因为/c 每个/r 粒子/n 都有/nr 
两个/m 维度/ns 分别 是 x 坐标 和y/nr 坐标 利用 欧氏距离 
的 计算 方法 我们 就 可以 很快 找到 最近 的 
邻居 由 此即 引入 了 另一种 重要 的 机器学习 算法 
即 K 邻近 算法 这个 K 就是 你 希望 找到 
的 邻居 的 数量 这三种 规则 可以 很 容易 的 
用 JavaScript 实现 首先 我们 计算 出 理想 的 分离 
角度 / / 1 . 隔离 避免 拥挤 的 邻居 
短距离 的 排斥力 separation = 0 if nearest . length 
0 { meanX = ENCOG . ArrayUtil . arrayMean nearest 
0 meanY = ENCOG . ArrayUtil . arrayMean nearest 1 
dx = meanX this . agentsi dy = meanY this 
. agentsi separation = Math . atan2 dx dy \ 
* 180 / Math . PI this . agentsi separation 
+ = 180 } 首先 我们 需要 计算 出 所有 
邻居 粒子 的 x 坐标 的 平均值 和y/nr 坐标 的 
平均值 这个 平均 坐标 点 就是 邻近 集群 的 中心点 
然后 借用 一些 三角函数 中 的 知识 计算 出 我们 
和 邻近 集群 中心点 之间 的 夹角 值 对 这个 
夹角 值 加上 180 因为 我们 是 希望 远离 这个 
邻近 的 邻居 的 进而 我们 就 不会 撞到 它们 
这个 才 是 我们 应该 努力 争取 的 理想 分离 
角度 紧接着 我们 会 计算 出 理想 的 对齐 角度 
如下 代码 所示 / / 2 . 对齐 转向 邻居 
的 平均 方向 alignment = 0 if neighbors . length 
0 { alignment = ENCOG . ArrayUtil . arrayMean neighbors 
2 this . agents i 2 } 对齐 非常简单 其实 
就是 所有 邻居 的 平均 角度 接下来 我们 计算 内聚力 
为此 我们 再 来 看看 邻居 不过 这回 考虑 的 
是 一个 更大 的 集合 几乎 包括 了 所有 的 
粒子 / / 3 . 内聚 转向 邻居 的 平均 
位置 长 距离 的 吸引力 cohesion = 0 if neighbors 
. length 0 { meanX = ENCOG . ArrayUtil . 
arrayMean this . agents 0 meanY = ENCOG . ArrayUtil 
. arrayMean this . agents 1 dx = meanX this 
. agents i 0 dy = meanY this . agents 
i 1 cohesion = Math . atan2 dx dy * 
180 / Math . PI this . agents i 2 
} 现在 我们 从 这个 规则 中 得到 了 理想 
的 角度 那么 必须 要 开始 转动 粒子 或者 说是 
代理 了 / / 执行 转向 操作 / / 这三种 
规则 的 参数 应用 值 是 可以 配置 的 / 
/ 我 提供 的 这三个 默认值 比例 的 运行 表现 
很好 turnAmount = cohesion * this . constCohesion + alignment 
* this . constAlignment + separation * this . constSeparation 
this . agents i 2 + = turnAmount 到 目前 
为止 我们 研究 的 技术 并 不是 随机性 的 而是 
可以 被 认定 为 决定性 的 也 就是说 得到 的 
结果 总 是 可以 预测 的 对于 本文 的 内容 
的 排版 我们 会 做出 180度 的 调整 剩下 的 
技术 都是/nr 研究 随机性 的 也 就是 用 随机性 来 
解决问题 旅行 推销员 问题 TSP 问题 旅行 推销员 问题 TSP 
意为 存在 一名 推销员 他 必须 经过 一定 数量 的 
城市 而 这条 最短 的 旅行 路线 就 是 我们 
寻找 的 目标 其中 允许 推销员 从 任意 一个 城市 
开始 或者 结束 唯一 的 要求 是 推销员 必须 经过 
每 一个 城市 并 且 只能 经过 一次 如果 用 
一般 的 迭代 程序实现 这 似乎 是 一个 简单 的 
任务 思考 一下 随着 城市 数量 的 增加 可能 的 
排列 组合 数量 会 增加 多少 如果 只有 一 两个 
城市 那只/nr 需要 一步 迭代 就 够了 如果 是 三 
个 城市 呢 迭代 步骤 就 变成 了 6步 表格 
8 1列 举出 了 迭代 步骤 的 增长 速度 表 
1 用 常规 程序 解决 TSP 问题 的 步骤 数目 
表格 中 的 计算 公式 就是 阶乘 步骤 数目 n 
的 数量 就是 用 阶乘 符号 计算 的 任意 n 
值 的 阶乘 计算 方式 是 n × n − 
1 × n − 2 . . . . . 
. . 3 × 2 × 1 由 这个 公式 
不难看出 当 一个 程序 必须 使用 暴力 方式 进行 搜索 
时 这些 数值 会 变得 非常 大 在下 一节 的 
讨论 中 我们 使用 的 示例 程序 会在 几 分钟 
内 找到 一个 能 解决 50 个 城市 问题 的 
解决方案 这个 程序 用到 是 模拟 退 火法 的 思路 
而 不是 使用 普通 的 暴力 搜索 模拟退火/n 法/l 模拟退火/n 
法是/nr 一种/m 模拟退火/n 的/uj 物理/n 过程/n 的/uj 编程/n 方法/n 退火 
是 指 将 某种 材料 比如 钢铁 或者 玻璃 加热 
后再/nr 冷却 的 方法 通常 用来 软化 材料 以及 降低 
材料 硬度 由此可知 模拟退火 法 就是 将 一个 解决方案 暴露在 
热处理 的 环境 中 然后 进行 冷却 处理 进而 产生 
一个 更好 的 解决方案 你 可以 在 下面 的 URL 
中 运行 模拟退火 法的/nr 示例 程序 http //i //i www/w 
./i heatonresearch/w ./i com/w //i fun/w //i tsp/w //i anneal/w 
模拟退火/n 法是/nr 通过/p 从/p 起始/v 温度/n 到/v 结束/v 温度/n 的/uj 
多次/m 迭代/v 进行/v 实现/v 的/uj 循环 计数 允许 你 指定 
温度 下降 的 粒度 温度 越高 系统 引入 的 随机性 
就 越高 你 可以 配置 这三个 参数 的 值 下面 
的 JavaScript 代码 实现 了 模拟 退 火法 anneal . 
randomize = function path temperature { var length = path 
. length 1 / / 调整 路径 上 城市 的 
次序 即 模拟退火 for var i = 0 i temperature 
i + + { var index1 = Math . floor 
length * Math . random var index2 = Math . 
floor length * Math . random var d = universe 
. pathDistance path index1 index1 + 1 + universe . 
pathDistance path index2 index2 + 1 universe . pathDistance path 
index1 index2 universe . pathDistance path index1 + 1 index2 
+ 1 if d 0 { / / 如果 需要 
的话 对 index1 和 index2 进行 排序 if index2 index1 
{ var temp = index1 index1 = index2 index2 = 
temp } for index2 index1 index2 { var temp = 
path index1 + 1 path index1 + 1 = path 
index2 path index2 = temp index1 + + } } 
} } 上面 的 随机化 函数 是 专门 为 TSP 
问题 定义 的 在 Encog 框架 中 模拟 退 火法 
是 通用 的 相对于 TSP 独立 所以 你 必须 为 
你 希望 解决 的 问题 提供 一个 随机 函数 基本 
来说 随机化 函数 会 根据 温度 对 城市 的 旅行 
路线 进行 修正 上面 的 函数 只是 简单 地 根据 
温度 将 旅行 路线 中 的 路线 上 经过 城市 
次序 进行 对换 温度 越高 对换 的 次数 越多 随机 
城市 这 个 程序 的 常见 用法 是 将 随机 
几个 城市 放置 地图 上 这些 城市 出现 在 地图 
上 的 随机 的 几个 位置 随机 城市 问题 的 
排列 组合 相比 于 其他 的 固定 城市 组合 要 
更 困难 一些 在下 图中 你 可以 看到 包含 了 
50个 随机 的 城市 的 地图 图 4 随机 城市 
一旦 解决 了 这组 随机 城市 TSP 问题 结果 就 
如下 图 所示 图 5 可能 的 解决 方案 你 
可能 想 要 通过 改变 参数 来 评估 模拟退火 法的/nr 
实际 效果 为此 需要 重新 运行 该 程序 并且 你 
应该 随机化 旅行 路线 这样 你 就 可以 用 相同 
的 城市 配置 重新 开始 城市圈 你 可以 将 城市 
位置 以 椭圆 的 形状 进行 排列 这样 就 更容易 
理解 模拟退火 法是/nr 如何 演化 出 最佳 解决方案 的 围绕 
一个 椭圆 的 最优 路径 与 它 的 周长 形状 
类似 在 这里 你 可以 利用 模拟 退 火法 找到 
一条 几乎 就是 最优 的 路径 图 6 城市圈 遗传算法 
利用 遗传算法 GA 可以 得到 TSP 问题 的 潜在 解决方案 
GA 是 通过 简单 的 进化 操作 来 创建 一个 
能够 不断 改进 的 解决方案 这 整个 过程 就 相当于 
生物 遗传 进化 的 精简 版 进化 其实 就是 通过 
交叉 和 突变 实现 的 所以 当 两个 解决方案 交配 
并 产生 后 代时 就 相当于 发生 了 交叉 而 
当 单一 的 解决方案 稍微 有所 改变 时就/nr 相当于 引发 
了 突变 类似于 模拟退火 法 GA 遗传算法 也是 随机 的 
在/p 交叉/n 过程/n 中/f 会由/i 随机性/n 来/v 决定/v 父本/n 和母/nr 
本会/r 遗产/vn 什么样/r 的/uj 特征/n 给/p 子代/n 你 可以 在 
下面 的 URL 中 在线 查看 TSP 旅行 推销员 问题 
的 遗传算法 应用程序 http / / www . heatonresearch . 
com / fun / tsp / genetic 为了 使用 Encog 
框架 中 自带 的 遗传算法 你 必须 定义 变异 和 
交叉 这两个 操作 它们 的 实现 取决于 你 正在 寻找 
的 解决 方案 的 类型 下面 的 代码 定义 了 
TSP 问题 的 突变 操作 genetic . mutate = function 
performMutation data { var iswap1 = Math . floor Math 
. random * data . length var iswap2 = Math 
. floor Math . random * data . length / 
/ 不相 等时 if iswap1 = = iswap2 { / 
/ 继续 下 一步 / / 但是 不要 出界 if 
iswap1 0 { iswap1 } else { iswap1 + + 
} } var t = data iswap1 data iswap1 = 
data iswap2 data iswap2 = t } 这段 代码 与 
模拟退火 法的/nr 随机 化 操作 非常 类似 本质上 程序 对 
列表 中 的 两个 城市 进行 了 交换 操作 所以 
我们 必须 保证 这 两个 随机 城市 是 不 相同 
的 因为 一旦 相同 这 两个 城市 就 不会 发生 
交换 交叉 操作 比较复杂 下面 的 代码 实现 了 交叉 
函数 genetic . crossover = function performCrossover motherArray fatherArray child1Array 
child2Array { / / 染色体 此处 泛指 遗传 特性 必须 
在 两个 位置 被 切割 并 确定 他们 var cutLength 
= motherArray . length / 5 var cutpoint1 = Math 
. floor Math . random * motherArray . length cutLength 
var cutpoint2 = cutpoint1 + cutLength / / 记录 这 
两个 子代 中 每一个 染色 体中 所带 的 基因 默认 
为 false var taken1 = { } var taken2 = 
{ } / / 处理 削减 的 染色体 部分 for 
var i = 0 i motherArray . length i + 
+ { if i cutpoint1 | | i cutpoint2 { 
child1Array i = fatherArray i child2Array i = motherArray i 
taken1 fatherArray i = true taken2 motherArray i = true 
} } / / 处理 外部 的 染色体 部分 for 
var i = 0 i motherArray . length i + 
+ { if i cutpoint1 | | i cutpoint2 { 
child1Array i = getNotTaken motherArray taken1 child2Array i = getNotTaken 
fatherArray taken2 } } } 上面 代码 的 原理 如下 
在 城市 的 道路 上 取 两个 切点 这/r 就/d 
意味着/v 把/p 父本/n 和/c 母本/n 的/uj 特性/n 都/d 各自/r 分割/v 
成了/nr 三份/mq 父本 和 母本 有着 相同 的 切点 这些 
切割 的 规模 是 随机 的 然后 通过 交换 父辈 
的 三份 来 创建 两个 子代 例如 观察 下面 的 
父本 和 母本 m1 m2 m3 m4 m5 m6 m7 
m8 m9 m10 f1 f2 f3 f4 f5 f6 f7 
f8 f9 f10 现在 我们 将 这些 切点 加进去 m1 
m2 m3 m4 m5 m6 m7 m8 m9 m10 f1 
f2 f3 f4 f5 f6 f7 f8 f9 f10 如此 
会 产生 下面 两个 子代 m1 m2 f3 f4 f5 
f6 m7 m8 m9 m10 f1 f2 m3 m4 m5 
m6 f7 f8 f9 f10 根据 另一个 随机事件 每个 解决 
方案 都 可能 会 发生 突变 突变 就是 将 新 
产生 的 信息 添加到 种群 遗传 的 过程 否则 就是 
简单 的 传递 已经 存在 的 遗传 特征 XOR 神经网络 
神经 网络 是 另外 一种 基于 生物学 的 机器 学习 
方法 它 非常 松散地 建立在 人脑 的 基础 上 神经 
网络 是 由 神经 突触 连接 的 神经元 组成 的 
每一个 突触 本身 都 具有 权重 众多 突触 的 权重 
构成 了 神经 网络 的 记忆 如下 所示 的 神经 
网络 示意图 图 7 一个 神经 网络 如图所示 的 结构 
其实 就是 我们 下 一节 要 创建 的 神经 网络 
你/r 可以/c 在/p 上面/f 的/uj 神经/n 网络/n 中/f 看到/v 有/v 
一个/m 输入/v 层/q 和/c 一个/m 输出/v 层/q 神经网络 接收 来自 
输入 层 的 刺激 并 交由 输出 层 进行 相应 
输出 神经网络 内部 也 可能 存在 隐藏 层 该 层 
中 同样 包含 有 神经元 隐藏 层 也 有助于 信息 
的 处理 XOR 神经网络 异或 神经网络 有/v 两个/m 输入/v 和/c 
一个/m 输出/v 两个 输入端 接收 布尔值 0 或者 1 输出 
神经 元也 输出 布尔值 其 目的 就是 让 神经 网络 
实现 和 XOR 异或 运算 操作符 相同 的 功能 0 
XOR 0 = 0 1 XOR 0 = 1 0 
XOR 1 = 1 1 XOR 1 = 0 当 
两个 输入 不 一致 时 异或 XOR 操作符 的 输出 
必 为 1 你 可以 在 下面 看到 异或 XOR 
的 示例 输出 Training XOR with Resilient Propagation RPROP Training 
Iteration # 1 Error 0 . 266564333804989 Training Iteration # 
2 Error 0 . 2525674154011323 Training Iteration # 3 Error 
0 . 2510141208338126 Training Iteration # 4 Error 0 . 
2501895607116004 Training Iteration # 5 Error 0 . 2 4 
6 0 4 6 6 0 2 9 6 6 
1 7 5 1 2 Training Iteration # 6 Error 
0 . 2 4 3 6 3 6 9 7 
4 6 5 4 3 0 1 2 3 Training 
Iteration # 7 Error 0 . 2 4 0 0 
7 5 4 2 6 2 2 0 0 0 
8 8 3 Training Iteration # 8 Error 0 . 
2 3 5 9 4 3 6 1 5 9 
1 8 9 3 7 3 7 Training Iteration # 
9 Error 0 . 2 3 1 1 0 1 
9 9 0 6 9 0 4 1 1 3 
7 Training Iteration # 10 Error 0 . 2 2 
4 0 2 0 3 1 4 0 8 2 
5 6 8 0 6 . . . Training Iteration 
# 41 Error 0 . 0169149539750981 Training Iteration # 42 
Error 0 . 0 1 2 9 8 3 2 
8 9 6 2 8 9 7 9 8 6 
2 Training Iteration # 43 Error 0 . 0 1 
0 2 1 7 9 0 9 1 3 5 
9 8 5 5 6 2 Training Iteration # 44 
Error 0 . 0 0 7 4 4 2 4 
3 3 7 3 1 7 4 2 2 6 
4 Testing neural network Input 0 0 Output 0 . 
0 0 0 0 0 5 2 9 6 7 
5 9 3 2 6 4 0 0 6 5 
9 Ideal 0 Input 1 0 Output 0 . 9176637562838892 
Ideal 1 Input 0 1 Output 0 . 9249242746585553 Ideal 
1 Input 1 1 Output 0 . 0 3 6 
5 5 6 4 2 3 4 0 2 0 
4 2 1 2 6 Ideal 0 正如 上文 所示 
它 用了 44个 迭代 训练 来 教 神经 网络 执行 
XOR 操作 神经 网络 的 初始化 权重 是从 随机 数字 
开始 的 数据 训练 的 过程 中 会 逐渐 调整 
权重 以 产生 期望 的 输出 神经 网络 的 随机 
部分 是 权重 的 初始化 量值 除了 这些 神经 网络 
是 决定性 的 给定 相同 的 权重 和 输入 神经网络 
始终 会 产生 相同 的 输出 在 上面 的 输出 
中 你 可能 会 注意 到 输出 的 结果 并 
不是 非常 精确 的 因为 神经网络 永远 不会 为 1 
的 输出 精确 到 1.0 由于 开始 的 权重 是 
随机 的 所以 你 不 可能 从 这个 神经 网络 
中 得到 两 个 相同 的 结果 另外 由于 一些 
随机 的 初始化 权重 量值 是 完全 不可 训练 的 
正因如此 有时 你 会 看到 XOR 神经 网络 达到 了 
5000 的 最大 训练 值 然而 就 还是 放弃 了 
你 可以 在 下面 URL 中 看到 这个 案例 的 
运行 实例 http / / www . heatonresearch . com 
/ fun / ann / xor 我们 现在 来 观察 
这 个 程序 是 如何 构建 的 首先 我们 创建 
输入 和 理想 输出 var XOR _ INPUT = 0 
0 1 0 0 1 1 1 var XOR _ 
IDEAL = 0 1 1 0 上面 的 两个 数组 
分别 包含 了 输入 和 理想 输出 这个 真相 表 
将被 用来 训练 神经网络 接着 我们 来 创建 一个三层 神经网络 
输入 层 有 两个 神经元 隐藏 的 神经元 有 三个 
输出 层 有一个 神经元 var network = ENCOG . BasicNetwork 
. create ENCOG . BasicLayer . create ENCOG . A 
c t i v a t i o n i 
g m o i d . create 2 1 ENCOG 
. BasicLayer . create ENCOG . A c t i 
v a t i o n i g m o 
i d . create 3 1 ENCOG . BasicLayer . 
create ENCOG . A c t i v a t 
i o n i g m o i d . 
create 1 0 network . randomize 创建 和 随机化 神经 
网络 的 时候 将会 调用 随机化 函数 将 权重 填充 
为 随机 值 训练 神经 网络 有 很多 不同 方法 
对于 本例 我们 会 采用 RPROP 一种 基于 弹性 反向 
传播 的 神经 网络 算法 原理 来 实现 var train 
= ENCOG . P r o p a g a 
t i o n T r a i n e 
r . create network XOR _ INPUT XOR _ IDEAL 
RPROP 0 0 现在 我们 将 通过 迭代 训练 进行 
循环 处理 直到 出错率 降到 可以 接受 的 水平 线 
以下 为止 var iteration = 1 do { train . 
iteration var str = Training Iteration # + iteration + 
Error + train . error con . writeLine str iteration 
+ + } while iteration 1000 & & train . 
error 0.01 现在 神经 网络 的 训练 已 完成 我们 
将 对 输入 数组 进行 循环 处理 并将 其 提交 
给 神经网络 神经 网络 会 显示 出 对应 输出 var 
input = 0 0 var output = con . writeLine 
Testing neural network for var i = 0 i XOR 
_ INPUT . length i + + { network . 
compute XOR _ INPUT i output var str = Input 
+ String XOR _ INPUT i 0 + + String 
XOR _ INPUT i 1 + Output + String output 
0 + Ideal + String XOR _ IDEAL i 0 
con . writeLine str } 这是 对 神经 网络 的 
一个 非常 简单 的 介绍 我 还 做 了 一个 
关于 Java 和C#/nr 神经网络 内容 你 如果 只 对 神经 
网络 感兴趣 下面 的 内容 应该 会 有所 帮助 ahref 
= http Introduction to Neural Networks for Java ahref = 
http Introduction to Neural Networks for C # / ahref 
= http 此外 如果 你 想 了解 神经 网络 的 
基本 介绍 下面 的 文章 可能会 对 你 有用 http 
/ / www . heatonresearch . com / content / 
non mathematical introduction using neural networks 神经网络 分类 现在 我们 
来看 一个 稍微 复杂 些 的 神经 网络 分类 这个 
神经 网络 将 会 学习 如何 进行 分类 我们 会 
学到 神经 网络 是 如何 通过 训练 数据集 来 学习 
对 数据 点 进行 分类 并且 能够 对 训练 数据 
集中 不 存在 的 数据 点 进行 分类 你 可以 
在 下面 的 URL 中 在线 运行 这个 示例代码 http 
/ / www . heatonresearch . com / ann / 
classification 本 案例 将 利用 前馈 神经网络 原理 进行 分类 
为了 充分 利用 这个 程序 我们 在 画图 区域 绘制 
了 几个 彩色 点 必须 保证 你 至少 有 两个 
彩色 点 否则 程序 就 无法 进行 分类 一旦 你 
开始 画点 并且 点击 begin 开始 则 神经 网络 也 
就 开始 训练 了 你 将 看到 你 提供 的 
数据 点 附近 的 其他 区域 是 如何 进行 分类 
的 上 一个 神经 网络 案例 有是/nr 两个 输入 神经 
元和 三个 输出 神经元 的 隐藏 层 的 结构 是由 
drop 列表 决定 的 举例来说 如果 你 选择 了 2 
10 10 3 你 将会 得到 一个 与 以下 图像 
相似 的 网络 这个 网络 有 两个 隐藏 层 每层 
有 10个 神经元 输入 神经元 代表 一个 点 的 x 
坐标 和y/nr 坐标 为了 绘出 上面 的 图像 该 程序 
在 x 坐标 和y/nr 坐标 的 网格 上 进行 循环 
处理 每个 网格 组件 都会 对 神经 网络 进行 查询 
左上角 的 细胞 是 0 0 右 下角 的 细胞 
坐标 是 1 1 对于 具有 sigmoid 常用 的 非线性 
激活 函数 激活 函数 的 神经 网络 数据 通常 可以 
在 0 到 1 之间 的 范围 内 接受 输入 
因此 这个 范围 的 表现 良好 中心点 是 0.5 0.5 
神经 网络 的 输出 即 正方形 中 像素点 的 RGB 
颜色 值 0 0 0 表示 黑色 1 1 1 
表示 白色 当 你 在 绘图 区域 画点 时 就 
等同于 在 提供 训练 数据 输入 神经元 将会 根据 你 
输入 的 数据 训 练出 放置 x 坐标 和y/nr 坐标 
的 方式 期望 或者 理想 中 的 输出 应该是 与 
你 在 该 位置 选择 的 颜色 近似 一致 让 
我们 来看 一个 简单 的 案例 如果 你 只画 出 
两个 数据 点 那么 这个 区域 就 会被 分割 成 
两部分 如下 图 所示 你 可以 看到 一个 红色 的 
数据 点 和 一个 蓝色 的 数据 点 图 8 
两 个数 据点 的 分类 该 算法 为了 让 应用程序 
得到 的 错误 评级 比较 低 它 仅 需要 保证 
蓝色 数据 点 位于 蓝色 区域 而 红色 数据 点 
位于 红色 区域 其他 所有 像素点 都是 基于 已知 像素点 
的 猜测 但 由于 这样 已知 的 数据 非常 少 
所以 神经网络 很难 真正 猜到 这 两个 区域 之间 的 
边界 到底 在 哪里 如果 你 提供 了 更多 的 
训练 数据 那你会/nr 得到 一个 更加 复杂 的 形状 如果 
你 选择 创建 一个 双色 的 随机 图像 那你会/nr 得到 
与 下图 类似 的 数据 点 图 9 多 个数 
据点 的 分类 在此 图中 神经网络 创建 了 一种 更加 
复杂 的 模式 试图 来 适应 所有 的 数据 点 
你 还 可以 选择 创建 一个 复杂 的 多 颜色 
模式 下面 的 案例 中 为数 据点 随机 生成 了 
颜色 值 神经网络 甚至 会将 颜色 进行 混合 试图 做出 
妥协 以此来 尽可能 地 降低 误差 图 10 多 颜色数 
据点 分 类此 算法 甚至 有可能 学习 复杂 的 相互 
螺旋 的 形状 如下 图 所示 图 11 螺旋 数 
据点 的 分类 延伸 阅读 本文 介绍 了 JavaScript 中的 
机器学习 如果 想 了解 更多 关于 机器 学习 的 知识 
那么 你 可能会 对 下面 的 链接 感兴趣 Encog 项目 
Encog 维基百科 关于 Encog 的 更多 信息 Facebook 上 关于 
Encog 的 内容 历史 2012年 10月 16日 的 第一 个 
版本 引用 文件 版本 Encog JS v 1.0 翻译人 白加黑 
大人 该 成员 来自 云+/nr 社区 翻译社 原文 链接 https 
/ / www . codeproject . com / Articles / 
477689 / JavaScript Machine Learning and Neural Networks wi 原文 
作者 JeffHeaton 原 文译 题 通过/p JS/w 库/n Encog/w 实现/v 
JavaScript/w 机器学习/i 和/c 神经学/n 网络/n 相关/v 阅读/v Python/w 中/f Keras/w 
深度/ns 学习/v 库/n 的/uj 回归/v 教程/n 从/p 程序员/n 的/uj 角度/n 
设计/vn 一个/m Java/w 的/uj 神经/n 网络/n 如何/r 使用/v scikit learn 
为 机器 学习准备 文本 数据 此文 已由 作者 授权 云加 
社区 发布 转载 请 注明 文章 出处 