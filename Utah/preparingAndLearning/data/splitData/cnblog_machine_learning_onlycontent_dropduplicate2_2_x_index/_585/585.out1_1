有幸 参加 了 微软 OpenHack 挑战赛 虽然 题目 难度 不大 
但是 很 有意思 学到 了 很多 东西 还 有幸 认识 
了 微软 梁健/nr 老师 谢谢您 的 帮助 同时 还 认识 
同行 的 很多 朋友 非常高兴 把 这段 难忘 的 比赛 
记录 一下 ~ ~ 也 分享 一下 代码 给 那些 
没有 参加 的 朋友 数据集 文末 链接 首先 每支 队伍 
会 收到 一个 数据集 它 是 一个 登山 公司 提供 
的 装备 图片 有 登山 镐 鞋子 登山扣 不 知道 
叫 什么 的 雪地 爪 手套 冲锋衣 安全带 一共 12个 
类别 每个 类别 几百 个 样本 我们 的 任务 就是 
对 这些 图片 分类 和 识别 简单 看一下 赛 题 
赛 题 共有 6道 简单 描述 一下 1 搭建 环境 
略过 2 图像 正规化 包括 颜色 和 大小 3 通过 
机器学习 方法 对 图像 分类 precision 0.84 通过 深度 学习 
方法 对 图像 分类 precision 0.95 部署 略过 6 目标 
检测 用 全新 的 数据集 检测 雪地中 的 登山 者 
是否 带 头盔 航拍 图像 有点 难度 ~ _ _ 
_ _ _ _ _ _ _ _ _ _ 
_ _ _ _ _ _ _ _ _ _ 
_ _ _ _ _ _ _ _ _ _ 
_ _ _ _ _ _ _ 下面 是 每道 
题目 的 详细 描述 和 代码 题目 2 完成 以下 
任务 选择 一种 基本 颜色 例如 白色 并 填充 所有 
图片尺寸 不是 1 1 比例 的 图像 不 通过 直接 
拉伸 的 方式 重塑 至 128x128x3 像素 的 阵列 形状 
确保 每个 图像 的 像素 范围 从0到/nr 255 包含 或 
0 255 也 称为 对比度 拉伸 contrast stretching . 标准化 
或 均衡 以 确保 像素 在 0 255 范围 内 
. 成功 完成 的 标准 团队 将在 Jupyter Notebook 中 
运行 一个 代码 单元 绘制 原始 图像 然后 绘制 填充 
后的/nr 像素 值 归一化 或 均衡 图像 展示 给 教练 
看 . 团队 将在 Jupyter notebook 为 教练 运行 一个 
代码 单元 显示 的 像素 值 的 直方图 应该在 0 
到 255 的 范围内 包括 0 和 255 . def 
normalize src arr = array src arr = arr . 
astype float # Do not touch the alpha channel for 
i in range 3 minval = arr . . . 
i . min maxval = arr . . . i 
. max if minval = maxval arr . . . 
i = minval arr . . . i * = 
255.0 / maxval minval arr = arr . astype uint8 
return Image . fromarray arr RGB import matplotlib . pyplot 
as plt from PIL import ImageColor from matplotlib . pyplot 
import imshow from PIL import Image from pylab import * 
import copy plt . figure figsize = 10 10 # 
设置 窗口 大小 # src = Image . open 100974 
. jpeg src = Image . open rose . jpg 
src _ array = array src plt . subplot 2 
2 1 plt . title src plt . imshow src 
plt . axis off ar = src _ array 0 
. flatten ag = src _ array 1 . flatten 
ab = src _ array 2 . flatten plt . 
subplot 2 2 2 plt . title src hist plt 
. axis 0 255 0 0.03 plt . hist ar 
bins = 256 normed = 1 facecolor = red edgecolor 
= r hold = 1 # 原始 图像 直方图 plt 
. hist ag bins = 256 normed = 1 facecolor 
= g edgecolor = g hold = 1 # 原始 
图像 直方图 plt . hist ab bins = 256 normed 
= 1 facecolor = b edgecolor = b # 原 
g 始 图像 直方图 dst = normalize src dst _ 
array = array dst plt . subplot 2 2 3 
plt . title dst plt . imshow dst plt . 
axis off ar = dst _ array 0 . flatten 
ag = dst _ array 1 . flatten ab = 
dst _ array 2 . flatten plt . subplot 2 
2 4 plt . title dst hist plt . axis 
0 255 0 0.03 plt . hist ar bins = 
256 normed = 1 facecolor = red edgecolor = r 
hold = 1 # 原始 图像 直方图 plt . hist 
ag bins = 256 normed = 1 facecolor = g 
edgecolor = g hold = 1 # 原始 图像 直方图 
plt . hist ab bins = 256 normed = 1 
facecolor = b edgecolor = b # 原 g 始 
图像 直方图 View Code 题目 3 使用 一个 非 参数 
化 分类 方法 参考 参考 文档 来 创建 一个 模型 
预测 新的 户外 装备 图像 的 分类 情况 训练 来自 
挑战 2 的 预处理 过 的 128x128x3 的 装备 图像 
所 使用 的 算法 可以 从 scikit learn 库 中 
挑选 现有 的 非 参数 化 算法 来做 分类 向 
教练 展示 所 提供 的 测试 数据集 的 精确度 并且 
精确度 分数 需要 超过 80% dir _ data = data 
/ preprocess _ images / equipments = axes boots carabiners 
crampons gloves hardshell _ jackets harnesses helmets insulated _ jackets 
pulleys rope tents train _ data = y = import 
os from PIL import Image for equip _ name in 
equipments dir _ equip = dir _ data + equip 
_ name for filename in os . listdir dir _ 
equip if filename . find jpeg = 1 name = 
dir _ equip + / + filename img = Image 
. open name . convert L train _ data . 
append list img . getdata y . append equip _ 
name View Codefrom sklearn import svm from sklearn . cross 
_ validation import train _ test _ split train _ 
X test _ X train _ y test _ y 
= train _ test _ split train _ data y 
test _ size = 0.3 random _ state = 0 
from sklearn import neighbors from sklearn . metrics import precision 
_ recall _ fscore _ support as score from sklearn 
. metrics import precision _ score recall _ score clf 
_ knn = neighbors . K N e i g 
h b o r s C l a s s 
i f i e r algorithm = kd _ tree 
clf _ knn . fit train _ X train _ 
y y _ pred = clf _ knn . predict 
test _ X View Codeprint _ _ doc _ _ 
import itertools import numpy as np import matplotlib . pyplot 
as plt from sklearn import svm datasets from sklearn . 
model _ selection import train _ test _ split from 
sklearn . metrics import confusion _ matrix def plot _ 
confusion _ matrix cm classes normalize = False title = 
Confusion matrix cmap = plt . cm . Blues This 
function prints and plots the confusion matrix . Normalization can 
be applied by setting ` normalize = True ` . 
if normalize cm = cm . astype float / cm 
. sum axis = 1 np . newaxis print Normalized 
confusion matrix else print Confusion matrix without normalization print cm 
plt . imshow cm interpolation = nearest cmap = cmap 
plt . title title plt . colorbar tick _ marks 
= np . arange len classes plt . xticks tick 
_ marks classes rotation = 45 plt . yticks tick 
_ marks classes fmt = . 2f if normalize else 
d thresh = cm . max / 2 . for 
i j in itertools . product range cm . shape 
0 range cm . shape 1 plt . text j 
i format cm i j fmt h o r i 
z o n t a l a l i g 
n m e n t = center color = white 
if cm i j thresh else black plt . tight 
_ layout plt . ylabel True label plt . xlabel 
Predicted label # Compute confusion matrix # cnf _ matrix 
= confusion _ matrix y _ test y _ pred 
np . set _ printoptions precision = 2 confusion _ 
mat = confusion _ matrix test _ y y _ 
pred labels = equipments # Plot non normalized confusion matrix 
plt . figure figsize = 10 10 plot _ confusion 
_ matrix confusion _ mat classes = equipments title = 
Confusion matrix without normalization # Plot normalized confusion matrix plt 
. figure figsize = 10 10 plot _ confusion _ 
matrix confusion _ mat classes = equipments normalize = True 
title = Normalized confusion matrix plt . show View Code 
因为 要求 精确度 0.8 sklearn/w 中的/i 很多/m 算法/n 应该/v 都能/nr 
满足/v 我 选择 了 准确 度 比较 高的/nr KNN 来 
建模 应该 足够 用了 算 一下 presion 和 recall 轻松 
超越 0.8 题目 4 挑战 完成 标准 使用 深度 学习 
模型 如 CNN 分析 复杂 数据 团队 将在 Jupyter Notebook 
上为 教练 运行 一个 代码 单元 展示 模型 的 准确度 
为 90％ 或 更高 准确度 如果 要 0.9 sklearn 中的 
机器学习 算法 就 很难 达到 了 关键 时刻 只能 上 
CNNimport matplotlib . pyplot as plt from PIL import ImageColor 
from matplotlib . pyplot import imshow from PIL import Image 
from pylab import * dir _ data = data / 
preprocess _ images / equipments = axes boots carabiners crampons 
gloves hardshell _ jackets harnesses helmets insulated _ jackets pulleys 
rope tents train _ data = y = import os 
from PIL import Image i = 0 for equip _ 
name in equipments dir _ equip = dir _ data 
+ equip _ name for filename in os . listdir 
dir _ equip if filename . find jpeg = 1 
name = dir _ equip + / + filename img 
= Image . open name . convert L train _ 
data . append array img . tolist y . append 
i i + = 1 train _ data = np 
. asarray train _ data View Codefrom sklearn import svm 
from sklearn . cross _ validation import train _ test 
_ split import numpy as np import keras num _ 
classes = 12 img _ rows = 128 img _ 
cols = 128 train _ X test _ X train 
_ y test _ y = train _ test _ 
split train _ data y test _ size = 0.3 
random _ state = 0 train _ X = train 
_ X . reshape train _ X . shape 0 
img _ rows img _ cols 1 test _ X 
= test _ X . reshape test _ X . 
shape 0 img _ rows img _ cols 1 train 
_ X = train _ X . astype float32 test 
_ X = test _ X . astype float32 train 
_ X / = 255 test _ X / = 
255 print x _ train shape train _ X . 
shape print train _ X . shape 0 train samples 
print test _ X . shape 0 test samples # 
convert class vectors to binary class matrices train _ y 
= keras . utils . to _ categorical train _ 
y num _ classes test _ y = keras . 
utils . to _ categorical test _ y num _ 
classes View Codefrom keras . layers import Dense Activation Convolution2D 
MaxPooling2D Flatten from keras . models import Sequential from keras 
. layers import Convolution2D MaxPooling2D Conv2D import keras model = 
Sequential model . add Conv2D 32 kernel _ size = 
3 3 activation = relu input _ shape = 128 
128 1 model . add MaxPooling2D pool _ size = 
2 2 model . add Conv2D 64 3 3 activation 
= relu model . add MaxPooling2D pool _ size = 
2 2 # model . add Dropout 0.25 model . 
add Flatten model . add Dense 128 activation = relu 
# model . add Dropout 0.5 model . add Dense 
12 activation = softmax model . compile loss = keras 
. losses . categorical _ crossentropy optimizer = keras . 
optimizers . Adadelta metrics = accuracy model . fit train 
_ X train _ y batch _ size = 128 
epochs = 50 verbose = 1 validation _ data = 
test _ X test _ y score = model . 
evaluate test _ X test _ y verbose = 0 
print Test loss score 0 print Test accuracy score 1 
View CodeCNN 的 混淆 矩阵 比 KNN 的 好 了 
不少 训练 了 好多 次 不断 调整 各个 卷积 层 
和 参数 终于 达到 了 一个 比较 好 的 效果 
~ ~ 题目 6 使用 深度 学习 框架 基于 一个 
常用 的 模型 比如 Faster R CNN 训练 一个 目标 
检测 的 模型 这个 模型 需要 能够 检测 并且 使用 
方框 框出 图片 中 出现 的 每一个 头盔 这道 题目 
首先 要 自己 标注 样本 几百张 图像 标注 完 累 
的 半死 这里 我们 使用 VOTT 来 标注 它 会 
自动 生成 一个 样本 描述 文件 很 方便 Faster R 
CNN 的 程序 我们 参考 了 git 上 的 一个 
红细胞 检测 的 项目 https / / github . com 
/ THULiusj / C o s m i c a 
d D e t e c t i o n 
Keras Tensorflow FasterRCNN 代码 非常多 就不 贴了 最后 来 一张 
效果图 本文 数据集 和 VOTT 工具 链接 https / / 
pan . baidu . com / s / 1 F 
F w 0 P L J r r O h 
w R 6 J 1 H e x P J 
A 提 取码 s242 