目录 1 . 关联 分析 2 . Apriori 原理 3 
. 使用 Apriori 算法 来 发现 频繁 集 4 . 
从 频繁 集中 挖掘 关联 规则 5 . 总结 1 
. 关联 分析   返回 目录 关联 分析 是 一种 
在 大规模 数据 集中 寻找 有趣 关系 的 任务 这种 
关系 表现 为 两种 形式 1 . 频繁 项集/nr frequency 
item sets 经常 同时 出现 的 一些 元素 的 集合 
2 . 关联 规则 association rules 意味着 两 种元素 之间 
存在 很强 的 关系 下面 举例 来 说明 上面 的 
两个 概念 表 1 一个 来自 Hole Foods 天 食品店 
的 简单 交易 清单 交易 号码 商品 0 豆奶 莴苣 
1 莴苣 尿布 葡萄酒 甜菜 2 莴苣 尿布 葡萄酒 橙汁 
3 莴苣 豆奶 尿布 葡萄酒 4 莴苣 豆奶 尿布 橙汁 
频繁 项集是/nr 指 经常 出现 在 一起 的 元素 的 
集合 上表 中的 集合 { 葡萄酒 尿布 豆奶 } 就是 
频繁 项集的/nr 一个 例子 同样 可以 找到 如 尿布 葡萄酒 
的 关联 规则 意味着 如果 有人 买了 尿布 就 很可能 
也会 买 葡萄酒 使用/v 频繁/a 项集和/nr 关联/ns 规则/n 商家 可以 
更好 地 理解 顾客 的 消费 行为 所以 大部分 关联 
规则 分析 示例 来自 零售业 理解 关联 分析 首先 需要 
搞 清楚 下面 三个 问题 1 . 如何 定义 这些 
有用 的 关系 2 . 这些 关系 的 强弱 程度 
又 是 如何 定义 3 . 频繁 的 定义 是 
什么 要回答 上面 的 问题 最 重要 的 是 理解 
两个 概念 支持度 和 可信度 支持度 一个 项集的/nr 支持 度 
support 被 定义 为 数据 集中 包含 该项 集 的 
记录 占 总 记录 的 比例 从表1/nr 可以 看出 项集/nr 
{ 豆奶 } 的 支持 度 为 $ 4/5 $ 
而在 5 条 交易 记录 中 3 条 包含 { 
豆奶 尿布 } 因此 { 豆奶 尿布 } 的 支持 
度 为 $ 3/5 $ . 可信度 或 置信度 confidence 
是 针对 一条 诸如 $ { 尿布 } { 葡萄酒 
} $ 的 关联 规则 来 定义 的 这条 规则 
的 可信度 被 定义 为 支持度 { 尿布 葡萄酒 } 
  /   支持度 { 尿布 } 在 表 1 
中 可以 发现   { 尿布 葡萄酒 } 的 支持 
度 是 $ 3/5 $ { 尿布 } 的 支持 
度 为 $ 4/5 $ 所以 关联 规则 尿布 葡萄酒 
的 可信度 为 $ 3/4 = 0.75 $ 意思 是 
对于 所有 包含 尿布 的 记录 中 该 关联 规则 
对 其中 的 75% 记录 都 适用 2 . Apriori 
原理   返回 目录 假设 经营 了 一家 杂货店 于是 
我们 对 那些 经常 在 一起 购买 的 商品 非常 
感兴趣 假设 我们 只有 4 种 商品 商品 0 商品 
1 商品 2 商品 3 . 那么 如何 得 可能 
被 一起 购买 的 商品 的 组合 上图 显示 了 
物品 之间 所有 可能 的 组合 从上往下 一个 集合 是 
  $ \ textrm { Ø } $ 表示 不 
包含 任何 物品 的 空集 物品 集合 之间 的 连线 
表明 两个 或者 更多 集合 可以 组合 形成 一个 更大 
的 集合 我们 的 目标 是 找到 经常 在 一起 
购买 的 物品 集合 这里 使用 集合 的 支持 度 
来 度量 其 出现 的 频率 一个 集合 出现 的 
支持 度 是 指 有 多少 比例 的 交易 记录 
包含 该 集合 例如 对于 上图 要 计算 $ { 
0 3 } $ 的 支持 度 直接 的 想法 
是 遍历 每条 记录 统计 包含 有 $ 0 $ 
和 $ 3 $ 的 记录 的 数量 使用 该 
数量 除以 总 记录 数 就 可以 得到 支持 度 
而这 只是 针对 单个 集合   $ { 0 3 
} $ . 要 获得 每种 可能 集合 的 支持 
度 就 需要 多次 重复 上述 过程 对于 上图 虽然 
仅有 4中 物品 也 需要 遍历 数据 15次 随着 物品 
数目 的 增加 遍历 次数 会 急剧 增加 对于 包含 
$ N $ 种 物品 的 数据 集 共有   
$ 2 ^ { N } 1 $ 种 项集/nr 
组合 所以 即使 只 出售 $ 100 $   种 
商品 的 商店 也会有 $ 1.26 \ times10 ^ { 
30 } $ 中 可能 的 组合 计算 量 太大 
为了 降低 计算 时间 研究 人员 发现 了 $ Apriori 
$ 原理 可以 帮 我们 减少 感兴趣 的 频繁 项集的/nr 
数目 $ Apriori $ 的 原理 如果/c 某个/r 项集是/nr 频繁/a 
项集/nr 那么 它 所有 的 子集 也是 频繁 的 即 
如果 { 0 1 } 是 频繁 的 那么 { 
0 } { 1 } 也 一定 是 频繁 的 
这个 原理 直观 上 没有 什么 用 但是 反 过来看 
就有 用了 也 就是说 如果 一个 项集/nr 是非 频繁 的 
那么 它 的 所有 超集 也 是非 频繁 的 如下 
图 所示 3 . 使用 Apriori 算法 来 发现 频繁 
集   返回 目录 上面 提到 关联 分析 的 两个 
目标 发现/v 频繁/a 项集和/nr 发现/v 关联/ns 规则/n 首先 需要 找到 
频繁 项集/nr 然后 根据 频繁 项集/nr 获得 关联 规则 首先 
来 讨论 发现 频繁 项集/nr Apriori 是 发现 频繁 项集的/nr 
一种 方法 首先 会 生成 所有 单个 物品 的 项集/nr 
列表 扫描 交易 记录 来 查看 哪些 项集/nr 满足 最小 
支持度 要求 那些 不 满足 最小 支持度 的 集合 会被 
去掉 对 剩下 的 集合 进行 组合 以 生成 包含 
两个 元素 的 项集/nr 接下来 重新 扫描 交易 记录 去掉 
不满足 最小 支持度 的 项集/nr 重复 进行 直到 所 有项 
集 都被 去掉 数据集 扫描 的 伪代码 对 数据 集中 
的 每条 交易 记录 tran 对 每个 候 选项 集 
can 检查一下 can 是否是 tran 的 子集 如果 是 则 
增加 can 的 计 数值 对 每个 候 选项 集 
如果 其 支持 度 不 低于 最低值 则/d 保留/v 返回/v 
所有/b 频繁/a 项集/nr 列表/n 有/v 上面/f 的/uj 伪代码/i 写出/v 代码/n 
如下/t # * coding utf 8 * Apriori exercise . 
Created on Fri Nov 27 11 09 03 2015 @ 
author 90Zeng def loadDataSet 创建 一个 用于 测试 的 简单 
的 数据 集 return 1 3 4 2 3 5 
1 2 3 5 2 5 def createC1 dataSet 构建 
初始 候 选项 集 的 列表 即 所有 候 选项 
集 只 包含 一个 元素 C1 是 大小 为 1 
的 所有 候 选项 集 的 集合 C1 = for 
transaction in dataSet for item in transaction if item not 
in C1 C1 . append item C1 . sort return 
map frozenset C1 def scanD D Ck minSupport 计算 Ck 
中的 项 集在 数据 集合 D 记录 或者 transactions 中 
的 支持 度 返回 满足 最小 支持度 的 项集的/nr 集合 
和/c 所有/b 项集/nr 支持度/i 信息/n 的/uj 字典/n ssCnt = { 
} for tid in D # 对于 每 一条 transaction 
for can in Ck # 对于 每一个 候 选项 集 
can 检查 是否 是 transaction 的 一部分 # 即 该 
候选 can 是否 得到 transaction 的 支持 if can . 
issubset tid ssCnt can = ssCnt . get can 0 
+ 1 numItems = float len D retList = supportData 
= { } for key in ssCnt # 每个 项集的/nr 
支持 度 support = ssCnt key / numItems # 将 
满足 最小 支持度 的 项集/nr 加入 retList if support = 
minSupport retList . insert 0 key # 汇总 支持 度 
数据 supportData key = support return retList supportData 注 关于 
上面 代码 中 frozenset 是 为了 冻结 集合 使 集合 
由 可变 变为 不可变 这样 这些 集合 就 可以 作为 
字典 的 键值 首先 来 测试 一下 上面 代码 看看 
运行 效果 if _ _ name _ _ = = 
_ _ main _ _ # 导入 数据集 myDat = 
loadDataSet # 构建 第一 个 候选 项集/nr 列表 C1 C1 
= createC1 myDat # 构建 集合 表示 的 数据集 D 
D = map set myDat # 选择 出 支持度 不小于 
0.5 的/uj 项集/nr 作为/v 频繁/a 项集/nr L suppData = scanD 
D C1 0.5 print u 频繁 项集L/nr L print u 
所有 候 选项 集 的 支持 度 信息 suppData 运行 
结果 runfile E / Python / PythonScripts / Apriori . 
py wdir = r E / Python / PythonScripts 频繁 
项集L/nr frozenset 1 frozenset 3 frozenset 2 frozenset 5 所有 
候 选项 集 的 支持 度 信息 { frozenset 4 
0.25 frozenset 5 0.75 frozenset 2 0.75 frozenset 3 0.75 
frozenset 1 0.5 } 可以 看出 只有 支持度 不小于 0.5 
的 项集被/nr 选中 到 L 中 作为 频繁 项集/nr 根据 
不同 的 需求 我们 可以 设定 最小 支持度 的 值 
从而 得到 我们 想要 的 频繁 项集/nr 上面/f 的/uj 示例/n 
只是/c 选择/v 出来了/i 项/n 集中/v 只/d 包含/v 一个/m 元素/n 的/uj 
频繁/a 项集/nr 下面 需要 整合 上面 的 代码 选择 出 
包含 2个 3个 直至 个 数据 等于 所有 候选 元素 
个数 的 频繁 项集/nr 从而 形成 完整 的 $ Apriori 
$ 的 算法 首先 给出 伪代码 当 集合 中的 元素 
个数 大于 $ 0 $ 时 构建 一个 $ k 
$ 个/q 项/n 组成/v 的/uj 候选/v 项集/nr 列表/n 检查数据/n 确认/v 
每个/r 项集/nr 都是/i 频繁/a 项集/nr 保留/v 频繁/a 项集/nr 并 构建 
$ k + 1 $ 项/n 组成/v 的/uj 候选/v 项集的/nr 
列表/n 程序清单/n # Aprior 算法 def aprioriGen Lk k 由 
初始 候 选项 集 的 集合 Lk 生成 新的 生成 
候 选项 集 k 表示 生成 的 新 项 集中 
所含 有的 元素 个数 retList = lenLk = len Lk 
for i in range lenLk for j in range i 
+ 1 lenLk L1 = list Lk i k 2 
L2 = list Lk j k 2 L1 . sort 
L2 . sort if L1 = = L2 retList . 
append Lk i | Lk j return retList def apriori 
dataSet minSupport = 0.5 # 构建 初始 候 选项 集 
C1 C1 = createC1 dataSet # 将 dataSet 集 合化 
以 满足 scanD 的 格式 要求 D = map set 
dataSet # 构建 初始 的 频繁 项集/nr 即 所有 项集/nr 
只有 一个 元素 L1 suppData = scanD D C1 minSupport 
L = L1 # 最初 的 L1 中的 每个 项集/nr 
含有 一个 元素 新 生成 的 # 项集/nr 应该 含有 
2个 元素 所以 k = 2 k = 2 while 
len L k 2 0 Ck = aprioriGen L k 
2 k Lk supK = scanD D Ck minSupport # 
将 新的 项集的/nr 支持 度 数据 加入 原来 的 总 
支持度 字典 中 suppData . update supK # 将 符合 
最小 支持度 要求 的 项集/nr 加入 L L . append 
Lk # 新/a 生成/v 的/uj 项/n 集中/v 的/uj 元素/n 个数/n 
应/v 不断/d 增加/v k + = 1 # 返回 所有 
满足 条件 的 频繁 项集的/nr 列表 和 所有 候 选项 
集 的 支持 度 信息 return L suppData 关于 上面 
程序 函数   aprioriGen   中的 $ k 2 $ 
的 说明 当 利用 { 0 } { 1 } 
{ 2 } 这些/r 只含/i 有/v 一个/m 元素/n 的/uj 候选/v 
项集/nr 构建/v 含有/v 2 个 元素 的 候选 项集时/nr 就是 
两两 合并 得到 { 0 1 } { 0 2 
} { 1 2 } 如果 进一步 用 包含 连个 
元素 的 候选 项集来/nr 构建 包含 3 个 元素 的 
候选 项集/nr 同样 两两 合并 就会 得到 { 0 1 
2 } { 0 1 2 } { 0 1 
2 } . 就是说 会 出现 重复 的 项集/nr 接下来 
就 需要 扫描 三 元素 项集/nr 得到 非 重复 结果 
显然 增加 了 计算 时间 现在 如果 比较 { 0 
1 } { 0 2 } { 1 2 } 
的 第 0 个 元素 并 只对 第 0 个 
元素 相同 的 集合 求 并 就会 得到 { 0 
1 2 } 而且 只 有 一次 操作 这样 就 
不 需要 遍历 列表 来 寻找 非 重复 值 测试 
上面 代码 if _ _ name _ _ = = 
_ _ main _ _ # 导入 数据集 myDat = 
loadDataSet # 选择 频繁 项集/nr L suppData = apriori myDat 
0.5 print u 频繁 项集L/nr L print u 所有 候 
选项 集 的 支持 度 信息 suppData 运行 结果 最小 
支持度 0.5 runfile E / Python / PythonScripts / Apriori 
. py wdir = r E / Python / PythonScripts 
频繁 项集L/nr frozenset 1 frozenset 3 frozenset 2 frozenset 5 
frozenset 1 3 frozenset 2 5 frozenset 2 3 frozenset 
3 5 frozenset 2 3 5 所有 候 选项 集 
的 支持 度 信息 { frozenset 5 0.75 frozenset 3 
0.75 frozenset 2 3 5 0.5 frozenset 1 2 0.25 
frozenset 1 5 0.25 frozenset 3 5 0.5 frozenset 4 
0.25 frozenset 2 3 0.5 frozenset 2 5 0.75 frozenset 
1 0.5 frozenset 1 3 0.5 frozenset 2 0.75 } 
在 测试 一下 最小 支持度 为 0.7 时的/nr 情况 runfile 
E / Python / PythonScripts / Apriori . py wdir 
= r E / Python / PythonScripts 频繁 项集L/nr frozenset 
3 frozenset 2 frozenset 5 frozenset 2 5 所有 候 
选项 集 的 支持 度 信息 { frozenset 5 0.75 
frozenset 3 0.75 frozenset 3 5 0.5 frozenset 4 0.25 
frozenset 2 3 0.5 frozenset 2 5 0.75 frozenset 1 
0.5 frozenset 2 0.75 } 频繁 项集/nr 相比 最小 支持度 
0.5 时要少/nr 符合 预期 4 . 从 频繁 集中 挖掘 
关联 规则   返回 目录 要 找到 关联 规则 先 
从 一个 频繁 集 开始 我们 想 知道 对于 频繁 
项 集中 的 元素 能否 获取 其它 内容 即 某个 
元素 或者 某个 集合 可能会 推导 出 另 一个 元素 
从表1/nr 可以 得到 如果/c 有/v 一个/m 频繁/a 项集/nr { 豆奶 
莴苣 } 那么 就 可能 有 一条 关联 规则 豆奶 
莴苣 意味着 如果 有人 购买 了 豆奶 那么 在 统计 
上 他 会 购买 莴苣 的 概率 较大 但是 这 
一条 反过来 并不一定 成立 从/p 一个/m 频繁/a 项集/nr 可以/c 产生/n 
多少/m 条/n 关联/ns 规则/n 呢/y 可以 基于 该 频繁 项集/nr 
生成 一个 可能 的 规则 列表 然后 测试 每条 规则 
的 可信度 如果 可信度 不满足 最小值 要求 则 去掉 该 
规则 类似于 前面 讨论 的 频繁 项集/nr 生成 一个 频繁 
项集/nr 可以 产生 许多 可能 的 关联 规则 如果能 在 
计算 规则 可信度 之前 就 减少 规则 的 数目 就会 
很好 的 提高 计算 效率 这里 有 一条 规律 就是 
如果 某 条规 则 并不 满足 最小 可信度 要求 那么 
该 规则 的 所有 子集 也 不会 满足 最小 可信度 
要求 例如 下图 的 解释 所以 可以 利用 上 图 
所示 的 性质 来 减少 测试 的 规则 数目 关联 
规则 生成 函数 清单 # 规则 生成 与 评价 def 
calcConf freqSet H supportData brl minConf = 0.7 计算 规则 
的 可信度 返回 满足 最小 可信度 的 规则 freqSet frozenset 
频繁 项集/nr H frozenset 频繁 项 集中 所有 的 元素 
supportData dic 频繁 项 集中 所有 元素 的 支持 度 
brl tuple 满足 可信度 条件 的 关联 规则 minConf float 
最小 可信度 prunedH = for conseq in H conf = 
supportData freqSet / supportData freqSet conseq if conf = minConf 
print freqSet conseq conseq conf conf brl . append freqSet 
conseq conseq conf prunedH . append conseq return prunedH def 
rulesFromConseq freqSet H supportData brl minConf = 0.7 对/p 频繁/a 
项/n 集中/v 元素/n 超过/v 2/m 的/uj 项集/nr 进行/v 合并/v freqSet 
frozenset 频繁 项集/nr H frozenset 频繁 项 集中 的 所有 
元素 即 可以 出现 在 规则 右 部 的 元素 
supportData dict 所 有项 集 的 支持 度 信息 brl 
tuple 生成 的 规则 m = len H 0 # 
查看 频繁 项集/nr 是否 大 到 移除 大小 为 m 
的 子集 if len freqSet m + 1 Hmp1 = 
aprioriGen H m + 1 Hmp1 = calcConf freqSet Hmp1 
supportData brl minConf # 如果 不止 一 条规 则 满足 
要求 进一步 递归 合并 if len Hmp1 1 rulesFromConseq freqSet 
Hmp1 supportData brl minConf def generateRules L supportData minConf = 
0.7 根据/p 频繁/a 项集和/nr 最小/a 可信度/l 生成/v 规则/n L list 
存储 频繁 项集/nr supportData dict 存储 着 所有 项集/nr 不 
仅仅 是 频繁 项集/nr 的 支持 度 minConf float 最小 
可信度 bigRuleList = for i in range 1 len L 
for freqSet in L i # 对于 每一个 频繁 项集的/nr 
集合 freqSet H1 = frozenset item for item in freqSet 
# 如果 频繁 项 集中 的 元素 个数 大于 2 
需要 进一步 合并 if i 1 rulesFromConseq freqSet H1 supportData 
bigRuleList minConf else calcConf freqSet H1 supportData bigRuleList minConf return 
bigRuleList 测试 if _ _ name _ _ = = 
_ _ main _ _ # 导入 数据集 myDat = 
loadDataSet # 选择 频繁 项集/nr L suppData = apriori myDat 
0.5 rules = generateRules L suppData minConf = 0.7 print 
rules \ n rules 运行 结果 runfile E / Python 
/ PythonScripts / Apriori . py wdir = r E 
/ Python / PythonScripts frozenset 1 frozenset 3 conf 1.0 
frozenset 5 frozenset 2 conf 1.0 frozenset 2 frozenset 5 
conf 1.0 rules frozenset 1 frozenset 3 1.0 frozenset 5 
frozenset 2 1.0 frozenset 2 frozenset 5 1.0 将 可信度 
降为 0.5 之后 runfile E / Python / PythonScripts / 
Apriori . py wdir = r E / Python / 
PythonScripts frozenset 3 frozenset 1 conf 0.666666666667 frozenset 1 frozenset 
3 conf 1.0 frozenset 5 frozenset 2 conf 1.0 frozenset 
2 frozenset 5 conf 1.0 frozenset 3 frozenset 2 conf 
0.666666666667 frozenset 2 frozenset 3 conf 0.666666666667 frozenset 5 frozenset 
3 conf 0.666666666667 frozenset 3 frozenset 5 conf 0.666666666667 frozenset 
5 frozenset 2 3 conf 0.666666666667 frozenset 3 frozenset 2 
5 conf 0.666666666667 frozenset 2 frozenset 3 5 conf 0.666666666667 
rules frozenset 3 frozenset 1 0 . 6666666666666666 frozenset 1 
frozenset 3 1.0 frozenset 5 frozenset 2 1.0 frozenset 2 
frozenset 5 1.0 frozenset 3 frozenset 2 0 . 6666666666666666 
frozenset 2 frozenset 3 0 . 6666666666666666 frozenset 5 frozenset 
3 0 . 6666666666666666 frozenset 3 frozenset 5 0 . 
6666666666666666 frozenset 5 frozenset 2 3 0 . 6666666666666666 frozenset 
3 frozenset 2 5 0 . 6666666666666666 frozenset 2 frozenset 
3 5 0 . 6666666666666666 一旦 降低 可信度 阈值 就 
可以 获得 更多 的 规则 5 . 总结   返回 
目录 有 上面 分析 可以 看出 Apriori 算法 易 编码 
缺点 是 在 大 数据 集上 可能 较慢 