介绍 在 学习 机器 学习 的 时候 首当其冲 的 就是 
准备 一份 通用 的 数据集 方便 与 其他 的 算法 
进行 比较 在 这里 我 写 了 一个 用于 加载 
MNIST 数据集 的 方法 并将 其 进行 封装 主要 用于 
将 MNIST 数据集 转换成 numpy . array 格式 的 训练 
数据 直接 下面 看 下面 的 代码 吧 主要 还 
是 如何 用 python 去 读取 binnary file MNIST 数据集 
原 网址 http / / yann . lecun . com 
/ exdb / mnist / Github 源码 下载 数据集 源文件 
+ 解压 文件 + 字体 图像 jpg 格式 py 源码 
文件 文件目录 / utils / data _ util . py 
用于 加载 MNIST 数据集 方法 文件 / utils / test 
. py 用于 测试 的 文件 一个 简单 的 KNN 
测试 MNIST 数据集 / data / train images . idx3 
ubyte 训练 集 X / dataset / train labels . 
idx1 ubyte 训练 集 y / dataset / data / 
t10k images . idx3 ubyte 测试 集 X / dataset 
/ data / t10k labels . idx1 ubyte 测试 集 
yMNIST 数据集 解释 将 MNIST 文件 解 压后 发现 这些 
文件 并 不是 标准 的 图像格式 这些 图像 数据 都保 
存在 二进制 文件 中 每个 样本 图像 的 宽 高为/nr 
28 * 28 mnist 的 结构 如下 选取 train images 
code TRAINING SET IMAGE FILE train images idx3 ubyte offset 
type value description 0000 32 bit integer 0x00000803 2051 magic 
number 0004 32 bit integer 60000 number of images 0008 
32 bit integer 28 number of rows 0012 32 bit 
integer 28 number of columns 0016 unsigned byte pixel 0017 
unsigned byte pixel . . . . . . . 
. xxxx unsigned byte pixel 首先 该 数据 是以 二进制 
存储 的 我们 读取 的 时候 要以 rb 方式 读取 
其次 真正 的 数据 只有 value 这 一项 其他 的 
type 等 只是 来 描述 的 并不 真正 在 数据文件 
里面 也 就是说 在 读取 真实 数据 之前 我们 要 
读取 4个 32 bit integer . 由 offset 我们 可以 
看出 真正 的 pixel 是从 0016 开始 的 一个 int 
32位 所以在 读取 pixel 之前 我们 要 读取 4个 32 
bit integer 也 就是 magic number number of images number 
of rows number of columns . 当然 在 这里 使用 
struct . unpack _ from 会 比较 方便 . 源码 
说明 IIII 指 的 是 使用 大端 法 读取 4个 
unsinged int 32 bit integer 784B 指 的 是 使用 
大端 法 读取 784个 unsigned bytedata _ util . py 
文件 code # * coding utf 8 * Created on 
Thu Feb 25 14 40 06 2016 load MNIST dataset 
@ author liudiwei import numpy as np import struct import 
matplotlib . pyplot as plt import os class DataUtils object 
MNIST 数据集 加载 输出 格式 为 numpy . array 使用 
方法 如下 from data _ util import DataUtils def main 
trainfile _ X = . . / dataset / MNIST 
/ train images . idx3 ubyte trainfile _ y = 
. . / dataset / MNIST / train labels . 
idx1 ubyte testfile _ X = . . / dataset 
/ MNIST / t10k images . idx3 ubyte testfile _ 
y = . . / dataset / MNIST / t10k 
labels . idx1 ubyte train _ X = DataUtils filename 
= trainfile _ X . getImage train _ y = 
DataUtils filename = trainfile _ y . getLabel test _ 
X = DataUtils testfile _ X . getImage test _ 
y = DataUtils testfile _ y . getLabel # 以下 
内容 是 将 图像 保存 到 本地 文件 中 # 
path _ trainset = . . / dataset / MNIST 
/ imgs _ train # path _ testset = . 
. / dataset / MNIST / imgs _ test # 
if not os . path . exists path _ trainset 
# os . mkdir path _ trainset # if not 
os . path . exists path _ testset # os 
. mkdir path _ testset # DataUtils outpath = path 
_ trainset . outImg train _ X train _ y 
# DataUtils outpath = path _ testset . outImg test 
_ X test _ y return train _ X train 
_ y test _ X test _ y def _ 
_ init _ _ self filename = None outpath = 
None self . _ filename = filename self . _ 
outpath = outpath self . _ tag = self . 
_ twoBytes = II self . _ fourBytes = IIII 
self . _ pictureBytes = 784B self . _ labelByte 
= 1B self . _ twoBytes2 = self . _ 
tag + self . _ twoBytes self . _ fourBytes2 
= self . _ tag + self . _ fourBytes 
self . _ pictureBytes2 = self . _ tag + 
self . _ pictureBytes self . _ labelByte2 = self 
. _ tag + self . _ labelByte def getImage 
self 将 MNIST 的 二进制 文件 转换成 像素 特征 数据 
binfile = open self . _ filename rb # 以 
二进制 方式 打开 文件 buf = binfile . read binfile 
. close index = 0 numMagic numImgs numRows numCols = 
struct . unpack _ from self . _ fourBytes2 \ 
buf \ index index + = struct . calcsize self 
. _ fourBytes images = for i in range numImgs 
imgVal = struct . unpack _ from self . _ 
pictureBytes2 buf index index + = struct . calcsize self 
. _ pictureBytes2 imgVal = list imgVal for j in 
range len imgVal if imgVal j 1 imgVal j = 
1 images . append imgVal return np . array images 
def getLabel self 将 MNIST 中 label 二进制 文件 转换成 
对应 的 label 数字 特征 binFile = open self . 
_ filename rb buf = binFile . read binFile . 
close index = 0 magic numItems = struct . unpack 
_ from self . _ twoBytes2 buf index index + 
= struct . calcsize self . _ twoBytes2 labels = 
for x in range numItems im = struct . unpack 
_ from self . _ labelByte2 buf index index + 
= struct . calcsize self . _ labelByte2 labels . 
append im 0 return np . array labels def outImg 
self arrX arrY 根据 生成 的 特征 和 数字 标号 
输出 png 的 图像 m n = np . shape 
arrX # 每张 图 是 28 * 28 = 784Byte 
for i in range 1 img = np . array 
arrX i img = img . reshape 28 28 outfile 
= str i + _ + str arrY i + 
. png plt . figure plt . imshow img cmap 
= binary # 将 图像 黑白 显示 plt . savefig 
self . _ outpath + / + outfile test . 
py 文件 简单 地 测试 了 一下 KNN 算法 代码 
如下 code # * coding utf 8 * Created on 
Thu Feb 25 16 09 58 2016 Test MNIST dataset 
@ author liudiwei from sklearn import neighbors from data _ 
util import DataUtils import datetime def main trainfile _ X 
= . . / dataset / MNIST / train images 
. idx3 ubyte trainfile _ y = . . / 
dataset / MNIST / train labels . idx1 ubyte testfile 
_ X = . . / dataset / MNIST / 
t10k images . idx3 ubyte testfile _ y = . 
. / dataset / MNIST / t10k labels . idx1 
ubyte train _ X = DataUtils filename = trainfile _ 
X . getImage train _ y = DataUtils filename = 
trainfile _ y . getLabel test _ X = DataUtils 
testfile _ X . getImage test _ y = DataUtils 
testfile _ y . getLabel return train _ X train 
_ y test _ X test _ y def testKNN 
train _ X train _ y test _ X test 
_ y = main startTime = datetime . datetime . 
now knn = neighbors . K N e i g 
h b o r s C l a s s 
i f i e r n _ neighbors = 3 
knn . fit train _ X train _ y match 
= 0 for i in xrange len test _ y 
predictLabel = knn . predict test _ X i 0 
if predictLabel = = test _ y i match + 
= 1 endTime = datetime . datetime . now print 
use time + str endTime startTime print error rate + 
str 1 match * 1.0 / len test _ y 
if _ _ name _ _ = = _ _ 
main _ _ testKNN 通过 main 方法 最后 直接 返回 
numpy . array 格式 的 数据 train _ X train 
_ y test _ X test _ y 如果 你 
需要 直接 条 用 main 方法 即可 更多 机器学习 文章 
请进 http / / www . csuldw . com . 
