第 一题 很明显 1 质数 有很 明确 的 定义 所以 
辨别 质数 并不需要 ML 2 在 课件 中 反复 提到 
的 信用卡 发放 问题 3 计算 重力 加速度 有 明确 
的 方法 不 需要 ML 4 在 繁忙 十字路口 最优 
交通 红绿灯 的 周期 由于 每端 时间 的 车流量 很难 
去 预测 所以 需要 ML 去 自己 学习 控制 周期 
5 根据 年龄 推荐 医学 检验 无法 通过 明确 定义 
程序 直接判断 电脑 需要 自己 ML 得出 值得 推荐 的 
结果 下棋 时 data 是 一笔 一笔 喂给 电脑 每一步 
没有 明确 的 label 题目 中 也 提到 了 feedback 
也 就是 奖惩 所以 很 明显 是 r e i 
n f o r c e m e n t 
l e a r n i n g 依 题意 
书 并没有 label 和 课件 中的 例子 articles = topic 
一样 很 明显 是 unsupervised learning 依 题意 是 binary 
classification 每个 x 有 明确 的 label 所以 是 supervised 
learning 评估 药物 的 疗效 由于 每 次 实验 很贵 
也 就是 标注 每个 x 很贵 所以 我们 的 data 
只有 一 部分 有 label 只有 当 机器 不 确定 
的 情况 我们 才 去做 实验 获得 label 所以 这是 
active learningOff Training Set error 即 不在 训练 集中 的 
测试 错误 所以 我们 求 的 是 N + 1 
~ N + L 的 error 依 题意 只有 当 
1 ~ N + L 中的 数 是 偶数 的 
时候 f ≠ g 产生 error 所以 1 ~ N 
+ L 中 共有 ⌊ N + L / 2 
⌋ 个 偶数 1 ~ N 中 共有 ⌊ N 
/ 2 ⌋ 个 偶数 所以 N + 1 ~ 
N + L 中有 ⌊ N + L / 2 
⌋ ⌊ N / 2 ⌋ 个 偶数 所以 Eots 
= 1 / L * ⌊ N + L / 
2 ⌋ ⌊ N / 2 ⌋ 这道 题 乍一看 
真是 绕 啊 仔细 分析 一下 有/v 多少/m 种/m 能/v 
产生/n D/w in a noiseless setting 的 f 也 就是说 
在 D 内 这些 f 产生 的 值 都是 相同 
的 这些 f 的 不同 都 发生 在 N + 
1 ~ N + L 中 在 N + 1 
~ N + L 中 每个 值 都有 { 1 
1 } 两种 取值 所以 共有 2 ˆ L 种 
不同 的 情况 即能 产生 2 ˆ L 个 不同 
的 f 前 三个 选项 很明显 可以 看 出来 不对 
思考 下 第四 个 选项 为什么 对 Eots 是 不在 
训练 集中 的 测试 错误 也 就是 A D 和f在/nr 
N + 1 ~ N + L 上 结果 的 
差异 通过 上 题 我们 知道 f 已经 取得 了 
N + 1 ~ N + L 上 所有 可能 
的 结果 所以 A1 D 和 A2 D 在 N 
+ 1 ~ N + L 上 的 取值 都是 
f 中 的 一种 所以 A1 D 和 A2 D 
与 所有 f 的 Eots 取 期望 是 一样 的 
我们 可以 这样 计算 对于 每一个 A A D 与 
f 的 差异 都 是从 0 到 f 分布 的 
我们 都 可以 通过 如下 方法 计算 0位 差异 C 
L 0 个 1位 差异 C L 1 个 2位 
差异 C L 2 3位 差异 C L 3 L 
位 差异 C L L 所以 不管 什么 A 值 
都是 一样 的 期望 也 就是 一样 的 这道 题 
就是 比较 简单 的 概率 计算 C 10 5 * 
0.5 ˆ 10 ≈ 0.24 C 10 1 * 0.1 
* 0.9 ˆ 9 ≈ 0.39 C 10 1 * 
0.9 * 0.1 ˆ 9 + 0.1 ˆ 10 = 
9.1 * 10 9hoeffding 不等式 P | v µ | 
0.8   ≤ 2 * e ˆ 2 * 0.8 
ˆ 2 * 10   ≈ 5.52 * 10 6 
又是 概率 问题 出现 5个 橘色 1 的 概率 橘色 
1 出现 在 B 和C/nr 类型 骰子 里 所以 1/4 
* 0 + 1/4 * 1 + 1/4 * 1 
+ 1/4 * 0 ˆ 5 = 1/32 = 8/256 
上 一题 的 升级版 能 出现 的 纯 橘色 数字 
1 2 3 4 5 6 其中 1 3 分布 
在 B 和C/nr 类型 的 骰子 上 4 6 出现 
在 A 和D/nr 类型 的 骰子 上 2 出现 在 
A C 类型 的 骰子 上 5 出现 在 B 
D 类型 的 骰子 上 针对 这 4中 情况 来 
计算 1 1/4 * 0 + 1/4 * 1 + 
1/4 * 1 + 1/4 * 0 ˆ 5 = 
1/32 2 1/4 * 1 + 1/4 * 0 + 
1/4 * 0 + 1/4 * 1 ˆ 5 = 
1/32 3 1/4 * 1 + 1/4 * 0 + 
1/4 * 1 + 1/4 * 0 ˆ 5 = 
1/32 4 1/4 * 0 + 1/4 * 1 + 
1/4 * 0 + 1/4 * 1 ˆ 5 = 
1/32 由于 1 和 3 中有 C 重复 1 和 
4 中有 B 重复 2 和 3 中有 A 重复 
2 和 4 中有 D 重复 需要 去掉 重复 的 
情况 所以 1 + 3 + 2 + 4 1/4 
ˆ 5 * 4 = 1/8 1/256 = 31 / 
256navi cycle 的 意思 是 每次 发生 的 错误 时 
循环 不 重新 开始 而是 接着 进行 程序代码 如下 1 
import numpy 2 3 class navi _ cycle _ PLA 
object 4 def _ _ init _ _ self dimension 
count 5 self . _ _ dimension = dimension 6 
self . _ _ count = count 7 8 def 
train _ Matrix self path 9 training _ set = 
open path 10 X _ train = numpy . zeros 
self . _ _ count self . _ _ dimension 
11 y _ train = numpy . zeros self . 
_ _ count 1 12 x = 13 x _ 
count = 0 14 for line in training _ set 
15 x . append 1 16 for str in line 
. split 17 if len str . split \ t 
= = 1 18 x . append float str 19 
else 20 x . append float str . split \ 
t 0 21 y _ train x _ count 0 
= int str . split \ t 1 . strip 
22 X _ train x _ count = x 23 
x = 24 x _ count + = 1 25 
return X _ train y _ train 26 27 def 
interationCount self path 28 count = 0 29 X _ 
train y _ train = self . train _ Matrix 
path 30 w = numpy . zeros self . _ 
_ dimension 1 31 while True 32 flag = 0 
33 for i in range self . _ _ count 
34 if numpy . dot X _ train i w 
0 * y _ train i 0 = 0 35 
w + = y _ train i 0 * X 
_ train i . reshape 5 1 36 count + 
= 1 37 flag = 1 38 if flag = 
= 0 39 break 40 return count 41 42 my 
_ Percetron = navi _ cycle _ PLA 5 400 
43 print my _ Percetron . interationCount ntumlone _ hw1 
_ hw1 _ 15 _ train . dat 每次 实验 
前 把 X 的 顺序 打乱 重复 2000次 1 import 
numpy 2 import random 3 4 class random _ PLA 
object 5 def _ _ init _ _ self dimension 
count 6 self . _ _ dimension = dimension 7 
self . _ _ count = count 8 9 def 
random _ Matrix self path 10 training _ set = 
open path 11 randomLst = 12 x = 13 x 
_ count = 0 14 for line in training _ 
set 15 x . append 1 16 for str in 
line . split 17 if len str . split \ 
t = = 1 18 x . append float str 
19 else 20 x . append float str . split 
\ t 0 21 x . append int str . 
split \ t 1 . strip 22 randomLst . append 
x 23 x = 24 x _ count + = 
1 25 return randomLst 26 27 def train _ Maxtrix 
self path 28 X _ train = numpy . zeros 
self . _ _ count self . _ _ dimension 
29 y _ train = numpy . zeros self . 
_ _ count 1 30 randomLst = self . random 
_ Matrix path 31 random . shuffle randomLst 32 for 
i in range self . _ _ count 33 for 
j in range self . _ _ dimension 34 X 
_ train i j = randomLst i j 35 y 
_ train i 0 = randomLst i self . _ 
_ dimension 36 return X _ train y _ train 
37 38 39 def interationCount self path 40 count = 
0 41 X _ train y _ train = self 
. train _ Maxtrix path 42 w = numpy . 
zeros self . _ _ dimension 1 43 while True 
44 flag = 0 45 for i in range self 
. _ _ count 46 if numpy . dot X 
_ train i w 0 * y _ train i 
0 = 0 47 w + = y _ train 
i 0 * X _ train i . reshape 5 
1 48 count + = 1 49 flag = 1 
50 if flag = = 0 51 break 52 return 
count 53 54 average _ count = 0 55 for 
i in range 2000 56 my _ Percetron = random 
_ PLA 5 400 57 average _ count + = 
my _ Percetron . interationCount ntumlone _ hw1 _ hw1 
_ 15 _ train . dat 58 print average _ 
count / 2000.0 这次 是 在 w 每次 更新 的 
时候 加上 一个 权重 0.51 import numpy 2 import random 
3 4 class random _ PLA object 5 def _ 
_ init _ _ self dimension count 6 self . 
_ _ dimension = dimension 7 self . _ _ 
count = count 8 9 def random _ Matrix self 
path 10 training _ set = open path 11 randomLst 
= 12 x = 13 x _ count = 0 
14 for line in training _ set 15 x . 
append 1 16 for str in line . split 17 
if len str . split \ t = = 1 
18 x . append float str 19 else 20 x 
. append float str . split \ t 0 21 
x . append int str . split \ t 1 
. strip 22 randomLst . append x 23 x = 
24 x _ count + = 1 25 return randomLst 
26 27 def train _ Maxtrix self path 28 X 
_ train = numpy . zeros self . _ _ 
count self . _ _ dimension 29 y _ train 
= numpy . zeros self . _ _ count 1 
30 randomLst = self . random _ Matrix path 31 
random . shuffle randomLst 32 for i in range self 
. _ _ count 33 for j in range self 
. _ _ dimension 34 X _ train i j 
= randomLst i j 35 y _ train i 0 
= randomLst i self . _ _ dimension 36 return 
X _ train y _ train 37 38 39 def 
interationCount self path 40 count = 0 41 X _ 
train y _ train = self . train _ Maxtrix 
path 42 w = numpy . zeros self . _ 
_ dimension 1 43 while True 44 flag = 0 
45 for i in range self . _ _ count 
46 if numpy . dot X _ train i w 
0 * y _ train i 0 = 0 47 
w + = 0.5 * y _ train i 0 
* X _ train i . reshape 5 1 48 
count + = 1 49 flag = 1 50 if 
flag = = 0 51 break 52 return count 53 
54 average _ count = 0 55 for i in 
range 2000 56 my _ Percetron = random _ PLA 
5 400 57 average _ count + = my _ 
Percetron . interationCount ntumlone _ hw1 _ hw1 _ 15 
_ train . dat 58 print average _ count / 
2000.0 从这 题 开始 考察 的 是 Pocket 算法 了 
话 不多 说 上 代码 1 import numpy 2 import 
random 3 import copy 4 5 class Pocket object 6 
def _ _ init _ _ self dimension train _ 
count test _ count 7 self . _ _ dimension 
= dimension 8 self . _ _ train _ count 
= train _ count 9 self . _ _ test 
_ count = test _ count 10 11 def random 
_ Matrix self path 12 training _ set = open 
path 13 randomLst = 14 x = 15 x _ 
count = 0 16 for line in training _ set 
17 x . append 1 18 for str in line 
. split 19 if len str . split \ t 
= = 1 20 x . append float str 21 
else 22 x . append float str . split \ 
t 0 23 x . append int str . split 
\ t 1 . strip 24 randomLst . append x 
25 x = 26 x _ count + = 1 
27 return randomLst 28 29 def train _ Maxtrix self 
path 30 X _ train = numpy . zeros self 
. _ _ train _ count self . _ _ 
dimension 31 y _ train = numpy . zeros self 
. _ _ train _ count 1 32 randomLst = 
self . random _ Matrix path 33 random . shuffle 
randomLst 34 for i in range self . _ _ 
train _ count 35 for j in range self . 
_ _ dimension 36 X _ train i j = 
randomLst i j 37 y _ train i 0 = 
randomLst i self . _ _ dimension 38 return X 
_ train y _ train 39 40 41 def interationW 
self path 42 count = 0 43 X _ train 
y _ train = self . train _ Maxtrix path 
44 w = numpy . zeros self . _ _ 
dimension 1 45 bestCount = self . _ _ train 
_ count 46 bestW = numpy . zeros self . 
_ _ dimension 1 47 48 while True 49 for 
i in range self . _ _ train _ count 
50 if numpy . dot X _ train i w 
0 * y _ train i 0 = 0 51 
w + = 0.5 * y _ train i 0 
* X _ train i . reshape 5 1 52 
count + = 1 53 num = 0 54 for 
j in range self . _ _ train _ count 
55 if numpy . dot X _ train j w 
0 * y _ train j 0 = 0 56 
num + = 1 57 if num bestCount 58 bestCount 
= num 59 bestW = copy . deepcopy w 60 
if count = = 50 61 break 62 if count 
= = 50 63 break 64 return bestW 65 66 
def test _ Matrix self test _ path 67 X 
_ test = numpy . zeros self . _ _ 
test _ count self . _ _ dimension 68 y 
_ test = numpy . zeros self . _ _ 
test _ count 1 69 test _ set = open 
test _ path 70 x = 71 x _ count 
= 0 72 for line in test _ set 73 
x . append 1 74 for str in line . 
split 75 if len str . split \ t = 
= 1 76 x . append float str 77 else 
78 x . append float str . split \ t 
0 79 y _ test x _ count 0 = 
int str . split \ t 1 . strip 80 
X _ test x _ count = x 81 x 
= 82 x _ count + = 1 83 return 
X _ test y _ test 84 85 def testError 
self train _ path test _ path 86 w = 
self . interationW train _ path 87 X _ test 
y _ test = self . test _ Matrix test 
_ path 88 count = 0.0 89 for i in 
range self . _ _ test _ count 90 if 
numpy . dot X _ test i w 0 * 
y _ test i 0 = 0 91 count + 
= 1 92 return count / self . _ _ 
test _ count 93 94 average _ error _ rate 
= 0 95 for i in range 2000 96 my 
_ Pocket = Pocket 5 500 500 97 average _ 
error _ rate + = my _ Pocket . testError 
ntumlone _ hw1 _ hw1 _ 18 _ train . 
dat ntumlone _ hw1 _ hw1 _ 18 _ test 
. dat 98 print average _ error _ rate / 
2000.0 这道 题 意在 Pocket 和 PLA 做 对比 看样 
看出 Pocket 算法 在 同等 更新 下好 很多 1 import 
numpy 2 import random 3 4 class random _ PLA 
object 5 def _ _ init _ _ self dimension 
train _ count test _ count 6 self . _ 
_ dimension = dimension 7 self . _ _ train 
_ count = train _ count 8 self . _ 
_ test _ count = test _ count 9 10 
def random _ Matrix self path 11 training _ set 
= open path 12 randomLst = 13 x = 14 
x _ count = 0 15 for line in training 
_ set 16 x . append 1 17 for str 
in line . split 18 if len str . split 
\ t = = 1 19 x . append float 
str 20 else 21 x . append float str . 
split \ t 0 22 x . append int str 
. split \ t 1 . strip 23 randomLst . 
append x 24 x = 25 x _ count + 
= 1 26 return randomLst 27 28 def train _ 
Maxtrix self path 29 X _ train = numpy . 
zeros self . _ _ train _ count self . 
_ _ dimension 30 y _ train = numpy . 
zeros self . _ _ train _ count 1 31 
randomLst = self . random _ Matrix path 32 random 
. shuffle randomLst 33 for i in range self . 
_ _ train _ count 34 for j in range 
self . _ _ dimension 35 X _ train i 
j = randomLst i j 36 y _ train i 
0 = randomLst i self . _ _ dimension 37 
return X _ train y _ train 38 39 40 
def interationW self path 41 count = 0 42 X 
_ train y _ train = self . train _ 
Maxtrix path 43 w = numpy . zeros self . 
_ _ dimension 1 44 while True 45 for i 
in range self . _ _ train _ count 46 
if numpy . dot X _ train i w 0 
* y _ train i 0 = 0 47 w 
+ = 0.5 * y _ train i 0 * 
X _ train i . reshape 5 1 48 count 
+ = 1 49 if count = = 50 50 
break 51 if count = = 50 52 break 53 
return w 54 55 def test _ Matrix self test 
_ path 56 X _ test = numpy . zeros 
self . _ _ test _ count self . _ 
_ dimension 57 y _ test = numpy . zeros 
self . _ _ test _ count 1 58 test 
_ set = open test _ path 59 x = 
60 x _ count = 0 61 for line in 
test _ set 62 x . append 1 63 for 
str in line . split 64 if len str . 
split \ t = = 1 65 x . append 
float str 66 else 67 x . append float str 
. split \ t 0 68 y _ test x 
_ count 0 = int str . split \ t 
1 . strip 69 X _ test x _ count 
= x 70 x = 71 x _ count + 
= 1 72 return X _ test y _ test 
73 74 def testError self train _ path test _ 
path 75 w = self . interationW train _ path 
76 X _ test y _ test = self . 
test _ Matrix test _ path 77 count = 0.0 
78 for i in range self . _ _ test 
_ count 79 if numpy . dot X _ test 
i w 0 * y _ test i 0 = 
0 80 count + = 1 81 return count / 
self . _ _ test _ count 82 83 average 
_ error _ rate = 0 84 for i in 
range 2000 85 my _ PLA = random _ PLA 
5 500 500 86 average _ error _ rate + 
= my _ PLA . testError ntumlone _ hw1 _ 
hw1 _ 18 _ train . dat ntumlone _ hw1 
_ hw1 _ 18 _ test . dat 87 print 
average _ error _ rate / 2000.0 和第/nr 18题 一样 
只是 把 更新 次数 增大 到 100 1 import numpy 
2 import random 3 import copy 4 5 class Pocket 
object 6 def _ _ init _ _ self dimension 
train _ count test _ count 7 self . _ 
_ dimension = dimension 8 self . _ _ train 
_ count = train _ count 9 self . _ 
_ test _ count = test _ count 10 11 
def random _ Matrix self path 12 training _ set 
= open path 13 randomLst = 14 x = 15 
x _ count = 0 16 for line in training 
_ set 17 x . append 1 18 for str 
in line . split 19 if len str . split 
\ t = = 1 20 x . append float 
str 21 else 22 x . append float str . 
split \ t 0 23 x . append int str 
. split \ t 1 . strip 24 randomLst . 
append x 25 x = 26 x _ count + 
= 1 27 return randomLst 28 29 def train _ 
Maxtrix self path 30 X _ train = numpy . 
zeros self . _ _ train _ count self . 
_ _ dimension 31 y _ train = numpy . 
zeros self . _ _ train _ count 1 32 
randomLst = self . random _ Matrix path 33 random 
. shuffle randomLst 34 for i in range self . 
_ _ train _ count 35 for j in range 
self . _ _ dimension 36 X _ train i 
j = randomLst i j 37 y _ train i 
0 = randomLst i self . _ _ dimension 38 
return X _ train y _ train 39 40 41 
def interationW self path 42 count = 0 43 X 
_ train y _ train = self . train _ 
Maxtrix path 44 w = numpy . zeros self . 
_ _ dimension 1 45 bestCount = self . _ 
_ train _ count 46 bestW = numpy . zeros 
self . _ _ dimension 1 47 48 while True 
49 for i in range self . _ _ train 
_ count 50 if numpy . dot X _ train 
i w 0 * y _ train i 0 = 
0 51 w + = 0.5 * y _ train 
i 0 * X _ train i . reshape 5 
1 52 count + = 1 53 num = 0 
54 for j in range self . _ _ train 
_ count 55 if numpy . dot X _ train 
j w 0 * y _ train j 0 = 
0 56 num + = 1 57 if num bestCount 
58 bestCount = num 59 bestW = copy . deepcopy 
w 60 if count = = 100 61 break 62 
if count = = 100 63 break 64 return bestW 
65 66 def test _ Matrix self test _ path 
67 X _ test = numpy . zeros self . 
_ _ test _ count self . _ _ dimension 
68 y _ test = numpy . zeros self . 
_ _ test _ count 1 69 test _ set 
= open test _ path 70 x = 71 x 
_ count = 0 72 for line in test _ 
set 73 x . append 1 74 for str in 
line . split 75 if len str . split \ 
t = = 1 76 x . append float str 
77 else 78 x . append float str . split 
\ t 0 79 y _ test x _ count 
0 = int str . split \ t 1 . 
strip 80 X _ test x _ count = x 
81 x = 82 x _ count + = 1 
83 return X _ test y _ test 84 85 
def testError self train _ path test _ path 86 
w = self . interationW train _ path 87 X 
_ test y _ test = self . test _ 
Matrix test _ path 88 count = 0.0 89 for 
i in range self . _ _ test _ count 
90 if numpy . dot X _ test i w 
0 * y _ test i 0 = 0 91 
count + = 1 92 return count / self . 
_ _ test _ count 93 94 average _ error 
_ rate = 0 95 for i in range 2000 
96 my _ Pocket = Pocket 5 500 500 97 
average _ error _ rate + = my _ Pocket 
. testError ntumlone _ hw1 _ hw1 _ 18 _ 
train . dat ntumlone _ hw1 _ hw1 _ 18 
_ test . dat 98 print average _ error _ 
rate / 2000.0 到此 第一次 作业 就 全部 完成 了 
~ ~ 20道 题 看似 不多 但是 工作量 真是 大 
啊 概念 计算 编程 全部都 涵盖 了 真是 不 容易 
后面 再接再厉 了 ~ 