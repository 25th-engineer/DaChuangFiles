摘要 本文 对 Apriori 算法 进行 了 简单 介绍 并 
通过 Python 进行 实现 进而 结合 UCI 数据库 中的 肋 
形 蘑菇 数据集 对 算法 进行 验证 啤酒 与 尿布 
的 例子 相信 很多 人 都 听说 过 吧 故事 
是 这样 的 在 一家 超市 中 人们 发现 了 
一个 特别 有趣 的 现象 尿布 与 啤酒 这两种 风马牛不相及 
的 商品 居然 摆 在 一起 但 这一 奇怪 的 
举措 居然 使 尿布 和 啤酒 的 销量 大幅 增加 
了 这 可不 是 一个 笑话 而是 一直 被 商家 
所 津津乐道 的 发生 在 美国 沃尔玛 连锁 超市 的 
真实 案例 原来 美国 的 妇女 通常 在家 照顾 孩子 
所以 她们 经常 会 嘱咐 丈夫 在 下班 回家 的 
路上 为 孩子 买 尿布 而 丈夫 在 买 尿布 
的 同时 又 会 顺手 购买 自己 爱喝 的 啤酒 
这个 发现 为 商家 带来 了 大量 的 利润 但是 
如何 从 浩如烟海 却又 杂乱无章 的 数据 中 发现 啤酒 
和 尿布 销售 之间 的 联系 呢 这种 从大/nr 规模 
的 数据 中 发现 物品 间 隐含 关系 的 方法 
被 称为 关联 分析 也 就是 本文 要 主要 研究 
的 一种 常用 的 分析 方法 Apriori 算法 是 最 
著名 的 关联 规则 挖掘 算法 之一 下面 就 围绕 
该 算法 展开 学习 一 关联 分析 关联 分析 是 
一种 在 大规模 数据 集中 寻找 有趣 关系 的 任务 
这些 任务 有 两种 形式 频繁/a 项集和/nr 关联/ns 规则/n 频繁 
项集是/nr 经常 出现 在 一块 的 物品 的 集合 关联 
规则 暗示 的 是 两种 物品 之间 可能 存在 很强 
的 关系 可以 结合 某家 店 的 交易 清单 来 
说明 这 两个 概念 交易 号码 商品 0 豆奶 草莓 
1 草莓 尿布 啤酒 辣椒酱 2 豆奶 尿布 黄瓜 饼干 
3 黄瓜 饼干 尿布 啤酒 4 黄瓜 啤酒 尿布 黄瓜 
频繁 项集指/nr 的 就是 那些 经常 一起 出现 的 物品 
集合 比如 { 啤酒 尿布 饼干 } 就是 频繁 项 
集中 的 一个 例子 而 根据 上表 也 可以 找到 
尿布 啤酒 这样 的 关联 规则 而 我们 是 要 
通过 关联 分析 大 规模 数据 从而/nr 发现 数据 之间 
存在 的 有趣 关系 那么 问题 来了 什么样 的 关系 
是 有趣 的 呢 而 这个 有趣 又 是 怎么 
定义 的 呢 我们 可以 通过 支持 度 support 和 
可信度 置信度 confidence 来 定义 一个 项集的/nr 支持 度 指 
的 是 数据 集中 包含 该项 集 记录 所占 的 
比例 上例 中 { 豆奶 } 的 支持 度 是 
2/5 { 啤酒 尿布 } 的 支持 度 是 3/5 
可信度 是 针对 于像{/nr 尿布 } { 啤酒 } 这样 
的 关联 规则 来 定义 的 定义 为 支持度 { 
尿布 葡萄酒 } / 支持度 尿布 二 Apriori 原理 上述 
我们 通过 支持 度 和 可信度 来 定义 发现 数据 
之间 存在 的 关系 我们 知道 在 商品 列表 中 
可能 存在 单一 商品 组成 的 频繁 项集/nr 当然 也 
存在 两个 以及 两个 以上 的 商品 组成 的 频繁 
项集/nr 而在 计算 一个 频繁 项集的/nr 支持 度 时 通常 
需要 遍历 所有 的 商品 列表 求得 对于 列表 数目 
较少 的 情况 该 方法 无疑 是 没问题 的 但当 
列表 数目 成千上万 时 计算 量过大 这种方法 势必 是 不 
适用 的 那么 如何 解决 上述 问题 呢 Apriori 原理 
可以 解决 Apriori 原理 是 说 如果 某个 项集是/nr 频繁 
的 那么 它 的 所有 子集 势必 也 是 频繁 
的 这个 原理 从 表面 上看 没什么 大用 但是 反过来 
如果/c 一个/m 项集/nr 是非/v 频繁/a 项集/nr 那么 它 所 对应 
的 超集 就 全都 是非 频繁 项集/nr 这样/r 在/p 确定/v 
了/ul 一个/m 项集/nr 是非/v 频繁/a 项/n 集了/i 之后/f 它 所 
对应 的 超集 的 支持 度 我们 就 可以 不去 
计算 了 这在 很大 程度 上 避免 了 项集/nr 数目 
的 指数 增长 可以 更加 合理 的 计算 频繁 项集/nr 
三   Apriori 算法 1 使用/v Apriori/w 算法/n 来/v 发现/v 
频繁/a 项集/nr Apriori/w 算法/n 是/v 用来/v 发现/v 频繁/a 项集的/nr 一种/m 
方法/n Apriori 算法 的 两个 输入 参数 分别 是 最小 
支持度 和 数据集 该 算法 首先 生成 所有 单个 物品 
的 项集/nr 列表 遍历 之后 去掉 不满足 最小 支持度 要求 
的 项集/nr 接下来 对 剩下 的 集合 进行 组合 生成 
包含 两个 元素 的 项集/nr 去掉 不满足 最小 支持度 的 
项集/nr 重复 该 过程 直到 去掉 所有 不 满足 最小 
支持度 的 项集/nr 首先 采用 python 生成 所有 的 单个 
物品 所 对应 的 项集/nr 并 构建 一个 得到 频繁 
项集的/nr 函数 代码 如下 # * coding cp936 * Apriori 
算法 Ben 2015 . 09.28 # coding utf 8 from 
numpy import * def loadData return 1 3 4 2 
3 5 1 2 3 5 2 5 def createC1 
dataSet c1 = for transaction in dataSet for item in 
transaction if not item in c1 c1 . append item 
c1 . sort return map frozenset c1 def scanD D 
Ck minSupport ssCnt = { } for tid in D 
for can in Ck if can . issubset tid # 
判断 tid 是否 在 can 中 if not ssCnt . 
has _ key can ssCnt can = 1 else ssCnt 
can + = 1 numItems = float len D retList 
= supportData = { } for key in ssCnt support 
= ssCnt key / numItems if support = minSupport retList 
. insert 0 key supportData key = support return retList 
supportData 对 上述 代码 进行 测试 # test dataSet = 
loadData c1 = createC1 dataSet D = map set dataSet 
L1 supportData = scanD D c1 0.5 print L1 print 
supportData 结合 构建 的 单个 商品 项集/nr 判断 上述 代码 
是 可用 的 据此 结合 之前 的 分析 构建 完整 
的 算法 代码 如下 # 构建 多 个 商品 对应 
的 项集/nr def aprioriGen Lk k retList = lenLk = 
len Lk for i in range lenLk for j in 
range i + 1 lenLk L1 = list Lk i 
k 2 L2 = list Lk j k 2 L1 
. sort L2 . sort if L1 = = L2 
retList . append Lk i | Lk j return retList 
def apriori dataSet minSupport = 0.5 C1 = createC1 dataSet 
D = map set dataSet L1 supportData = scanD D 
C1 minSupport L = L1 k = 2 while len 
L k 2 0 Ck = aprioriGen L k 2 
k Lk supK = scanD D Ck minSupport supportData . 
update supK L . append Lk k + = 1 
return L supportData 这样 就 对 得到 频繁 项集的/nr 思想 
进行 了 实现 下面 验证 dataSet = loadData minSupport = 
0.5 a b = apriori dataSet minSupport print a print 
b 结果 为 所有 频繁 项集以/nr 及其 所 对应 的 
支持 度 符合 预期 2 从/p 频繁/a 项/n 集中/v 挖掘/v 
关联/ns 规则/n 频繁/a 项集/nr 可以/c 使用/v Apriori/w 算法/n 寻找/v 当然 
下来 就是 要 找出 关联 规则 了 我们 知道 假设/vn 
有/v 一个/m 频繁/a 项集/nr 它们 之间 就 有可能 有 一条 
关联 规则 即 可以 表示 为 . . . . 
. . 但 反过来 并不一定 成立 其中 箭头 左边 对应 
的 集合 为 前件 箭头 右边 对应 的 集合 为 
后件 在上 一节 我们 使用 最小 支持度 来 量化 频繁 
项集/nr 对应 的 采用 可信度 来 量化 关联 规则 其中 
一条 规则 p H 的 可信度 定义 为 support P 
| H / support P 为 找到 其中 的 关联 
规则 我们 可以 先 生成 一个 可能 的 规则 列表 
然后 测试 每条 规则 的 可信度 结合 可信度 的 最小 
要求 得到 关联 规则 同 寻找 频繁 项集/nr 类似 我们 
可以 为 每个 频繁 项集/nr 产生 许多 关联 规则 这样 
就会 有 很多 的 关联 规则 产生 结合 Apriori 原理 
如果 某 条 规则 不 满足 最小 可信度 要求 那么 
该 规则 的 所有 子集 也就 不满足 最小 可信度 要求 
据此 我们 可以 减少 需要 测试 的 规则 数目 简化 
问题 寻找 关联 规则 的 思想 是 从/p 一个/m 频繁/a 
项集/nr 开始/v 创建 一个 规则 列表 首先 将 规则 的 
右边 限定 为 一个 元素 对 这些 规则 进行 测试 
接下来 合并 剩下 的 规则 来 创建 一个 新的 规则 
列表 规则 的 右边 限定 为 两个 元素 就 这样 
一步 一步 实现 代码 如下 # 使用 关联 规则 生成 
函数 def generateRules L supportData minConf = 0.7 bigRuleList = 
for i in range 1 len L for freqSet in 
L i H1 = frozenset item for item in freqSet 
if i 1 rulesFromConseq freqSet H1 supportData bigRuleList minConf else 
calcConf freqSet H1 supportData bigRuleList minConf return bigRuleList # 集合 
右边 一个 元素 def calcConf freqSet H supportData brl minConf 
= 0.7 prunedH = for conseq in H conf = 
supportData freqSet / supportData freqSet conseq if conf = minConf 
print freqSet conseq conseq conf conf brl . append freqSet 
conseq conseq conf prunedH . append conseq return prunedH # 
生成 更多 的 关联 规则 def rulesFromConseq freqSet H supportData 
br1 minConf = 0.7 m = len H 0 if 
len freqSet m + 1 Hmp1 = aprioriGen H m 
+ 1 Hmp1 = calcConf freqSet Hmp1 supportData br1 minConf 
if len Hmp1 1 rulesFromConseq freqSet Hmp1 supportData br1 minConf 
接下来 对 上述 的 程序 进行 测试 # test dataSet 
= loadData minSupport = 0.5 L suppData = apriori dataSet 
minSupport rules = generateRules L suppData minConf = 0.5 print 
rules 上述 程序 的 结果 表明 该 算法 在 小 
数据 集中 可以 实现 其中 更换 可信度 阈值 minConf 可以 
获得 不同 的 关联 规则 四 发现 毒蘑菇 的 特征 
上面 我们 已经 将 Apriori 算法 应用到 小 数据 集上 
在 本节 我们 将 算法 应用 到 真实 数据 上 
有时 我们 寻找 的 不是 频繁 项集/nr 而是 对 某些 
特定 的 有 规律 的 特征 在 本节 中 我们 
会 寻找 毒蘑菇 的 一些 公共 特征 从而 发现 哪些 
特征 是 毒蘑菇 特有 的 我们 从 UCI 数据库 中 
寻找 数据集 mushroom . dat 其中 第一 个 特征 表示 
有毒 或者 没毒 2 表示 有毒 下面 进行 测试 mushDatSet 
= line . split for line in open mushroom . 
dat . readlines L supportData = apriori mushDatSet minSupport = 
0.3 for item in L 1 if item . intersection 
2 print item 结果 如下 frozenset 2 59 frozenset 39 
2 frozenset 2 67 frozenset 2 34 frozenset 2 23 
frozenset 2 86 frozenset 76 2 frozenset 90 2 frozenset 
2 53 frozenset 93 2 frozenset 63 2 frozenset 2 
28 frozenset 2 85 frozenset 2 36 这样 就 可以 
发现 毒蘑菇 相关 的 特征 这 就是 我 对 该 
算法 的 理解 和 总结 难免 有错 还望 大家 不吝赐教 
~ 