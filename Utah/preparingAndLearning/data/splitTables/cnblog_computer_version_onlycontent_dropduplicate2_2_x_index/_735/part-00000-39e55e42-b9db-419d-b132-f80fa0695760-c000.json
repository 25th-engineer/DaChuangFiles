{"content2":"边缘检测时计算机视觉中的重要任务，边缘是像素与背景或周边区域不同的链，表达了图像中很多重要信息。噪声对边缘的影响图像中有噪声是在所难免的，也是非常正常的。而噪声没有一个准确的描述模型，所以很难利用噪声。一般来说，高斯模型是一个很好的噪声模型，也就是噪声各个幅值出现的概率服从高斯分布。将高斯噪声与图像叠加所形成的图像称为静态高斯噪声图像。有限差分对噪声的响应有限差分相当于是一个高通滤波器，会对高频信号进行相应，噪声以孤立点的形式出现，含有较多高频成分。高斯函数的傅里叶变换还是高斯函数。解决问题的办法是对图像进行平滑，后对平滑后的图像进行有限差分。差分 K**I高斯平滑G**I目标图像是K**G**I先计算K**G获得操作图像的模板将这个模板和图像卷积。高斯函数的模板不能太大，1σ的高斯模板需要5*5,如果是2σ的高斯模板则需要10*10，这会降低卷积操作的速度。边缘检测算法边缘含有图像的大量信息，边缘检测算法的三条要求信噪比——–对噪声的响应要低于对边缘的响应定位精度——最大响应在边缘处低误报率——在边缘处应只有一个最大值基于二阶导数的边缘检测Created with Raphaël 2.1.2开始高斯平滑求xy方向二阶导数并相加0点处既图像边缘结束clear all close all clc [a,b]=uigetfile('*'); pic=imread(a); g_pic=rgb2gray(pic); f = fspecial('gaussian',[5 5],1); img=imfilter(g_pic,f); DX=[0 0 0;1 -2 1;0 0 0]; DY=[0 1 0;0 -2 0;0 1 0]; DD=DX+DY; L_img=imfilter(img,DD); %搜索二阶导数最大值 A=size(L_img); BW=zeros(A); for i=2:A(1)-1 for j=2:A(2)-1 if L_img(i,j)>L_img(i+1,j)&&L_img(i,j)>L_img(i-1,j) BW(i,j)=1; elseif L_img(i,j)>L_img(i,j+1)&&L_img(i,j)>L_img(i,j-1) BW(i,j)=1; end end end subplot(2,1,1) imshow(g_pic,[]); subplot(2,1,2) imshow(BW,[]);写这个程序还是遇到了一点问题的，这里访问size,不能直接访问列，不能写成A（：，1）要写成A（1），A（2）。上面是matlab代码。对图片的检测结果如下图所示可以看出，这种方法的缺点是在角点处有断点，原因是基于二阶导数的边缘检测，在边缘方向剧烈改变时会有较差表现。二阶导数的响应又一个沿着边缘方向和垂直于边缘方向的响应组成。基于梯度的边缘检测为了克服基于导数的边缘检测和更好的提取角点，有人设计了这种基于梯度的边缘检测。这种方法的思想是边缘处于梯度方向最大值处，并且预计在沿着边缘梯度垂线方向出现下一个梯度点。和log的思想相比，canny利用了边缘梯度的信息，引入了方向性。并且抛弃了利用导数的数值判断编译的思想。这种思想是将图片看作二维函数，每个xy对应一个函数值。每个像素点都有梯度方向。Created with Raphaël 2.1.2开始求取梯度方向和梯度值找到梯度值最大的点沿着梯度方向搜索是否梯度值最大沿着垂直梯度方向搜索是否已找到整条边缘结束yesnoyesno梯度<∂f∂x,∂f∂y>版权声明：本文为博主原创文章，未经博主允许不得转载。"}
