{"content2":"计算机视觉—DoG和LoG算子\nbrycezou@163.com\n阅读本文，需要有一定的数字图像处理基础，否则不太容易明白数学公式想要传达的物理意义。希望通过仅此一篇文章就能让你理解图像处理中的高斯滤波（也叫高斯平滑、高斯模糊、高斯卷积）、DoG算子、LoG算子，以及它们之间的关系。下面先讲理论，再讲实际应用。在理论部分，一切语言都显得过于苍白，因此我只给出了最核心的、最简单的、最优美的公式，当然包括一些必要的推导过程。\n理 论 篇\n1、高斯函数\n在图像处理中，常用的二维高斯函数为\nG(x,y,σ)=12πσ2e−(x2+y2)/2σ2\nG(x,y,\\sigma)=\\frac{1}{2\\pi\\sigma^2}e^{-(x^2+y^2)/2\\sigma^2}\n2、DoG算子\nDoG\nDoG（\nDifference\nDifference\nof\nof\nGaussian\nGaussian ）算子定义为\nDoG=G(x,y,σ1)−G(x,y,σ2)\nDoG=G(x,y,\\sigma_1)−G(x,y,\\sigma_2)\n3、LoG算子\n拉普拉斯算子为\n∇2f=∂2f∂x2+∂2f∂y2\n\\nabla^2f=\\frac{\\partial^2f}{\\partial{x^2}}+\\frac{\\partial^2f}{\\partial{y^2}}\n对二维高斯函数应用拉普拉斯算子得\n∇2G=∂2G∂x2+∂2G∂y2=−2σ2+x2+y22πσ6e−(x2+y2)/2σ2\n\\nabla^2G=\\frac{\\partial^2G}{\\partial{x^2}}+\\frac{\\partial^2G}{\\partial{y^2}}= \\frac{-2\\sigma^2+x^2+y^2}{2\\pi\\sigma^6}e^{-(x^2+y^2)/2\\sigma^2}\nLoG\nLoG（\nLaplacian\nLaplacian\nof\nof\nGaussian\nGaussian ）算子定义为\nLoG=σ2∇2G\nLoG=\\sigma^2\\nabla^2G\n4、DoG和LoG的关系\n对二维高斯函数关于\nσ\n\\sigma 求一阶偏导数得\n∂G∂σ=−2σ2+x2+y22πσ5e−(x2+y2)/2σ2\n\\frac{\\partial G}{\\partial \\sigma}= \\frac{-2\\sigma^2+x^2+y^2}{2\\pi\\sigma^5}e^{-(x^2+y^2)/2\\sigma^2}\n不难发现\n∂G∂σ=σ∇2G\n\\frac{\\partial G}{\\partial \\sigma}=\\sigma\\nabla^2G\n在\nDoG\nDoG 算子中，令\nσ1=kσ2=kσ\n\\sigma_1=k\\sigma_2=k\\sigma，则\nDoG=G(x,y,kσ)−G(x,y,σ)\nDoG=G(x,y,k\\sigma)−G(x,y,\\sigma)\n进一步地\n∂G∂σ=limΔσ→0G(x,y,σ+Δσ)−G(x,y,σ)(σ+Δσ)−σ≈G(x,y,kσ)−G(x,y,σ)kσ−σ\n\\frac{\\partial G}{\\partial \\sigma}= \\lim_{\\Delta\\sigma\\to0}\\frac{G(x,y,\\sigma+\\Delta\\sigma)-G(x,y,\\sigma)}{(\\sigma+\\Delta\\sigma)-\\sigma}\\approx \\frac{G(x,y,k\\sigma)-G(x,y,\\sigma)}{k\\sigma-\\sigma}\n因此\nσ∇2G=∂G∂σ≈G(x,y,kσ)−G(x,y,σ)kσ−σ\n\\sigma\\nabla^2G=\\frac{\\partial G}{\\partial\\sigma}\\approx \\frac{G(x,y,k\\sigma)-G(x,y,\\sigma)}{k\\sigma-\\sigma}\n即\nG(x,y,kσ)−G(x,y,σ)≈(k−1)σ2∇2G\nG(x,y,k\\sigma)-G(x,y,\\sigma)\\approx(k-1)\\sigma^2\\nabla^2G\n这表明\n可以用\nDoG\nDoG 算子来近似\nLoG\nLoG 算子\n。\n应 用 篇\n1、计算高斯卷积模板\n#include <iostream> #include <math.h> using namespace std; #define PI 3.1415926 int main(int argc, char *argv[]) { double sigma = 1; int N = 2*ceil(3*sigma)+1; double *val = new double[N*N]; int R = N/2; for(int i = 0; i < N; i++) { for(int j = 0; j < N; j++) { double r = (i-R)*(i-R)+(j-R)*(j-R); double res = exp(-r/(2*sigma*sigma)); res = res/(2*PI*sigma*sigma); val[i*N+j] = res; } } delete []val; return 0; }\n下图就是该段代码生成的\n5x5\n5x5 的高斯模板\n在图像处理中，为了提升计算速度，通常会牺牲少部分计算精度，使用整数模板代替浮点数模板。常见的\n3x3\n3x3 和\n5x5\n5x5 整数模板为\n116⎡⎣⎢⎢121242121⎤⎦⎥⎥,1273⎡⎣⎢⎢⎢⎢⎢1474141626164726412674162616414741⎤⎦⎥⎥⎥⎥⎥\n\\frac{1}{16} \\left[\\begin{matrix}1 & 2 & 1\\\\2 & 4 & 2\\\\1 & 2 & 1\\end{matrix}\\right], \\frac{1}{273} \\left[\\begin{matrix}1 & 4 & 7 & 4 & 1\\\\4 & 16 & 26 & 16 & 4\\\\7 & 26 & 41 & 26 & 7\\\\4 & 16 & 26 & 16 & 4\\\\1 & 4 & 7 & 4 & 1\\end{matrix}\\right]\n2、快速计算高斯卷积\n由于高斯函数可以写成可分离的形式，因此可以采用可分离滤波器来实现加速。\n可分离滤波器，就是可以把一个多维的卷积转化成多个一维的卷积。\n具体到二维的高斯滤波，就是指先对行做一维卷积，再对列做一维卷积。这样就可以将计算复杂度从O(M*M*N*N)降到O(2*M*M*N)，M、N分别是图像和滤波器的窗口大小。\n3、DoG算子应用\n在理论上\nDoG(x,y,σ1,σ2)∗I(x,y)=G(x,y,σ1)∗I(x,y)−G(x,y,σ2)∗I(x,y)\nDoG(x,y,\\sigma_1,\\sigma_2)*I(x,y)=G(x,y,\\sigma_1)*I(x,y)-G(x,y,\\sigma_2)*I(x,y)\n因此，实际计算中，只需要先对输入图像作2个不同尺度的高斯平滑，然后将两幅图像相减，非常简单！\n4、公式推导——符号计算\n在理解算法原理的时候，难免要进行公式推导。事实上，本文涉及的公式，不全是作者自己推导出来的，例如，求偏导数的公式就是计算机辅助完成的，虽然偷了个懒，但可以快速验证自己的理解是否正确，效率挺高。常见的符号计算工具有MATLAB，但本人使用的是Mac，没装MATLAB，无意间发现有一个Python包\nSymPy\n可以进行符号计算，而且可以将结果导出为LaTeX格式，非常赞，强烈推荐！下面是一段示例代码\nfrom sympy import * x, y, s, pi, k = symbols('x,y,s,pi,k') G_0 = 1/(2*pi*s**2) * exp(-(x**2+y**2)/(2*s**2)) ff = diff(G_0, s, 1) gg = diff(G_0, x, 2) + diff(G_0, y, 2) print latex(together(ff)) print latex(together(gg))"}
