{"content2":"4.8   A Sample of Python Libraries Python库的样本\nPython has hundreds of third-party libraries, specialized software packages that extend the functionality of Python. NLTK is one such library. To realize the full power of Python programming, you should become familiar with several other libraries. Most of these will need to be manually installed on your computer.\nMatplotlib 绘图工具\nPython has some libraries that are useful for visualizing language data. The Matplotlib package supports sophisticated plotting functions with a MATLAB-style interface, and is available from http://matplotlib.sourceforge.net/ .\nSo far we have focused on textual presentation and the use of formatted print statements to get output lined up in columns. It is often very useful to display numerical data in graphical form, since this often makes it easier to detect patterns. For example, in Example 3.7 we saw a table of numbers showing the frequency of particular modal verbs in the Brown Corpus, classified by genre. The program in Example 4.13 presents the same information in graphical format. The output is shown in Figure 4.14 (a color figure in the graphical display).\ncolors = 'rgbcmyk' # red, green, blue, cyan, magenta, yellow, black\ndef bar_chart(categories, words, counts):\n\"Plot a bar chart showing counts for each word by category\"\nimport pylab\nind = pylab.arange(len(words))\nwidth = 1 / (len(categories) + 1)\nbar_groups = []\nfor c in range(len(categories)):\nbars = pylab.bar(ind+c*width, counts[categories[c]], width,\ncolor=colors[c % len(colors)])\nbar_groups.append(bars)\npylab.xticks(ind+width, words)\npylab.legend([b[0] for b in bar_groups], categories, loc='upper left')\npylab.ylabel('Frequency')\npylab.title('Frequency of Six Modal Verbs by Genre')\npylab.show()\n>>> genres = ['news', 'religion', 'hobbies', 'government', 'adventure']\n>>> modals = ['can', 'could', 'may', 'might', 'must', 'will']\n>>> cfdist = nltk.ConditionalFreqDist(\n...              (genre, word)\n...              for genre in genres\n...              for word in nltk.corpus.brown.words(categories=genre)\n...              if word in modals)\n...\n>>> counts = {}\n>>> for genre in genres:\n...     counts[genre] = [cfdist[genre][word] for word in modals]\n>>> bar_chart(genres, modals, counts)\nExample 4.13 (code_modal_plot.py):\nFigure 4.13: Frequency of Modals in Different Sections of the Brown Corpus\nFigure 4.14: Bar Chart（柱状图） Showing Frequency of Modals in Different Sections of Brown Corpus\nFrom the bar chart it is immediately obvious that may and must have almost identical relative frequencies. The same goes for could and might.\nIt is also possible to generate such data visualizations on the fly. For example, a web page with form input could permit visitors to specify search parameters, submit the form, and see a dynamically generated visualization. To do this we have to specify the Agg backend for matplotlib, which is a library for producing raster (pixel) images . Next, we use all the same PyLab methods as before, but instead of displaying the result on a graphical terminal using pylab.show(), we save it to a file using pylab.savefig() . We specify the filename and dpi, then print HTML markup that directs the web browser to load the file.\n>>> import matplotlib\n>>> matplotlib.use('Agg')\n>>> pylab.savefig('modals.png')\n>>> print 'Content-Type: text/html'\n>>> print\n>>> print '<html><body>'\n>>> print '<img src=\"modals.png\"/>'\n>>> print '</body></html>'\nNetworkX\nThe NetworkX package is for defining and manipulating structures consisting of nodes and edges, known as graphs. It is available from https://networkx.lanl.gov/ . NetworkX can be used in conjunction with Matplotlib to visualize networks, such as WordNet (the semantic network（语义网络） we introduced in Section 2.5). The program in Example 4.15 initializes an empty graph  then traverses the WordNet hypernym hierarchy adding edges to the graph . Notice that the traversal is recursive , applying the programming technique discussed in Section 4.7. The resulting display is shown in Figure 4.16.\nimport networkx as nx\nimport matplotlib\nfrom nltk.corpus import wordnet as wn\ndef traverse(graph, start, node):\ngraph.depth[node.name] = node.shortest_path_distance(start)\nfor child in node.hyponyms():\ngraph.add_edge(node.name, child.name)\ntraverse(graph, start, child)\ndef hyponym_graph(start):\nG = nx.Graph()\nG.depth = {}\ntraverse(G, start, start)\nreturn G\ndef graph_draw(graph):\nnx.draw_graphviz(graph,\nnode_size = [16 * graph.degree(n) for n in graph],\nnode_color = [graph.depth[n] for n in graph],\nwith_labels = False)\nmatplotlib.pyplot.show()\n>>> dog = wn.synset('dog.n.01')\n>>> graph = hyponym_graph(dog)\n>>> graph_draw(graph)\nExample 4.15 (code_networkx.py): Figure 4.15: Using the NetworkX and Matplotlib Libraries\nFigure 4.16: Visualization with NetworkX and Matplotlib: Part of the WordNet hypernym hierarchy is displayed, starting with dog.n.01 (the darkest node in the middle); node size is based on the number of children of the node, and color is based on the distance of the node from dog.n.01; this visualization was produced by the program in Example 4.15.\ncsv 逗号分隔值格式\nLanguage analysis work often involves data tabulations, containing information about lexical items, or the participants in an empirical study, or the linguistic features extracted from a corpus. Here's a fragment of a simple lexicon, in CSV format:\nsleep, sli:p, v.i, a condition of body and mind ...\nwalk, wo:k, v.intr, progress by lifting and setting down each foot ...\nwake, weik, intrans, cease to sleep\nWe can use Python's CSV library to read and write files stored in this format. For example, we can open a CSV file called lexicon.csv  and iterate over its rows :\n>>> import csv\n>>> input_file = open(\"lexicon.csv\", \"rb\")\n>>> for row in csv.reader(input_file):\n...     print row\n['sleep', 'sli:p', 'v.i', 'a condition of body and mind ...']\n['walk', 'wo:k', 'v.intr', 'progress by lifting and setting down each foot ...']\n['wake', 'weik', 'intrans', 'cease to sleep']\nEach row is just a list of strings. If any fields contain numerical data, they will appear as strings, and will have to be converted using int() or float().\nNumPy 基本的数值运算包，高级的有SciPy\nThe NumPy package provides substantial support for numerical processing in Python. NumPy has a multi-dimensional array object, which is easy to initialize and access:\n>>> from numpy import array\n>>> cube = array([ [[0,0,0], [1,1,1], [2,2,2]],\n...                [[3,3,3], [4,4,4], [5,5,5]],\n...                [[6,6,6], [7,7,7], [8,8,8]] ])\n>>> cube[1,1,1]\n4\n>>> cube[2].transpose()\narray([[6, 7, 8],\n[6, 7, 8],\n[6, 7, 8]])\n>>> cube[2,1:]\narray([[7, 7, 7],\n[8, 8, 8]])\nNumPy includes linear algebra functions. Here we perform singular value decomposition(奇异值分解) on a matrix, an operation used in latent semantic analysis（潜在语义分析） to help identify implicit concepts in a document collection.\n>>> from numpy import linalg\n>>> a=array([[4,0], [3,-5]])\n>>> u,s,vt = linalg.svd(a)\n>>> u\narray([[-0.4472136 , -0.89442719],\n[-0.89442719, 0.4472136 ]])\n>>> s\narray([ 6.32455532, 3.16227766])\n>>> vt\narray([[-0.70710678, 0.70710678],\n[-0.70710678, -0.70710678]])\nNLTK's clustering package（聚类包） nltk.cluster makes extensive use of NumPy arrays, and includes support for k-means clustering, Gaussian EM clustering, group average agglomerative clustering, and dendrogram plots. For details, type help(nltk.cluster).\nOther Python Libraries 其他的Python库\nThere are many other Python libraries, and you can search for them with the help of the Python Package Index http://pypi.python.org/ . Many libraries provide an interface to external software, such as relational databases (e.g. mysql-python) and large document collections (e.g. PyLucene). Many other libraries give access to file formats such as PDF, MSWord, and XML (pypdf, pywin32, xml.etree), RSS feeds (e.g. feedparser), and electronic mail (e.g. imaplib, email)."}
