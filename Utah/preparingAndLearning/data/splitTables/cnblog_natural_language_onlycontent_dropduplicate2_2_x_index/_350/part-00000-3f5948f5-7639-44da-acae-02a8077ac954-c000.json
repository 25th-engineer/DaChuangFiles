{"content2":"什么是解析？\n在自然语言的学习过程，个人一定都学过语法，比如句子能够用主语、谓语、宾语来表示。在自然语言的处理过程中。有很多应用场景都须要考虑句子的语法，因此研究语法解析变得很重要。\n语法解析有两个基本的问题，其一是句子语法在计算机中的表达与存储方法。以及语料数据集；其二是语法解析的算法。\n对于第一个问题，我们能够用树状结构图来表示，例如以下图所看到的。S表示句子；NP、VP、PP是名词、动词、介词短语（短语级别）；N、V、P各自是名词、动词、介词。\n实际存储的时候上述的树能够表示为(S (NP (N Boeing)) (VP (V is) (VP (V located) (PP (P in) (NP (N Seattle))))))。互联网上已经有成熟的、手工标注的语料数据集。比如The Penn Treebank Project （Penn Treebank II Constituent Tags）。\n对于第二个问题，我们须要有合适的算法来处理。这也是我们本章将要讨论的内容。\n上下文无关语法（Context-Free Grammer）\n为了生成句子的语法树，我们能够定义例如以下的一套上下文无关语法。\n1）N表示一组非叶子节点的标注。比如{S、NP、VP、N...}\n2）Σ表示一组叶子结点的标注。比如{boeing、is...}\n3）R表示一组规则，每条规则能够表示为X->Y1Y2...Yn，X∈N。Yi∈(N∪Σ)\n4）S表示语法树開始的标注\n举例来说，语法的一个语法子集能够表示为下图所看到的。当给定一个句子时，我们便能够依照从左到右的顺序来解析语法。比如。句子the man sleeps就能够表示为(S (NP (DT the) (NN man)) (VP sleeps))。\n这种上下文无关的语法能够非常easy的推导出一个句子的语法结构，可是缺点是推导出的结构可能存在二义性。比如以下两张图中的语法树都能够表示同一个句子。\n常见的二义性问题有：1）单词的不同词性，如can一般表示“能够”这个情态动词。有时表示罐子；2）介词短语的作用范围。如VP PP PP这种结构，第二个介词短语可能形容VP，也可能形容第一个PP；3）连续的名字，如NN NN NN。\n概率分布的上下文无关语法（Probabilistic Context-Free Grammar）\n因为语法的解析存在二义性，我们就须要找到一种方法从多种可能的语法树种找出最可能的一棵树。一种常见的方法既是PCFG （Probabilistic Context-Free Grammar）。例如以下图所看到的。除了常规的语法规则以外，我们还对每一条规则赋予了一个概率。\n对于每一棵生成的语法树，我们将当中所以规则的概率的乘积作为语法树的出现概率。\n综上所述，当我们或得多颗语法树时，我们能够分别计算每颗语法树的概率p(t)。出现概率最大的那颗语法树就是我们希望得到的结果，即arg max p(t)。\n训练算法\n我们已经定义了语法解析的算法，而这个算法依赖于CFG中对于N、Σ、R、S的定义以及PCFG中的p(x)。上文中我们提到了Penn Treebank通过手工的方法已经提供了一个很大的语料数据集，我们的任务就是从语料库中训练出PCFG所须要的參数。\n1）统计出语料库中全部的N与Σ；\n2）利用语料库中的全部规则作为R；\n3）针对每一个规则A -> B。从语料库中估算p(x) = p(A -> B) / p(A)；\n在CFG的定义的基础上，我们又一次定义一种叫Chomsky的语法格式。\n这样的格式要求每条规则仅仅能是X -> Y1 Y2或者X -> Y的格式。实际上Chomsky语法格式保证生产的语法树总是二叉树的格式，同一时候随意一棵语法树总是可以转化成Chomsky语法格式。\n语法树预測算法\n如果我们已经有一个PCFG的模型，包括N、Σ、R、S、p(x)等參数，而且语法树总数Chomsky语法格式。当输入一个句子x1, x2, ... , xn时。我们要怎样计算句子相应的语法树呢？\n第一种方法是暴力遍历的方法。每一个单词x可能有m = len(N)种取值，句子长度是n，每种情况至少存在n个规则，所以在时间复杂度O(m*n*n)的情况下。我们能够推断出全部可能的语法树并计算出最佳的那个。\n另外一种方法当然是动态规划，我们定义w[i, j, X]是第i个单词至第j个单词由标注X来表示的最大概率。直观来讲。比如xi, xi+1, ... , xj，当X=PP时。子树可能是多种解释方式。如(P NP)或者(PP PP)。可是w[i, j, PP]代表的是继续往上一层递归时，我们仅仅选择当前概率最大的组合方式。特殊情况下。w[i, i, X] = p(X -> xi)。因此，动态规划的方程能够表示为w[i, j, X] = max (p(X -> Y Z) * w(i, s, Y) * w(s+1, j, Z))。关于动态规划方法。leetcode里有不少案例能够说明。\n语法解析依照上述的算法过程便完毕了。虽说PCFG也有一些缺点，比如：1）缺乏词法信息。2）连续短语（如名词、介词）的处理等。但整体来讲它给语法解析提供了一种很有效的实现方法。\n版权声明：本文博主原创文章。博客，未经同意不得转载。"}
