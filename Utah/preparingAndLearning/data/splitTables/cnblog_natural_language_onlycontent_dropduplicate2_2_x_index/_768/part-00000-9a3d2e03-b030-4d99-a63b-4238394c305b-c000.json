{"content2":"转载请注明出处“\n一块努力的牛皮糖\n”：\nhttp://www.cnblogs.com/yuxc/\n新手上路，翻译不恰之处，恳请指出，不胜感谢\nUpdated log\n1st 2011.8.6\n3.2 Strings: Text Processing at the Lowest Level  字符串：最底层的文本处理\nPS:个人认为这部分很重要，字符串处理是NLP里最基本的部分，各位童鞋好好看，老鸟略过...\nIt’s time to study a fundamental data type that we’ve been studiously（故意地） avoiding so far. In earlier chapters we focused on a text as a list of words. We didn’t look too closely at words and how they are handled in the programming language. By using NLTK’s corpus interface we were able to ignore the files that these texts had come from. The contents of a word, and of a file, are represented by programming languages as a fundamental data type known as a string. In this section, we explore strings in detail, and show the connection between strings, words, texts, and files.\nBasic Operations with Strings 字符串的基本操作\nStrings are specified using single quotes ①or double quotes②, as shown in the following code example. If a string contains a single quote, we must backslash-escape the quote③ so Python knows a literal quote character is intended, or else put the string in double quotes②. Otherwise, the quote inside the string④will be interpreted as a close quote, and the Python interpreter will report a syntax error:\n>>> monty = 'Monty Python' ①\n>>> monty\n'Monty Python'\n>>> circus = \"Monty Python's Flying Circus\" ②\n>>> circus\n\"Monty Python's Flying Circus\"\n>>> circus = 'Monty Python\\'s Flying Circus' ③\n>>> circus\n\"Monty Python's Flying Circus\"\n>>> circus = 'Monty Python's Flying Circus'  ④\nFile \"<stdin>\", line 1\ncircus = 'Monty Python's Flying Circus'\n^\nSyntaxError: invalid syntax\nSometimes strings go over several lines. Python provides us with various ways of entering them. In the next example, a sequence of two strings is joined into a single string. We need to use backslash ① or parentheses ② so that the interpreter knows that the statement is not complete after the first line.\n>>> couplet = \"Shall I compare thee to a Summer's day?\"\\\n...           \"Thou are more lovely and more temperate:\" ①\n>>> print couplet\nShall I compare thee to a Summer's day?Thou are more lovely and more temperate:\n>>> couplet = (\"Rough winds do shake the darling buds of May,\"\n...           \"And Summer's lease hath all too short a date:\")  ②\n>>> print couplet\nRough winds do shake the darling buds of May,And Summer's lease hath all too short a date:\nUnfortunately these methods do not give us a newline between the two lines of the sonnet(十四行诗). Instead, we can use a triple-quoted string as follows:\n>>> couplet = \"\"\"Shall I compare thee to a Summer's day?\n... Thou are more lovely and more temperate:\"\"\"\n>>> print couplet\nShall I compare thee to a Summer's day?\nThou are more lovely and more temperate:\n>>> couplet = '''Rough winds do shake the darling buds of May,\n... And Summer's lease hath all too short a date:'''\n>>> print couplet\nRough winds do shake the darling buds of May,\nAnd Summer's lease hath all too short a date:\nNow that we can define strings, we can try some simple operations on them. First let’s look at the + operation, known as concatenation ① . It produces a new string that is a copy of the two original strings pasted together end-to-end（首尾相连）. Notice that concatenation doesn’t do anything clever like insert a space between the words. We can even multiply strings②:\n>>> 'very' + 'very' + 'very' ①\n'veryveryvery'\n>>> 'very' * 3 ②\n'veryveryvery'\nYour Turn: Try running the following code, then try to use your understanding of the string + and * operations to figure out how it works. Be careful to distinguish between the string ' ', which is a single whitespace character, and '', which is the empty string.\n>>> a = [1, 2, 3, 4, 5, 6, 7, 6, 5, 4, 3, 2, 1]\n>>> b = [' ' * 2 * (7 - i) + 'very' * i for i in a]\n>>> for line in b:\n...     print b\nWe’ve seen that the addition and multiplication operations apply to strings, not just numbers. However, note that we cannot use subtraction or division with strings:\n>>> 'very' - 'y'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for -: 'str' and 'str'\n>>> 'very' / 2\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for /: 'str' and 'int'\nThese error messages are another example of Python telling us that we have got our data types in a muddle（困惑）. In the first case, we are told that the operation of subtraction (i.e., -) cannot apply to objects of type str (strings), while in the second, we are told that division cannot take str and int as its two operands.\nPrinting Strings 打印字符串\nSo far, when we have wanted to look at the contents of a variable or see the result of a calculation, we have just typed the variable name into the interpreter. We can also see the contents of a variable using the print statement:\n>>> print monty\nMonty Python\nNotice that there are no quotation marks this time. When we inspect a variable by typing its name in the interpreter, the interpreter prints the Python representation of its value. Since it’s a string, the result is quoted. However, when we tell the interpreter to print the contents of the variable, we don’t see quotation characters, since there are none inside the string.\nThe print statement allows us to display more than one item on a line in various ways,\nas shown here:\n>>> grail = 'Holy Grail'\n>>> print monty + grail\nMonty PythonHoly Grail\n>>> print monty, grail\nMonty Python Holy Grail\n>>> print monty, \"and the\", grail   #会在词之间自动添加空格\nMonty Python and the Holy Grail\nAccessing Individual Characters 访问单独的字符\nAs we saw in Section 1.2 for lists, strings are indexed, starting from zero. When we index a string, we get one of its characters (or letters). A single character is nothing special—it’s just a string of length 1.\n>>> monty[0]\n'M'\n>>> monty[3]\n't'\n>>> monty[5]\n' '\nAs with lists, if we try to access an index that is outside of the string, we get an error:\n>>> monty[20]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in ?\nIndexError: string index out of range\nAgain as with lists, we can use negative indexes for strings, where -1 is the index of the last character①. Positive and negative indexes give us two ways to refer to any position in a string. In this case, when the string had a length of 12, indexes 5 and -7 both refer to the same character (a space). (Notice that 5 = len(monty) - 7.)\n>>> monty[-1]  #注意 monty='Monty Python' 我刚还在想就5个字符啊…\n'n'\n>>> monty[5]\n' '\n>>> monty[-7]\n' '\nWe can write for loops to iterate over the characters in strings. This print statement ends with a trailing comma, which is how we tell Python not to print a newline at the end.\n>>> sent = 'colorless green ideas sleep furiously'\n>>> for char in sent:\n...     print char,\n...\nc o l o r l e s s   g r e e n   i d e a s   s l e e p   f u r i o u s l y\nWe can count individual characters as well. We should ignore the case distinction by normalizing everything to lowercase, and filter out non-alphabetic characters:\n>>> from nltk.corpus import gutenberg\n>>> raw = gutenberg.raw('melville-moby_dick.txt')\n>>> fdist = nltk.FreqDist(ch.lower() for ch in raw if ch.isalpha())\n>>> fdist.keys()\n['e', 't', 'a', 'o', 'n', 'i', 's', 'h', 'r', 'l', 'd', 'u', 'm', 'c', 'w',\n'f', 'g', 'p', 'b', 'y', 'v', 'k', 'q', 'j', 'x', 'z']\nThis gives us the letters of the alphabet, with the most frequently occurring letters listed first (this is quite complicated and we’ll explain it more carefully later). You might like to visualize the distribution using fdist.plot(). The relative character frequencies of a text can be used in automatically identifying the language of the text.\nAccessing Substrings 访问子字符串\nA substring is any continuous section of a string that we want to pull out（取出） for further processing. We can easily access substrings using the same slice notation we used for lists (see Figure 3-2). For example, the following code accesses the substring starting at index 6, up to (but not including) index 10:\n>>> monty[6:10]\n'Pyth'\nFigure 3-2. String slicing字符串切片: The string Monty Python is shown along with its positive and negative indexes; two substrings are selected using “slice” notation. The slice [m,n] contains the characters from position m through n-1.\nHere we see the characters are 'P', 'y', 't', and 'h', which correspond to monty[6] ...monty[9] but not monty[10]. This is because a slice starts at the first index but finishes one before the end index.\nWe can also slice with negative indexes—the same basic rule of starting from the start index and stopping one before the end index applies; here we stop before the space character.\n>>> monty[-12:-7]\n'Monty'\nAs with list slices, if we omit the first value, the substring begins at the start of the string.\nIf we omit the second value, the substring continues to the end of the string:\n>>> monty[:5]\n'Monty'\n>>> monty[6:]\n'Python'\nWe test if a string contains a particular substring using the in operator, as follows:\n>>> phrase = 'And now for something completely different'\n>>> if 'thing' in phrase:\n...     print 'found \"thing\"'\nfound \"thing\"\nWe can also find the position of a substring within a string, using find():\n>>> monty.find('Python')\n6\nYour Turn: Make up a sentence and assign it to a variable, e.g., sent = 'my sentence...'. Now write slice expressions to pull out individual words. (This is obviously not a convenient way to process the words of a text!)\nMore Operations on Strings 更多的字符串操作\nPython has comprehensive（全面的）support for processing strings. A summary, including some operations we haven’t seen yet, is shown in Table 3-2. For more information on strings, type help(str) at the Python prompt.\nTable 3-2. Useful string methods: Operations on strings in addition to the string tests shown in Table 1-4; all methods produce a new string or list\nMethod             　　　　　　　　 Functionality\ns.find(t)              Index of first instance of string t inside s (-1 if not found)\ns.rfind(t)             Index of last instance of string t inside s (-1 if not found)\ns.index(t)            Like s.find(t), except it raises ValueError if not found\ns.rindex(t)           Like s.rfind(t), except it raises ValueError if not found\ns.join(text)          Combine the words of the text into a string using s as the glue\ns.split(t)             Split s into a list wherever a t is found (whitespace by default)\ns.splitlines()        Split s into a list of strings, one per line\ns.lower()             A lowercased version of the string s\ns.upper()             An uppercased version of the string s\ns.titlecase()         A titlecased version of the string s\ns.strip()               A copy of s without leading or trailing whitespace\ns.replace(t, u)      Replace instances of t with u inside s\nThe Difference Between Lists and Strings 列表和字符串之间的不同\nStrings and lists are both kinds of sequence. We can pull them apart by indexing and slicing them, and we can join them together by concatenating them. However, we can not join strings and lists:\n>>> query = 'Who knows?'\n>>> beatles = ['John', 'Paul', 'George', 'Ringo']\n>>> query[2]\n'o'\n>>> beatles[2]\n'George'\n>>> query[:2]\n'Wh'\n>>> beatles[:2]\n['John', 'Paul']\n>>> query + \" I don't\"\n\"Who knows? I don't\"\n>>> beatles + 'Brian'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: can only concatenate list (not \"str\") to list\n>>> beatles + ['Brian']\n['John', 'Paul', 'George', 'Ringo', 'Brian']\nWhen we open a file for reading into a Python program, we get a string corresponding to the contents of the whole file. If we use a for loop to process the elements of this string, all we can pick out （挑选出）are the individual characters—we don’t get to choose the granularity. By contrast, the elements of a list can be as big or small as we like: for example, they could be paragraphs, sentences, phrases, words, characters. So lists have the advantage that we can be flexible about the elements they contain, and correspondingly flexible about any downstream（后阶段的） processing. Consequently, one of the first things we are likely to do in a piece of NLP code is tokenize a string into a list of strings (Section 3.7). Conversely, when we want to write our results to a file, or to a terminal, we will usually format them as a string (Section 3.9). Lists and strings do not have exactly the same functionality. Lists have the added power that you can change their elements:\n>>> beatles[0] = \"John Lennon\"\n>>> del beatles[-1]\n>>> beatles\n['John Lennon', 'Paul', 'George']\nOn the other hand, if we try to do that with a string—changing the 0th character in query to 'F'—we get:\n>>> query[0] = 'F'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in ?\nTypeError: object does not support item assignment\nThis is because strings are immutable（不可变的）: you can’t change a string once you have created it. However, lists are mutable, and their contents can be modified at any time. As a result, lists support operations that modify the original value rather than producing a new value.\nYour Turn: Consolidate your knowledge of strings by trying some of the exercises on strings at the end of this chapter."}
