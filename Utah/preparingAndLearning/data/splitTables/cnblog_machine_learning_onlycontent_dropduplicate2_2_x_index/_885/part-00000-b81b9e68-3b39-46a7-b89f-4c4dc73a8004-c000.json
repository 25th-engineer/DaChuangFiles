{"content2":"首先先来讲讲闲话\n如果让你现在去搞机器学习，你会去吗？不会的话是因为你对这方面不感兴趣，还是因为你觉得这东西太难了，自己肯定学不来？如果你觉的太难了，很好，相信看完这篇文章，你就会有胆量踏入机器学习这一领域。\n机器学习(Machine-Learning)，一个在才学一年编程的人看来十分高大尚的东西，不知不觉就接触了它。暑假的时候表哥给我布置了任务，在github上有一篇DeepLearningFlappyBird，他当时要我一天之内先让这段代码跑起来，然后第二天再把这段代码翻译成C++的.......wtf？？？我当时一脸懵逼，一个才学编程一年不到的，C和C++的水平也就差不多是大学课堂教完后的那种，跑起来可能还算容易，但要翻译？！！   饶了我吧  orz。。。当时配了一天的环境，到那天晚上快12点了，终于跑起来了。然后到了第二天，我先去查了查tensorflow，opencv3在VS上使用，发现根本搞不定。。。我电脑上装的是VS2013，里面只有32位的，emmmm。。得下个VS2017，看了看电脑空间，不够了！好的，放弃，以后有空闲得慌了再来搞吧。。。。\n前几天开学了，还没什么事干，突然就想到机器学习了（其实dalao提到了感知机这东西），就试着去做了做，也就当个入门吧。\n再来聊聊机器学习\n机器学习说白了跟人类学习是一样的，只不过机器可以无止境的学习，并且，机器学习时完全不需要懂什么原理，只要知道怎么去实现就行。就如Alpha Go，你们觉得它懂得棋理吗？我觉得肯定不懂，但通过对无数的棋谱的学习，让人觉得它肯定掌握了围棋的真谛。\n机器学习的标准范式表达\n对于一个Task及其Performance的度量方法，给出特定的Algorithm，能够通过利用Experience Data不断提高在该Task上的\nPerformance的方法，就称为机器学习。\n其实这个定义就是“学习”的全部含义，这个事情按照机器的思路来做，就是机器学习\n说白了，只要算法合理，每次学习都能有提高，机器有足够的运算能力，就能将机器的能力达到极致从而超越人类。机器学习的本质就是建立（\"数据\"——\"认知\"）关系库。\n下面就来讲讲感知机\n先扯扯定义：感知机（perceptron）是二分类的线性分类模型，输入为实例的特征向量，输出为实例的类别（取+1和-1）。感知机对应于输入空间中将实例划分为两类的分离超平面。感知机旨在求出该超平面，为求得超平面导入了基于误分类的损失函数，利用梯度下降法 对损失函数进行最优化（最优化）。感知机的学习算法具有简单而易于实现的优点，分为原始形式和对偶形式。感知机预测是用学习得到的感知机模型对新的实例进行预测的，因此属于判别模型。感知机由Rosenblatt于1957年提出的，是神经网络和支持向量机的基础。\n拿二维平面举例，\n看这张图，很明显，直线没有将红蓝点完全分开在两个区域，我们可以将其称为错误的直线，感知机要做的，就是根据各点坐标，将错误的直线纠正为正确的，这样得到的直线就是训练的结果。\n说了这么多，要怎么实现呢？　　看下面的流程图\n/* * 判断所有点的位置关系,进行分类 */ public boolean classify() { boolean flag = false; while (!flag) { for (int i = 0; i < arrayList.size(); i++) { if (Anwser(arrayList.get(i)) <= 0) { Update(arrayList.get(i)); break; } if (i + 1 == arrayList.size()) { flag = true; } } } return true; }\n/* * 点乘返回sum */ private double Dot(double[] w, double[] x) { double sum = 0; for (int i = 0; i < x.length; i++) { sum += w[i] * x[i]; } return sum; } /* * 返回函数计算的值 */ private double Anwser(Point point) { System.out.println(Arrays.toString(w)); System.out.println(b); return point.y * (Dot(w, point.x) + b); }\n如果还有疑问，那可能就是w与b怎么修改了，我们会定义一个变量η（0≤η≤1）作为步长，在统计学是中成为学习速率。步长越大，梯度下降的速度越快，更能接近极小点。如果步长过大，有可能导致跨过极小点，导致函数发散；如果步长过小，有可能会耗很长时间才能达到极小点。默认为1\n对于wi   wi+=η*y*xi\n对于b      b+=η*y\npublic void Update(Point point) { for (int i = 0; i < w.length; i++) { w[i] += eta * point.y * point.x[i]; } b += eta * point.y; return; }\n这样，我们就可以完成成w、b的更新了。\n将上面的步骤组合起来，就可以实现感知机了。\n谈谈自己的想法\n写了这个感知机后，发现机器学习并不是想象当中那么难，其实只要知道怎么去算就可以了（目前比较浅显的理解，可能我还没接触到难的地方），而且Python中，有关机器学习的库可以说是很完善了，如果熟悉了这些库的用法，即使不懂算法，也时能用这些库来做开发的，要知道算法岗和开发岗还是不一样的\n这是我选取的测试用例及结果\n1 Point p1 = new Point(new double[] { 0, 0, 0, 1 }, -1); 2 Point p2 = new Point(new double[] { 1, 0, 0, 0 }, 1); 3 Point p3 = new Point(new double[] { 2, 1, 0, 0 }, 1); 4 Point p4 = new Point(new double[] { 2, 1, 0, 1 }, -1);\n[0.0, 0.0, 0.0, 0.0] 0.0 [0.0, 0.0, 0.0, -1.0] -1.0 [0.0, 0.0, 0.0, -1.0] -1.0 [1.0, 0.0, 0.0, -1.0] 0.0 [1.0, 0.0, 0.0, -1.0] 0.0 [1.0, 0.0, 0.0, -1.0] 0.0 [1.0, 0.0, 0.0, -1.0] 0.0 [-1.0, -1.0, 0.0, -2.0] -1.0 [-1.0, -1.0, 0.0, -2.0] -1.0 [0.0, -1.0, 0.0, -2.0] 0.0 [0.0, -1.0, 0.0, -2.0] 0.0 [1.0, -1.0, 0.0, -2.0] 1.0 [1.0, -1.0, 0.0, -2.0] 1.0 [1.0, -1.0, 0.0, -2.0] 1.0 [1.0, -1.0, 0.0, -2.0] 1.0 [-1.0, -2.0, 0.0, -3.0] 0.0 [-1.0, -2.0, 0.0, -3.0] 0.0 [0.0, -2.0, 0.0, -3.0] 1.0 [0.0, -2.0, 0.0, -3.0] 1.0 [0.0, -2.0, 0.0, -3.0] 1.0 [2.0, -1.0, 0.0, -3.0] 2.0 [2.0, -1.0, 0.0, -3.0] 2.0 [2.0, -1.0, 0.0, -3.0] 2.0 [2.0, -1.0, 0.0, -3.0] 2.0 [0.0, -2.0, 0.0, -4.0] 1.0 [0.0, -2.0, 0.0, -4.0] 1.0 [0.0, -2.0, 0.0, -4.0] 1.0 [2.0, -1.0, 0.0, -4.0] 2.0 [2.0, -1.0, 0.0, -4.0] 2.0 [2.0, -1.0, 0.0, -4.0] 2.0 [2.0, -1.0, 0.0, -4.0] 2.0 [0.0, -2.0, 0.0, -5.0] 1.0 [0.0, -2.0, 0.0, -5.0] 1.0 [0.0, -2.0, 0.0, -5.0] 1.0 [2.0, -1.0, 0.0, -5.0] 2.0 [2.0, -1.0, 0.0, -5.0] 2.0 [2.0, -1.0, 0.0, -5.0] 2.0 [2.0, -1.0, 0.0, -5.0] 2.0 [0.0, -2.0, 0.0, -6.0] 1.0 [0.0, -2.0, 0.0, -6.0] 1.0 [0.0, -2.0, 0.0, -6.0] 1.0 [2.0, -1.0, 0.0, -6.0] 2.0 [2.0, -1.0, 0.0, -6.0] 2.0 [2.0, -1.0, 0.0, -6.0] 2.0 [2.0, -1.0, 0.0, -6.0] 2.0"}
