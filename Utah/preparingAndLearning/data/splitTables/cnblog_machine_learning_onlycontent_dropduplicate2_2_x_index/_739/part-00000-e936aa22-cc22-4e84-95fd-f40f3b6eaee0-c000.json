{"content2":"目录\n线性代数\n一、基本知识\n二、向量操作\n三、矩阵运算\n概率论与随机过程\n一、概率与分布\n1.1 条件概率与独立事件\n1.2 联合概率分布\n二、期望\n三、方差\n3.1 方差\n3.2 协方差与相关系数\n3.3 协方差矩阵\n四、大数定律及中心极限定理\n4.1 切比雪夫不等式\n4.2 大数定理\n4.3 中心极限定理\n五、不确定性来源\n六、常见概率分布\n6.1 均匀分布\n6.2 二项分布\n6.3 高斯分布\n6.4 指数分布\n6.5 拉普拉斯分布\n6.6 狄拉克分布\n6.7 多项式分布与狄里克雷分布\n6.8 混合概率分布\n七、先验分布与后验分布\n八、测度论\n九、信息论\n数值计算\n一、数值稳定性\n1.1 近似误差\n1.2 softmax 函数\n二、Conditioning\n三、梯度下降法\n四、海森矩阵\n4.1 二阶导数\n4.2 海森矩阵\n4.3 海森矩阵与学习率\n4.4 驻点与全局极小点\n四、牛顿法\n五、拟牛顿法\n5.1 原理\n5.2 DFP 算法\n5.2 BFGS 算法\n5.3 Broyden 类算法\n六、 约束优化\n6.1 原理\n6.2 KKT 方法\n线性代数\n一、基本知识\n本文中所有的向量都是列向量的形式：\n\\[\\mathbf{\\vec x}=(x_1,x_2,\\cdots,x_n)^T=\\begin{bmatrix}x_1\\\\x_2\\\\ \\vdots \\\\x_n\\end{bmatrix}\\] 本书中所有的矩 \\(\\mathbf X\\in \\mathbb R^{m\\times n}\\) 都表示为：\n\\[\\mathbf X = \\begin{bmatrix} x_{1,1}&x_{1,2}&\\cdots&x_{1,n}\\\\ x_{2,1}&x_{2,2}&\\cdots&x_{2,n}\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ x_{m,1}&x_{m,2}&\\cdots&x_{m,n}\\\\ \\end{bmatrix}\\] 简写为 \\((x_{i,j})_{m\\times n}\\) 或 \\([x_{i,j}]_{m\\times n}\\) 。\n矩阵的F范数：设矩 \\(\\mathbf A=(a_{i,j})_{m\\times n}\\) ，则其F范数为 \\(||\\mathbf A||_F=\\sqrt{\\sum_{i,j}a_{i,j}^{2}}\\) 。\n它是向量 \\(L_2\\) 范数的推广。\n矩阵的迹：设矩 \\(\\mathbf A=(a_{i,j})_{m\\times n}\\) ， $ \\mathbf A$ 的迹为 \\(tr(\\mathbf A)=\\sum_{i}a_{i,i}\\) 。\n迹的性质有：\n\\(\\mathbf A\\) 的F 范数等 \\(\\mathbf A\\mathbf A^T\\) 的迹的平方根 \\(||\\mathbf A||_F=\\sqrt{tr(\\mathbf A \\mathbf A^{T})}\\) 。\n\\(\\mathbf A\\) 的迹等 \\(\\mathbf A^T\\) 的迹 \\(tr(\\mathbf A)=tr(\\mathbf A^{T})\\) 。\n交换律：假设 \\(\\mathbf A\\in \\mathbb R^{m\\times n},\\mathbf B\\in \\mathbb R^{n\\times m}\\) ，则有 \\(tr(\\mathbf A\\mathbf B)=tr(\\mathbf B\\mathbf A)\\) 。\n结合律 \\(tr(\\mathbf A\\mathbf B\\mathbf C)=tr(\\mathbf C\\mathbf A\\mathbf B)=tr(\\mathbf B\\mathbf C\\mathbf A)\\) 。\n二、向量操作\n一组向 \\(\\mathbf{\\vec v}_1,\\mathbf{\\vec v}_2,\\cdots,\\mathbf{\\vec v}_n\\) 是线性相关的：指存在一组不全为零的实 \\(a_1,a_2,\\cdots,a_n\\) ，使得 \\(\\sum_{i=1}^{n}a_i\\mathbf{\\vec v}_i=\\mathbf{\\vec 0}\\) 。\n一组向 \\(\\mathbf{\\vec v}_1,\\mathbf{\\vec v}_2,\\cdots,\\mathbf{\\vec v}_n\\) 是线性无关的，当且仅 \\(a_i=0,i=1,2,\\cdots,n\\) 时，才有 \\(\\sum_{i=1}^{n}a_i\\mathbf{\\vec v}_i=\\mathbf{\\vec 0}\\) 。\n一个向量空间所包含的最大线性无关向量的数目，称作该向量空间的维数。\n三维向量的点积 \\(\\mathbf{\\vec u}\\cdot\\mathbf{\\vec v} =u _xv_x+u_yv_y+u_zv_z = |\\mathbf{\\vec u}| | \\mathbf{\\vec v}| \\cos(\\mathbf{\\vec u},\\mathbf{\\vec v})\\) 。\n三维向量的叉积：\n\\[\\mathbf{\\vec w}=\\mathbf{\\vec u}\\times \\mathbf{\\vec v}=\\begin{bmatrix}\\mathbf{\\vec i}& \\mathbf{\\vec j}&\\mathbf{\\vec k}\\\\ u_x&u_y&u_z\\\\ v_x&v_y&v_z\\\\ \\end{bmatrix}\\] 其 \\(\\mathbf{\\vec i}, \\mathbf{\\vec j},\\mathbf{\\vec k}\\) 分别 \\(x,y,z\\) 轴的单位向量。\n\\[\\mathbf{\\vec u}=u_x\\mathbf{\\vec i}+u_y\\mathbf{\\vec j}+u_z\\mathbf{\\vec k},\\quad \\mathbf{\\vec v}=v_x\\mathbf{\\vec i}+v_y\\mathbf{\\vec j}+v_z\\mathbf{\\vec k}\\]\n$\\mathbf{\\vec u} $ 和 \\(\\mathbf{\\vec v}\\) 的叉积垂直于 \\(\\mathbf{\\vec u},\\mathbf{\\vec v}\\) 构成的平面，其方向符合右手规则。\n叉积的模等于 \\(\\mathbf{\\vec u},\\mathbf{\\vec v}\\) 构成的平行四边形的面积\n\\(\\mathbf{\\vec u}\\times \\mathbf{\\vec v}=-\\mathbf{\\vec v}\\times \\mathbf{\\vec u}\\)\n$\\mathbf{\\vec u}\\times( \\mathbf{\\vec v} \\times \\mathbf{\\vec w})=(\\mathbf{\\vec u}\\cdot \\mathbf{\\vec w})\\mathbf{\\vec v}-(\\mathbf{\\vec u}\\cdot \\mathbf{\\vec v})\\mathbf{\\vec w} $\n三维向量的混合积：\n\\[[\\mathbf{\\vec u} \\;\\mathbf{\\vec v} \\;\\mathbf{\\vec w}]=(\\mathbf{\\vec u}\\times \\mathbf{\\vec v})\\cdot \\mathbf{\\vec w}= \\mathbf{\\vec u}\\cdot (\\mathbf{\\vec v} \\times \\mathbf{\\vec w})\\\\ =\\begin{vmatrix} u_x&u_y&u_z\\\\ v_x&v_y&v_z\\\\ w_x&w_y&w_z \\end{vmatrix} =\\begin{vmatrix} u_x&v_x&w_x\\\\ u_y&v_y&w_y\\\\ u_z&v_z&w_z\\end{vmatrix} \\] 其物理意义为： \\(\\mathbf{\\vec u} ,\\mathbf{\\vec v} ,\\mathbf{\\vec w}\\) 为三个棱边所围成的平行六面体的体积。 \\(\\mathbf{\\vec u} ,\\mathbf{\\vec v} ,\\mathbf{\\vec w}\\) 构成右手系时，该平行六面体的体积为正号。\n两个向量的并矢：给定两个向 \\(\\mathbf {\\vec x}=(x_1,x_2,\\cdots,x_n)^{T}, \\mathbf {\\vec y}= (y_1,y_2,\\cdots,y_m)^{T}\\) ，则向量的并矢记作：\n\\[\\mathbf {\\vec x}\\mathbf {\\vec y} =\\begin{bmatrix}x_1y_1&x_1y_2&\\cdots&x_1y_m\\\\ x_2y_1&x_2y_2&\\cdots&x_2y_m\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ x_ny_1&x_ny_2&\\cdots&x_ny_m\\\\ \\end{bmatrix}\\] 也记 \\(\\mathbf {\\vec x}\\otimes\\mathbf {\\vec y}\\) 或 \\(\\mathbf {\\vec x} \\mathbf {\\vec y}^{T}\\) 。\n三、矩阵运算\n给定两个矩 \\(\\mathbf A=(a_{i,j}) \\in \\mathbb R^{m\\times n},\\mathbf B=(b_{i,j}) \\in \\mathbb R^{m\\times n}\\) ，定义：\n阿达马积Hadamard product（又称作逐元素积）：\n\\[\\mathbf A \\circ \\mathbf B =\\begin{bmatrix} a_{1,1}b_{1,1}&a_{1,2}b_{1,2}&\\cdots&a_{1,n}b_{1,n}\\\\ a_{2,1}b_{2,1}&a_{2,2}b_{2,2}&\\cdots&a_{2,n}b_{2,n}\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ a_{m,1}b_{m,1}&a_{m,2}b_{m,2}&\\cdots&a_{m,n}b_{m,n}\\end{bmatrix}\\]\n克罗内积Kronnecker product：\n\\[\\mathbf A \\otimes \\mathbf B =\\begin{bmatrix}a_{1,1}\\mathbf B&a_{1,2}\\mathbf B&\\cdots&a_{1,n}\\mathbf B\\\\ a_{2,1}\\mathbf B&a_{2,2}\\mathbf B&\\cdots&a_{2,n}\\mathbf B\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ a_{m,1}\\mathbf B&a_{m,2}\\mathbf B&\\cdots&a_{m,n}\\mathbf B \\end{bmatrix}\\]\n\\(\\mathbf {\\vec x},\\mathbf {\\vec a},\\mathbf {\\vec b},\\mathbf {\\vec c}\\) \\(n\\) 阶向量 \\(\\mathbf A,\\mathbf B,\\mathbf C,\\mathbf X\\) \\(n\\) 阶方阵，则有：\n\\[\\frac{\\partial(\\mathbf {\\vec a}^{T}\\mathbf {\\vec x}) }{\\partial \\mathbf {\\vec x} }=\\frac{\\partial(\\mathbf {\\vec x}^{T}\\mathbf {\\vec a}) }{\\partial \\mathbf {\\vec x} } =\\mathbf {\\vec a}\\] \\[\\frac{\\partial(\\mathbf {\\vec a}^{T}\\mathbf X\\mathbf {\\vec b}) }{\\partial \\mathbf X }=\\mathbf {\\vec a}\\mathbf {\\vec b}^{T}=\\mathbf {\\vec a}\\otimes\\mathbf {\\vec b}\\in \\mathbb R^{n\\times n}\\] \\[\\frac{\\partial(\\mathbf {\\vec a}^{T}\\mathbf X^{T}\\mathbf {\\vec b}) }{\\partial \\mathbf X }=\\mathbf {\\vec b}\\mathbf {\\vec a}^{T}=\\mathbf {\\vec b}\\otimes\\mathbf {\\vec a}\\in \\mathbb R^{n\\times n}\\] \\[\\frac{\\partial(\\mathbf {\\vec a}^{T}\\mathbf X\\mathbf {\\vec a}) }{\\partial \\mathbf X }=\\frac{\\partial(\\mathbf {\\vec a}^{T}\\mathbf X^{T}\\mathbf {\\vec a}) }{\\partial \\mathbf X }=\\mathbf {\\vec a}\\otimes\\mathbf {\\vec a}\\] \\[\\frac{\\partial(\\mathbf {\\vec a}^{T}\\mathbf X^{T}\\mathbf X\\mathbf {\\vec b}) }{\\partial \\mathbf X }=\\mathbf X(\\mathbf {\\vec a}\\otimes\\mathbf {\\vec b}+\\mathbf {\\vec b}\\otimes\\mathbf {\\vec a})\\] \\[\\frac{\\partial[(\\mathbf A\\mathbf {\\vec x}+\\mathbf {\\vec a})^{T}\\mathbf C(\\mathbf B\\mathbf {\\vec x}+\\mathbf {\\vec b})]}{\\partial \\mathbf {\\vec x}}=\\mathbf A^{T}\\mathbf C(\\mathbf B\\mathbf {\\vec x}+\\mathbf {\\vec b})+\\mathbf B^{T}\\mathbf C(\\mathbf A\\mathbf {\\vec x}+\\mathbf {\\vec a})\\] \\[\\frac{\\partial (\\mathbf {\\vec x}^{T}\\mathbf A \\mathbf {\\vec x})}{\\partial \\mathbf {\\vec x}}=(\\mathbf A+\\mathbf A^{T})\\mathbf {\\vec x}\\] \\[\\frac{\\partial[(\\mathbf X\\mathbf {\\vec b}+\\mathbf {\\vec c})^{T}\\mathbf A(\\mathbf X\\mathbf {\\vec b}+\\mathbf {\\vec c})]}{\\partial \\mathbf X}=(\\mathbf A+\\mathbf A^{T})(\\mathbf X\\mathbf {\\vec b}+\\mathbf {\\vec c})\\mathbf {\\vec b}^{T} \\] \\[\\frac{\\partial (\\mathbf {\\vec b}^{T}\\mathbf X^{T}\\mathbf A \\mathbf X\\mathbf {\\vec c})}{\\partial \\mathbf X}=\\mathbf A^{T}\\mathbf X\\mathbf {\\vec b}\\mathbf {\\vec c}^{T}+\\mathbf A\\mathbf X\\mathbf {\\vec c}\\mathbf {\\vec b}^{T}\\]\n如 \\(f\\) 是一元函数，则：\n其逐元向量函数为 \\(f(\\mathbf{\\vec x}) =(f(x_1),f(x_2),\\cdots,f(x_n))^{T}\\) 。\n其逐矩阵函数为：\n\\[f(\\mathbf X)=\\begin{bmatrix} f(x_{1,1})&f(x_{1,2})&\\cdots&f(x_{1,n})\\\\ f(x_{2,1})&f(x_{2,2})&\\cdots&f(x_{2,n})\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ f(x_{m,1})&f(x_{m,2})&\\cdots&f(x_{m,n})\\\\ \\end{bmatrix}\\]\n其逐元导数分别为：\n\\[f^{\\prime}(\\mathbf{\\vec x}) =(f^{\\prime}(x1),f^{\\prime}(x2),\\cdots,f^{\\prime}(x_n))^{T}\\\\ f^{\\prime}(\\mathbf X)=\\begin{bmatrix} f^{\\prime}(x_{1,1})&f^{\\prime}(x_{1,2})&\\cdots&f^{\\prime}(x_{1,n})\\\\ f^{\\prime}(x_{2,1})&f^{\\prime}(x_{2,2})&\\cdots&f^{\\prime}(x_{2,n})\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ f^{\\prime}(x_{m,1})&f^{\\prime}(x_{m,2})&\\cdots&f^{\\prime}(x_{m,n})\\\\ \\end{bmatrix}\\]\n各种类型的偏导数：\n标量对标量的偏导数 \\(\\frac{\\partial u}{\\partial v}\\) 。\n标量对向量 \\(n\\) 维向量）的偏导数 \\(\\frac{\\partial u}{\\partial \\mathbf {\\vec v}}=(\\frac{\\partial u}{\\partial v_1},\\frac{\\partial u}{\\partial v_2},\\cdots,\\frac{\\partial u}{\\partial v_n})^{T}\\) 。\n标量对矩阵 \\(m\\times n\\) 阶矩阵)的偏导数：\n\\[\\frac{\\partial u}{\\partial \\mathbf V}=\\begin{bmatrix} \\frac{\\partial u}{\\partial V_{1,1}}&\\frac{\\partial u}{\\partial V_{1,2}}&\\cdots&\\frac{\\partial u}{\\partial V_{1,n}}\\\\ \\frac{\\partial u}{\\partial V_{2,1}}&\\frac{\\partial u}{\\partial V_{2,2}}&\\cdots&\\frac{\\partial u}{\\partial V_{2,n}}\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ \\frac{\\partial u}{\\partial V_{m,1}}&\\frac{\\partial u}{\\partial V_{m,2}}&\\cdots&\\frac{\\partial u}{\\partial V_{m,n}} \\end{bmatrix}\\]\n向量 \\(m\\) 维向量）对标量的偏导数 \\(\\frac{\\partial \\mathbf {\\vec u}}{\\partial v}=(\\frac{\\partial u_1}{\\partial v},\\frac{\\partial u_2}{\\partial v},\\cdots,\\frac{\\partial u_m}{\\partial v})^{T}\\) 。\n向量 \\(m\\) 维向量）对向量 \\(n\\) 维向量)的偏导数（雅可比矩阵，行优先）\n\\[\\frac{\\partial \\mathbf {\\vec u}}{\\partial \\mathbf {\\vec v}}=\\begin{bmatrix} \\frac{\\partial u_1}{\\partial v_1}&\\frac{\\partial u_1}{\\partial v_2}&\\cdots&\\frac{\\partial u_1}{\\partial v_n}\\\\ \\frac{\\partial u_2}{\\partial v_1}&\\frac{\\partial u_2}{\\partial v_2}&\\cdots&\\frac{\\partial u_2}{\\partial v_n}\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ \\frac{\\partial u_m}{\\partial v_1}&\\frac{\\partial u_m}{\\partial v_2}&\\cdots&\\frac{\\partial u_m}{\\partial v_n} \\end{bmatrix}\\] 如果为列优先，则为上面矩阵的转置。\n矩阵 \\(m\\times n\\) 阶矩阵)对标量的偏导数\n\\[\\frac{\\partial \\mathbf U}{\\partial v}=\\begin{bmatrix} \\frac{\\partial U_{1,1}}{\\partial v}&\\frac{\\partial U_{1,2}}{\\partial v}&\\cdots&\\frac{\\partial U_{1,n}}{\\partial v}\\\\ \\frac{\\partial U_{2,1}}{\\partial v}&\\frac{\\partial U_{2,2}}{\\partial v}&\\cdots&\\frac{\\partial U_{2,n}}{\\partial v}\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ \\frac{\\partial U_{m,1}}{\\partial v}&\\frac{\\partial U_{m,2}}{\\partial v}&\\cdots&\\frac{\\partial U_{m,n}}{\\partial v} \\end{bmatrix}\\]\n对于矩阵的迹，有下列偏导数成立：\n\\[\\frac{\\partial [tr(f(\\mathbf X))]}{\\partial \\mathbf X }=(f^{\\prime}(\\mathbf X))^{T}\\] \\[\\frac{\\partial [tr(\\mathbf A\\mathbf X\\mathbf B)]}{\\partial \\mathbf X }=\\mathbf A^{T}\\mathbf B^{T} \\] \\[\\frac{\\partial [tr(\\mathbf A\\mathbf X^{T}\\mathbf B)]}{\\partial \\mathbf X }=\\mathbf B\\mathbf A \\] \\[\\frac{\\partial [tr(\\mathbf A\\otimes\\mathbf X )]}{\\partial \\mathbf X }=tr(\\mathbf A)\\mathbf I\\] \\[\\frac{\\partial [tr(\\mathbf A\\mathbf X \\mathbf B\\mathbf X)]}{\\partial \\mathbf X }=\\mathbf A^{T}\\mathbf X^{T}\\mathbf B^{T}+\\mathbf B^{T}\\mathbf X \\mathbf A^{T} \\] \\[\\frac{\\partial [tr(\\mathbf X^{T} \\mathbf B\\mathbf X \\mathbf C)]}{\\partial \\mathbf X }=(\\mathbf B^{T}+\\mathbf B)\\mathbf X \\mathbf C \\mathbf C^{T} \\] \\[\\frac{\\partial [tr(\\mathbf C^{T}\\mathbf X^{T} \\mathbf B\\mathbf X \\mathbf C)]}{\\partial \\mathbf X }=\\mathbf B\\mathbf X \\mathbf C +\\mathbf B^{T}\\mathbf X \\mathbf C^{T} \\] \\[\\frac{\\partial [tr(\\mathbf A\\mathbf X \\mathbf B\\mathbf X^{T} \\mathbf C)]}{\\partial \\mathbf X }= \\mathbf A^{T}\\mathbf C^{T}\\mathbf X\\mathbf B^{T}+\\mathbf C \\mathbf A \\mathbf X \\mathbf B\\] \\[\\frac{\\partial [tr((\\mathbf A\\mathbf X\\mathbf B+\\mathbf C)(\\mathbf A\\mathbf X\\mathbf B+\\mathbf C))]}{\\partial \\mathbf X }= 2\\mathbf A ^{T}(\\mathbf A\\mathbf X\\mathbf B+\\mathbf C)\\mathbf B^{T}\\]\n假 \\(\\mathbf U= f(\\mathbf X)\\) 是关 \\(\\mathbf X\\) 的矩阵值函数 \\(f:\\mathbb R^{m\\times n}\\rightarrow \\mathbb R^{m\\times n}\\) ）， \\(g(\\mathbf U)\\) 是关 \\(\\mathbf U\\) 的实值函数 $g:\\mathbb R^{m\\times n}\\rightarrow \\mathbb R $ ），则下面链式法则成立：\n\\[\\frac{\\partial g(\\mathbf U)}{\\partial \\mathbf X}= \\left(\\frac{\\partial g(\\mathbf U)}{\\partial x_{i,j}}\\right)_{m\\times n}=\\begin{bmatrix} \\frac{\\partial g(\\mathbf U)}{\\partial x_{1,1}}&\\frac{\\partial g(\\mathbf U)}{\\partial x_{1,2}}&\\cdots&\\frac{\\partial g(\\mathbf U)}{\\partial x_{1,n}}\\\\ \\frac{\\partial g(\\mathbf U)}{\\partial x_{2,1}}&\\frac{\\partial g(\\mathbf U)}{\\partial x_{2,2}}&\\cdots&\\frac{\\partial g(\\mathbf U)}{\\partial x_{2,n}}\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ \\frac{\\partial g(\\mathbf U)}{\\partial x_{m,1}}&\\frac{\\partial g(\\mathbf U)}{\\partial x_{m,2}}&\\cdots&\\frac{\\partial g(\\mathbf U)}{\\partial x_{m,n}}\\\\ \\end{bmatrix}\\\\ =\\left(\\sum_{k}\\sum_{l}\\frac{\\partial g(\\mathbf U)}{\\partial u_{k,l}}\\frac{\\partial u_{k,l}}{\\partial x_{i,j}}\\right)_{m\\times n}=\\left(tr\\left[\\left(\\frac{\\partial g(\\mathbf U)}{\\partial \\mathbf U}\\right)^{T}\\frac{\\partial \\mathbf U}{\\partial x_{i,j}}\\right]\\right)_{m\\times n}\\]\n概率论与随机过程\n一、概率与分布\n1.1 条件概率与独立事件\n条件概率：已 \\(A\\) 事件发生的条件 \\(B\\) 发生的概率，记 \\(P(B\\mid A)\\) ，它等于事 \\(AB\\) 的概率相对于事 \\(A\\) 的概率，即：\n\\[P(B\\mid A)=\\frac {P(AB)}{P(A)}\\] 其中必须 \\(P(A) \\gt 0\\)\n条件概率分布的链式法则：对 \\(n\\) 个随机变 \\(\\mathbf x_1,\\mathbf x_2,\\cdots,\\mathbf x_n\\) ，有：\n\\[P(\\mathbf x_1,\\mathbf x_2,\\cdots,\\mathbf x_n)=P(\\mathbf x_1)\\prod_{i=2}^{n}P(\\mathbf x_i \\mid \\mathbf x_1,\\cdots,\\mathbf x_{i-1})\\]\n两个随机变 \\(\\mathbf x,\\mathbf y\\) 相互独立的数学描述：\n\\[\\forall x\\in \\mathcal X,\\forall y\\in \\mathcal Y, P(\\mathbf x=x,\\mathbf y=y)=P(\\mathbf x=x)P(\\mathbf y=y)\\] 记作 \\(\\mathbf x \\bot \\mathbf y\\)\n两个随机变 \\(\\mathbf x,\\mathbf y\\) 关于随机变 \\(\\mathbf z\\) 条件独立的数学描述：\n\\[\\forall x\\in \\mathcal X,\\forall y\\in \\mathcal Y,\\forall z \\in\\mathcal Z\\\\ P(\\mathbf x=x,\\mathbf y=y\\mid \\mathbf z=z)=P(\\mathbf x=x\\mid \\mathbf z=z)P(\\mathbf y=y\\mid \\mathbf z=z)\\] 记作 \\(\\mathbf x \\bot \\mathbf y \\mid \\mathbf z\\)\n1.2 联合概率分布\n定 \\({\\mathbf x}\\) \\({\\mathbf y}\\) 的联合分布为：\n\\[P(a,b)=P\\{{\\mathbf x} \\le a, {\\mathbf y} \\le b\\}, - \\infty \\lt a,b \\lt + \\infty \\]\n\\({\\mathbf x}\\) 的分布可以从联合分布中得到：\n\\[ P_{\\mathbf x}(a)=P\\{{\\mathbf x} \\le a\\}=P\\{{\\mathbf x} \\le a, {\\mathbf y} \\le \\infty\\}=P(a,\\infty), - \\infty \\lt a \\lt + \\infty \\] 类似的 \\({\\mathbf y}\\) 的分布可以从联合分布中得到：\n\\[ P_{\\mathbf y}(b)=P\\{{\\mathbf y} \\le b\\}=P\\{{\\mathbf x} \\le \\infty, {\\mathbf y} \\le b\\}=P(\\infty,b), - \\infty \\lt b \\lt + \\infty \\]\n\\({\\mathbf x}\\) \\({\\mathbf y}\\) 都是离散随机变量时，定 \\({\\mathbf x}\\) \\({\\mathbf y}\\) 的联合概率质量函数为 \\(p(x,y)=P\\{{\\mathbf x}=x,{\\mathbf y}=y\\}\\)\n\\({\\mathbf x}\\) \\({\\mathbf y}\\) 的概率质量函数分布为：\n\\[p_{\\mathbf x}(x)=\\sum_{y \\;:\\;p(x,y) \\gt 0}p(x,y) \\\\ p_{\\mathbf y}(y)=\\sum_{x \\;:\\;p(x,y) \\gt 0}p(x,y)\\]\n\\({\\mathbf x}\\) \\({\\mathbf y}\\) 联合地连续时，即存在函 \\(p(x,y)\\) ，使得对于所有的实数集 \\(A\\) \\(B\\) 满足：\n\\[P\\{{\\mathbf x} \\in A, {\\mathbf y} \\in B\\}=\\int_B \\int_A p(x,y) dx dy\\] 则函 \\(p(x,y)\\) 称 \\({\\mathbf x}\\) \\({\\mathbf y}\\) 的概率密度函数。\n联合分布为\n\\[P(a,b)=P\\{{\\mathbf x} \\le a, {\\mathbf y} \\le b\\}= \\int_{-\\infty}^{a} \\int_{-\\infty}^{b} p(x,y) dx dy\\]\n\\({\\mathbf x}\\) \\({\\mathbf y}\\) 的概率密度函数以及分布函数分别为：\n\\[P_{\\mathbf x}(a)=\\int_{-\\infty}^{a} \\int_{-\\infty}^{\\infty} p(x,y) dx dy =\\int_{-\\infty}^{a} p_{\\mathbf x}(x)dx\\\\ P_{\\mathbf y}(b)=\\int_{-\\infty}^{\\infty} \\int_{-\\infty}^{b} p(x,y) dx dy=\\int_{-\\infty}^{b} p_{\\mathbf y}(y)dy\\\\ p_{\\mathbf x}(x)=\\int_{-\\infty}^{\\infty} p(x,y) dy\\\\ p_{\\mathbf y}(y)=\\int_{-\\infty}^{\\infty} p(x,y) dx\\]\n二、期望\n期望：（是概率分布的泛函，函数的函数）\n离散型随机变 \\({\\mathbf x}\\) 的期望：\n\\[\\mathbb E[{\\mathbf x}]=\\sum_{i=1}^{\\infty}x_ip_i\\]\n若级数不收敛，则期望不存在\n连续性随机变 \\({\\mathbf x}\\) 的期望：\n\\[\\mathbb E[{\\mathbf x}]=\\int_{-\\infty}^{\\infty}xp(x)dx\\]\n若极限不收敛，则期望不存在\n期望描述了随机变量的平均情况，衡量了随机变 \\({\\mathbf x}\\) 的均值\n定理： \\({\\mathbf y}=g({\\mathbf x})\\) 均为随机变量 \\(g(\\cdot)\\) 是连续函数\n\\({\\mathbf x}\\) 为离散型随机变量， \\({\\mathbf y}\\) 的期望存在，则：\n\\[\\mathbb E[{\\mathbf y}]=\\mathbb E[g({\\mathbf x})]=\\sum_{i=1}^{\\infty}g(x_i)p_i\\]\n\\({\\mathbf x}\\) 为连续型随机变量， \\({\\mathbf y}\\) 的期望存在，则：\n\\[\\mathbb E[{\\mathbf y}]=\\mathbb E[g({\\mathbf x})]=\\int_{-\\infty}^{\\infty}g(x)p(x)dx\\] 该定理的意义在于：当 \\(\\mathbb E({\\mathbf y})\\) 时，不必计算 \\({\\mathbf y}\\) 的分布，只需要利 \\({\\mathbf x}\\) 的分布即可。该定理可以推广至两个或者两个以上随机变量的情况。此时：\n\\[ \\mathbb E[Z]=\\mathbb E[g({\\mathbf x},{\\mathbf y})]=\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}g(x,y)p(x,y)dxdy\\]\n上述公式也记做：\n\\[\\mathbb E_{\\mathbf x\\sim P}[g(x)]=\\sum_{x}g(x)p(x)\\\\ \\mathbb E_{\\mathbf x\\sim P}[g(x)]=\\int g(x)p(x)dx\\\\ \\mathbb E_{\\mathbf x,\\mathbf y\\sim P}[g(x)]\\int g(x,y)p(x,y)dxdy\\]\n期望性质：\n常数的期望就是常数本身\n对常 \\(C\\) 有：\n\\[\\mathbb E[C{\\mathbf x}]=C\\mathbb E[{\\mathbf x}]\\]\n对两个随机变 \\({\\mathbf x},{\\mathbf y}\\) ，有：\n\\[\\mathbb E[{\\mathbf x}+{\\mathbf y}]=\\mathbb E[{\\mathbf x}]+\\mathbb E[{\\mathbf y}]\\]\n该结论可以推广到任意有限个随机变量之和的情况\n对两个相互独立的随机变量，有：\n\\[\\mathbb E[{\\mathbf x}{\\mathbf y}]=\\mathbb E[{\\mathbf x}]\\mathbb E[{\\mathbf y}]\\]\n该结论可以推广到任意有限个相互独立的随机变量之积的情况\n三、方差\n3.1 方差\n对随机变 \\({\\mathbf x}\\) ， \\(\\mathbb E[({\\mathbf x}-\\mathbb E[{\\mathbf x}])^{2}]\\) 存在，则称它 \\({\\mathbf x}\\) 的方差，记 \\(Var[{\\mathbf x}]\\) \\({\\mathbf x}\\) 的标准差为方差的开平方。即：\n\\[Var[{\\mathbf x}]=\\mathbb E[({\\mathbf x}-\\mathbb E[{\\mathbf x}])^{2}] \\\\ \\sigma=\\sqrt{Var[{\\mathbf x}]}\\]\n方差度量了随机变量 \\({\\mathbf x}\\) 与期望值偏离的程度，衡量了 \\({\\mathbf x}\\) 取值分散程度的一个尺度。\n由于绝对值 \\(|{\\mathbf x}-\\mathbb E[{\\mathbf x}] |\\) 带有绝对值，不方便运算，因此采用平方来计算。又因为 \\(|{\\mathbf x}-\\mathbb E[{\\mathbf x}]|^2\\) 是一个随机变量，因此对它取期望，即得 \\({\\mathbf x}\\) 与期望值偏离的均值\n根据定义可知：\n\\[Var[{\\mathbf x}]=\\mathbb E[({\\mathbf x}-\\mathbb E[{\\mathbf x}])^{2}]=\\mathbb E[{\\mathbf x}^{2}]-(\\mathbb E[{\\mathbf x}])^{2}\\\\ Var [f(\\mathbf x)]=\\mathbb E[(f(\\mathbf x)-\\mathbb E[f(\\mathbf x)])^{2}]\\]\n对于一个期望 \\(\\mu\\) ，方差 \\(\\sigma^{2},\\sigma \\ne 0\\) 的随机变 \\({\\mathbf x}\\) ，随机变 \\({\\mathbf x}^{*}=\\frac {{\\mathbf x}-\\mu}{\\sigma}\\) 的数学期望为0，方差为1。 \\({\\mathbf x}^{\\ast}\\) \\({\\mathbf x}\\) 的标准化变量\n方差的性质：\n常数的方差恒为0\n对常 \\(C\\) \\(Var[C{\\mathbf x}]=C^{2}Var[{\\mathbf x}]\\)\n对两个随机变 \\({\\mathbf x},{\\mathbf y}\\) ，有 $Var[{\\mathbf x}+{\\mathbf y}]=Var[{\\mathbf x}] +Var[{\\mathbf y}] +2\\mathbb E[({\\mathbf x}-\\mathbb E[{\\mathbf x}])({\\mathbf y}-\\mathbb E[{\\mathbf y}])] $\n当 \\({\\mathbf x}\\) 和 \\({\\mathbf y}\\) 相互独立时，有 $Var[{\\mathbf x}+{\\mathbf y}] = Var[{\\mathbf x}] +Var[{\\mathbf y}] $ 。可以推广至任意有限多个相互独立的随机变量之和的情况\n\\(Var [{\\mathbf x}] =0\\) 的充要条件 \\({\\mathbf x}\\) 以概率1取常数\n3.2 协方差与相关系数\n对于二维随机变 \\(({\\mathbf x},{\\mathbf y})\\) ，可以讨论描 \\({\\mathbf x}\\) \\({\\mathbf y}\\) 之间相互关系的数字特征。\n定义 $\\mathbb E[({\\mathbf x}-\\mathbb E[{\\mathbf x}])({\\mathbf y}-\\mathbb E [{\\mathbf y}])] $ 为随机变量 \\({\\mathbf x}\\) 与 \\({\\mathbf y}\\) 的协方差，记作 $ Cov[ {\\mathbf x},{\\mathbf y}]=\\mathbb E[({\\mathbf x}-\\mathbb E[{\\mathbf x}])({\\mathbf y}-\\mathbb E [{\\mathbf y}])]$ 。\n定义 \\(\\rho_{{\\mathbf x}{\\mathbf y}}=\\frac {Cov[{\\mathbf x},{\\mathbf y}]}{\\sqrt{Var[{\\mathbf x}] }\\sqrt{Var[{\\mathbf y}]}}\\) 为随机变量 \\({\\mathbf x}\\) 与 \\({\\mathbf y}\\) 　的相关系数，它是协方差的归一化。\n由定义可知：\n\\[Cov[ {\\mathbf x},{\\mathbf y}] =Cov[ {\\mathbf y},{\\mathbf x}] \\\\ Cov [{\\mathbf x},{\\mathbf x}] =Var [{\\mathbf x}] \\\\ Var [{\\mathbf x}+{\\mathbf y}] =Var [{\\mathbf x}] +Var [{\\mathbf y}] +2Cov [{\\mathbf x},{\\mathbf y}] \\]\n协方差的性质：\n$Cov [a{\\mathbf x},b{\\mathbf y}] =abCov [{\\mathbf x},{\\mathbf y}] $ , \\(a,b\\) 为常数\n$Cov[ {\\mathbf x}_1+{\\mathbf x}_2,{\\mathbf y} ]=Cov [{\\mathbf x}_1,{\\mathbf y}] +Cov [{\\mathbf x}_2,{\\mathbf y}] $\n\\(Cov [f(\\mathbf x),g(\\mathbf y)]=\\mathbb E[(f(\\mathbf x)-\\mathbb E[f(\\mathbf x)])(g(\\mathbf y)-\\mathbb E[g(\\mathbf y)])]\\)\n\\(\\rho[f(\\mathbf x),g(\\mathbf y)]=\\frac {Cov[f(\\mathbf x),g(\\mathbf y)]}{\\sqrt{Var[f(\\mathbf x)] }\\sqrt{Var[g(\\mathbf y)]}}\\)\n协方差的物理意义：\n协方差的绝对值越大，说明两个随机变量都远离它们的均值。\n协方差如果为正，则说明两个随机变量同时趋向于取较大的值；如果为负，则说明一个随变量趋向于取较大的值，另一个随机变量趋向于取较小的值\n两个随机变量的独立性可以导出协方差为零。但是两个随机变量的协方差为零无法导出独立性\n因为独立性也包括：没有非线性关系。有可能两个随机变量是非独立的，但是协方差为零\n假设随机变 \\(\\mathbf x\\sim U[-1,1]\\) 。定义随机变 \\(\\mathbf s\\) 的概率分布函数为：\n\\[P(\\mathbf s=1)= \\frac 12P(\\mathbf s=-1)= \\frac 12 \\] 定义随机变 \\(\\mathbf y=\\mathbf {sx}\\) ，则随机变 \\(\\mathbf x,\\mathbf y\\) 是非独立的，但是有 \\(Cov[\\mathbf x,\\mathbf y]=0\\)\n相关系数的物理意义：考虑以随机变 \\({\\mathbf x}\\) 的线性函 \\(a+b{\\mathbf x}\\) 来近似表 \\({\\mathbf y}\\) 。以均方误差\n\\[e=\\mathbb E[({\\mathbf y}-(a+b{\\mathbf x}))^{2}]=\\mathbb E[{\\mathbf y}^{2}] +b^{2}\\mathbb E[{\\mathbf x}^{2}] +a^{2}-2b\\mathbb E[{\\mathbf x}{\\mathbf y}] +2ab\\mathbb E[{\\mathbf x}] -2a\\mathbb E [{\\mathbf y}] \\] 来衡量 \\(a+b{\\mathbf x}\\) 近似表 \\({\\mathbf y}\\) 的好坏程度 \\(e\\) 越小表示近似程度越高。为求得\n最好的近似，则 \\(a,b\\) 分别取偏导数，得到：\n\\[a_0=\\mathbb E[{\\mathbf y}] -b_0\\mathbb E[{\\mathbf x}] =\\mathbb E[{\\mathbf y}] -\\mathbb E[{\\mathbf x}] \\frac{Cov [{\\mathbf x},{\\mathbf y}]}{Var [{\\mathbf x}] }\\\\ b_0=\\frac{Cov[ {\\mathbf x},{\\mathbf y}] }{Var[ {\\mathbf x}] }\\\\ \\min(e)=\\mathbb E[({\\mathbf y}-(a_0+b_0{\\mathbf x}))^{2}]=(1-\\rho^{2}_{{\\mathbf x}{\\mathbf y}})Var [{\\mathbf y}] \\] 因此有以下定理：\n\\(|\\rho_{{\\mathbf x}{\\mathbf y}}| \\le 1\\) \\(|...|\\) 是绝对值）\n\\(|\\rho_{{\\mathbf x}{\\mathbf y}}| = 1\\) 的充要条件是，存在常数 \\(a,b\\) 使得 \\(P\\{{\\mathbf y}=a+b{\\mathbf x}\\}=1\\)\n\\(|\\rho_{{\\mathbf x}{\\mathbf y}}|\\) 较大时 \\(e\\) 较小，表明随机变 \\({\\mathbf x}\\) \\({\\mathbf y}\\) 联系较紧密，于 \\(\\rho_{{\\mathbf x}{\\mathbf y}}\\) 是一个表 \\({\\mathbf x}\\) \\({\\mathbf y}\\) 之间线性关系紧密程度的量。\n\\(\\rho_{{\\mathbf x}{\\mathbf y}}=0\\) 时， \\({\\mathbf x}\\) \\({\\mathbf y}\\) 不相关。\n不相关是就线性关系来讲的，而相互独立是一般关系而言的。\n相互独立一定不相关；不相关则未必独立。\n3.3 协方差矩阵\n矩： \\({\\mathbf x}\\) \\({\\mathbf y}\\) 是随机变量\n若 \\(\\mathbb E[{\\mathbf x}^{k}] ,k=1,2,\\cdots\\) 存在，则称它为 \\({\\mathbf x}\\) 的 \\(k\\) 阶原点矩，简称 \\(k\\) 阶矩\n若 \\(\\mathbb E[({\\mathbf x}-\\mathbb E[{\\mathbf x}])^{k}] ,k=2,3,\\cdots\\) 存在，则称它为 \\({\\mathbf x}\\) 的 \\(k\\) 阶中心矩\n若 \\(\\mathbb E[{\\mathbf x}^{k}{\\mathbf y}^{l}] ,k,l=1,2,\\cdots\\) 存在，则称它为 \\({\\mathbf x}\\) 和 \\({\\mathbf y}\\) 的 $ k+l$ 阶混合矩\n若 \\(\\mathbb E[({\\mathbf x}-\\mathbb E[{\\mathbf x}])^{k}({\\mathbf y}-\\mathbb E[{\\mathbf y}])^{l}] ,k,l=1,2,\\cdots\\) 存在，则称它为 \\({\\mathbf x}\\) 和 \\({\\mathbf y}\\) 的 \\(k+l\\) 阶混合中心矩\n因此期望是一阶原点矩，方差是二阶中心矩，协方差是二阶混合中心矩\n协方差矩阵：二维随机变 \\(({\\mathbf x}_1,{\\mathbf x}_2)\\) 有四个二阶中心矩（设他们都存在），记作：\n\\[\\begin{align} c_{11}&=\\mathbb E[({\\mathbf x}_1-\\mathbb E[{\\mathbf x}_1])^{2}] \\\\ c_{12}&=\\mathbb E[({\\mathbf x}_1-\\mathbb E[{\\mathbf x}_1])( {\\mathbf x}_2-\\mathbb E[{\\mathbf x}_2]) ] \\\\ c_{21}&=\\mathbb E[( {\\mathbf x}_2-\\mathbb E[{\\mathbf x}_2])({\\mathbf x}_1-\\mathbb E[{\\mathbf x}_1] ) ] \\\\ c_{22}&=\\mathbb E[({\\mathbf x}_2-\\mathbb E[{\\mathbf x}_2])^{2}] \\\\ \\end{align}\\] 这个矩阵称作随机变 \\(({\\mathbf x}_1,{\\mathbf x}_2)\\) 的协方差矩阵。\n\\(n\\) 维随机变 \\(({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n)\\) 的二阶混合中心 \\(c_{ij}=Cov [{\\mathbf x}_i,{\\mathbf x}_j] =\\mathbb E[({\\mathbf x}_i-\\mathbb E[{\\mathbf x}_i] )( {\\mathbf x}_j-\\mathbb E[{\\mathbf x}_j] ) ] ,i,j=1,2,\\cdots,n\\) ,都存在，则称矩阵\n\\[\\mathbf C= \\begin{bmatrix} c_{11} & c_{12} & \\cdots & c_{1n} \\\\ c_{21} & c_{22} & \\cdots & c_{2n} \\\\ \\vdots &\\vdots &\\ddots &\\vdots \\\\ c_{n1} & c_{n2} & \\cdots & c_{nn} \\\\ \\end{bmatrix}\\] \\(n\\) 维随机变 \\(({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n)\\) 的协方差矩阵。\n由于 \\(c_{ij}=c_{ji}, i\\ne j, i,j=1,2,\\cdots,n\\) 因此协方差矩阵是个对称阵\n通 \\(n\\) 维随机变量的分布是不知道的，或者太复杂以致数学上不容易处理。因此实际中协方差矩阵非常重要。\n四、大数定律及中心极限定理\n4.1 切比雪夫不等式\n切比雪夫不等式：随机变 \\({\\mathbf x}\\) 具有期 \\(\\mathbb E[{\\mathbf x}] =\\mu\\) ，方 \\(Var({\\mathbf x})=\\sigma^{2}\\) ,对于任意正 \\(\\varepsilon\\) ，不等式\n\\[P\\{|{\\mathbf x}-\\mu| \\ge \\varepsilon\\} \\le \\frac {\\sigma^{2}}{\\varepsilon^{2}}\\] 成立\n其意义是：对于距 $\\mathbb E[{\\mathbf x}] $ 足够远的地方（距离大于等 \\(\\varepsilon\\) ），事件出现的概率是小于等 $ \\frac {\\sigma^{2}}{\\varepsilon^{2}}$ ；即事件出现在区 \\([\\mu-\\varepsilon , \\mu+\\varepsilon]\\) 的概率大 \\(1- \\frac {\\sigma^{2}}{\\varepsilon^{2}}\\)\n该不等式给出了随机变 \\({\\mathbf x}\\) 在分布未知的情况下，事 \\(\\{|{\\mathbf x}-\\mu| \\le \\varepsilon\\}\\) 的下限估计（ \\(P\\{|{\\mathbf x}-\\mu| \\lt 3\\sigma\\} \\ge 0.8889\\)\n证明：\n\\[P\\{|{\\mathbf x}-\\mu| \\ge \\varepsilon\\}=\\int_{|x-\\mu| \\ge \\varepsilon}p(x)dx \\le \\int_{|x-\\mu| \\ge \\varepsilon} \\frac{|x-\\mu|^{2}}{\\varepsilon^{2}}p(x)dx \\\\ \\le \\frac {1}{\\varepsilon^{2}}\\int_{-\\infty}^{\\infty}(x-\\mu)^{2}p(x)dx=\\frac{\\sigma^{2}}{\\varepsilon^{2}}\\]\n切比雪夫不等式的特殊情况：设随机变 \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n,\\cdots\\) 相互独立，且具有相同的数学期望和方差 $ \\mathbb E[{\\mathbf x}_k] =\\mu, Var[{\\mathbf x}_k] =\\sigma^{2},k=1,2,\\cdots$ 。作 \\(n\\) 个随机变量的算术平均 $ \\overline {\\mathbf x} =\\frac {1}{n} \\sum _{k=1}^{n}{\\mathbf x}_k$ ，则对于任意正 $ \\varepsilon$ 有：\n\\[\\lim_{n\\rightarrow \\infty}P\\{|\\overline {\\mathbf x}-\\mu| \\lt \\varepsilon\\}=\\lim_{n\\rightarrow \\infty}P\\{|\\frac{1}{n}\\sum_{k=1}^{n}{\\mathbf x}_k-\\mu| \\lt \\varepsilon\\} =1\\] 证明：\n\\[\\mathbb E[\\frac{1}{n}\\sum_{k=1}^{n}{\\mathbf x}_k]=\\mu\\\\ Var[\\frac{1}{n}\\sum_{k=1}^{n}{\\mathbf x}_k]=\\frac{\\sigma^{2}}{n}\\] 有切比雪夫不等式，以 \\(n\\) 趋于无穷时，可以证明。详细过程省略\n4.2 大数定理\n依概率收敛： \\({\\mathbf y}_1,{\\mathbf y}_2,\\cdots,{\\mathbf y}_n,\\cdots\\) 是一个随机变量序列 \\(a\\) 是一个常数。若对于任意正 $ \\varepsilon$ 有 \\(\\lim_{n\\rightarrow \\infty}P\\{|{\\mathbf y}_{n}-a| \\le \\varepsilon \\}=1\\) ,则称序 \\({\\mathbf y}_1,{\\mathbf y}_2,\\cdots,{\\mathbf y}_n,\\cdots\\) 依概率收敛 \\(a\\) 。记作 \\({\\mathbf y}_{n} \\stackrel{P}{\\rightarrow} a\\)\n依概率收敛的两个含义：\n收敛：表明这是一个随机变量序列，而不是某个随机变量；且序列是无限长，而不是有限长\n依概率：表明序列无穷远处的随机变量 \\({\\mathbf y}_{\\infty}\\) 的分布规律为：绝大部分分布于点 \\(a\\) ，极少数位于 \\(a\\) 之外。且分布于 \\(a\\) 之外的事件发生的概率之和为0\n大数定理一：设随机变 \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n,\\cdots\\) 相互独立，且具有相同的数学期望和方差 $ \\mathbb E[{\\mathbf x}_k] =\\mu, Var[{\\mathbf x}_k] =\\sigma^{2},k=1,2,\\cdots$ 。则序列 $ \\overline {\\mathbf x} =\\frac {1}{n} \\sum _{k=1}^{n}{\\mathbf x}_k$ 依概率收敛 \\(\\mu\\) ， \\(\\overline {\\mathbf x} \\stackrel{P}{\\rightarrow} \\mu\\)\n这里并没有要求随机变量 \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n,\\cdots\\) 同分布\n伯努利大数定理： \\(n_A\\) \\(n\\) 次独立重复实验中事 \\(A\\) 发生的次数 \\(p\\) 是事 \\(A\\) 在每次试验中发生的概率。则对于任意正 $ \\varepsilon$ 有：\n\\[\\lim_{n \\rightarrow \\infty}P\\{|\\frac{n_{A}}{n}-p| \\lt \\varepsilon\\}=1 \\\\ or: \\quad \\lim_{n \\rightarrow \\infty}P\\{|\\frac{n_{A}}{n}-p| \\ge \\varepsilon\\}=0\\]\n即：当独立重复实验执行非常大的次数时，事件 \\(A\\) 发生的频率逼近于它的概率\n辛钦定理：设随机变 \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n,\\cdots\\) 相互独立，服从同一分布，且具有相同的数学期望 $ \\mathbb E[{\\mathbf x}_k] =\\mu,k=1,2,\\cdots$ 。则对于任意正 $ \\varepsilon$ 有：\n\\[\\lim_{n\\rightarrow \\infty}P\\{|\\frac{1}{n}\\sum_{k=1}^{n}{\\mathbf x}_k-\\mu| \\lt \\varepsilon\\} =1\\]\n这里并没有要求随机变量 \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n,\\cdots\\) 的方差存在\n伯努利大数定理是亲钦定理的特殊情况。\n4.3 中心极限定理\n独立同分布的中心极限定理：设随机变 \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n\\) 独立同分布，且具有数学期望和方差 \\(\\mathbb E[{\\mathbf x}_k] =\\mu, Var[{\\mathbf x}_k] =\\sigma^{2} \\gt 0,k=1,2,\\cdots\\) ，则随机变量之 \\(\\overline {S{\\mathbf x}_n}=\\sum_{k=1}^{n} {\\mathbf x}_k\\) 的标准变化量:\n\\[{\\mathbf y}_n=\\frac{\\overline {S{\\mathbf x}_n}-\\mathbb E[\\overline {S{\\mathbf x}_n}] }{\\sqrt{Var[\\overline {S{\\mathbf x}_n}] }}=\\frac{\\overline {S{\\mathbf x}_n}-n\\mu}{\\sqrt n \\sigma}\\] 的概率分布函 \\(F_n(x)\\) 对于任 \\(x\\) 满足：\n\\[\\lim_{n\\rightarrow \\infty}F_n(x)=\\lim_{n\\rightarrow \\infty}P\\{{\\mathbf y}_n \\le x\\}\\\\ =\\lim_{n\\rightarrow \\infty}P\\{\\frac{\\sum_{k=1}^{n} {\\mathbf x}_k-n\\mu}{\\sqrt n \\sigma} \\le x\\}\\\\ = \\int_{-\\infty}^{x} \\frac{1}{\\sqrt{2\\pi}}e^{-t^{2}/2}dt=\\Phi(x)\\]\n其物理意义为：均值方差为 \\(\\mu,\\sigma^{2}\\) 的独立同分布的随机变量 \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n\\) 之和 \\(\\overline {S{\\mathbf x}_n}=\\sum_{k=1}^{n} {\\mathbf x}_k\\) 的标准变化量 \\({\\mathbf y}_n\\) ，当 \\(n\\) 充分大时，其分布近似与标准正态分布。即 \\(\\overline {S{\\mathbf x}_n}=\\sum_{k=1}^{n} {\\mathbf x}_k\\) 在 \\(n\\) 充分大时，其分布近似于 \\(N(n\\mu,n\\sigma^{2})\\)\n一般情况下，很难求出 \\(n\\) 个随机变量之和的分布函数。因此当 \\(n\\) 充分大时，可以通过正态分布来做理论上的分析或者计算。\nLiapunov定理：设随机变 \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n,\\cdots\\) 相互独立，具有数学期望和方差 \\(\\mathbb E[{\\mathbf x}_k] =\\mu_k,Var[{\\mathbf x}_k] =\\sigma_k^{2} \\gt 0, k=1,2,\\cdots\\) ，记 \\(B_n^{2}=\\sum_{k=1}^{n}\\sigma_k^{2}\\) 。\n若存在正 \\(\\delta\\) ，使得 \\(n \\rightarrow \\infty\\) 时，\n\\[\\frac{1}{B_n^{2+\\delta}}\\sum_{k=1}^{n}\\mathbb E [|{\\mathbf x}_k-\\mu_k|^{2+\\delta}] \\rightarrow 0\\] 则随机变量之 \\(\\overline {S{\\mathbf x}_n}=\\sum_{k=1}^{n} {\\mathbf x}_k\\) 的标准变化量:\n\\[Z_n=\\frac{\\overline {S{\\mathbf x}_n}-\\mathbb E[\\overline {S{\\mathbf x}_n}] }{\\sqrt{Var [\\overline {S{\\mathbf x}_n}] }}=\\frac{\\overline {S{\\mathbf x}_n}-\\sum_{k=1}^{n}\\mu_k}{B_n}\\] 的概率分布函 \\(F_n(x)\\) 对于任 \\(x\\) 满足：\n\\[\\lim_{n\\rightarrow \\infty}F_n(x)=\\lim_{n\\rightarrow \\infty}P\\{Z_n \\le x\\}\\\\ =\\lim_{n\\rightarrow \\infty}P\\{\\frac{\\sum_{k=1}^{n} {\\mathbf x}_k-\\sum_{k=1}^{n}\\mu_k}{B_n} \\le x\\}\\\\ = \\int_{-\\infty}^{x} \\frac{1}{\\sqrt{2\\pi}}e^{-t^{2}/ 2}dt=\\Phi(x)\\]\n其物理意义为：相互独立的随机变量 \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n,\\cdots\\) 之和 \\(\\overline {S{\\mathbf x}_n}=\\sum_{k=1}^{n} {\\mathbf x}_k\\) 的衍生随机变量序 \\(Z_n=\\frac{\\overline {S{\\mathbf x}_n}-\\sum_{k=1}^{n}\\mu_k}{B_n}\\) ，当 \\(n\\) 充分大时，其分布近似与标准正态分布。\n这里并不要求 \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n,\\cdots\\) 同分布\nDemoiver-Laplace定理：设随机变量序 \\(\\eta_n,n=1,2,...\\) 服从参数 \\(n, p(0 \\lt p \\lt 1)\\) 的二项分布，则对于任 \\(x\\) ,有：\n\\[\\lim_{n\\rightarrow \\infty}P\\{\\frac{\\eta_n-np}{\\sqrt{np(1-p)}} \\le x\\}=\\int_{-\\infty}^{x} \\frac{1}{\\sqrt{2\\pi}}e^{-t^{2}\\mid 2}dt=\\Phi(x)\\]\n该定理表明，正态分布是二项分布的极限分布。当 \\(n\\) 充分大时，可以利用正态分布来计算二项分布的概率。\n五、不确定性来源\n机器学习中不确定性有三个来源:\n模型本身固有的随机性。如量子力学中的粒子动力学方程。\n不完全的观测。即使是确定性系统，当无法观测所有驱动变量时，结果也是随机的。\n不完全建模。有时必须放弃一些观测信息。\n如机器人建模中：虽然可以精确观察机器人周围每个对象的位置；但在预测这些对象将来的位置时，对空间进行了离散化。则位置预测将带有不确定性。\n六、常见概率分布\n6.1 均匀分布\n离散随机变量的均匀分布：假 \\(\\mathbf x\\) \\(k\\) 个取值 \\(x_1,x_2,\\cdots,x_k\\) ，则均匀分布的概率密度函数(probability mass function:PMF)为：\n\\[P(\\mathbf x=x_i) =\\frac 1k,\\quad i=1,2,\\cdots,k\\]\n连续随机变量的均匀分布：假 \\(\\mathbf x\\) 在[a,b]上均匀分布，则其概率密度函数(probability density function：PDF)为：\n\\[p(\\mathbf x=x)=\\begin{cases} 0,&x\\notin [a,b]\\\\ \\frac{1}{b-a},&x \\in [a,b]\\\\ \\end{cases} \\]\n6.2 二项分布\n伯努利分布（二项分布）：参数 \\(\\phi\\in [0,1]\\) 。随机变 \\(\\mathbf x \\in \\{0,1\\}\\)\n概率分布函数为：\n\\[P(\\mathbf x=x)=\\phi^{x}(1-\\phi)^{1-x}\\;,x \\in \\{0,1\\}\\]\n期望： \\(\\mathbb E_{\\mathbf x}[x]=\\phi\\)\n方差： \\(Var_{\\mathbf x}[x]=\\phi(1-\\phi)\\)\ncategorical分布：它是二项分布的推广，也称作multinoulli分布。假设随机变 \\(\\mathbf x \\in \\{1,2,\\cdots,K\\}\\) ，其概率分布函数为：\n\\[P(\\mathbf x=1)=\\theta_1\\\\ P(\\mathbf x=2)=\\theta_2\\\\ \\vdots\\\\ P(\\mathbf x=K-1)=\\theta_{K-1}\\\\ P(\\mathbf x=K)=1-\\sum_{i=1}^{K-1}\\theta_i \\\\\\] 其 \\(\\theta_i\\) 为参数，它满 \\(\\theta_i \\in [0,1]\\) ， \\(\\sum_{i=1}^{K-1}\\theta_i \\in [0,1]\\) 。\n6.3 高斯分布\n6.3.1 一维正态分布\n正态分布的概率密度函数为:\n\\[p(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-(x-\\mu)^{2}/ (2\\sigma^{2})}, -\\infty \\lt x \\lt \\infty\\] 其 $\\mu,\\sigma(\\sigma \\gt 0) $ 为常数。\n若随机变量 \\({\\mathbf x}\\) 的概率密度函数如上所述，则称 \\({\\mathbf x}\\) 服从参数为 \\(\\mu,\\sigma\\) 的正态分布或者高斯分布，记作 \\({\\mathbf x} \\sim N(\\mu,\\sigma^{2})\\) 。\n特别的，当 \\(\\mu=0,\\sigma=1\\) 时，称为标准正态分布，其概率密度函数记作 \\(\\varphi(x)\\) , 分布函数记作 \\(\\Phi(x)\\)\n为了计算方便，有时也记作：\n\\[\\mathcal N(x;\\mu,\\beta^{-1}) =\\sqrt{\\frac{\\beta}{2\\pi}}\\exp\\left(-\\frac{1}{2}\\beta(x-\\mu)^{2}\\right)\\] 其 \\(\\beta \\in (0,\\infty)\\)\n正态分布是很多应用中的合理选择。如果某个随机变量取值范围是实数，且对它的概率分布一无所知，通常会假设它服从正态分布。有两个原因支持这一选择：\n建模的任务的真实分布通常都确实接近正态分布。中心极限定理表明，多个独立随机变量的和近似正态分布。\n在具有相同方差的所有可能的概率分布中，正态分布的熵最大（即不确定性最大）。\n正态分布的概率密度函数性质：\n曲线关于 \\(x=\\mu\\) 对称\n曲线在 \\(x=\\mu\\) 时取最大值\n曲线在 $x=\\mu \\pm \\sigma $ 处有拐点\n参 \\(\\mu\\) 决定曲线的位置 \\(\\sigma\\) 决定图形的胖瘦\n\\({\\mathbf x} \\sim N(\\mu,\\sigma^{2})\\) 则 \\(\\frac{{\\mathbf x}-\\mu}{\\sigma} \\sim N(0,1)\\)\n有限个相互独立的正态随机变量的线性组合仍然服从正态分布。\n正态分布的期望就 \\(\\mu\\) ，方差就 \\(\\sigma^{2}\\)\n若随机变 \\({\\mathbf x}_i \\sim N(\\mu_i,\\sigma_i^{2}),i=1,2,\\cdots,n\\) 且它们相互独立，则它们的线性组合：\n\\(C_1{\\mathbf x}_1+C_2{\\mathbf x}_2+\\cdots+C_n{\\mathbf x}_n\\) 其中 \\(C_1,C_2,\\cdots,C_n\\) 不全是为0的常数）仍然服从正态分布，且：\n\\[C_1{\\mathbf x}_1+C_2{\\mathbf x}_2+\\cdots+C_n{\\mathbf x}_n \\sim N(\\sum_{i=1}^{n}C_i\\mu_i,\\sum_{i=1}^{n}C_i^{2}\\sigma_i^{2})\\]\n6.3.2 多维正态分布\n二维正态随机变 \\(({\\mathbf x}_1,{\\mathbf x}_2)\\) 的概率密度为：\n\\[p(x_1,x_2)=\\\\ \\frac{1}{2\\pi\\sigma_1\\sigma_2\\sqrt{1-\\rho^{2}}}\\exp\\{\\frac{-1}{2(1-\\rho^{2})}[\\frac{(x_1-\\mu_1)^{2}}{\\sigma_1^{2}}-2\\rho\\frac{(x_1-\\mu_1)(x_2-\\mu_2)}{\\sigma_1\\sigma_2}+\\frac{(x_2-\\mu_2)^{2}}{\\sigma_2^{2}}]\\}\\] 可以计算出:\n\\[p_{\\mathbf x}(x)=\\frac{1}{\\sqrt{2\\pi}\\sigma_1}e^{-(x-\\mu_1)^{2}/ (2\\sigma_1^{2})}, -\\infty \\lt x \\lt \\infty \\\\ p_{\\mathbf y}(y)=\\frac{1}{\\sqrt{2\\pi}\\sigma_2}e^{-(y-\\mu_2)^{2}/ (2\\sigma_2^{2})}, -\\infty \\lt y \\lt \\infty\\\\ \\mathbb E[{\\mathbf x}] =\\mu_1 \\\\ \\mathbb E[{\\mathbf y}] =\\mu_2 \\\\ Var[{\\mathbf x}] =\\sigma_1^{2} \\\\ Var[{\\mathbf y}]=\\sigma_2^{2}\\\\ Cov[{\\mathbf x},{\\mathbf y}]=\\int_{-\\infty}^{\\infty}\\int_{-\\infty}^{\\infty}(x-\\mu_1)(y-\\mu_2)p(x,y)dxdy=\\rho \\sigma_1\\sigma_2\\\\ \\rho_{{\\mathbf x}{\\mathbf y}}=\\rho\\]\n引入矩阵：\n\\[\\mathbf{\\vec {\\mathbf x}}=\\begin{bmatrix} x_1 \\\\ x_2 \\end{bmatrix} \\quad \\mathbf{\\vec \\mu}=\\begin{bmatrix} \\mu_1 \\\\ \\mu_2 \\end{bmatrix}\\\\ \\mathbf{\\Sigma}=\\begin{bmatrix} c_{11} &c_{12}\\\\ c_{21} &c_{22} \\end{bmatrix} = \\begin{bmatrix} \\sigma_1^{2} & \\rho \\sigma_1 \\sigma_2 \\\\ \\rho \\sigma_1 \\sigma_2 & \\sigma_2^{2} \\end{bmatrix}\\] \\(\\mathbf \\Sigma\\) \\(({\\mathbf x}_1,{\\mathbf x}_2)\\) 的协方差矩阵。其行列式 \\(\\det \\mathbf{\\Sigma} =\\sigma_1^{2}\\sigma_2^{2}(1-\\rho^{2})\\) ，其逆矩阵为：\n\\[\\mathbf{\\Sigma}^{-1}=\\frac{1}{\\det\\mathbf \\Sigma}\\begin{bmatrix} \\sigma_2^{2} & -\\rho \\sigma_1 \\sigma_2 \\\\ -\\rho \\sigma_1 \\sigma_2 & \\sigma_1^{2} \\end{bmatrix}\\] 于 \\(({\\mathbf x}_1,{\\mathbf x}_2)\\) 的概率密度函数可以写 \\(( \\mathbf {\\vec {\\mathbf x}}- \\mathbf {\\vec \\mu})^{T}\\) 表示矩阵的转置：\n\\[p(x_1,x_2)=\\frac{1}{(2\\pi)(\\det \\mathbf \\Sigma)^{1/ 2}}\\exp\\{- \\frac 12 ( \\mathbf {\\vec {\\mathbf x}}- \\mathbf {\\vec \\mu})^{T} \\mathbf \\Sigma^{-1}( \\mathbf {\\vec {\\mathbf x}}- \\mathbf {\\vec \\mu})\\}\\] 其中均 \\(\\mu_1,\\mu_2\\) 决定了曲面的位置（本例中均值都为0）。标准 \\(\\sigma_1,\\sigma_2\\) 决定了曲面的陡峭程度（本例中方差都为1）。 \\(\\rho\\) 决定了协方差矩阵的形状，从而决定了曲面的形状\n\\(\\rho=0\\) 时，协方差矩阵对角线非零，其他位置均为零。此时表示随机变量之间不相关。此时的联合分布概率函数形状如下图所示，曲面在 \\(z=0\\) 平面的截面是个圆形：\n\\(\\rho=0.5\\) 时，协方差矩阵对角线非零，其他位置均为零。此时表示随机变量之间相关。此时的联合分布概率函数形状如下图所示，曲面在 \\(z=0\\) 平面的截面是个椭圆，相当于圆形沿着直线 \\(y=x\\) 方向压缩 ：\n\\(\\rho=1\\) 时，协方差矩阵对角线非零，其他位置均为零。此时表示随机变量之间完全相关。此时的联合分布概率函数形状为：曲面在 \\(z=0\\) 平面的截面是直线 \\(y=x\\) ，相当于圆形沿着直线 \\(y=x\\) 方向压缩成一条直线 。由于 \\(\\rho=1\\) 会导致除数为 0，因此这里给出 \\(\\rho=0.9\\) ：\n多维正态随机变 \\(({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n)\\) ，引入列矩阵：\n\\[\\mathbf{\\vec {\\mathbf x}}=\\begin{bmatrix} x_1 \\\\ x_2 \\\\ \\vdots\\\\ x_n \\end{bmatrix} \\quad \\mathbf{\\vec \\mu}=\\begin{bmatrix} \\mu_1 \\\\ \\mu_2\\\\ \\vdots\\\\ \\mu_n \\end{bmatrix}=\\begin{bmatrix} \\mathbb E[{\\mathbf x}_1] \\\\ \\mathbb E[{\\mathbf x}_2] \\\\ \\vdots\\\\ \\mathbb E[{\\mathbf x}_n] \\end{bmatrix}\\] \\(\\mathbf \\Sigma\\) \\(({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n)\\) 的协方差矩阵。则\n\\[p(x_1,x_2,x_3,\\cdots,x_n)=\\frac {1}{(2\\pi)^{n/2}(\\det \\mathbf \\Sigma)^{1/2}} \\exp \\{- \\frac 12( \\mathbf {\\vec {\\mathbf x}}- \\mathbf {\\vec \\mu})^{T}\\mathbf \\Sigma^{-1}( \\mathbf {\\vec {\\mathbf x}}- \\mathbf {\\vec \\mu})\\}\\] 记做\n\\[\\mathcal N(\\mathbf{\\vec x};\\mathbf{\\vec \\mu},\\mathbf\\Sigma) =\\sqrt{\\frac{1}{(2\\pi)^{n}det(\\mathbf\\Sigma)}}\\exp\\left(-\\frac 12(\\mathbf{\\vec x-\\vec \\mu})^{T}\\mathbf\\Sigma^{-1}(\\mathbf{\\vec x-\\vec \\mu})\\right)\\]\n\\(n\\) 维正态变量具有下列四条性质：\n\\(n\\) 维正态变量的每一个分量都是正态变量；反之， \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n\\) 都是正态变量，且相互独立， \\(({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n)\\) \\(n\\) 维正态变量\n\\(n\\) 维随机变 \\(({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n)\\) 服 \\(n\\) 维正态分布的充要条件 \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n\\) 的任意线性组合 \\(l_1{\\mathbf x}_1+l_2{\\mathbf x}_2+\\cdots+l_n{\\mathbf x}_n\\) 服从一维正态分布，其 \\(l_1,l_2,\\cdots,l_n\\) 不全为0\n\\(({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n)\\) 服 \\(n\\) 维正态分布， \\({\\mathbf y}_1,{\\mathbf y}_2,\\cdots,{\\mathbf y}_k\\) \\({\\mathbf x}_j,j=1,2,\\cdots,n\\) 的线性函数， \\(({\\mathbf y}_1,{\\mathbf y}_2,\\cdots,{\\mathbf y}_k)\\) 也服从多维正态分布\n这一性质称为正态变量的线性变换不变性\n\\(({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n)\\) 服 \\(n\\) 维正态分布， \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n\\) 相互独 \\(\\Longleftrightarrow\\) \\({\\mathbf x}_1,{\\mathbf x}_2,\\cdots,{\\mathbf x}_n\\) 两两不相关\n6.4 指数分布\n指数分布：\n概率密度函数：\n\\[p(x;\\lambda)=\\begin{cases} 0,& x\\lt0\\\\ \\frac{\\lambda}{\\exp(\\lambda x)},& x\\ge0\\\\ \\end{cases} \\]\n期望： \\(\\mathbb E_{\\mathbf x}[x]=\\frac{1}{\\lambda}\\)\n方差： \\(Var_{\\mathbf x}[x]=\\frac{1}{\\lambda^{2}}\\)\n6.5 拉普拉斯分布\n拉普拉斯分布：\n概率密度函数：\n\\[p(x;\\mu,\\gamma)=\\frac{1}{2\\gamma}\\exp\\left(-\\frac{|x-\\mu|}{\\gamma}\\right) \\]\n期望： \\(\\mathbb E_{\\mathbf x}[x]=\\mu\\)\n方差： \\(Var_{\\mathbf x}[x]=2\\gamma^{2}\\)\n6.6 狄拉克分布\n狄拉克分布：假设所有的概率都集中在一 \\(\\mu\\) 上，则对应的概率密度函数为：\n\\[p(x)=\\delta(x-\\mu) \\] 其 \\(\\delta(\\cdot)\\) 为狄拉克函数，其性质为：\n\\[\\delta(x)=0,\\forall x\\neq 0 \\int_{-\\infty}^{\\infty}\\delta(x)dx=1 \\]\n狄拉克分布的一个典型用途就是定义连续型随机变量的经验分布函数。假设数据集中有样 \\(\\mathbf{\\vec x}_1,\\mathbf{\\vec x}_2,\\cdots,\\mathbf{\\vec x}_N\\) ，则定义经验分布函数：\n\\[\\hat p(\\mathbf{\\vec x})=\\frac 1N\\sum_{i=1}^{N}\\delta(\\mathbf{\\vec x}-\\mathbf{\\vec x}_i)\\] 它就是对每个样本赋予了一个概率质 \\(\\frac 1N\\) 。\n对于离散型随机变量的经验分布，则经验分布函数就是multinoulli分布，它简单地等于训练集中的经验频率。\n经验分布的两个作用：\n通过查看训练集样本的经验分布，从而指定该训练集的样本采样的分布（保证采样之后的分布不失真）\n经验分布就是使得训练数据的可能性最大化的概率密度函数\n6.7 多项式分布与狄里克雷分布\n多项式分布的质量密度函数：\n\\[Mult(m_1,m_2,\\cdots,m_K;\\vec\\mu,N)=\\frac{N!}{m_1!m_2!\\cdots m_K!}\\prod_{k=1}^{K}\\mu_k^{m_k}\\] 它 \\((\\mu_1+\\mu_2+\\cdots+\\mu_K)^{m_1+m_2+\\cdots+m_K}\\) 的多项式展开的形式\n狄利克雷分布的概率密度函数：\n\\[Dir(\\vec\\mu;\\vec\\alpha)=\\frac{\\Gamma(\\sum_{k=1}^{K}\\alpha_k)}{\\sum_{k=1}^{K}\\Gamma(\\alpha_k)}\\prod_{k=1}^{K}\\mu_k^{\\alpha_k-1}\\]\n可以看到，多项式分布与狄里克雷分布的概率密度函数非常相似，区别仅仅在于前面的归一化项\n多项式分布是针对离散型随机变量，通过求和获取概率\n狄里克雷分布时针对连续型随机变量，通过求积分来获取概率\n6.8 混合概率分布\n混合概率分布：它组合了其他几个分量的分布来组成。\n在每次生成样本中，首先通过multinoulli分布来决定选用哪个分量，然后由该分量的分布函数来生成样本。\n其概率分布函数为：\n\\[P(\\mathbf x)=\\sum_{i}P(c=i)P(\\mathbf x\\mid c=i)\\] 其 \\(P(c=i)\\) 为一个multinoulli分布 \\(c\\) 的取值范围就是各分量的编号。\n前面介绍的连续型随机变量的经验分布函数就是一个混合概率分布的例子，此 \\(P(c=i)=\\frac 1N\\)\n混合概率分布可以通过简单的概率分布创建更复杂的概率分布\n一个常见的例子是混合高斯模型，其 \\(P(\\mathbf x\\mid c=i)\\) 为高斯模型。每个分量都有对应的参 \\((\\mathbf{\\vec \\mu}_i,\\mathbf \\Sigma_i)\\)\n有些混合高斯模型有更强的约束，如 \\(\\forall i,\\mathbf \\Sigma_i=\\mathbf\\Sigma\\) ，更进一步还可以要求 \\(\\mathbf\\Sigma\\) 为一个对角矩阵。\n混合高斯模型是一个通用的概率密度函数逼近工具。任何平滑的概率密度函数都可以通过足够多分量的混合高斯模型来逼近。\n七、先验分布与后验分布\n在贝叶斯学派中，先验分布+数据（似然）= 后验分布\n例如：假设需要识别一大箱苹果中的好苹果、坏苹果的概率。\n根据你对苹果好、坏的认知，给出先验分布为：50个好苹果和50个坏苹果\n现在你拿出10个苹果，发现有：8个好苹果，2个坏苹果。\n根据数据，你得到后验分布为：58个好苹果，52个坏苹果\n再拿出10个苹果，发现有：9个好苹果，1个坏苹果。\n根据数据，你得到后验分布为：67个好苹果，53个坏苹果\n这样不断重复下去，不断更新后验分布。当一箱苹果清点完毕，则得到了最终的后验分布。\n在这里：\n如果不使用先验分布，仅仅清点这箱苹果中的好坏，则得到的分布只能代表这一箱苹果。\n采用了先验分布之后得到的分布，可以认为是所有箱子里的苹果的分布。\n先验分布时：给出的好、坏苹果的个数（也就是频数）越大，则先验分布越占主导地位。\n假设好苹果的概率 \\(p\\) ，则抽 \\(N\\) 个苹果中，好苹果个数 \\(k\\) 个的概率为一个二项分布：\n\\[Binom(k\\mid p;N)=C_N^kp^k(1-p)^{N-k}\\] 其 \\(C_N^k\\) 为组合数。\n现在的问题是：好苹果的概 \\(p\\) 不再固定，而是服从一个分布。\n假设好苹果的概 \\(p\\) 的先验分布为贝塔分布\n\\[Beta(p; \\alpha,\\beta)=\\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha)\\Gamma(\\beta)}p^{\\alpha-1}(1-p)^{\\beta-1}\\]\n则后验概率为：\n\\[P(p\\mid k; N,\\alpha,\\beta)=\\frac{P(k\\mid p; N)\\times P(p; \\alpha,\\beta)}{P(k; N,\\alpha,\\beta)} \\\\ \\propto P(k\\mid p; N)\\times P(p; \\alpha,\\beta)=C_N^kp^k(1-p)^{N-k}\\times \\frac{\\Gamma(\\alpha+\\beta)}{\\Gamma(\\alpha)\\Gamma(\\beta)}p^{\\alpha-1}(1-p)^{\\beta-1}\\\\ \\propto p^{k+\\alpha-1}(1-p)^{N-k+\\beta-1}\\] 归一化之后，得到后验概率为：\n\\[P(p\\mid k;N,\\alpha,\\beta)=\\frac{\\Gamma(\\alpha+\\beta+N)}{\\Gamma(\\alpha+k)\\Gamma(\\beta+N-k)}p^{k+\\alpha-1}(1-p)^{N-k+\\beta-1} \\]\n好苹果概 \\(p\\) 的先验分布的期望为：\n\\[\\mathbb E[p]=\\frac{\\alpha}{\\alpha+\\beta}\\] 好苹果概 \\(p\\) 的后验分布的期望为：\n\\[\\mathbb E[p\\mid k]=\\frac{\\alpha+k}{\\alpha+\\beta+N}\\]\n根据上述例子所述：\n好苹果的先验概率的期望为 \\(\\frac {50}{50+50}=\\frac 12\\)\n进行第一轮数据校验之后，好苹果的后验概率的期望为 \\(\\frac {50+8}{50+50+10}=\\frac {58}{110}\\)\n如果 \\(\\alpha\\) 视为先验的好苹果数量 \\(\\beta\\) 视为先验的坏苹果数量 \\(N\\) 表示箱子中苹果的数量 \\(k\\) 表示箱子中的好苹果数量（相应的 \\(N-k\\) 就是箱子中坏苹果的数量）。则：好苹果的先验概率分布的期望、后验概率分布的期望符合人们的生活经验。\n这里使用先验分布和后验分布的期望，因 \\(p\\) 是一个随机变量。若想通过一个数值来刻画好苹果的可能性，则用期望较好。\n更一般的，如果苹果不仅仅分为好、坏两种，而是分作“尺寸1、尺寸2、...尺 \\(K\\) ”等。 \\(N\\) 个苹果中， \\(m_1\\) 个尺寸1的苹果 \\(m_2\\) 个尺寸2的苹果... \\(m_K\\) 个尺 \\(K\\) 的苹果的概率服从多项式分布：\n\\[Mult(m_1,m_2,\\cdots,m_K;\\vec\\mu,N)=\\frac{N!}{m_1!m_2!\\cdots m_K!}\\prod_{k=1}^{K}\\mu_k^{m_k}\\] 其中苹果为尺寸1的概率 \\(\\mu_1\\) ，尺寸2的概率 \\(\\mu_2\\) ，...尺 \\(K\\) 的概率 \\(\\mu_K\\) \\(N=\\sum_{k=1}^Km_k\\)\n假设苹果尺寸的先验概率分布为狄利克雷分布：\n\\[Dir(\\vec\\mu;\\vec\\alpha)=\\frac{\\Gamma(\\sum_{k=1}^{K}\\alpha_k)}{\\sum_{k=1}^{K}\\Gamma(\\alpha_k)}\\prod_{k=1}^{K}\\mu_k^{\\alpha_k-1}\\] 苹果尺寸的先验概率分布的期望为：\n\\[\\mathbb E[\\vec\\mu]=\\left(\\frac{\\alpha_1}{\\sum_{k=1}^K\\alpha_k},\\frac{\\alpha_2}{\\sum_{k=1}^K\\alpha_k},\\cdots,\\frac{\\alpha_K}{\\sum_{k=1}^K\\alpha_k}\\right)\\]\n则苹果尺寸的后验概率分布也为狄里克雷分布：\n\\[Dir(\\vec\\mu;\\vec\\alpha+\\mathbf{\\vec m})=\\frac{\\Gamma(N+\\sum_{k=1}^{K}\\alpha_k)}{\\sum_{k=1}^{K}\\Gamma(\\alpha_k+m_k)}\\prod_{k=1}^{K}\\mu_k^{\\alpha_k+m_k-1}\\] 苹果尺寸的后验概率分布的期望为：\n\\[\\mathbb E[\\vec\\mu]=\\left(\\frac{\\alpha_1+m_1}{N+\\sum_{k=1}^K\\alpha_k},\\frac{\\alpha_2+m_2}{N+\\sum_{k=1}^K\\alpha_k},\\cdots,\\frac{\\alpha_K+m_K}{N+\\sum_{k=1}^K\\alpha_k}\\right)\\]\n八、测度论\n测度为零：非正式化的提法是，如果集合中的点的数量可以忽略不计，则该集合的测度为零。\n如：二维空间中的直线的测度为零，而正方形的测度非零。\n几乎处处相等：不满足条件的那些点组成的集合的测度为零。\n假设随机变 \\(\\mathbf x,\\mathbf y\\) 满 \\(\\mathbf y=g(\\mathbf x)\\) ，且函 \\(g(\\cdot)\\) 满足：处处连续、可导、且存在反函数。\n则有：\n\\[p_{\\mathbf x}(x)=p_{\\mathbf y}(g(x)) \\left|\\frac{\\partial g(x)}{\\partial x}\\right|\\] 或者等价地：\n\\[p_{\\mathbf y}(y)=p_{\\mathbf x}(g^{-1}(y)) \\left|\\frac{\\partial x}{\\partial y}\\right| \\]\n如果扩展到高维空间，则有：\n\\[p_{\\mathbf x}(\\mathbf{\\vec x})=p_{\\mathbf y}(g(\\mathbf{\\vec x})) \\left|\\det\\left(\\frac{\\partial g(\\mathbf{\\vec x})}{\\partial \\mathbf{\\vec x}}\\right)\\right|\\]\n并不 \\(p_{\\mathbf y}(y)=p_{\\mathbf x}(g^{-1}(y))\\) ，这是因 \\(g(\\cdot)\\) 引起了空间扭曲，从而导 \\(\\int p_{\\mathbf x}(g(x))dx \\neq 1\\) 。其实我们有：\n\\[|p_{\\mathbf y}(g(x))dy|=|p_{\\mathbf x}(x)dx|\\] 求解该方程，即得到上述解。\n九、信息论\n信息论背后的原理是：从不太可能发生的事件中能学到更多的有用信息。\n发生可能性较大的事件包含较少的信息\n发生可能性较小的事件包含较多的信息\n独立事件包含额外的信息\n对于事 \\(\\mathbf x=x\\) ，定义自信息self-information为：\n\\[I(x)=-\\log P(x) \\]\n自信息仅仅处理单个输出，但是如果计算自信息的期望，它就是熵：\n\\[H(\\mathbf x)=\\mathbb E_{\\mathbf x\\sim P}[I(x)]=-\\mathbb E_{\\mathbf x\\sim P}[\\log P(x)]\\] 记 \\(H(P)\\) 。\n熵刻画了按照真实分 \\(P\\) 来识别一个样本所需要的编码长度的期望（即平均编码长度）。\n如：含有4个字母(A,B,C,D)的样本集中，真实分 \\(P=(\\frac 12,\\frac 12,0,0)\\) ，则只需要1位编码即可识别样本。\nKL散度：对于给定的随机变 \\(\\mathbf x\\) ,它的两个概率分布函 \\(P(x)\\) \\(Q(x)\\) 的区别可以用KL散度来度量：\n\\[D_{KL}(P||Q)=\\mathbb E_{\\mathbf x\\sim P}\\left[\\log \\frac{P(x)}{Q(x)}\\right]=\\mathbb E_{\\mathbf x\\sim P}\\left[\\log P(x) -\\log Q(x) \\right]\\]\nKL散度非负。当它为0时，当且仅当 P和Q是同一个分布（对于离散型随机变量），或者两个分布几乎处处相等（对于连续型随机变量）\n\\(D_{KL}(P||Q) \\neq D_{KL}(Q||P)\\)\n交叉熵cross-entropy \\(H(P,Q)=H(P)+D_{KL}(P||Q)=-\\mathbb E_{\\mathbf x\\sim P}\\log Q(x)\\) 。\n交叉熵刻画了使用错误分 \\(Q\\) 来表示真实分 \\(P\\) 中的样本的平均编码长度。\n\\(D_{KL(P||Q)}\\) 刻画了错误分 \\(Q\\) 编码真实分 \\(P\\) 带来的平均编码长度的增量。\n数值计算\n一、数值稳定性\n1.1 近似误差\n在计算机中执行数学运算需要使用有限的比特位来表达实数，这会引入近似误差\n近似误差可以在多步数值运算中传递、积累，从而导致理论上成功的算法失败\n数值算法设计时要考虑将累计误差最小化\n上溢出overflow和下溢出underflow：\n一种严重的误差是下溢出：当接近零的数字四舍五入为零时，发生下溢出\n许多函数在参数为零和参数为一个非常小的正数时，行为是不同的。如对数函数要求自变量大于零；除法中要求除数非零。\n另一种严重的误差是上溢出：当数值非常大，超过了计算机的表示范围时，发生上溢出。\n1.2 softmax 函数\n一个数值稳定性的例子是softmax函数。\n\\(\\mathbf{\\vec x}=(x_1,x_2,\\cdots,x_n)^{T}\\) ，则softmax函数定义为：\n\\[\\text{softmax}(\\mathbf{\\vec x})=\\left(\\frac{\\exp(x_1)}{\\sum_{j=1}^{n}\\exp(x_j)},\\frac{\\exp(x_2)}{\\sum_{j=1}^{n}\\exp(x_j)},\\cdots,\\frac{\\exp(x_n)}{\\sum_{j=1}^{n}\\exp(x_j)}\\right)^{T} \\] 当所有 \\(x_i\\) 都等于常 \\(c\\) 时，softmax函数的每个分量的理论值都 \\(\\frac 1n\\)\n考虑 \\(c\\) 是一个非常大的负数（比如趋近负无穷），此时 \\(\\exp( c)\\) 下溢出。此时 $ \\frac{\\exp(c )}{\\sum_{j=1}^{n}\\exp(c )}$ 分母为零，结果未定义。\n考虑 \\(c\\) 是一个非常大的正数（比如趋近正无穷），此时 \\(\\exp( c)\\) 上溢出。 $ \\frac{\\exp(c )}{\\sum_{j=1}^{n}\\exp(c )}$ 的结果未定义。\n解决的办法是： \\(\\mathbf{\\vec z}=\\mathbf{\\vec x}-\\max_i x_i\\) ，则 $\\text{softmax}(\\mathbf{\\vec z}) $ 的 \\(i\\) 个分量为：\n\\[\\text{softmax}(\\mathbf{\\vec z})_i=\\frac{\\exp(z_i)}{\\sum_{j=1}^{n}\\exp(z_j)}=\\frac{\\exp(\\max_k x_k)\\exp(z_i)}{\\exp(\\max_k x_k)\\sum_{j=1}^{n}\\exp(z_j)}\\\\ =\\frac{\\exp(z_i+\\max_k x_k)}{\\sum_{j=1}^{n}\\exp(z_j+\\max_k x_k)}\\\\ =\\frac{\\exp(x_i)}{\\sum_{j=1}^{n}\\exp(x_j)}\\\\ =\\text{softmax}(\\mathbf{\\vec x})_i\\]\n当 $\\mathbf{\\vec x} $ 的分量较小时， $\\mathbf{\\vec z} $ 的分量至少有一个为零，从而导致 \\(\\text{softmax}(\\mathbf{\\vec z})_i\\) 的分母至少有一项为 1，从而解决了下溢出的问题。\n当 $\\mathbf{\\vec x} $ 的分量较大时 \\(\\text{softmax}(\\mathbf{\\vec z})_i\\) 相当于分子分母同时除以一个非常大的数 \\(\\exp(\\max_i x_i)\\) ，从而解决了上溢出。\n还有个问题： $\\mathbf{\\vec x} $ 的分量较小时 \\(\\text{softmax}(\\mathbf{\\vec x})_i\\) 的计算结果可能为0。\n此 \\(\\log \\text{softmax}(\\mathbf{\\vec x})\\) 趋向于负无穷，非数值稳定的。因此需要设计专门的函数来计 \\(\\log\\text{softmax}\\) ，而不是 \\(\\text{softmax}\\) 的结果传递 \\(\\log\\) 函数。\n通常 \\(\\text{softmax}\\) 函数的输出作为模型的输出。由于一般使用样本的交叉熵作为目标函数，因此需要用 \\(\\text{softmax}\\) 输出的对数。\n当从头开始实现一个数值算法时，需要考虑数值稳定性。\n当使用现有的数值计算库时，不需要考虑数值稳定性。\nsoftmax名字的来源是hardmax。\nhardmax把一个向 $\\mathbf{\\vec x} $ 映射成向 \\((0,\\cdots,0,1,0,\\cdots,0)^T\\) 。即 \\(\\mathbf{\\vec x}\\) 最大元素的位置填充1，其它位置填充0。\nsoftmax会在这些位置填充0.0~1.0之间的值（如：某个概率值）。\n二、Conditioning\nConditioning刻画了一个函数的如下特性：当函数的输入发生了微小的变化时，函数的输出的变化有多大。\n对于Conditioning较大的函数，在数值计算中可能有问题。因为函数输入的舍入误差可能导致函数输出的较大变化。\n对于方 \\(\\mathbf A\\in \\mathbb R^{n\\times n}\\) ，其条件数condition number为：\n\\[\\text{condition number}=\\max_{1\\le i,j\\le n,i\\ne j}\\left|\\frac{\\lambda_i}{\\lambda_j} \\right|\\] 其 \\(\\lambda_i,i=1,2,\\cdots,n\\) \\(\\mathbf A\\) 的特征值。\n方阵的条件数就是最大的特征值除以最小的特征值。\n当方阵的条件数很大时，矩阵的求逆将对误差特别敏感（即： \\(\\mathbf A\\) 的一个很小的扰动，将导致其逆矩阵一个非常明显的变化）。\n条件数是矩阵本身的特性，它会放大那些包含矩阵求逆运算过程中的误差。\n三、梯度下降法\n梯度下降法是求解无约束最优化问题的一种常见方法，优点是实现简单\n对于函数 \\(f:\\mathbb R^{n} \\rightarrow \\mathbb R\\) ，输入为多维的。假设输 \\(\\mathbf{\\vec x}=(x_1,x_2,\\cdots,x_n)^{T}\\) ，则定义梯度：\n\\[\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})=\\left(\\frac{\\partial}{\\partial x_1}f(\\mathbf{\\vec x}),\\frac{\\partial}{\\partial x_2}f(\\mathbf{\\vec x}),\\cdots,\\frac{\\partial}{\\partial x_n}f(\\mathbf{\\vec x})\\right)^{T}\\]\n驻点满足： \\(\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})=\\mathbf{\\vec 0}\\)\n沿着方 \\(\\mathbf{\\vec u}\\) 的方向导数directional derivative定义为：\n\\[\\lim_{\\alpha\\rightarrow 0}\\frac{f(\\mathbf{\\vec x}+\\alpha\\mathbf{\\vec u})-f(\\mathbf{\\vec x})}{\\alpha} \\] 其 \\(\\mathbf{\\vec u}\\) 为单位向量。\n方向导数就是 \\(\\frac{\\partial}{\\partial \\alpha}f(\\mathbf{\\vec x}+\\alpha\\mathbf{\\vec u})\\) 。根据链式法则，它也等于 \\(\\mathbf{\\vec u}^{T}\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})\\)\n为了最小 \\(f\\) ，则寻找一个方向：沿着该方向，函数值减少的速度最快（换句话说，就是增加最慢）。即：\n\\[\\min_{\\mathbf{\\vec u}} \\mathbf{\\vec u}^{T}\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})\\\\ s.t.\\quad ||\\mathbf{\\vec u}||_2=1\\]\n假 \\(\\mathbf{\\vec u}\\) 与梯度的夹角 \\(\\theta\\) ，则目标函数等于：\n\\[||\\mathbf{\\vec u}||_2||\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})||_2 \\cos\\theta\\] 考虑 \\(||\\mathbf{\\vec u}||_2=1\\) ，以及梯度的大小 \\(\\theta\\) 无关，于是上述问题转化为：\n\\[\\min_\\theta \\cos\\theta\\] 于是 \\(\\theta^{*}=\\pi\\) ， \\(\\mathbf{\\vec u}\\) 沿着梯度的相反的方向。\n即：梯度的方向是函数值增加最快的方向，梯度的相反方向是函数值减小的最快的方向。\n可以沿着负梯度的方向来降 \\(f\\) 的值，这就是梯度下降法。\n根据梯度下降法，为了寻 \\(f\\) 的最小点，迭代过程为：\n\\[\\mathbf{\\vec x}^{\\prime}= \\mathbf{\\vec x}-\\epsilon\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})\\] 迭代结束条件为：梯度向 \\(\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})\\) 的每个成分为零或者非常接近零。\n\\(\\epsilon\\) 为学习率，它是一个正数，决定了迭代的步长。\n选择学习率有多种方法：\n一种方法是：选 \\(\\epsilon\\) 为一个小的、正的常数\n另一种方法是：给定多 \\(\\epsilon\\) ，然后选择使 \\(f(\\mathbf{\\vec x}-\\epsilon\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x}))\\) 最小的那个值作为本次迭代的学习率（即：选择一个使得目标函数下降最大的学习率）。这种做法叫做线性搜索line search\n第三种方法是：求得 \\(f(\\mathbf{\\vec x}-\\epsilon\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x}))\\) 取极小值 \\(\\epsilon\\) ，即求解最优化问题：\n\\[\\epsilon^{*}=\\arg\\min_{\\epsilon,\\epsilon \\gt 0 }f(\\mathbf{\\vec x}-\\epsilon\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x}))\\] 这种方法也称作最速下降法。\n在最速下降法中，假设相邻的三个迭代点分别为 \\(\\mathbf{\\vec x}^{<k>},\\mathbf{\\vec x}^{<k+1>},\\mathbf{\\vec x}^{<k+2>}\\) ，可以证明 \\((\\mathbf{\\vec x}^{<k+1>}-\\mathbf{\\vec x}^{<k>})\\cdot (\\mathbf{\\vec x}^{<k+2>}-\\mathbf{\\vec x}^{<k+1>})=0\\) 。即相邻的两次搜索的方向是正交的！\n证明：\n\\[\\mathbf{\\vec x}^{<k+1>}=\\mathbf{\\vec x}^{<k>}-\\epsilon^{<k>}\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x}^{<k>})\\\\ \\mathbf{\\vec x}^{<k+2>}=\\mathbf{\\vec x}^{<k+1>}-\\epsilon^{<k+1>}\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x}^{<k+1>})\\\\\\] 根据最优化问题，有：\n\\[\\epsilon^{<k+1>}=\\arg\\min_{\\epsilon,\\epsilon \\gt 0 }f(\\mathbf{\\vec x}^{<k+1>}-\\epsilon\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x}^{<k+1>}))\\\\ \\rightarrow \\frac{\\partial f(\\mathbf{\\vec x}^{<k+1>}-\\epsilon\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x}^{<k+1>})) }{\\partial \\epsilon}\\mid_{\\epsilon=\\epsilon^{<k+1>}}=0\\\\ \\rightarrow \\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x}^{<k+2>})\\cdot \\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x}^{<k+1>})=0\\\\ \\rightarrow (\\mathbf{\\vec x}^{<k+1>}-\\mathbf{\\vec x}^{<k>})\\cdot (\\mathbf{\\vec x}^{<k+2>}-\\mathbf{\\vec x}^{<k+1>})=0\\]\n此时迭代的路线是锯齿形的，因此收敛速度较慢\n某些情况下如果梯度向 \\(\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})\\) 的形式比较简单，则可以直接求解方程：\n\\[\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})=\\mathbf{\\vec 0}\\]\n此时不用任何迭代，直接获得解析解。\n梯度下降算法：\n输入：\n目标函数 \\(f(\\mathbf {\\vec x})\\)\n梯度函数 $g(\\mathbf {\\vec x})=\\nabla f(\\mathbf {\\vec x}) $\n计算精度 \\(e\\)\n输出 \\(f(\\mathbf {\\vec x})\\) 的极小 \\(\\mathbf {\\vec x}^*\\)\n算法步骤：\n选取初始 \\(\\mathbf {\\vec x}^{<0>}\\in \\mathbb R^{n}\\) , \\(k=0\\)\n计 \\(f(\\mathbf {\\vec x}^{<k>})\\)\n计算梯 \\(\\mathbf {\\vec g}_k=g(\\mathbf {\\vec x}^{<k>})\\)\n若梯 \\(|\\mathbf {\\vec g}_k| \\lt e\\) ，则停止迭代 \\(\\mathbf {\\vec x}^*=\\mathbf {\\vec x}\\)\n即此时导数为0\n若梯 \\(|\\mathbf {\\vec g}_k| \\ge e\\) ，则 \\(\\mathbf {\\vec p}_k=-\\mathbf {\\vec g}_k\\) ， \\(\\epsilon_k\\) \\(\\epsilon_k =\\min_{\\epsilon \\le 0}f(\\mathbf {\\vec x}^{<k>}+\\epsilon \\mathbf {\\vec p}_k)\\)\n通常这也是个最小化问题。但是可以给定一系列 \\(\\epsilon_k\\) 的值：如[10,1,0.1,0.01,0.001,0.0001]然后从中挑选\n\\(\\mathbf {\\vec x}^{<k+1>} = \\mathbf {\\vec x}^{<k>}+\\epsilon_k \\mathbf {\\vec p}_k\\) ，计 \\(f(\\mathbf {\\vec x}^{<k+1>})\\)\n若 \\(|f(\\mathbf {\\vec x}^{<k+1>})-f(\\mathbf {\\vec x}^{<k>})| \\lt e\\) 或者 \\(|\\mathbf {\\vec x}^{<k+1>}-\\mathbf {\\vec x}^{<k>}| \\lt e\\) 时，停止迭代 \\(\\mathbf {\\vec x}^*=\\mathbf {\\vec x}\\)\n否则，令 \\(k=k+1\\) ，计算梯度 \\(\\mathbf {\\vec g}_k=g(\\mathbf {\\vec x}^{<k>})\\) 继续迭代\n当目标函数是凸函数时，梯度下降法的解是全局最优的。\n通常情况下，梯度下降法的解不保证是全局最优的\n梯度下降法的收敛速度未必是最快的\n四、海森矩阵\n4.1 二阶导数\n二阶导 \\(f^{\\prime\\prime}(x)\\) 刻画了曲率。假设有一个二次函数（实际任务中，很多函数不是二次的，但是在局部可以近似为二次函数）：\n如果函数的二阶导数为零，则它是一条直线。如果梯度为 1，则当沿着负梯度的步长为 \\(\\epsilon\\) 时，函数值减少 \\(\\epsilon\\)\n如果函数的二阶导数为负，则函数向下弯曲。如果梯度为1，则当沿着负梯度的步长为 \\(\\epsilon\\) 时，函数值减少的量大于 \\(\\epsilon\\)\n如果函数的二阶导数为正，则函数向上弯曲。如果梯度为1，则当沿着负梯度的步长为 \\(\\epsilon\\) 时，函数值减少的量少于 \\(\\epsilon\\)\n4.2 海森矩阵\n当函数输入为多维时，定义海森矩阵：\n\\[\\mathbf H(f)(\\mathbf{\\vec x}) =\\begin{bmatrix} \\frac{\\partial^{2}}{\\partial x_1\\partial x_1}f&\\frac{\\partial^{2}}{\\partial x_1\\partial x_2}f&\\cdots&\\frac{\\partial^{2}}{\\partial x_1\\partial x_n}f\\\\ \\frac{\\partial^{2}}{\\partial x_2\\partial x_1}f&\\frac{\\partial^{2}}{\\partial x_2\\partial x_2}f&\\cdots&\\frac{\\partial^{2}}{\\partial x_2\\partial x_n}f\\\\ \\vdots&\\vdots&\\ddots&\\vdots\\\\ \\frac{\\partial^{2}}{\\partial x_n\\partial x_1}f&\\frac{\\partial^{2}}{\\partial x_n\\partial x_2}f&\\cdots&\\frac{\\partial^{2}}{\\partial x_n\\partial x_n}f \\end{bmatrix}\\] 即海森矩阵的 \\(i\\) \\(j\\) 列元素为：\n\\[\\mathbf H_{i,j}=\\frac{\\partial^{2}}{\\partial x_i\\partial x_j}f(\\mathbf{\\vec x}) \\]\n当二阶偏导是连续时，海森矩阵是对称阵，即有 \\(\\mathbf H=\\mathbf H^{T}\\)\n在深度学习中大多数海森矩阵都是对称阵\n对于特定方 \\(\\mathbf{\\vec d}\\) 上的二阶导数为：\n\\[\\mathbf{\\vec d}^T\\mathbf H \\mathbf{\\vec d}\\]\n如果 \\(\\mathbf{\\vec d}\\) 是海森矩阵的特征向量，则该方向的二阶导数就是对应的特征值\n如果 \\(\\mathbf{\\vec d}\\) 不是海森矩阵的特征向量，则该方向的二阶导数就是所有特征值的加权平均，权重在 (0,1)之间。且与 \\(\\mathbf{\\vec d}\\) 夹角越小的特征向量对应的特征值具有更大的权重。\n最大特征值确定了最大二阶导数，最小特征值确定最小二阶导数\n4.3 海森矩阵与学习率\n\\(f(\\mathbf{\\vec x})\\) \\(\\mathbf{\\vec x}_0\\) 处泰勒展开：\n\\[f(\\mathbf{\\vec x}) \\approx f(\\mathbf{\\vec x}_0)+(\\mathbf{\\vec x}-\\mathbf{\\vec x}_0 )^{T}\\mathbf{\\vec g}+\\frac 12(\\mathbf{\\vec x}-\\mathbf{\\vec x}_0)^{T}\\mathbf H (\\mathbf{\\vec x}-\\mathbf{\\vec x}_0)\\] 其 \\(\\mathbf{\\vec g}\\) \\(\\mathbf{\\vec x}_0\\) 处的梯度 \\(\\mathbf H\\) \\(\\mathbf{\\vec x}_0\\) 处的海森矩阵。\n根据梯度下降法：\n\\[\\mathbf{\\vec x}^{\\prime}= \\mathbf{\\vec x}-\\epsilon\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})\\] 应用在 \\(\\mathbf{\\vec x}_0\\) ，有：\n\\[f(\\mathbf{\\vec x}_0-\\epsilon\\mathbf{\\vec g})\\approx f(\\mathbf{\\vec x}_0)-\\epsilon\\mathbf{\\vec g}^{T}\\mathbf{\\vec g}+\\frac 12\\epsilon^{2}\\mathbf{\\vec g}^{T}\\mathbf H \\mathbf{\\vec g}\\]\n第一项代表函数在点 \\(\\mathbf{\\vec x}_0\\) 处的值\n第二项代表由于斜率的存在，导致函数值的变化\n第三项代表由于曲率的存在，对于函数值变化的矫正\n注意：如 \\(\\frac 12\\epsilon^{2}\\mathbf{\\vec g}^{T}\\mathbf H \\mathbf{\\vec g}\\) 较大，则很有可能导致：沿着负梯度的方向，函数值反而增加！\n如 \\(\\mathbf{\\vec g}^{T}\\mathbf H \\mathbf{\\vec g} \\le 0\\) ，则无 \\(\\epsilon\\) 取多大的值，可以保证函数值是减小的\n如 \\(\\mathbf{\\vec g}^{T}\\mathbf H \\mathbf{\\vec g} \\gt 0\\) ，则学习 \\(\\epsilon\\) 不能太大。 \\(\\epsilon\\) 太大则函数值增加\n根 \\(f(\\mathbf{\\vec x}_0-\\epsilon\\mathbf{\\vec g}) - f(\\mathbf{\\vec x}_0) \\lt 0\\) 有：\n\\[\\epsilon \\lt \\frac{\\mathbf{2\\vec g}^{T}\\mathbf{\\vec g}}{\\mathbf{\\vec g}^{T}\\mathbf H\\mathbf{\\vec g}}\\]\n考虑最速下降法，选择使 \\(f\\) 下降最快 \\(\\epsilon\\) ，则有：\n\\[\\epsilon^{*}=\\arg\\min_{\\epsilon,\\epsilon \\gt 0 }f(\\mathbf{\\vec x}_0-\\epsilon\\mathbf{\\vec g})\\] 求 \\(\\frac{\\partial }{\\partial \\epsilon} f(\\mathbf{\\vec x}_0-\\epsilon\\mathbf{\\vec g})=0\\) 有：\n\\[\\epsilon^{*}=\\frac{\\mathbf{\\vec g}^{T}\\mathbf{\\vec g}}{\\mathbf{\\vec g}^{T}\\mathbf H\\mathbf{\\vec g}}\\] > 根 \\(\\mathbf{\\vec g}^{T}\\mathbf H \\mathbf{\\vec g} \\gt 0\\) ，很明显有 $\\epsilon^{*} \\lt \\frac{\\mathbf{2\\vec g}^{T}\\mathbf{\\vec g}}{\\mathbf{\\vec g}^{T}\\mathbf H\\mathbf{\\vec g}} $\n由于海森矩阵为实对称阵，因此它可以进行特征值分解。\n假设其特征值从大到小排列为：\n\\[\\lambda_1,\\lambda_2,\\cdots,\\lambda_n\\] 其瑞利商 \\(R(\\mathbf{\\vec x})=\\frac{\\mathbf{\\vec x}^{T}\\mathbf H\\mathbf{\\vec x}}{\\mathbf{\\vec x}^{T}\\mathbf{\\vec x}},\\mathbf{\\vec x} \\ne \\mathbf{\\vec 0}\\) ，可以证明：\n\\[\\lambda_n \\le R(\\mathbf{\\vec x}) \\le \\lambda_1\\\\ \\lambda_1=\\max_{\\mathbf{\\vec x}\\ne \\mathbf{\\vec 0}} R(\\mathbf{\\vec x})\\\\ \\lambda_n=\\min_{\\mathbf{\\vec x}\\ne \\mathbf{\\vec 0}} R(\\mathbf{\\vec x}) \\] 根据：\n\\[\\epsilon^{*}=\\frac{\\mathbf{\\vec g}^{T}\\mathbf{\\vec g}}{\\mathbf{\\vec g}^{T}\\mathbf H\\mathbf{\\vec g}}=\\frac{1}{R(\\mathbf{\\vec g})}\\] 可知海森矩阵决定了学习率的取值范围。\n最坏的情况下，梯度 \\(\\mathbf{\\vec g}\\) 与海森矩阵最大特征值 \\(\\lambda_1\\) 对应的特征向量平行，则此时最优学习率为 \\(\\frac {1}{\\lambda_1}\\)\n4.4 驻点与全局极小点\n满足导数为零的点（ \\(f^{\\prime}(x)=0\\) ）称作驻点。驻点可能为下面三种类型之一：\n局部极小点：在 \\(x\\) 的一个邻域内，该点的值最小\n局部极大点：在 \\(x\\) 的一个邻域内，该点的值最大\n鞍点：既不是局部极小，也不是局部极大\n全局极小点 \\(x^{*}=\\arg\\min_x f(x)\\) 。\n全局极小点可能有一个或者多个\n在深度学习中，目标函数很可能具有非常多的局部极小点，以及许多位于平坦区域的鞍点。这使得优化非常不利。因此通常选取一个非常低的目标函数值，而不一定要是全局最小值。\n二阶导数可以配合一阶导数来决定驻点的类型：\n局部极小点 \\(f^{\\prime}(x)=0,f^{\\prime\\prime}(x)\\gt 0\\)\n局部极大点 \\(f^{\\prime}(x)=0,f^{\\prime\\prime}(x)\\lt 0\\)\n\\(f^{\\prime}(x)=0,f^{\\prime\\prime}(x)= 0\\) ：驻点的类型可能为任意三者之一。\n对于多维的情况类似：\n局部极小点 $\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})=0 $ ，且海森矩阵为正定的（即所有的特征值都是正的）。\n当海森矩阵为正定时，任意方向的二阶偏导数都是正的。\n局部极大点 $\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})=0 $ ，且海森矩阵为负定的（即所有的特征值都是负的）。\n当海森矩阵为负定时，任意方向的二阶偏导数都是负的。\n$\\nabla _{\\mathbf{\\vec x}} f(\\mathbf{\\vec x})=0 $ ，且海森矩阵的特征值中至少一个正值、至少一个负值时，为鞍点。\n当海森矩阵非上述情况时，驻点类型无法判断。\n下图 \\(f(\\mathbf{\\vec x})=x_1^{2}-x_2^{2}\\) 在原点附近的等值线。其海森矩阵为一正一负。\n沿着 \\(x_1\\) 方向，曲线向上；沿着 \\(x_2\\) 方向，曲线向下。\n鞍点就是在一个横截面内的局部极小值，另一个横截面内的局部极大值。\n四、牛顿法\n梯度下降法有个缺陷：它未能利用海森矩阵的信息\n当海森矩阵的条件数较大时，不同方向的梯度的变化差异很大。\n在某些方向上，梯度变化很快；在有些方向上，梯度变化很慢\n梯度下降法未能利用海森矩阵，也就不知道应该优先搜索导数长期为负的方向。\n本质上应该沿着负梯度方向搜索。但是沿着该方向的一段区间内，如果导数一直为负，则可以直接跨过该区间。前提是：必须保证该区间内，该方向导数一直为负。\n当海森矩阵的条件数较大时，也难以选择合适的步长。\n步长必须足够小，从而能够适应较强曲率的地方（对应着较大的二阶导数，即该区域比较陡峭）\n但是如果步长太小，对于曲率较小的地方（对应着较小的二阶导数，即该区域比较平缓）则推进太慢。\n曲率刻画弯曲程度，曲率越大则曲率半径越小\n下图是利用梯度下降法寻找函数最小值的路径。\n该函数是二次函数，海森矩阵条件数为 5，表明最大曲率是最小曲率的5倍。\n红线为梯度下降的搜索路径。（它没有用最速下降法，而是用到线性搜索。如果是最速下降法，则相邻两次搜索的方向正交）\n牛顿法结合了海森矩阵。\n考虑泰勒展开式：\n\\[f(\\mathbf{\\vec x}) \\approx f(\\mathbf{\\vec x}_0)+(\\mathbf{\\vec x}-\\mathbf{\\vec x}_0 )^{T}\\mathbf{\\vec g}+\\frac 12(\\mathbf{\\vec x}-\\mathbf{\\vec x}_0)^{T}\\mathbf H (\\mathbf{\\vec x}-\\mathbf{\\vec x}_0)\\] 其 \\(\\mathbf{\\vec g}\\) \\(\\mathbf{\\vec x}_0\\) 处的梯度 \\(\\mathbf H\\) \\(\\mathbf{\\vec x}_0\\) 处的海森矩阵。\n如 \\(\\mathbf{\\vec x}\\) 为极值点，则有 \\(\\frac{\\partial}{\\partial \\mathbf{\\vec x}}f(\\mathbf{\\vec x})=\\mathbf{\\vec 0}\\) ，则有：\n\\[\\mathbf{\\vec x}^{*}=\\mathbf{\\vec x}_0 -\\mathbf H^{-1}\\mathbf{\\vec g}\\]\n当 \\(f\\) 是个正定的二次型，则牛顿法直接一次就能到达最小值点\n当 \\(f\\) 不是正定的二次型，则可以在局部近似为正定的二次型，那么则采用多次牛顿法即可到达最小值点。\n一维情况下，梯度下降法和牛顿法的原理展示：\n梯度下降法：下一次迭代的 \\(\\mathbf {\\vec x}^{<k+1>}=\\mathbf {\\vec x}^{<k>}-\\epsilon_k \\nabla f(\\mathbf {\\vec x})\\) 。\n对于一维的情况，可以固定 \\(\\epsilon_k=\\eta\\) ，由于随着迭代的推进 \\(f^{\\prime}(x)\\) 绝对值是减小的（直到0），因此越靠近极值点 \\(\\Delta(x)\\) 越小\n牛顿法：目标 \\(\\nabla f(\\mathbf {\\vec x})=0\\) 。在一维情况下就是求 \\(f^\\prime (x)=0\\) 。牛顿法的方法是： \\(x=x^{<k>}\\) \\(y=f^{\\prime}(x)\\) 切线，该切线过 \\((x^{<k>},f^{\\prime}(x^{<k>}))\\) 。该切线 \\(x\\) 轴上的交点就是\n\\[x^{<k+1>}=x^{<k>}-\\frac {f^{\\prime}(x^{<k>})}{f^{\\prime\\prime}(x^{<k>})}\\] 推广到多维情况下就是：\n\\[\\mathbf {\\vec x}^{<k+1>}=\\mathbf {\\vec x}^{<k>}-\\mathbf H_k^{-1}\\mathbf {\\vec g}_k\\]\n当位于一个极小值点附近时，牛顿法比梯度下降法能更快地到达极小值点。\n如果在一个鞍点附近，牛顿法效果很差；而梯度下降法此时效果较好（除非负梯度的方向刚好指向了鞍点）。\n仅仅利用了梯度的优化算法（如梯度下降法）称作一阶优化算法；同时利用了海森矩阵的优化算法（如牛顿法）称作二阶优化算法\n牛顿法算法：\n输入：\n目标函数 \\(f(\\mathbf {\\vec x})\\)\n梯度 \\(g(\\mathbf {\\vec x})=\\nabla f(\\mathbf {\\vec x})\\)\n海森矩阵 \\(\\mathbf H(\\mathbf {\\vec x})\\)\n精度要求 \\(e\\)\n输出 \\(f(\\mathbf {\\vec x})\\) 的极小值 \\(\\mathbf {\\vec x}^*\\)\n算法步骤：\n选取初始 \\(\\mathbf {\\vec x}^{<0>}\\in \\mathbb R^{n}\\) , \\(k=0\\)\n计 \\(\\mathbf {\\vec g}_k=g(\\mathbf {\\vec x}^{<k>})\\)\n\\(|\\mathbf {\\vec g}_k| \\lt e\\) ，则停止计算，得到近似 \\(\\mathbf {\\vec x}=\\mathbf {\\vec x}^*\\)\n\\(|\\mathbf {\\vec g}_k| \\ge e\\) ，则:\n计算 \\(\\mathbf H_k=\\mathbf H(\\mathbf {\\vec x}^{<k>})\\) ，并求 \\(\\mathbf {\\vec p}_k,\\mathbf H_k \\mathbf {\\vec p}_k=-\\mathbf {\\vec g}_k\\)\n置 \\(\\mathbf {\\vec x}^{<k+1>}=\\mathbf {\\vec x}^{<k>}+\\mathbf {\\vec p}_k\\)\n置 \\(k=k+1\\) ，计算 \\(\\mathbf {\\vec g}_k=g(\\mathbf {\\vec x}^{<k>})\\) ，迭代\n梯度下降法中，每一 \\(\\mathbf {\\vec x}\\) 增加的方向一定是梯度相反的方 \\(- \\epsilon_k \\nabla_k\\)\n增加的幅度由 \\(\\epsilon_k\\) 决定，若跨度过大容易引发震荡；\n而牛顿法中，每一 \\(\\mathbf {\\vec x}\\) 增加的方向是梯度增速最大的反方 \\(- \\mathbf H_k^{-1} \\nabla_k\\) （它通常情况下与梯度不共线）\n增加的幅度已经包含在 $ \\mathbf H_k^{-1}$ 中（也可以乘以学习率作为幅度的系数）\n深度学习中的目标函数非常复杂，无法保证可以通过上述优化算法进行优化。因此有时会限定目标函数具有Lipschitz连续，或者其导数Lipschitz连续。\nLipschitz连续的定义：对于函数 \\(f\\) ，存在一个Lipschitz常数 \\(\\mathcal L\\) ，使得\n\\[\\forall \\mathbf{\\vec x},\\forall \\mathbf{\\vec y}, |f(\\mathbf{\\vec x})-f(\\mathbf{\\vec y})| \\le \\mathcal L ||\\mathbf{\\vec x}-\\mathbf{\\vec y}||_2\\]\nLipschitz连续的意义是：输入的一个很小的变化，会引起输出的一个很小的变化。\n与之相反的是：输入的一个很小的变化，会引起输出的一个很大的变化\n凸优化在某些特殊的领域取得了巨大的成功。但是在深度学习中，大多数优化问题都难以用凸优化来描述。\n凸优化的重要性在深度学习中大大降低。凸优化仅仅作为一些深度学习算法的子程序。\n五、拟牛顿法\n5.1 原理\n在牛顿法的迭代中，需要计算海森矩阵的逆矩 \\(\\mathbf H^{-1}\\) ，这一计算比较复杂。\n可以考虑用一个 \\(n\\) 阶矩阵 \\(\\mathbf G_k=G(\\mathbf {\\vec x}^{<k>})\\) 来近似代替 \\(\\mathbf H^{-1}_k=H^{-1}(\\mathbf {\\vec x}^{<k>})\\) 。\n先看海森矩阵满足的条件 \\(\\mathbf {\\vec g}_{k+1}-\\mathbf {\\vec g}_k=\\mathbf H_k (\\mathbf {\\vec x}^{<k+1>}-\\mathbf {\\vec x}^{<k>})\\)\n令 \\(\\mathbf {\\vec y}_k=\\mathbf {\\vec g}_{k+1}-\\mathbf {\\vec g}_k, \\vec \\delta_k=\\mathbf {\\vec x}^{<k+1>}-\\mathbf {\\vec x}^{<k>}\\) 则有 \\(\\mathbf {\\vec y}_k=\\mathbf H_k \\vec \\delta_k\\) ，或者 \\(\\mathbf H_k^{-1}\\mathbf {\\vec y}_k=\\vec \\delta_k\\) 。这称为拟牛顿条件\n根据牛顿法的迭代: \\(\\mathbf {\\vec x}^{<k+1>}=\\mathbf {\\vec x}^{<k>}-\\mathbf H_k^{-1}\\mathbf {\\vec g}_k\\) ，将 \\(f(\\mathbf {\\vec x})\\) 在 \\(\\mathbf {\\vec x}^{<k>}\\) 的一阶泰勒展开：\n\\[ f(\\mathbf {\\vec x}^{<k+1>})=f(\\mathbf {\\vec x}^{<k>})+f'(\\mathbf {\\vec x}^{<k>})(\\mathbf {\\vec x}^{<k+1>}-\\mathbf {\\vec x}^{<k>})\\\\ =f(\\mathbf {\\vec x}^{<k>})+\\mathbf {\\vec g}_k^{T}(-\\mathbf H_k^{-1}\\mathbf {\\vec g}_k)=f(\\mathbf {\\vec x}^{<k>})-\\mathbf {\\vec g}_k^{T}\\mathbf H^{-1}_k\\mathbf {\\vec g}_k\\] \\(\\mathbf H_k\\) 是正定矩阵时，总 \\(f(\\mathbf {\\vec x}^{<k+1>})<f(\\mathbf {\\vec x}^{<k>})\\) ，因此每次都是沿着函数递减的方向迭代\n拟牛顿法如果选 \\(\\mathbf G_k\\) 作 \\(\\mathbf H_k^{-1}\\) 的近似时 \\(\\mathbf G_k\\) 同样要满足两个条件：\n\\(\\mathbf G_k\\) 必须是正定的\n\\(\\mathbf G_k\\) 满足拟牛顿条件 \\(\\mathbf G_{k+1}\\mathbf {\\vec y}_k=\\vec \\delta_k\\)\n因 \\(\\mathbf G_0\\) 是给定的初始化条件，所以下标 \\(k+1\\) 开始\n按照拟牛顿条件，在每次迭代中可以选择更新矩 \\(\\mathbf G_{k+1}=\\mathbf G_k+\\Delta \\mathbf G_k\\)\n正定矩阵定义： \\(\\mathbf M\\) \\(n\\times n\\) 阶方阵，如果对任何非零向 \\(\\mathbf {\\vec x}\\) ，都 \\(\\mathbf {\\vec x}^{T} \\mathbf M \\mathbf {\\vec x} \\gt 0\\) ，就 \\(\\mathbf M\\) 正定矩阵\n正定矩阵判定：\n判定定理1：对称阵 \\(\\mathbf M\\) 为正定的充分必要条件是 \\(\\mathbf M\\) 的特征值全为正。\n判定定理2：对称阵 \\(\\mathbf M\\) 为正定的充分必要条件是 \\(\\mathbf M\\) 的各阶顺序主子式都为正。\n判定定理3：任意阵 \\(\\mathbf M\\) 为正定的充分必要条件是 \\(\\mathbf M\\) 合同于单位阵。\n正定矩阵的性质：\n正定矩阵一定是非奇异的。奇异矩阵的定义：若 \\(n\\times n\\) 阶矩阵 \\(\\mathbf M\\) 为奇异阵，则其的行列式为零，即 \\(|\\mathbf M|=0\\) 。\n正定矩阵的任一主子矩阵也是正定矩阵。\n若 \\(\\mathbf M\\) \\(n\\times n\\) 阶对称正定矩阵，则存在唯一的主对角线元素都是正数的下三角阵 \\(\\mathbf L\\) ，使得 \\(\\mathbf M=\\mathbf L\\mathbf L^{T}\\) ，此分解式称为 正定矩阵的乔列斯基（Cholesky）分解。\n若 \\(\\mathbf M\\) 为 \\(n\\times n\\) 阶正定矩阵，则 \\(\\mathbf M\\) 为 \\(n\\times n\\) 阶可逆矩阵。\n正定矩阵在某个合同变换下可化为标准型，即对角矩阵。\n所有特征值大于零的对称矩阵也是正定矩阵。\n合同矩阵：两个实对称矩 \\(\\mathbf A\\) \\(\\mathbf B\\) 是合同的，当且仅当存在一个可逆矩 \\(\\mathbf P\\) ，使 \\(\\mathbf A=\\mathbf P^{T}\\mathbf B\\mathbf P\\)\n\\(\\mathbf A\\) 的合同变换：对某个可逆矩阵 \\(\\mathbf P\\) ，对 \\(\\mathbf A\\) 执行 \\(\\mathbf P^{T}\\mathbf A\\mathbf P\\)\n5.2 DFP 算法\nDFP算法(Davidon-Fletcher-Powell)选 \\(\\mathbf G_{k+1}\\) 的方法是：\n假设每一步迭代 \\(\\mathbf G_{k+1}\\) 是 \\(\\mathbf G_k\\) 加上两个附加项构成 \\(\\mathbf G_{k+1}=\\mathbf G_k+\\mathbf P_k+\\mathbf Q_k\\) ，其 \\(\\mathbf P_k,\\mathbf Q_k\\) 是待定矩阵。此时有 \\(\\mathbf G_{k+1}\\mathbf {\\vec y}_k=\\mathbf G_k\\mathbf {\\vec y}_k+\\mathbf P_k\\mathbf {\\vec y}_k+\\mathbf Q_k\\mathbf {\\vec y}_k\\) 。\n为了满足拟牛顿条件，可以取 \\(\\mathbf P_k\\mathbf {\\vec y}_k=\\vec \\delta_k,\\quad \\mathbf Q_k\\mathbf {\\vec y}_k =-\\mathbf G_k\\mathbf {\\vec y}_k\\) 。\n这样 \\(\\mathbf P_k,\\mathbf Q_k\\) 不止一个。例如取\n\\[\\mathbf P_k=\\frac{\\vec \\delta_k\\vec \\delta_k^{T}}{\\vec \\delta_k^{T}\\mathbf {\\vec y}_k},\\quad \\mathbf Q_k=-\\frac{\\mathbf G_k\\mathbf {\\vec y}_k \\mathbf {\\vec y}_k^{T} \\mathbf G_k}{\\mathbf {\\vec y}_k^{T}\\mathbf G_k \\mathbf {\\vec y}_k}\\]\n这 \\(\\vec \\delta_k,\\mathbf {\\vec y}_k\\) 都是列向量\n则迭代公式为：\n\\[\\mathbf G_{k+1}=\\mathbf G_k+\\frac{\\vec \\delta_k\\vec \\delta_k^{T}}{\\vec \\delta_k^{T}\\mathbf {\\vec y}_k}-\\frac{\\mathbf G_k\\mathbf {\\vec y}_k \\mathbf {\\vec y}_k^{T} \\mathbf G_k}{\\mathbf {\\vec y}_k^{T} \\mathbf G_k \\mathbf {\\vec y}_k}\\]\n其中的向 \\(\\vec \\delta_k,\\mathbf {\\vec y}_k\\) 都是列向量\n可以证明，如果初始矩 \\(\\mathbf G_0\\) 是正定的，则迭代过程中每个矩 \\(\\mathbf G_k\\) 都是正定的\nDFP算法：\n输入：\n目标函数 \\(f(\\mathbf {\\vec x})\\)\n梯度 \\(g(\\mathbf {\\vec x})=\\nabla f(\\mathbf {\\vec x})\\)\n精度要求 \\(e\\)\n输出 \\(f(\\mathbf {\\vec x})\\) 的极小值 \\(\\mathbf {\\vec x}^*\\)\n算法步骤：\n选取初始 \\(\\mathbf {\\vec x}^{<0>}\\in \\mathbb R^{n}\\) , \\(\\mathbf G_0\\) 为正定对称矩阵， \\(k\\) =0\n计 \\(\\mathbf {\\vec g}_k=g(\\mathbf {\\vec x}^{<k>})\\)\n\\(|\\mathbf {\\vec g}_k| \\lt e\\) ，则停止计算，得到近似 \\(\\mathbf {\\vec x}=\\mathbf {\\vec x}^*\\)\n\\(|\\mathbf {\\vec g}_k| \\ge e\\) ，则:\n计算 \\(\\mathbf {\\vec p}_k=-\\mathbf G_k\\mathbf {\\vec g}_k\\)\n一维搜索：求 \\(\\epsilon_k\\) ： \\(\\epsilon_k=\\min_{\\epsilon \\ge 0}f(\\mathbf {\\vec x}^{<k>}+\\epsilon\\mathbf {\\vec p}_k)\\)\n设置 \\(\\mathbf {\\vec x}^{<k+1>}=\\mathbf {\\vec x}^{<k>}+\\epsilon_k\\mathbf {\\vec p}_k\\)\n计算 \\(\\mathbf {\\vec g}_{k+1}=g(\\mathbf {\\vec x}^{<k+1>})\\) 。若 \\(|\\mathbf {\\vec g}_{k+1}| \\lt \\varepsilon\\) ， 则停止计算，得到近似解 \\(\\mathbf {\\vec x}=\\mathbf {\\vec x}^*\\)\n否则计算 \\(\\mathbf G_{k+1}\\) ，置 \\(k=k+1\\) ，计算 \\(\\mathbf {\\vec p}_k=-\\mathbf G_k\\mathbf {\\vec g}_k\\) 迭代\nDFP算法中，每一 \\(\\mathbf {\\vec x}\\) 增加的方向 \\(-\\mathbf G_k \\nabla_k\\) 的方向。增加的幅度 \\(\\epsilon_k\\) 决定，若跨度过大容易引发震荡\n5.2 BFGS 算法\nBFGS是最流行的拟牛顿算法。DFP算法中， \\(\\mathbf G_k\\) 逼 \\(\\mathbf H^{-1}\\) 。换个角度可以用矩 \\(\\mathbf B_k\\) 逼近海森矩 \\(\\mathbf H\\) 。此时对应的拟牛顿条件为 \\(\\mathbf B_{k+1}\\vec \\delta_k=\\mathbf {\\vec y}_k\\) 。\n因 \\(\\mathbf B_0\\) 是给定的初始化条件，所以下标 \\(k+1\\) 开始\n令 \\(\\mathbf B_{k+1}=\\mathbf B_k+\\mathbf P_k+\\mathbf Q_k\\) ，有 \\(\\mathbf B_{k+1}\\vec \\delta_k=\\mathbf B_k\\vec \\delta_k+\\mathbf P_k\\vec \\delta_k+\\mathbf Q_k\\vec \\delta_k\\)\n可以 \\(\\mathbf P_k\\vec \\delta_k=\\mathbf {\\vec y}_k,\\mathbf Q_k\\vec \\delta_k=-\\mathbf B_k\\vec \\delta_k\\) 。寻找合适 \\(\\mathbf P_k,\\mathbf Q_k\\) ，可以得到BFGS算法矩阵 \\(\\mathbf B_{k+1}\\) 的迭代公式：\n\\[\\mathbf B_{k+1}=\\mathbf B_k+\\frac{\\mathbf {\\vec y}_k\\mathbf {\\vec y}_k^{T}}{\\mathbf {\\vec y}_k^{T}\\vec \\delta_k}-\\frac{\\mathbf B_k\\vec \\delta_k\\vec \\delta_k^{T}\\mathbf B_k}{\\vec \\delta_k^{T}\\mathbf B_k\\vec \\delta_k}\\]\n其中的向 \\(\\vec \\delta_k,\\mathbf {\\vec y}_k\\) 都是列向量\n可以证明， \\(\\mathbf B_0\\) 是正定的，则迭代过程中每个矩 \\(\\mathbf B_k\\) 都是正定的。\nBFGS算法：\n输入：\n目标函数 \\(f(\\mathbf {\\vec x})\\)\n梯度 \\(g(\\mathbf {\\vec x})=\\nabla f(\\mathbf {\\vec x})\\)\n精度要求 \\(\\ e\\)\n输出 \\(f(\\mathbf {\\vec x})\\) 的极小值 \\(\\mathbf {\\vec x}^*\\)\n算法步骤：\n选取初始 \\(\\mathbf {\\vec x}^{<0>}\\in \\mathbb R^{n}\\) , \\(\\mathbf B_0\\) 为正定对称矩阵， \\(k\\) =0\n计 \\(\\mathbf {\\vec g}_k=g(\\mathbf {\\vec x}^{<k>})\\)\n\\(|\\mathbf {\\vec g}_k| \\lt e\\) ，则停止计算，得到近似 \\(\\mathbf {\\vec x}=\\mathbf {\\vec x}^*\\)\n\\(|\\mathbf {\\vec g}_k| \\ge e\\) ，则:\n\\(\\mathbf B_k\\mathbf {\\vec p}_k=-\\mathbf {\\vec g}_k\\) 求 \\(\\mathbf {\\vec p}_k\\)\n这里表面上看需要对矩阵求逆。但是实际 \\(\\mathbf B_k^{-1}\\) 有迭代公式。根据Sherman-Morrison公式以 \\(\\mathbf B_k\\) 的迭代公式，可以得 \\(\\mathbf B_k^{-1}\\) 的迭代公式\n一维搜索： \\(\\epsilon_k\\) \\(\\epsilon_k=\\min_{\\epsilon \\ge 0}f(\\mathbf {\\vec x}^{<k>}+\\epsilon\\mathbf {\\vec p}_k)\\)\n设 \\(\\mathbf {\\vec x}^{<k+1>}=\\mathbf {\\vec x}^{<k>}+\\epsilon_k\\mathbf {\\vec p}_k\\)\n计 \\(\\mathbf {\\vec g}_{k+1}=g(\\mathbf {\\vec x}^{<k+1>})\\) 。 \\(|\\mathbf {\\vec g}_{k+1}| \\lt e\\) ，则停止计算，得到近似 \\(\\mathbf {\\vec x}=\\mathbf {\\vec x}^*\\)\n否则计算，置 \\(=k+1\\) 。 \\(\\mathbf B_k\\mathbf {\\vec p}_k=-\\mathbf {\\vec g}_k\\) 求 \\(\\mathbf {\\vec p}_k\\) ，迭代\nBFPS算法中，每一 \\(\\mathbf {\\vec x}\\) 增加的方向 \\(-\\mathbf B_k^{-1} \\nabla_k\\) 的方向。增加的幅度 \\(\\epsilon_k\\) 决定，若跨度过大容易引发震荡\n5.3 Broyden 类算法\n若 \\(\\mathbf G_k=\\mathbf B_k^{-1},\\mathbf G_{k+1}=\\mathbf B_{k+1}^{-1}\\) ，则对式子\n\\[\\mathbf B_{k+1}=\\mathbf B_k+\\frac{\\mathbf {\\vec y}_k\\mathbf {\\vec y}_k^{T}}{\\mathbf {\\vec y}_k^{T}\\vec \\delta_k}-\\frac{\\mathbf B_k\\vec \\delta_k\\vec \\delta_k^{T}\\mathbf B_k}{\\vec \\delta_k^{T}\\mathbf B_k\\vec \\delta_k}\\] 使用两次Sherman-Morrison公式可得：\n\\[\\mathbf G_{k+1}=(\\mathbf I-\\frac{\\vec \\delta_k\\mathbf {\\vec y}_k^{T}}{\\vec \\delta_k^{T}\\mathbf {\\vec y}_k})\\mathbf G_k(\\mathbf I-\\frac{\\vec \\delta_k\\mathbf {\\vec y}_k^{T}}{\\vec \\delta_k^{T}\\mathbf {\\vec y}_k})^{T}+\\frac{\\vec \\delta_k\\vec \\delta_k^{T}}{\\vec \\delta_k^{T}\\mathbf {\\vec y}_k}\\] > 其中的向 \\(\\vec \\delta_k,\\mathbf {\\vec y}_k\\) 都是列向量\n令DFP算法获得 \\(\\mathbf G_{k+1}\\) 的迭代公式记作\n\\[\\mathbf G^{DFP}=\\mathbf G_k+\\frac{\\vec \\delta_k\\vec \\delta_k^{T}}{\\vec \\delta_k^{T}\\mathbf {\\vec y}_k}-\\frac{\\mathbf G_k\\mathbf {\\vec y}_k \\mathbf {\\vec y}_k^{T} \\mathbf G_k}{\\mathbf {\\vec y}_k^{T} \\mathbf G_k \\mathbf {\\vec y}_k}\\] 由BFGS算法获得 \\(\\mathbf G_{k+1}\\) 的迭代公式记作\n\\[\\mathbf G^{BFGS}=(\\mathbf I-\\frac{\\vec \\delta_k\\mathbf {\\vec y}_k^{T}}{\\vec \\delta_k^{T}\\mathbf {\\vec y}_k})\\mathbf G_k(\\mathbf I-\\frac{\\vec \\delta_k\\mathbf {\\vec y}_k^{T}}{\\vec \\delta_k^{T}\\mathbf {\\vec y}_k})^{T}+\\frac{\\vec \\delta_k\\vec \\delta_k^{T}}{\\vec \\delta_k^{T}\\mathbf {\\vec y}_k}\\] 他们都满足拟牛顿条件，所以他们的线性组合 \\(\\mathbf G_{k+1}= \\alpha \\mathbf G^{DFP}+(1- \\alpha)\\mathbf G^{BFGS}\\) 也满足拟牛顿条件，而且是正定的。其 \\(0 \\le \\alpha \\le 1\\) 。\n这样获得了一族拟牛顿法，称为Broyden类算法\nSherman-Morrison公式：假 \\(\\mathbf A\\) \\(n\\) 阶可逆矩阵 \\(\\mathbf {\\vec u},\\mathbf {\\vec v}\\) \\(n\\) 维列向量， \\(\\mathbf A+\\mathbf {\\vec u}\\mathbf {\\vec v}^{T}\\) 也是可逆矩阵，则：\n\\[(\\mathbf A+\\mathbf {\\vec u}\\mathbf {\\vec v}^{T})^{-1}=\\mathbf A^{-1}-\\frac{\\mathbf A^{-1}\\mathbf {\\vec u}\\mathbf {\\vec v}^{T}\\mathbf A^{-1}}{1+\\mathbf {\\vec v}^{T}\\mathbf A^{-1}\\mathbf {\\vec u}}\\]\n六、 约束优化\n6.1 原理\n在有的最优化问题中，希望输 \\(\\mathbf {\\vec x}\\) 位于特定的集 \\(\\mathbb S\\) 中，这称作约束优化问题。\n集 \\(\\mathbb S\\) 内的点 \\(\\mathbf {\\vec x}\\) 称作可行解\n集合 \\(\\mathbb S\\) 也称作可行域。\n约束优化的一个简单方法是：对梯度下降法进行修改。\n每次迭代后，将得到的新 \\(\\mathbf {\\vec x}\\) 映射到集 \\(\\mathbb S\\) 中\n如果使用线性搜索：则每次只搜索那些使得新 \\(\\mathbf {\\vec x}\\) 位于集 \\(\\mathbb S\\) 中的那 \\(\\epsilon\\)\n另一个做法：将线性搜索得到的新的 \\(\\mathbf {\\vec x}\\) 映射到集合 \\(\\mathbb S\\) 中。\n或者：在线性搜索之前，将梯度投影到可行域的切空间内\n6.2 KKT 方法\n在约束最优化问题中，常常利用拉格朗日对偶性将原始问题转换为对偶问题，通过求解对偶问题而得到原始问题的解。\n约束最优化问题的原始问题：\n假 \\(f(\\mathbf {\\vec x}),c_i(\\mathbf {\\vec x}),h_j(\\mathbf {\\vec x})\\) 是定义 \\(\\mathbb R^{n}\\) 上的连续可微函数。考虑约束最优化问题：\n\\[\\min_{\\mathbf {\\vec x} \\in \\mathbb R^{n}}f(\\mathbf {\\vec x})\\\\ s.t. \\quad c_i(\\mathbf {\\vec x}) \\le 0,i=1,2,\\cdots,k \\;;\\quad h_j(\\mathbf {\\vec x})=0,j=1,2,\\cdots,l\\] 可行域由等式和不等式确定\n\\[\\mathbb S=\\{\\mathbf {\\vec x} \\mid c_i(\\mathbf {\\vec x}) \\le 0,i=1,2,\\cdots,k \\;;\\quad h_j(\\mathbf {\\vec x})=0,j=1,2,\\cdots,l\\}\\]\n6.2.1 原始问题\n引入拉格朗日函数：\n\\[L(\\mathbf {\\vec x},\\vec \\alpha,\\vec\\beta)=f(\\mathbf {\\vec x})+\\sum_{i=1}^{k}\\alpha_ic_i(\\mathbf {\\vec x})+\\sum_{j=1}^{l}\\beta_jh_j(\\mathbf {\\vec x})\\] 这 \\(\\mathbf {\\vec x}=(x^{(1)},x^{(2)},\\cdots,x^{(n)})^{T} \\in \\mathbb R^{n}, \\alpha_i,\\beta_j\\) 是拉格朗日乘子 \\(\\alpha_i \\ge 0\\)\n\\(L(\\mathbf {\\vec x}, \\vec \\alpha\\vec\\beta)\\) 是 \\(\\mathbf {\\vec x}, \\vec \\alpha,\\vec \\beta\\) 的多元非线性函数\n定义函数：\n\\[\\theta_P(\\mathbf {\\vec x})=\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\alpha_i \\ge 0}L(\\mathbf {\\vec x},\\vec \\alpha, \\vec\\beta)\\] 其中下 \\(P\\) 表示原始问题。则有：\n\\[ \\theta_P(\\mathbf {\\vec x})= \\begin{cases} f(\\mathbf {\\vec x}), & \\text{if $\\mathbf {\\vec x}$ statisfy original problem's constraint} \\\\ +\\infty, & \\text{or else.} \\end{cases}\\]\n\\(\\mathbf {\\vec x}\\) 满足原问题的约束，则很容易证 \\(L(\\mathbf {\\vec x},\\vec \\alpha,\\vec\\beta)=f(\\mathbf {\\vec x})+\\sum_{i=1}^{k}\\alpha_ic_i(\\mathbf {\\vec x}) \\le f(\\mathbf {\\vec x})\\) ，等号 \\(\\alpha_i=0\\) 时取到\n\\(\\mathbf {\\vec x}\\) 不满足原问题的约束：\n若不满足 $ c_i(\\mathbf {\\vec x}) \\le 0$ ：设违反的为 \\(c_{i0}(\\mathbf {\\vec x}) \\gt 0\\) ，则令 \\(\\vec \\alpha_{i0} \\rightarrow \\infty\\) ， \\(L(\\mathbf {\\vec x},\\vec \\alpha,\\vec\\beta)=f(\\mathbf {\\vec x})+\\sum_{i=1}^{k}\\alpha_ic_i(\\mathbf {\\vec x}) \\rightarrow \\infty\\)\n若不满足 $ h_j(\\mathbf {\\vec x}) = 0$ ： 设违反的为 \\(h_{j0}(\\mathbf {\\vec x}) \\ne 0\\) ，则令 \\(\\vec\\beta_{j0}h_{j0}(\\mathbf {\\vec x}) \\rightarrow \\infty\\) ， \\(L(\\mathbf {\\vec x},\\vec \\alpha,\\vec\\beta)=f(\\mathbf {\\vec x})+\\sum_{i=1}^{k}\\alpha_ic_i(\\mathbf {\\vec x})+\\vec\\beta_{j0}h_{j0}(\\mathbf {\\vec x}) \\rightarrow \\infty\\)\n考虑极小化问题：\n\\[\\min_{\\mathbf {\\vec x}} \\theta_P(\\mathbf {\\vec x})=\\min_{\\mathbf {\\vec x}}\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\alpha_i \\ge 0}L(\\mathbf {\\vec x},\\vec \\alpha, \\vec\\beta)\\] 则该问题是与原始最优化问题是等价的，即他们有相同的问题。\n\\(\\min_{\\mathbf {\\vec x}}\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\alpha_i \\ge 0}L(\\mathbf {\\vec x},\\vec \\alpha, \\vec\\beta)\\) 称为广义拉格朗日函数的极大极小问题。\n为了方便，定义原始问题的最优值为：\n\\[p^{*}=\\min_{\\mathbf {\\vec x}}\\theta_P(\\mathbf {\\vec x})\\]\n6.2.2 对偶问题\n对偶问题：定 \\(\\theta_D(\\vec \\alpha,\\vec\\beta)=\\min_\\mathbf {\\vec x} L(\\mathbf {\\vec x},\\vec \\alpha,\\vec\\beta)\\) 。考虑极大 \\(\\theta_D(\\vec \\alpha,\\vec\\beta)\\) ，即：\n\\[\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\alpha_i \\ge 0}\\theta_D(\\vec \\alpha,\\vec\\beta)=\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\alpha_i \\ge 0} \\min_{\\mathbf {\\vec x}}L(\\mathbf {\\vec x},\\vec \\alpha, \\vec\\beta)\\]\n问题 \\(\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\alpha_i \\ge 0} \\min_{\\mathbf {\\vec x}}L(\\mathbf {\\vec x},\\vec \\alpha, \\vec\\beta)\\) 称为广义拉格朗日函数的极大极小问题。\n可以将广义拉格朗日函数的极大极小问题表示为约束最优化问题：\n\\[\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\alpha_i \\ge 0}\\theta_D(\\vec \\alpha,\\vec\\beta)=\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\alpha_i \\ge 0} \\min_{\\mathbf {\\vec x}}L(\\mathbf {\\vec x},\\vec \\alpha, \\vec\\beta)\\\\ s.t. \\alpha_i \\ge 0, i=1,2,\\cdots,k\\] 称为原始问题的对偶问题。\n定义对偶问题的最优值：\n\\[d^*=\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\alpha_i \\ge 0}\\theta_D(\\vec \\alpha,\\vec\\beta)\\]\n6.2.3 原始问题与对偶问题关系\n定理一：若原问题和对偶问题具有最优值，则：\n\\[d^{*}=\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\vec \\alpha_i \\ge 0}\\min_{\\mathbf {\\vec x}}L(\\mathbf {\\vec x},\\vec \\alpha, \\vec\\beta) \\le \\min_{\\mathbf {\\vec x}}\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\vec \\alpha_i \\ge 0}L(\\mathbf {\\vec x},\\vec \\alpha, \\vec\\beta)=p^{*}\\]\n推论一： \\(\\mathbf {\\vec x}^{*}\\) 为原始问题的可行解， \\(\\theta_P(\\mathbf {\\vec x}^{*})\\) 的值 \\(p^{*}\\) \\(\\vec \\alpha^{*},\\vec\\beta^{*}\\) 为对偶问题的可行解 \\(\\theta_D(\\vec \\alpha^{*},\\vec\\beta^{*})\\) 值 \\(d^{*}\\) 。\n如果 \\(p^{*}=d^{*}\\) ， \\(\\mathbf {\\vec x}^{*},\\vec \\alpha^{*},\\vec\\beta^{*}\\) 分别为原始问题和对偶问题的最优解。\n定理二：假设函 \\(f(\\mathbf {\\vec x})\\) \\(c_i(\\mathbf {\\vec x})\\) 为凸函数 \\(h_j(\\mathbf {\\vec x})\\) 是仿射函数；并且假设不等式约 \\(c_i(\\mathbf {\\vec x})\\) 是严格可行的，即存 \\(\\mathbf {\\vec x}\\) ，对于所 \\(i\\) \\(c_i(x) \\lt 0\\) 。\n则存 \\(\\mathbf {\\vec x}^{*},\\vec \\alpha^{*},\\vec\\beta^{*}\\) ，使得 \\(\\mathbf {\\vec x}^{*}\\) 是原始问 \\(\\min_{\\mathbf {\\vec x}}\\theta_P(\\mathbf {\\vec x})\\) 的解 \\(\\vec \\alpha^{*},\\vec\\beta^{*}\\) 是对偶问 \\(\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\alpha_i \\ge 0}\\theta_D(\\vec \\alpha,\\vec\\beta)\\) 的解，并 \\(p^{*}=d^{*}=L(\\mathbf {\\vec x}^{*},\\vec \\alpha^{*},\\vec\\beta^{*})\\)\n定理三：假设函 \\(f(\\mathbf {\\vec x})\\) \\(c_i(\\mathbf {\\vec x})\\) 为凸函数 \\(h_j(\\mathbf {\\vec x})\\) 是仿射函数；并且假设不等式约 \\(c_i(\\mathbf {\\vec x})\\) 是严格可行的，即存 \\(\\mathbf {\\vec x}\\) ，对于所 \\(i\\) \\(c_i(x) \\lt 0\\) 。\n则存 \\(\\mathbf {\\vec x}^{*},\\vec \\alpha^{*},\\vec\\beta^{*}\\) ，使 \\(\\mathbf {\\vec x}^{*}\\) 是原始问 \\(\\min_{\\mathbf {\\vec x}}\\theta_P(\\mathbf {\\vec x})\\) 的解 \\(\\vec \\alpha^{*},\\vec\\beta^{*}\\) 是对偶问 \\(\\max_{\\vec \\alpha,\\vec\\beta\\;:\\;\\alpha_i \\ge 0}\\theta_D(\\vec \\alpha,\\vec\\beta)\\) 的解的充要条件是 \\(\\mathbf {\\vec x}^{*},\\vec \\alpha^{*},\\vec\\beta^{*}\\) 满足下面的Karush-kuhn-Tucker(KKT)条件：\n\\[\\nabla_\\mathbf {\\vec x}L(\\mathbf {\\vec x}^{*},\\vec \\alpha^{*},\\vec\\beta^{*})=0\\\\ \\nabla_\\vec \\alpha L(\\mathbf {\\vec x}^{*},\\vec \\alpha^{*},\\vec\\beta^{*})=0\\\\ \\nabla_\\vec\\beta L(\\mathbf {\\vec x}^{*},\\vec \\alpha^{*},\\vec\\beta^{*})=0\\\\ \\vec \\alpha^{*}_ic_i(\\mathbf {\\vec x}^{*})=0,i=1,2,\\cdots,k\\\\ c_i(\\mathbf {\\vec x}^{*})\\le 0,i=1,2,\\cdots,k\\\\ \\vec \\alpha^{*}_i \\ge 0,i=1,2,\\cdots,k\\\\ h_j(\\mathbf {\\vec x}^{*})= 0,j=1,2,\\cdots,l\\]\n仿射函数：仿射函数即由1阶多项式构成的函数。\n一般形式 \\(f(\\mathbf {\\vec x}) = \\mathbf A \\mathbf {\\vec x} + b\\) ，这里 \\(\\mathbf A\\) 是一 \\(m\\times k\\) 矩阵 \\(\\mathbf {\\vec x}\\) 是一 \\(k\\) 维列向量 \\(b\\) 是一 \\(m\\) 维列向量\n它实际上反映了一种从 \\(k\\) 维到 \\(m\\) 维的空间映射关系。\n凸函数： \\(f\\) 为定义在区 \\(I\\) 上的函数，若 \\(I\\) 上的任意两 \\(\\mathbf {\\vec x}_1,\\mathbf {\\vec x}_2\\) 和任意的实 \\(\\lambda \\in (0,1)\\) ，总 \\(f(\\lambda \\mathbf {\\vec x}_1+(1-\\lambda)\\mathbf {\\vec x}_2) \\ge \\lambda f(\\mathbf {\\vec x}_1)+(1-\\lambda)f(\\mathbf {\\vec x}_2)\\) \\(f\\) 称 \\(I\\) 上的凸函数\n本文转载自华校专老师博客，博客地址：http://www.huaxiaozhuan.com/"}
