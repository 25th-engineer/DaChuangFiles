{"content2":"大家好！今天是我学习汇编语言的第一课。我感觉汇编好好玩啊！\n机器码编程\n哇！一上来就写程序了啊，还是用机器码的啊！是呢！嘿嘿！我们去下载1个二进制编辑器，我也不知道哪款好用点，我下载的是FlexHEX。然后我们打开它，并写入一下代码：CD 00\n以前我学C语言的时候，我知道CD 00 其实就是1100 1101 0000 0000啦！然后我们保存它为1个文件。关于文件名随便取啦！然后我们运行打开cmd，我们把刚才编辑保存好的文件拖到cmd中然后再运行！\n哇！程序输出了Divide overflow 好棒啊！一上来就可以机器码编程啦！而且只有2字节呀！看起来也不是那么的复杂啊！但是我看下面的程序，下面的程序是welcome to masm的机器码：\n大家看到了吗？！好多的01011001啊，要是我们写二进制机器码的时候1个被错误的写成0了，那如何去调试查找啊，所以汇编语言产生了哦！汇编语言它的主题是汇编指令，汇编指令呢只是机器指令便于书写记忆的一种格式。比如：机器指令1000100111011000 它的意思是寄存器BX的内容送到AX中，对于的汇编指令是：MOV AX,BX。大家看，这样的写法是不是更接近人类语言呀！(咦！什么是寄存器啊，这里怎么冒出来个寄存器，寄存器是CPU中可以存储数据的器件，一个CPU中有多个寄存器，AX,BX就是其中2个寄存器的代号)。现在我们看看我们的8086CPU中有哪些寄存器：我们用运行输入cmd，然后再输入debug，然后再在-后输入r.我们一起看看：\n哇！眼花了！仔细一瞧啊！其实也不晕啊，就13个寄存器啊（我暂时这样理解）！每个寄存器是16位的，也就是说十六位二进制数。\n既然汇编语言是机器语言的助记符。虽然它们是一一对应的，但是如果把汇编语言直接塞给CPU，CPU也还是不认识的呢，所以，要让电脑运行汇编程序，必须要有1个翻译啊。这个翻译呢就是汇编语言编译器啦！\n汇编语言的组成\n1,汇编指令（机器码的助记符）\n2，伪指令（由编译器执行）\n3，其他符号（由编译器识别）\n汇编语言的核心是汇编指令啦，它决定了汇编的特性哦。\n我的指令和数据在什么地方啊\nCPU是计算机的核心，它控制着整个计算机的运作，但是我们必须向它提供指令和数据它才能工作呢，那么这些指令和数据放在什么地方的啊，以前我们学C语言做调试的时候知道，我们调试的时候看就是内存，所以汇编语言也一样啊，指令和数据也是放在内存里的，但是我们现在要重新取个名字，听起来更专业点，呵呵，内存就叫存储器（这里要和寄存器搞清楚关系啊，寄存器是CPU内部的，虽然它也是存放东西的啦！）。\n大笨蛋CPU如何区分指令和数据啊\n1000100111011000 这个二进制机器码要是我们把它当做是数据的时候，那么它就是89D8H\n1000100111011000 这个二进制机器码要是我们把它当做是指令的时候，那么它就是MOV AX,BX\n但是大笨蛋CPU就认识二进制的啊，它怎么知道哪些是数据哪些是指令啊！它是这样认识的，大笨蛋CPU和其他芯片之间有导线连接，逻辑上可以划分为：地址总线，数据总线，控制总线。\n所以我们只要把1000100111011000放在地址总线，CPU就认识它是地址，如果把它放在数据总线上，那么CPU就认为他是数据，如果把它放在控制总线上，那么笨蛋CPU就认为它是指令。\n地址总线\n我们看到地址总线是一串0110101011010组成的，所以说呢，这些位二进制数有多少种变化CPU就可以对多少个存储单元进行寻址。也就是说，一个CPU有N根地址总线，那么这个CPU的地址总线宽度为N。这样的CPU最多可以寻址2的N次方个内存单元啦！\n数据总线\n数据总线就像一根和内存的高速公路呢！它的宽度决定了CPU和外界的数据传送的速度，当然高速公路越宽，这样就可以用很宽很宽的大卡车运货，这样每次运的货就更多！\n下面我们来看1个例子，我们向内存中写入数据89D8H的时候，8088，8086CPU的传送能力：\n8088CPU每次是传送8位数据：\n8086每次是传送16位的：\n从这个例子可以看出，8086一次就可以传送完8088两次才能传送完的数据啊！8086要先进呀！\n控制总线\n从地址总线，数据总线的知识，我们可以推理出有多少根控制总线，就意味着CPU提供了对外部器件的多少控制，呵呵！所以它的宽度决定了CPU对外部器件的控制能力啦！\n嗯！先学到这里！加油！梦想是总有一天要写出1个自己的操作系统出来。"}
