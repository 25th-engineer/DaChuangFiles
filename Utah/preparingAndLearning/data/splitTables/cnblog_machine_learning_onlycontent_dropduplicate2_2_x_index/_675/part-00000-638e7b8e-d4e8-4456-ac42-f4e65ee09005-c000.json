{"content2":"来自http://www.iro.umontreal.ca/~pift6266/H10/notes/mlintro.html （估计有点老了，不过文字不多，看一眼也无妨）\nVery Brief Introduction to Machine Learning for AI\n对应的ppt地址：http://www.iro.umontreal.ca/~pift6266/H10/intro_diapos.pdf\n1、智能\n智能的概念可以被以很多种方式定义。这里根据一些标准（例如对于大多数动物来说的生存和繁衍）我们将它定义成能够做出正确决策的能力，为了得到更好的决策，我们需要知识，对于其中一种知识形式来说，就是操作，即可以处理感知数据，然后用这些信息来做决策。\n2、人工智能\n计算机已经能够具有一些智能了，这都归功于人类已经涉及到的所有项目和那些我们认为很有用的事情（基本上是那些能够让计算机做出正确决策的部分）。但是还是有许多任务动物和人类能够轻松解决而仍然超出计算机可做到的范围之外事情，在21世纪初期，许多任务都标榜自己是人工智能，包含了许多感知和控制的任务，可是为什么我们还是没法写出这些任务的项目程序呢？我认为主要是因为我们还不知道如何显式（正式的，标准的）的表达这些任务，即使我们的大脑（耦合着我们的身体）可以容易做到。这些任务涉及到的知识当前都是隐晦的，但是我们可以通过数据和例子来得到这些任务的许多信息（例如，观察一个人在给定特定的问题或者输入的时候会得到什么）。我们如何让机器也有这样的智能？使用数据和例子来建立可操作的知识就是我们所谓的机器的学习了。\n3、机器学习\n机器学习有着很长一段历史而且超多的文献都是有关机器学习的，在这些文献中，推荐看：\nChris Bishop, “Pattern Recognition and Machine Learning”, 2007\nSimon Haykin, “Neural Networks: a Comprehensive Foundation”, 2009 (3rd edition)\nRichard O. Duda, Peter E. Hart and David G. Stork, “Pattern Classification”, 2001 (2nd edition)\n这里只说很小的一些概念，一些与这个主题密切相关的部分。\n4、学习的规范化\n首先，给出最通用的学习的数学式框架。给定一些训练样本：\n这里zi 表示的是从未知过程P（Z）中得到的采样样本。同样还需要给定一个损失函数 L ，这个函数的会将决策函数 f  和样本 z ，作为它的参数，而且会返回一个实值标量。我们想要在这个未知的生成过程P（Z）背景下，最小化这个 L（f，z）的期望值。\n5、有监督学习\n在有监督学习中，每个样本都是一个（输入，目标）对：Z = （X,Y），f 将X 作为参数。最通用的讲解例子就是：\na）回归：Y是一个实值标量或者向量，f 的输出是和Y的值一样的集合，并通常使用平方误差来作为损失函数：\nb）分类：Y是一个有限整数（例如，一个符号）对应一个类别索引，我们通常将负条件似然log作为损失函数，用来估计：\n这里我们有约束条件：\n6、无监督学习\n在无监督学习中，我们需要学习一个函数 f 来帮助我们描述这个未知的分布P（Z）。有时候 f 直接就是一个有关P（Z）自身的估计（被称为密度估计）。然而，在许多其他情况下 f  是一个试图描述密度聚集的位置。聚类算法可以将输入空间划分成不同的区域（通常以一个原型样本或者中心点作为区域的中心）。许多聚类算法生成一个硬分区（例如，K-means算法）然而其他的生成的是软分区（例如：高斯混合模型GMM），也就是对每个Z指派一个概率值去标识它属于每个类的概率。另一种无监督算法就是为Z 构建一个新的表征，许多DL算法就属于这一种，同样的PCA也是。\n7、局部泛化\n学习算法的大量工作主要是利用一个单一原则来得到泛化：局部泛化。它假设如果输入样本 xi 很靠近输入样本 xj ，那么相对应的输出 f（xi）和 f（xj）应该也很近。这是实现局部插值的基本原则。这个原则很有用，但是他也有很多限制：要是我们需要推断呢？或者说，要是目标未知函数有比训练样本个数更多的变量呢？在这种情况下局部泛化就不能work了，因为我们最少需要和目标函数涉及的变量一样多的样本，从而能够覆盖所有的变量而且能够通过这个原则来生成。这个问题与被称为维数灾难的问题密切相关，而且有以下几个原因。当输入空间是高维的，输出的变化很可能按照输入维度的指数变化。例如，设想我们希望在每个输入变量（输入向量的每个元素）的10个不同的值之间做出区分，而且我们关心这些n个变量的所有的10^n个组合。只用局部泛化,我们需要至少观察这些10^n个 组合的至少各一个采样，这样才能将结论推广到所有变量。\n8、分布式对比：局部表征和非局部泛化\n当翻译到这一段的时候，发现居然有人翻译过了。\n下面这最后一段非原创：\nhttp://www.xuebuyuan.com/848002.html（来自这里，好吧其实是我懒了，这段不翻了。）\n一个简单的整数的N二进制本地表示是连续的B比特序列，并且，除了第个N比特都是0。一种简单的整数的二进制分布式表示是一系列使用通常的二进制编码的log_2(B)个比特。在这个例子中我们看出，分布式表示的效率较本地表示有指数的提高。一般地，对于学习算法，分布式表示具有在相同自由参数个数的情况下捕获更多（指数级）变化的潜力。因此分布式表示具有更好的generalization的潜力，因为学习理论指出需要的样本数量是O(B)的，自由度的有效维数是O(B)的。\n另一个对于分布式表示和本地表示的区别的说明 （相应的，本地和非本地的generalization）是关于聚簇clustering和PCA或者RBM的。前者是本地的，而后者是分布式的。使用k-means聚簇算法我们为每个prototype维护一个参数向量，也就是说，每个由学习者划分的区域一个。使用PCA算法，我们通过跟踪主要变化方向来标志其分布。现在设想一个简化的PCA的解释，在这里我们最关心的是在每个变化的方向上，数据在该方向上的投影是否超过或低于某一门限。在d个方向上，我们能够区分2^d个不同的区域。RBM算法与此类似，它定义d个超平面，并用一个比特来标志在平面一侧或另一侧。一个RBM将一个输入区域同一个标志位的组合联系起来（在神经网络的说法中，这些比特位被称为隐藏单元）。RBM的参数个数大约等于这些比特位相对输入维度的倍数（times，应该是倍数吧。。。）。再一次我们发现RBM或者PCA（分布式表示）可以表示的区域个数可以按照参数的指数规律增长，而传统的聚簇算法（例如，k-means或者高斯混合，都是本地表示）可以表示的区域个数进按照参数个数线性增长。另一种看待角度是，意识到RBM可以按照隐藏单元的组合归纳相应的新区域，即使这里还没有样本被观测到。这对于聚簇算法是不可能的（除了在那些周围区域已经有样本被观察到的区域）。"}
